const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/browserAll-BG0lP3r1.js","assets/webworkerAll-DcBE8OqC.js"])))=>i.map(i=>d[i]);
let im, Zi, vr, mn, $e, st, fh, tm, Br, Xa, qs, RM, AE, Ft, _c, DE, Ue, gh, fe, Fr, Ms, xl, Bd, bm, xh, Ja, wE, PE, In, sm, rm, ni, CM, Zm, dm, Ot, Pe, ue, Be, qi, LA, UA, Pl, xs, Ki, ws, Yi, hd, en, ji, Se, zM, RA, jw, Ge, be, _e, lm, Od, Dr;
let __tla = (async ()=>{
    (function() {
        const t = document.createElement("link").relList;
        if (t && t.supports && t.supports("modulepreload")) return;
        for (const s of document.querySelectorAll('link[rel="modulepreload"]'))n(s);
        new MutationObserver((s)=>{
            for (const r of s)if (r.type === "childList") for (const a of r.addedNodes)a.tagName === "LINK" && a.rel === "modulepreload" && n(a);
        }).observe(document, {
            childList: !0,
            subtree: !0
        });
        function e(s) {
            const r = {};
            return s.integrity && (r.integrity = s.integrity), s.referrerPolicy && (r.referrerPolicy = s.referrerPolicy), s.crossOrigin === "use-credentials" ? r.credentials = "include" : s.crossOrigin === "anonymous" ? r.credentials = "omit" : r.credentials = "same-origin", r;
        }
        function n(s) {
            if (s.ep) return;
            s.ep = !0;
            const r = e(s);
            fetch(s.href, r);
        }
    })();
    const Bl = "175", M_ = 0, Gh = 1, T_ = 2, vf = 1, E_ = 2, $n = 3, ii = 0, Qe = 1, dn = 2, _i = 0, Ts = 1, Hh = 2, zh = 3, Vh = 4, A_ = 5, Fi = 100, w_ = 101, R_ = 102, C_ = 103, P_ = 104, I_ = 200, D_ = 201, L_ = 202, U_ = 203, yc = 204, bc = 205, N_ = 206, B_ = 207, F_ = 208, O_ = 209, k_ = 210, G_ = 211, H_ = 212, z_ = 213, V_ = 214, Sc = 0, Mc = 1, Tc = 2, Rs = 3, Ec = 4, Ac = 5, wc = 6, Rc = 7, yf = 0, W_ = 1, X_ = 2, gi = 0, Y_ = 1, q_ = 2, j_ = 3, $_ = 4, K_ = 5, Z_ = 6, J_ = 7, Wh = "attached", Q_ = "detached", bf = 300, Cs = 301, Ps = 302, Cc = 303, Pc = 304, qa = 306, Is = 1e3, fi = 1001, Ba = 1002, qe = 1003, Sf = 1004, lr = 1005, on = 1006, Ta = 1007, Zn = 1008, si = 1009, Mf = 1010, Tf = 1011, Tr = 1012, Fl = 1013, Vi = 1014, An = 1015, Ur = 1016, Ol = 1017, kl = 1018, Er = 1020, Ef = 35902, Af = 1021, wf = 1022, fn = 1023, Rf = 1024, Cf = 1025, Ar = 1026, wr = 1027, Gl = 1028, Hl = 1029, Pf = 1030, zl = 1031, Vl = 1033, Ea = 33776, Aa = 33777, wa = 33778, Ra = 33779, Ic = 35840, Dc = 35841, Lc = 35842, Uc = 35843, Nc = 36196, Bc = 37492, Fc = 37496, Oc = 37808, kc = 37809, Gc = 37810, Hc = 37811, zc = 37812, Vc = 37813, Wc = 37814, Xc = 37815, Yc = 37816, qc = 37817, jc = 37818, $c = 37819, Kc = 37820, Zc = 37821, Ca = 36492, Jc = 36494, Qc = 36495, If = 36283, tl = 36284, el = 36285, nl = 36286, tg = 2200, il = 2201, eg = 2202, Rr = 2300, Cr = 2301, no = 2302, ys = 2400, bs = 2401, Fa = 2402, Wl = 2500, ng = 2501, ig = 0, Df = 1, sl = 2, sg = 3200, rg = 3201, Lf = 0, ag = 1, di = "", De = "srgb", Ke = "srgb-linear", Oa = "linear", ce = "srgb", ts = 7680, Xh = 519, og = 512, cg = 513, lg = 514, Uf = 515, hg = 516, ug = 517, dg = 518, fg = 519, rl = 35044, Yh = "300 es", Jn = 2e3, ka = 2001;
    class $i {
        addEventListener(t, e) {
            this._listeners === void 0 && (this._listeners = {});
            const n = this._listeners;
            n[t] === void 0 && (n[t] = []), n[t].indexOf(e) === -1 && n[t].push(e);
        }
        hasEventListener(t, e) {
            const n = this._listeners;
            return n === void 0 ? !1 : n[t] !== void 0 && n[t].indexOf(e) !== -1;
        }
        removeEventListener(t, e) {
            const n = this._listeners;
            if (n === void 0) return;
            const s = n[t];
            if (s !== void 0) {
                const r = s.indexOf(e);
                r !== -1 && s.splice(r, 1);
            }
        }
        dispatchEvent(t) {
            const e = this._listeners;
            if (e === void 0) return;
            const n = e[t.type];
            if (n !== void 0) {
                t.target = this;
                const s = n.slice(0);
                for(let r = 0, a = s.length; r < a; r++)s[r].call(this, t);
                t.target = null;
            }
        }
    }
    const Oe = [
        "00",
        "01",
        "02",
        "03",
        "04",
        "05",
        "06",
        "07",
        "08",
        "09",
        "0a",
        "0b",
        "0c",
        "0d",
        "0e",
        "0f",
        "10",
        "11",
        "12",
        "13",
        "14",
        "15",
        "16",
        "17",
        "18",
        "19",
        "1a",
        "1b",
        "1c",
        "1d",
        "1e",
        "1f",
        "20",
        "21",
        "22",
        "23",
        "24",
        "25",
        "26",
        "27",
        "28",
        "29",
        "2a",
        "2b",
        "2c",
        "2d",
        "2e",
        "2f",
        "30",
        "31",
        "32",
        "33",
        "34",
        "35",
        "36",
        "37",
        "38",
        "39",
        "3a",
        "3b",
        "3c",
        "3d",
        "3e",
        "3f",
        "40",
        "41",
        "42",
        "43",
        "44",
        "45",
        "46",
        "47",
        "48",
        "49",
        "4a",
        "4b",
        "4c",
        "4d",
        "4e",
        "4f",
        "50",
        "51",
        "52",
        "53",
        "54",
        "55",
        "56",
        "57",
        "58",
        "59",
        "5a",
        "5b",
        "5c",
        "5d",
        "5e",
        "5f",
        "60",
        "61",
        "62",
        "63",
        "64",
        "65",
        "66",
        "67",
        "68",
        "69",
        "6a",
        "6b",
        "6c",
        "6d",
        "6e",
        "6f",
        "70",
        "71",
        "72",
        "73",
        "74",
        "75",
        "76",
        "77",
        "78",
        "79",
        "7a",
        "7b",
        "7c",
        "7d",
        "7e",
        "7f",
        "80",
        "81",
        "82",
        "83",
        "84",
        "85",
        "86",
        "87",
        "88",
        "89",
        "8a",
        "8b",
        "8c",
        "8d",
        "8e",
        "8f",
        "90",
        "91",
        "92",
        "93",
        "94",
        "95",
        "96",
        "97",
        "98",
        "99",
        "9a",
        "9b",
        "9c",
        "9d",
        "9e",
        "9f",
        "a0",
        "a1",
        "a2",
        "a3",
        "a4",
        "a5",
        "a6",
        "a7",
        "a8",
        "a9",
        "aa",
        "ab",
        "ac",
        "ad",
        "ae",
        "af",
        "b0",
        "b1",
        "b2",
        "b3",
        "b4",
        "b5",
        "b6",
        "b7",
        "b8",
        "b9",
        "ba",
        "bb",
        "bc",
        "bd",
        "be",
        "bf",
        "c0",
        "c1",
        "c2",
        "c3",
        "c4",
        "c5",
        "c6",
        "c7",
        "c8",
        "c9",
        "ca",
        "cb",
        "cc",
        "cd",
        "ce",
        "cf",
        "d0",
        "d1",
        "d2",
        "d3",
        "d4",
        "d5",
        "d6",
        "d7",
        "d8",
        "d9",
        "da",
        "db",
        "dc",
        "dd",
        "de",
        "df",
        "e0",
        "e1",
        "e2",
        "e3",
        "e4",
        "e5",
        "e6",
        "e7",
        "e8",
        "e9",
        "ea",
        "eb",
        "ec",
        "ed",
        "ee",
        "ef",
        "f0",
        "f1",
        "f2",
        "f3",
        "f4",
        "f5",
        "f6",
        "f7",
        "f8",
        "f9",
        "fa",
        "fb",
        "fc",
        "fd",
        "fe",
        "ff"
    ];
    let qh = 1234567;
    const pr = Math.PI / 180, Ds = 180 / Math.PI;
    function wn() {
        const i = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0;
        return (Oe[i & 255] + Oe[i >> 8 & 255] + Oe[i >> 16 & 255] + Oe[i >> 24 & 255] + "-" + Oe[t & 255] + Oe[t >> 8 & 255] + "-" + Oe[t >> 16 & 15 | 64] + Oe[t >> 24 & 255] + "-" + Oe[e & 63 | 128] + Oe[e >> 8 & 255] + "-" + Oe[e >> 16 & 255] + Oe[e >> 24 & 255] + Oe[n & 255] + Oe[n >> 8 & 255] + Oe[n >> 16 & 255] + Oe[n >> 24 & 255]).toLowerCase();
    }
    function Yt(i, t, e) {
        return Math.max(t, Math.min(e, i));
    }
    function Xl(i, t) {
        return (i % t + t) % t;
    }
    function pg(i, t, e, n, s) {
        return n + (i - t) * (s - n) / (e - t);
    }
    function mg(i, t, e) {
        return i !== t ? (e - i) / (t - i) : 0;
    }
    function mr(i, t, e) {
        return (1 - e) * i + e * t;
    }
    function _g(i, t, e, n) {
        return mr(i, t, 1 - Math.exp(-e * n));
    }
    function gg(i, t = 1) {
        return t - Math.abs(Xl(i, t * 2) - t);
    }
    function xg(i, t, e) {
        return i <= t ? 0 : i >= e ? 1 : (i = (i - t) / (e - t), i * i * (3 - 2 * i));
    }
    function vg(i, t, e) {
        return i <= t ? 0 : i >= e ? 1 : (i = (i - t) / (e - t), i * i * i * (i * (i * 6 - 15) + 10));
    }
    function yg(i, t) {
        return i + Math.floor(Math.random() * (t - i + 1));
    }
    function bg(i, t) {
        return i + Math.random() * (t - i);
    }
    function Sg(i) {
        return i * (.5 - Math.random());
    }
    function Mg(i) {
        i !== void 0 && (qh = i);
        let t = qh += 1831565813;
        return t = Math.imul(t ^ t >>> 15, t | 1), t ^= t + Math.imul(t ^ t >>> 7, t | 61), ((t ^ t >>> 14) >>> 0) / 4294967296;
    }
    function Tg(i) {
        return i * pr;
    }
    function Eg(i) {
        return i * Ds;
    }
    function Ag(i) {
        return (i & i - 1) === 0 && i !== 0;
    }
    function wg(i) {
        return Math.pow(2, Math.ceil(Math.log(i) / Math.LN2));
    }
    function Rg(i) {
        return Math.pow(2, Math.floor(Math.log(i) / Math.LN2));
    }
    function Cg(i, t, e, n, s) {
        const r = Math.cos, a = Math.sin, o = r(e / 2), c = a(e / 2), l = r((t + n) / 2), h = a((t + n) / 2), u = r((t - n) / 2), d = a((t - n) / 2), f = r((n - t) / 2), _ = a((n - t) / 2);
        switch(s){
            case "XYX":
                i.set(o * h, c * u, c * d, o * l);
                break;
            case "YZY":
                i.set(c * d, o * h, c * u, o * l);
                break;
            case "ZXZ":
                i.set(c * u, c * d, o * h, o * l);
                break;
            case "XZX":
                i.set(o * h, c * _, c * f, o * l);
                break;
            case "YXY":
                i.set(c * f, o * h, c * _, o * l);
                break;
            case "ZYZ":
                i.set(c * _, c * f, o * h, o * l);
                break;
            default:
                console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + s);
        }
    }
    function Tn(i, t) {
        switch(t.constructor){
            case Float32Array:
                return i;
            case Uint32Array:
                return i / 4294967295;
            case Uint16Array:
                return i / 65535;
            case Uint8Array:
                return i / 255;
            case Int32Array:
                return Math.max(i / 2147483647, -1);
            case Int16Array:
                return Math.max(i / 32767, -1);
            case Int8Array:
                return Math.max(i / 127, -1);
            default:
                throw new Error("Invalid component type.");
        }
    }
    function oe(i, t) {
        switch(t.constructor){
            case Float32Array:
                return i;
            case Uint32Array:
                return Math.round(i * 4294967295);
            case Uint16Array:
                return Math.round(i * 65535);
            case Uint8Array:
                return Math.round(i * 255);
            case Int32Array:
                return Math.round(i * 2147483647);
            case Int16Array:
                return Math.round(i * 32767);
            case Int8Array:
                return Math.round(i * 127);
            default:
                throw new Error("Invalid component type.");
        }
    }
    const Pg = {
        DEG2RAD: pr,
        RAD2DEG: Ds,
        generateUUID: wn,
        clamp: Yt,
        euclideanModulo: Xl,
        mapLinear: pg,
        inverseLerp: mg,
        lerp: mr,
        damp: _g,
        pingpong: gg,
        smoothstep: xg,
        smootherstep: vg,
        randInt: yg,
        randFloat: bg,
        randFloatSpread: Sg,
        seededRandom: Mg,
        degToRad: Tg,
        radToDeg: Eg,
        isPowerOfTwo: Ag,
        ceilPowerOfTwo: wg,
        floorPowerOfTwo: Rg,
        setQuaternionFromProperEuler: Cg,
        normalize: oe,
        denormalize: Tn
    };
    class Kt {
        constructor(t = 0, e = 0){
            Kt.prototype.isVector2 = !0, this.x = t, this.y = e;
        }
        get width() {
            return this.x;
        }
        set width(t) {
            this.x = t;
        }
        get height() {
            return this.y;
        }
        set height(t) {
            this.y = t;
        }
        set(t, e) {
            return this.x = t, this.y = e, this;
        }
        setScalar(t) {
            return this.x = t, this.y = t, this;
        }
        setX(t) {
            return this.x = t, this;
        }
        setY(t) {
            return this.y = t, this;
        }
        setComponent(t, e) {
            switch(t){
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t);
            }
            return this;
        }
        getComponent(t) {
            switch(t){
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error("index is out of range: " + t);
            }
        }
        clone() {
            return new this.constructor(this.x, this.y);
        }
        copy(t) {
            return this.x = t.x, this.y = t.y, this;
        }
        add(t) {
            return this.x += t.x, this.y += t.y, this;
        }
        addScalar(t) {
            return this.x += t, this.y += t, this;
        }
        addVectors(t, e) {
            return this.x = t.x + e.x, this.y = t.y + e.y, this;
        }
        addScaledVector(t, e) {
            return this.x += t.x * e, this.y += t.y * e, this;
        }
        sub(t) {
            return this.x -= t.x, this.y -= t.y, this;
        }
        subScalar(t) {
            return this.x -= t, this.y -= t, this;
        }
        subVectors(t, e) {
            return this.x = t.x - e.x, this.y = t.y - e.y, this;
        }
        multiply(t) {
            return this.x *= t.x, this.y *= t.y, this;
        }
        multiplyScalar(t) {
            return this.x *= t, this.y *= t, this;
        }
        divide(t) {
            return this.x /= t.x, this.y /= t.y, this;
        }
        divideScalar(t) {
            return this.multiplyScalar(1 / t);
        }
        applyMatrix3(t) {
            const e = this.x, n = this.y, s = t.elements;
            return this.x = s[0] * e + s[3] * n + s[6], this.y = s[1] * e + s[4] * n + s[7], this;
        }
        min(t) {
            return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this;
        }
        max(t) {
            return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this;
        }
        clamp(t, e) {
            return this.x = Yt(this.x, t.x, e.x), this.y = Yt(this.y, t.y, e.y), this;
        }
        clampScalar(t, e) {
            return this.x = Yt(this.x, t, e), this.y = Yt(this.y, t, e), this;
        }
        clampLength(t, e) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Yt(n, t, e));
        }
        floor() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
        }
        ceil() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
        }
        round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        }
        roundToZero() {
            return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
        }
        negate() {
            return this.x = -this.x, this.y = -this.y, this;
        }
        dot(t) {
            return this.x * t.x + this.y * t.y;
        }
        cross(t) {
            return this.x * t.y - this.y * t.x;
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y;
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
            return this.divideScalar(this.length() || 1);
        }
        angle() {
            return Math.atan2(-this.y, -this.x) + Math.PI;
        }
        angleTo(t) {
            const e = Math.sqrt(this.lengthSq() * t.lengthSq());
            if (e === 0) return Math.PI / 2;
            const n = this.dot(t) / e;
            return Math.acos(Yt(n, -1, 1));
        }
        distanceTo(t) {
            return Math.sqrt(this.distanceToSquared(t));
        }
        distanceToSquared(t) {
            const e = this.x - t.x, n = this.y - t.y;
            return e * e + n * n;
        }
        manhattanDistanceTo(t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
        }
        setLength(t) {
            return this.normalize().multiplyScalar(t);
        }
        lerp(t, e) {
            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this;
        }
        lerpVectors(t, e, n) {
            return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this;
        }
        equals(t) {
            return t.x === this.x && t.y === this.y;
        }
        fromArray(t, e = 0) {
            return this.x = t[e], this.y = t[e + 1], this;
        }
        toArray(t = [], e = 0) {
            return t[e] = this.x, t[e + 1] = this.y, t;
        }
        fromBufferAttribute(t, e) {
            return this.x = t.getX(e), this.y = t.getY(e), this;
        }
        rotateAround(t, e) {
            const n = Math.cos(e), s = Math.sin(e), r = this.x - t.x, a = this.y - t.y;
            return this.x = r * n - a * s + t.x, this.y = r * s + a * n + t.y, this;
        }
        random() {
            return this.x = Math.random(), this.y = Math.random(), this;
        }
        *[Symbol.iterator]() {
            yield this.x, yield this.y;
        }
    }
    class Gt {
        constructor(t, e, n, s, r, a, o, c, l){
            Gt.prototype.isMatrix3 = !0, this.elements = [
                1,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                1
            ], t !== void 0 && this.set(t, e, n, s, r, a, o, c, l);
        }
        set(t, e, n, s, r, a, o, c, l) {
            const h = this.elements;
            return h[0] = t, h[1] = s, h[2] = o, h[3] = e, h[4] = r, h[5] = c, h[6] = n, h[7] = a, h[8] = l, this;
        }
        identity() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
        }
        copy(t) {
            const e = this.elements, n = t.elements;
            return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this;
        }
        extractBasis(t, e, n) {
            return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
        }
        setFromMatrix4(t) {
            const e = t.elements;
            return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this;
        }
        multiply(t) {
            return this.multiplyMatrices(this, t);
        }
        premultiply(t) {
            return this.multiplyMatrices(t, this);
        }
        multiplyMatrices(t, e) {
            const n = t.elements, s = e.elements, r = this.elements, a = n[0], o = n[3], c = n[6], l = n[1], h = n[4], u = n[7], d = n[2], f = n[5], _ = n[8], g = s[0], p = s[3], m = s[6], x = s[1], y = s[4], v = s[7], I = s[2], w = s[5], R = s[8];
            return r[0] = a * g + o * x + c * I, r[3] = a * p + o * y + c * w, r[6] = a * m + o * v + c * R, r[1] = l * g + h * x + u * I, r[4] = l * p + h * y + u * w, r[7] = l * m + h * v + u * R, r[2] = d * g + f * x + _ * I, r[5] = d * p + f * y + _ * w, r[8] = d * m + f * v + _ * R, this;
        }
        multiplyScalar(t) {
            const e = this.elements;
            return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this;
        }
        determinant() {
            const t = this.elements, e = t[0], n = t[1], s = t[2], r = t[3], a = t[4], o = t[5], c = t[6], l = t[7], h = t[8];
            return e * a * h - e * o * l - n * r * h + n * o * c + s * r * l - s * a * c;
        }
        invert() {
            const t = this.elements, e = t[0], n = t[1], s = t[2], r = t[3], a = t[4], o = t[5], c = t[6], l = t[7], h = t[8], u = h * a - o * l, d = o * c - h * r, f = l * r - a * c, _ = e * u + n * d + s * f;
            if (_ === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
            const g = 1 / _;
            return t[0] = u * g, t[1] = (s * l - h * n) * g, t[2] = (o * n - s * a) * g, t[3] = d * g, t[4] = (h * e - s * c) * g, t[5] = (s * r - o * e) * g, t[6] = f * g, t[7] = (n * c - l * e) * g, t[8] = (a * e - n * r) * g, this;
        }
        transpose() {
            let t;
            const e = this.elements;
            return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this;
        }
        getNormalMatrix(t) {
            return this.setFromMatrix4(t).invert().transpose();
        }
        transposeIntoArray(t) {
            const e = this.elements;
            return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this;
        }
        setUvTransform(t, e, n, s, r, a, o) {
            const c = Math.cos(r), l = Math.sin(r);
            return this.set(n * c, n * l, -n * (c * a + l * o) + a + t, -s * l, s * c, -s * (-l * a + c * o) + o + e, 0, 0, 1), this;
        }
        scale(t, e) {
            return this.premultiply(io.makeScale(t, e)), this;
        }
        rotate(t) {
            return this.premultiply(io.makeRotation(-t)), this;
        }
        translate(t, e) {
            return this.premultiply(io.makeTranslation(t, e)), this;
        }
        makeTranslation(t, e) {
            return t.isVector2 ? this.set(1, 0, t.x, 0, 1, t.y, 0, 0, 1) : this.set(1, 0, t, 0, 1, e, 0, 0, 1), this;
        }
        makeRotation(t) {
            const e = Math.cos(t), n = Math.sin(t);
            return this.set(e, -n, 0, n, e, 0, 0, 0, 1), this;
        }
        makeScale(t, e) {
            return this.set(t, 0, 0, 0, e, 0, 0, 0, 1), this;
        }
        equals(t) {
            const e = this.elements, n = t.elements;
            for(let s = 0; s < 9; s++)if (e[s] !== n[s]) return !1;
            return !0;
        }
        fromArray(t, e = 0) {
            for(let n = 0; n < 9; n++)this.elements[n] = t[n + e];
            return this;
        }
        toArray(t = [], e = 0) {
            const n = this.elements;
            return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t;
        }
        clone() {
            return new this.constructor().fromArray(this.elements);
        }
    }
    const io = new Gt;
    function Nf(i) {
        for(let t = i.length - 1; t >= 0; --t)if (i[t] >= 65535) return !0;
        return !1;
    }
    function Pr(i) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", i);
    }
    function Ig() {
        const i = Pr("canvas");
        return i.style.display = "block", i;
    }
    const jh = {};
    function Pa(i) {
        i in jh || (jh[i] = !0, console.warn(i));
    }
    function Dg(i, t, e) {
        return new Promise(function(n, s) {
            function r() {
                switch(i.clientWaitSync(t, i.SYNC_FLUSH_COMMANDS_BIT, 0)){
                    case i.WAIT_FAILED:
                        s();
                        break;
                    case i.TIMEOUT_EXPIRED:
                        setTimeout(r, e);
                        break;
                    default:
                        n();
                }
            }
            setTimeout(r, e);
        });
    }
    function Lg(i) {
        const t = i.elements;
        t[2] = .5 * t[2] + .5 * t[3], t[6] = .5 * t[6] + .5 * t[7], t[10] = .5 * t[10] + .5 * t[11], t[14] = .5 * t[14] + .5 * t[15];
    }
    function Ug(i) {
        const t = i.elements;
        t[11] === -1 ? (t[10] = -t[10] - 1, t[14] = -t[14]) : (t[10] = -t[10], t[14] = -t[14] + 1);
    }
    const $h = new Gt().set(.4123908, .3575843, .1804808, .212639, .7151687, .0721923, .0193308, .1191948, .9505322), Kh = new Gt().set(3.2409699, -1.5373832, -.4986108, -.9692436, 1.8759675, .0415551, .0556301, -.203977, 1.0569715);
    function Ng() {
        const i = {
            enabled: !0,
            workingColorSpace: Ke,
            spaces: {},
            convert: function(s, r, a) {
                return this.enabled === !1 || r === a || !r || !a || (this.spaces[r].transfer === ce && (s.r = Qn(s.r), s.g = Qn(s.g), s.b = Qn(s.b)), this.spaces[r].primaries !== this.spaces[a].primaries && (s.applyMatrix3(this.spaces[r].toXYZ), s.applyMatrix3(this.spaces[a].fromXYZ)), this.spaces[a].transfer === ce && (s.r = Es(s.r), s.g = Es(s.g), s.b = Es(s.b))), s;
            },
            fromWorkingColorSpace: function(s, r) {
                return this.convert(s, this.workingColorSpace, r);
            },
            toWorkingColorSpace: function(s, r) {
                return this.convert(s, r, this.workingColorSpace);
            },
            getPrimaries: function(s) {
                return this.spaces[s].primaries;
            },
            getTransfer: function(s) {
                return s === di ? Oa : this.spaces[s].transfer;
            },
            getLuminanceCoefficients: function(s, r = this.workingColorSpace) {
                return s.fromArray(this.spaces[r].luminanceCoefficients);
            },
            define: function(s) {
                Object.assign(this.spaces, s);
            },
            _getMatrix: function(s, r, a) {
                return s.copy(this.spaces[r].toXYZ).multiply(this.spaces[a].fromXYZ);
            },
            _getDrawingBufferColorSpace: function(s) {
                return this.spaces[s].outputColorSpaceConfig.drawingBufferColorSpace;
            },
            _getUnpackColorSpace: function(s = this.workingColorSpace) {
                return this.spaces[s].workingColorSpaceConfig.unpackColorSpace;
            }
        }, t = [
            .64,
            .33,
            .3,
            .6,
            .15,
            .06
        ], e = [
            .2126,
            .7152,
            .0722
        ], n = [
            .3127,
            .329
        ];
        return i.define({
            [Ke]: {
                primaries: t,
                whitePoint: n,
                transfer: Oa,
                toXYZ: $h,
                fromXYZ: Kh,
                luminanceCoefficients: e,
                workingColorSpaceConfig: {
                    unpackColorSpace: De
                },
                outputColorSpaceConfig: {
                    drawingBufferColorSpace: De
                }
            },
            [De]: {
                primaries: t,
                whitePoint: n,
                transfer: ce,
                toXYZ: $h,
                fromXYZ: Kh,
                luminanceCoefficients: e,
                outputColorSpaceConfig: {
                    drawingBufferColorSpace: De
                }
            }
        }), i;
    }
    const $t = Ng();
    function Qn(i) {
        return i < .04045 ? i * .0773993808 : Math.pow(i * .9478672986 + .0521327014, 2.4);
    }
    function Es(i) {
        return i < .0031308 ? i * 12.92 : 1.055 * Math.pow(i, .41666) - .055;
    }
    let es;
    class Bg {
        static getDataURL(t, e = "image/png") {
            if (/^data:/i.test(t.src) || typeof HTMLCanvasElement > "u") return t.src;
            let n;
            if (t instanceof HTMLCanvasElement) n = t;
            else {
                es === void 0 && (es = Pr("canvas")), es.width = t.width, es.height = t.height;
                const s = es.getContext("2d");
                t instanceof ImageData ? s.putImageData(t, 0, 0) : s.drawImage(t, 0, 0, t.width, t.height), n = es;
            }
            return n.toDataURL(e);
        }
        static sRGBToLinear(t) {
            if (typeof HTMLImageElement < "u" && t instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && t instanceof ImageBitmap) {
                const e = Pr("canvas");
                e.width = t.width, e.height = t.height;
                const n = e.getContext("2d");
                n.drawImage(t, 0, 0, t.width, t.height);
                const s = n.getImageData(0, 0, t.width, t.height), r = s.data;
                for(let a = 0; a < r.length; a++)r[a] = Qn(r[a] / 255) * 255;
                return n.putImageData(s, 0, 0), e;
            } else if (t.data) {
                const e = t.data.slice(0);
                for(let n = 0; n < e.length; n++)e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[n] = Math.floor(Qn(e[n] / 255) * 255) : e[n] = Qn(e[n]);
                return {
                    data: e,
                    width: t.width,
                    height: t.height
                };
            } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), t;
        }
    }
    let Fg = 0;
    class Yl {
        constructor(t = null){
            this.isSource = !0, Object.defineProperty(this, "id", {
                value: Fg++
            }), this.uuid = wn(), this.data = t, this.dataReady = !0, this.version = 0;
        }
        set needsUpdate(t) {
            t === !0 && this.version++;
        }
        toJSON(t) {
            const e = t === void 0 || typeof t == "string";
            if (!e && t.images[this.uuid] !== void 0) return t.images[this.uuid];
            const n = {
                uuid: this.uuid,
                url: ""
            }, s = this.data;
            if (s !== null) {
                let r;
                if (Array.isArray(s)) {
                    r = [];
                    for(let a = 0, o = s.length; a < o; a++)s[a].isDataTexture ? r.push(so(s[a].image)) : r.push(so(s[a]));
                } else r = so(s);
                n.url = r;
            }
            return e || (t.images[this.uuid] = n), n;
        }
    }
    function so(i) {
        return typeof HTMLImageElement < "u" && i instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && i instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && i instanceof ImageBitmap ? Bg.getDataURL(i) : i.data ? {
            data: Array.from(i.data),
            width: i.width,
            height: i.height,
            type: i.data.constructor.name
        } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
    }
    let Og = 0, tn = class Ia extends $i {
        constructor(t = Ia.DEFAULT_IMAGE, e = Ia.DEFAULT_MAPPING, n = fi, s = fi, r = on, a = Zn, o = fn, c = si, l = Ia.DEFAULT_ANISOTROPY, h = di){
            super(), this.isTexture = !0, Object.defineProperty(this, "id", {
                value: Og++
            }), this.uuid = wn(), this.name = "", this.source = new Yl(t), this.mipmaps = [], this.mapping = e, this.channel = 0, this.wrapS = n, this.wrapT = s, this.magFilter = r, this.minFilter = a, this.anisotropy = l, this.format = o, this.internalFormat = null, this.type = c, this.offset = new Kt(0, 0), this.repeat = new Kt(1, 1), this.center = new Kt(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Gt, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = h, this.userData = {}, this.version = 0, this.onUpdate = null, this.renderTarget = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0;
        }
        get image() {
            return this.source.data;
        }
        set image(t = null) {
            this.source.data = t;
        }
        updateMatrix() {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
        }
        clone() {
            return new this.constructor().copy(this);
        }
        copy(t) {
            return this.name = t.name, this.source = t.source, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.channel = t.channel, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.colorSpace = t.colorSpace, this.renderTarget = t.renderTarget, this.isRenderTargetTexture = t.isRenderTargetTexture, this.userData = JSON.parse(JSON.stringify(t.userData)), this.needsUpdate = !0, this;
        }
        toJSON(t) {
            const e = t === void 0 || typeof t == "string";
            if (!e && t.textures[this.uuid] !== void 0) return t.textures[this.uuid];
            const n = {
                metadata: {
                    version: 4.6,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                image: this.source.toJSON(t).uuid,
                mapping: this.mapping,
                channel: this.channel,
                repeat: [
                    this.repeat.x,
                    this.repeat.y
                ],
                offset: [
                    this.offset.x,
                    this.offset.y
                ],
                center: [
                    this.center.x,
                    this.center.y
                ],
                rotation: this.rotation,
                wrap: [
                    this.wrapS,
                    this.wrapT
                ],
                format: this.format,
                internalFormat: this.internalFormat,
                type: this.type,
                colorSpace: this.colorSpace,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY,
                generateMipmaps: this.generateMipmaps,
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment
            };
            return Object.keys(this.userData).length > 0 && (n.userData = this.userData), e || (t.textures[this.uuid] = n), n;
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            });
        }
        transformUv(t) {
            if (this.mapping !== bf) return t;
            if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch(this.wrapS){
                case Is:
                    t.x = t.x - Math.floor(t.x);
                    break;
                case fi:
                    t.x = t.x < 0 ? 0 : 1;
                    break;
                case Ba:
                    Math.abs(Math.floor(t.x) % 2) === 1 ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x);
                    break;
            }
            if (t.y < 0 || t.y > 1) switch(this.wrapT){
                case Is:
                    t.y = t.y - Math.floor(t.y);
                    break;
                case fi:
                    t.y = t.y < 0 ? 0 : 1;
                    break;
                case Ba:
                    Math.abs(Math.floor(t.y) % 2) === 1 ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y);
                    break;
            }
            return this.flipY && (t.y = 1 - t.y), t;
        }
        set needsUpdate(t) {
            t === !0 && (this.version++, this.source.needsUpdate = !0);
        }
        set needsPMREMUpdate(t) {
            t === !0 && this.pmremVersion++;
        }
    };
    tn.DEFAULT_IMAGE = null;
    tn.DEFAULT_MAPPING = bf;
    tn.DEFAULT_ANISOTROPY = 1;
    class ne {
        constructor(t = 0, e = 0, n = 0, s = 1){
            ne.prototype.isVector4 = !0, this.x = t, this.y = e, this.z = n, this.w = s;
        }
        get width() {
            return this.z;
        }
        set width(t) {
            this.z = t;
        }
        get height() {
            return this.w;
        }
        set height(t) {
            this.w = t;
        }
        set(t, e, n, s) {
            return this.x = t, this.y = e, this.z = n, this.w = s, this;
        }
        setScalar(t) {
            return this.x = t, this.y = t, this.z = t, this.w = t, this;
        }
        setX(t) {
            return this.x = t, this;
        }
        setY(t) {
            return this.y = t, this;
        }
        setZ(t) {
            return this.z = t, this;
        }
        setW(t) {
            return this.w = t, this;
        }
        setComponent(t, e) {
            switch(t){
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                case 2:
                    this.z = e;
                    break;
                case 3:
                    this.w = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t);
            }
            return this;
        }
        getComponent(t) {
            switch(t){
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error("index is out of range: " + t);
            }
        }
        clone() {
            return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(t) {
            return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w !== void 0 ? t.w : 1, this;
        }
        add(t) {
            return this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this;
        }
        addScalar(t) {
            return this.x += t, this.y += t, this.z += t, this.w += t, this;
        }
        addVectors(t, e) {
            return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this;
        }
        addScaledVector(t, e) {
            return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this;
        }
        sub(t) {
            return this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this;
        }
        subScalar(t) {
            return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this;
        }
        subVectors(t, e) {
            return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this;
        }
        multiply(t) {
            return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this;
        }
        multiplyScalar(t) {
            return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this;
        }
        applyMatrix4(t) {
            const e = this.x, n = this.y, s = this.z, r = this.w, a = t.elements;
            return this.x = a[0] * e + a[4] * n + a[8] * s + a[12] * r, this.y = a[1] * e + a[5] * n + a[9] * s + a[13] * r, this.z = a[2] * e + a[6] * n + a[10] * s + a[14] * r, this.w = a[3] * e + a[7] * n + a[11] * s + a[15] * r, this;
        }
        divide(t) {
            return this.x /= t.x, this.y /= t.y, this.z /= t.z, this.w /= t.w, this;
        }
        divideScalar(t) {
            return this.multiplyScalar(1 / t);
        }
        setAxisAngleFromQuaternion(t) {
            this.w = 2 * Math.acos(t.w);
            const e = Math.sqrt(1 - t.w * t.w);
            return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this;
        }
        setAxisAngleFromRotationMatrix(t) {
            let e, n, s, r;
            const c = t.elements, l = c[0], h = c[4], u = c[8], d = c[1], f = c[5], _ = c[9], g = c[2], p = c[6], m = c[10];
            if (Math.abs(h - d) < .01 && Math.abs(u - g) < .01 && Math.abs(_ - p) < .01) {
                if (Math.abs(h + d) < .1 && Math.abs(u + g) < .1 && Math.abs(_ + p) < .1 && Math.abs(l + f + m - 3) < .1) return this.set(1, 0, 0, 0), this;
                e = Math.PI;
                const y = (l + 1) / 2, v = (f + 1) / 2, I = (m + 1) / 2, w = (h + d) / 4, R = (u + g) / 4, N = (_ + p) / 4;
                return y > v && y > I ? y < .01 ? (n = 0, s = .707106781, r = .707106781) : (n = Math.sqrt(y), s = w / n, r = R / n) : v > I ? v < .01 ? (n = .707106781, s = 0, r = .707106781) : (s = Math.sqrt(v), n = w / s, r = N / s) : I < .01 ? (n = .707106781, s = .707106781, r = 0) : (r = Math.sqrt(I), n = R / r, s = N / r), this.set(n, s, r, e), this;
            }
            let x = Math.sqrt((p - _) * (p - _) + (u - g) * (u - g) + (d - h) * (d - h));
            return Math.abs(x) < .001 && (x = 1), this.x = (p - _) / x, this.y = (u - g) / x, this.z = (d - h) / x, this.w = Math.acos((l + f + m - 1) / 2), this;
        }
        setFromMatrixPosition(t) {
            const e = t.elements;
            return this.x = e[12], this.y = e[13], this.z = e[14], this.w = e[15], this;
        }
        min(t) {
            return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this;
        }
        max(t) {
            return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this;
        }
        clamp(t, e) {
            return this.x = Yt(this.x, t.x, e.x), this.y = Yt(this.y, t.y, e.y), this.z = Yt(this.z, t.z, e.z), this.w = Yt(this.w, t.w, e.w), this;
        }
        clampScalar(t, e) {
            return this.x = Yt(this.x, t, e), this.y = Yt(this.y, t, e), this.z = Yt(this.z, t, e), this.w = Yt(this.w, t, e), this;
        }
        clampLength(t, e) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Yt(n, t, e));
        }
        floor() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
        }
        ceil() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
        }
        round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
        }
        roundToZero() {
            return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
        }
        negate() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
        }
        dot(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
        }
        normalize() {
            return this.divideScalar(this.length() || 1);
        }
        setLength(t) {
            return this.normalize().multiplyScalar(t);
        }
        lerp(t, e) {
            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this;
        }
        lerpVectors(t, e, n) {
            return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this;
        }
        equals(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w;
        }
        fromArray(t, e = 0) {
            return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this;
        }
        toArray(t = [], e = 0) {
            return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t;
        }
        fromBufferAttribute(t, e) {
            return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this;
        }
        random() {
            return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
        }
        *[Symbol.iterator]() {
            yield this.x, yield this.y, yield this.z, yield this.w;
        }
    }
    let kg = class extends $i {
        constructor(t = 1, e = 1, n = {}){
            super(), this.isRenderTarget = !0, this.width = t, this.height = e, this.depth = 1, this.scissor = new ne(0, 0, t, e), this.scissorTest = !1, this.viewport = new ne(0, 0, t, e);
            const s = {
                width: t,
                height: e,
                depth: 1
            };
            n = Object.assign({
                generateMipmaps: !1,
                internalFormat: null,
                minFilter: on,
                depthBuffer: !0,
                stencilBuffer: !1,
                resolveDepthBuffer: !0,
                resolveStencilBuffer: !0,
                depthTexture: null,
                samples: 0,
                count: 1
            }, n);
            const r = new tn(s, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace);
            r.flipY = !1, r.generateMipmaps = n.generateMipmaps, r.internalFormat = n.internalFormat, this.textures = [];
            const a = n.count;
            for(let o = 0; o < a; o++)this.textures[o] = r.clone(), this.textures[o].isRenderTargetTexture = !0, this.textures[o].renderTarget = this;
            this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.resolveDepthBuffer = n.resolveDepthBuffer, this.resolveStencilBuffer = n.resolveStencilBuffer, this._depthTexture = n.depthTexture, this.samples = n.samples;
        }
        get texture() {
            return this.textures[0];
        }
        set texture(t) {
            this.textures[0] = t;
        }
        set depthTexture(t) {
            this._depthTexture !== null && (this._depthTexture.renderTarget = null), t !== null && (t.renderTarget = this), this._depthTexture = t;
        }
        get depthTexture() {
            return this._depthTexture;
        }
        setSize(t, e, n = 1) {
            if (this.width !== t || this.height !== e || this.depth !== n) {
                this.width = t, this.height = e, this.depth = n;
                for(let s = 0, r = this.textures.length; s < r; s++)this.textures[s].image.width = t, this.textures[s].image.height = e, this.textures[s].image.depth = n;
                this.dispose();
            }
            this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e);
        }
        clone() {
            return new this.constructor().copy(this);
        }
        copy(t) {
            this.width = t.width, this.height = t.height, this.depth = t.depth, this.scissor.copy(t.scissor), this.scissorTest = t.scissorTest, this.viewport.copy(t.viewport), this.textures.length = 0;
            for(let e = 0, n = t.textures.length; e < n; e++){
                this.textures[e] = t.textures[e].clone(), this.textures[e].isRenderTargetTexture = !0, this.textures[e].renderTarget = this;
                const s = Object.assign({}, t.textures[e].image);
                this.textures[e].source = new Yl(s);
            }
            return this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.resolveDepthBuffer = t.resolveDepthBuffer, this.resolveStencilBuffer = t.resolveStencilBuffer, t.depthTexture !== null && (this.depthTexture = t.depthTexture.clone()), this.samples = t.samples, this;
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            });
        }
    };
    class Wi extends kg {
        constructor(t = 1, e = 1, n = {}){
            super(t, e, n), this.isWebGLRenderTarget = !0;
        }
    }
    class Bf extends tn {
        constructor(t = null, e = 1, n = 1, s = 1){
            super(null), this.isDataArrayTexture = !0, this.image = {
                data: t,
                width: e,
                height: n,
                depth: s
            }, this.magFilter = qe, this.minFilter = qe, this.wrapR = fi, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = new Set;
        }
        addLayerUpdate(t) {
            this.layerUpdates.add(t);
        }
        clearLayerUpdates() {
            this.layerUpdates.clear();
        }
    }
    class Gg extends tn {
        constructor(t = null, e = 1, n = 1, s = 1){
            super(null), this.isData3DTexture = !0, this.image = {
                data: t,
                width: e,
                height: n,
                depth: s
            }, this.magFilter = qe, this.minFilter = qe, this.wrapR = fi, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
        }
    }
    class Rn {
        constructor(t = 0, e = 0, n = 0, s = 1){
            this.isQuaternion = !0, this._x = t, this._y = e, this._z = n, this._w = s;
        }
        static slerpFlat(t, e, n, s, r, a, o) {
            let c = n[s + 0], l = n[s + 1], h = n[s + 2], u = n[s + 3];
            const d = r[a + 0], f = r[a + 1], _ = r[a + 2], g = r[a + 3];
            if (o === 0) {
                t[e + 0] = c, t[e + 1] = l, t[e + 2] = h, t[e + 3] = u;
                return;
            }
            if (o === 1) {
                t[e + 0] = d, t[e + 1] = f, t[e + 2] = _, t[e + 3] = g;
                return;
            }
            if (u !== g || c !== d || l !== f || h !== _) {
                let p = 1 - o;
                const m = c * d + l * f + h * _ + u * g, x = m >= 0 ? 1 : -1, y = 1 - m * m;
                if (y > Number.EPSILON) {
                    const I = Math.sqrt(y), w = Math.atan2(I, m * x);
                    p = Math.sin(p * w) / I, o = Math.sin(o * w) / I;
                }
                const v = o * x;
                if (c = c * p + d * v, l = l * p + f * v, h = h * p + _ * v, u = u * p + g * v, p === 1 - o) {
                    const I = 1 / Math.sqrt(c * c + l * l + h * h + u * u);
                    c *= I, l *= I, h *= I, u *= I;
                }
            }
            t[e] = c, t[e + 1] = l, t[e + 2] = h, t[e + 3] = u;
        }
        static multiplyQuaternionsFlat(t, e, n, s, r, a) {
            const o = n[s], c = n[s + 1], l = n[s + 2], h = n[s + 3], u = r[a], d = r[a + 1], f = r[a + 2], _ = r[a + 3];
            return t[e] = o * _ + h * u + c * f - l * d, t[e + 1] = c * _ + h * d + l * u - o * f, t[e + 2] = l * _ + h * f + o * d - c * u, t[e + 3] = h * _ - o * u - c * d - l * f, t;
        }
        get x() {
            return this._x;
        }
        set x(t) {
            this._x = t, this._onChangeCallback();
        }
        get y() {
            return this._y;
        }
        set y(t) {
            this._y = t, this._onChangeCallback();
        }
        get z() {
            return this._z;
        }
        set z(t) {
            this._z = t, this._onChangeCallback();
        }
        get w() {
            return this._w;
        }
        set w(t) {
            this._w = t, this._onChangeCallback();
        }
        set(t, e, n, s) {
            return this._x = t, this._y = e, this._z = n, this._w = s, this._onChangeCallback(), this;
        }
        clone() {
            return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(t) {
            return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this;
        }
        setFromEuler(t, e = !0) {
            const n = t._x, s = t._y, r = t._z, a = t._order, o = Math.cos, c = Math.sin, l = o(n / 2), h = o(s / 2), u = o(r / 2), d = c(n / 2), f = c(s / 2), _ = c(r / 2);
            switch(a){
                case "XYZ":
                    this._x = d * h * u + l * f * _, this._y = l * f * u - d * h * _, this._z = l * h * _ + d * f * u, this._w = l * h * u - d * f * _;
                    break;
                case "YXZ":
                    this._x = d * h * u + l * f * _, this._y = l * f * u - d * h * _, this._z = l * h * _ - d * f * u, this._w = l * h * u + d * f * _;
                    break;
                case "ZXY":
                    this._x = d * h * u - l * f * _, this._y = l * f * u + d * h * _, this._z = l * h * _ + d * f * u, this._w = l * h * u - d * f * _;
                    break;
                case "ZYX":
                    this._x = d * h * u - l * f * _, this._y = l * f * u + d * h * _, this._z = l * h * _ - d * f * u, this._w = l * h * u + d * f * _;
                    break;
                case "YZX":
                    this._x = d * h * u + l * f * _, this._y = l * f * u + d * h * _, this._z = l * h * _ - d * f * u, this._w = l * h * u - d * f * _;
                    break;
                case "XZY":
                    this._x = d * h * u - l * f * _, this._y = l * f * u - d * h * _, this._z = l * h * _ + d * f * u, this._w = l * h * u + d * f * _;
                    break;
                default:
                    console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a);
            }
            return e === !0 && this._onChangeCallback(), this;
        }
        setFromAxisAngle(t, e) {
            const n = e / 2, s = Math.sin(n);
            return this._x = t.x * s, this._y = t.y * s, this._z = t.z * s, this._w = Math.cos(n), this._onChangeCallback(), this;
        }
        setFromRotationMatrix(t) {
            const e = t.elements, n = e[0], s = e[4], r = e[8], a = e[1], o = e[5], c = e[9], l = e[2], h = e[6], u = e[10], d = n + o + u;
            if (d > 0) {
                const f = .5 / Math.sqrt(d + 1);
                this._w = .25 / f, this._x = (h - c) * f, this._y = (r - l) * f, this._z = (a - s) * f;
            } else if (n > o && n > u) {
                const f = 2 * Math.sqrt(1 + n - o - u);
                this._w = (h - c) / f, this._x = .25 * f, this._y = (s + a) / f, this._z = (r + l) / f;
            } else if (o > u) {
                const f = 2 * Math.sqrt(1 + o - n - u);
                this._w = (r - l) / f, this._x = (s + a) / f, this._y = .25 * f, this._z = (c + h) / f;
            } else {
                const f = 2 * Math.sqrt(1 + u - n - o);
                this._w = (a - s) / f, this._x = (r + l) / f, this._y = (c + h) / f, this._z = .25 * f;
            }
            return this._onChangeCallback(), this;
        }
        setFromUnitVectors(t, e) {
            let n = t.dot(e) + 1;
            return n < Number.EPSILON ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize();
        }
        angleTo(t) {
            return 2 * Math.acos(Math.abs(Yt(this.dot(t), -1, 1)));
        }
        rotateTowards(t, e) {
            const n = this.angleTo(t);
            if (n === 0) return this;
            const s = Math.min(1, e / n);
            return this.slerp(t, s), this;
        }
        identity() {
            return this.set(0, 0, 0, 1);
        }
        invert() {
            return this.conjugate();
        }
        conjugate() {
            return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
        }
        dot(t) {
            return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
        }
        lengthSq() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
        }
        length() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
        }
        normalize() {
            let t = this.length();
            return t === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this;
        }
        multiply(t) {
            return this.multiplyQuaternions(this, t);
        }
        premultiply(t) {
            return this.multiplyQuaternions(t, this);
        }
        multiplyQuaternions(t, e) {
            const n = t._x, s = t._y, r = t._z, a = t._w, o = e._x, c = e._y, l = e._z, h = e._w;
            return this._x = n * h + a * o + s * l - r * c, this._y = s * h + a * c + r * o - n * l, this._z = r * h + a * l + n * c - s * o, this._w = a * h - n * o - s * c - r * l, this._onChangeCallback(), this;
        }
        slerp(t, e) {
            if (e === 0) return this;
            if (e === 1) return this.copy(t);
            const n = this._x, s = this._y, r = this._z, a = this._w;
            let o = a * t._w + n * t._x + s * t._y + r * t._z;
            if (o < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, o = -o) : this.copy(t), o >= 1) return this._w = a, this._x = n, this._y = s, this._z = r, this;
            const c = 1 - o * o;
            if (c <= Number.EPSILON) {
                const f = 1 - e;
                return this._w = f * a + e * this._w, this._x = f * n + e * this._x, this._y = f * s + e * this._y, this._z = f * r + e * this._z, this.normalize(), this;
            }
            const l = Math.sqrt(c), h = Math.atan2(l, o), u = Math.sin((1 - e) * h) / l, d = Math.sin(e * h) / l;
            return this._w = a * u + this._w * d, this._x = n * u + this._x * d, this._y = s * u + this._y * d, this._z = r * u + this._z * d, this._onChangeCallback(), this;
        }
        slerpQuaternions(t, e, n) {
            return this.copy(t).slerp(e, n);
        }
        random() {
            const t = 2 * Math.PI * Math.random(), e = 2 * Math.PI * Math.random(), n = Math.random(), s = Math.sqrt(1 - n), r = Math.sqrt(n);
            return this.set(s * Math.sin(t), s * Math.cos(t), r * Math.sin(e), r * Math.cos(e));
        }
        equals(t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w;
        }
        fromArray(t, e = 0) {
            return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this;
        }
        toArray(t = [], e = 0) {
            return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t;
        }
        fromBufferAttribute(t, e) {
            return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this._onChangeCallback(), this;
        }
        toJSON() {
            return this.toArray();
        }
        _onChange(t) {
            return this._onChangeCallback = t, this;
        }
        _onChangeCallback() {}
        *[Symbol.iterator]() {
            yield this._x, yield this._y, yield this._z, yield this._w;
        }
    }
    class k {
        constructor(t = 0, e = 0, n = 0){
            k.prototype.isVector3 = !0, this.x = t, this.y = e, this.z = n;
        }
        set(t, e, n) {
            return n === void 0 && (n = this.z), this.x = t, this.y = e, this.z = n, this;
        }
        setScalar(t) {
            return this.x = t, this.y = t, this.z = t, this;
        }
        setX(t) {
            return this.x = t, this;
        }
        setY(t) {
            return this.y = t, this;
        }
        setZ(t) {
            return this.z = t, this;
        }
        setComponent(t, e) {
            switch(t){
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                case 2:
                    this.z = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t);
            }
            return this;
        }
        getComponent(t) {
            switch(t){
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error("index is out of range: " + t);
            }
        }
        clone() {
            return new this.constructor(this.x, this.y, this.z);
        }
        copy(t) {
            return this.x = t.x, this.y = t.y, this.z = t.z, this;
        }
        add(t) {
            return this.x += t.x, this.y += t.y, this.z += t.z, this;
        }
        addScalar(t) {
            return this.x += t, this.y += t, this.z += t, this;
        }
        addVectors(t, e) {
            return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this;
        }
        addScaledVector(t, e) {
            return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this;
        }
        sub(t) {
            return this.x -= t.x, this.y -= t.y, this.z -= t.z, this;
        }
        subScalar(t) {
            return this.x -= t, this.y -= t, this.z -= t, this;
        }
        subVectors(t, e) {
            return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this;
        }
        multiply(t) {
            return this.x *= t.x, this.y *= t.y, this.z *= t.z, this;
        }
        multiplyScalar(t) {
            return this.x *= t, this.y *= t, this.z *= t, this;
        }
        multiplyVectors(t, e) {
            return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this;
        }
        applyEuler(t) {
            return this.applyQuaternion(Zh.setFromEuler(t));
        }
        applyAxisAngle(t, e) {
            return this.applyQuaternion(Zh.setFromAxisAngle(t, e));
        }
        applyMatrix3(t) {
            const e = this.x, n = this.y, s = this.z, r = t.elements;
            return this.x = r[0] * e + r[3] * n + r[6] * s, this.y = r[1] * e + r[4] * n + r[7] * s, this.z = r[2] * e + r[5] * n + r[8] * s, this;
        }
        applyNormalMatrix(t) {
            return this.applyMatrix3(t).normalize();
        }
        applyMatrix4(t) {
            const e = this.x, n = this.y, s = this.z, r = t.elements, a = 1 / (r[3] * e + r[7] * n + r[11] * s + r[15]);
            return this.x = (r[0] * e + r[4] * n + r[8] * s + r[12]) * a, this.y = (r[1] * e + r[5] * n + r[9] * s + r[13]) * a, this.z = (r[2] * e + r[6] * n + r[10] * s + r[14]) * a, this;
        }
        applyQuaternion(t) {
            const e = this.x, n = this.y, s = this.z, r = t.x, a = t.y, o = t.z, c = t.w, l = 2 * (a * s - o * n), h = 2 * (o * e - r * s), u = 2 * (r * n - a * e);
            return this.x = e + c * l + a * u - o * h, this.y = n + c * h + o * l - r * u, this.z = s + c * u + r * h - a * l, this;
        }
        project(t) {
            return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix);
        }
        unproject(t) {
            return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld);
        }
        transformDirection(t) {
            const e = this.x, n = this.y, s = this.z, r = t.elements;
            return this.x = r[0] * e + r[4] * n + r[8] * s, this.y = r[1] * e + r[5] * n + r[9] * s, this.z = r[2] * e + r[6] * n + r[10] * s, this.normalize();
        }
        divide(t) {
            return this.x /= t.x, this.y /= t.y, this.z /= t.z, this;
        }
        divideScalar(t) {
            return this.multiplyScalar(1 / t);
        }
        min(t) {
            return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this;
        }
        max(t) {
            return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this;
        }
        clamp(t, e) {
            return this.x = Yt(this.x, t.x, e.x), this.y = Yt(this.y, t.y, e.y), this.z = Yt(this.z, t.z, e.z), this;
        }
        clampScalar(t, e) {
            return this.x = Yt(this.x, t, e), this.y = Yt(this.y, t, e), this.z = Yt(this.z, t, e), this;
        }
        clampLength(t, e) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Yt(n, t, e));
        }
        floor() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
        }
        ceil() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
        }
        round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
        }
        roundToZero() {
            return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
        }
        negate() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
        }
        dot(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z;
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
            return this.divideScalar(this.length() || 1);
        }
        setLength(t) {
            return this.normalize().multiplyScalar(t);
        }
        lerp(t, e) {
            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this;
        }
        lerpVectors(t, e, n) {
            return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this;
        }
        cross(t) {
            return this.crossVectors(this, t);
        }
        crossVectors(t, e) {
            const n = t.x, s = t.y, r = t.z, a = e.x, o = e.y, c = e.z;
            return this.x = s * c - r * o, this.y = r * a - n * c, this.z = n * o - s * a, this;
        }
        projectOnVector(t) {
            const e = t.lengthSq();
            if (e === 0) return this.set(0, 0, 0);
            const n = t.dot(this) / e;
            return this.copy(t).multiplyScalar(n);
        }
        projectOnPlane(t) {
            return ro.copy(this).projectOnVector(t), this.sub(ro);
        }
        reflect(t) {
            return this.sub(ro.copy(t).multiplyScalar(2 * this.dot(t)));
        }
        angleTo(t) {
            const e = Math.sqrt(this.lengthSq() * t.lengthSq());
            if (e === 0) return Math.PI / 2;
            const n = this.dot(t) / e;
            return Math.acos(Yt(n, -1, 1));
        }
        distanceTo(t) {
            return Math.sqrt(this.distanceToSquared(t));
        }
        distanceToSquared(t) {
            const e = this.x - t.x, n = this.y - t.y, s = this.z - t.z;
            return e * e + n * n + s * s;
        }
        manhattanDistanceTo(t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z);
        }
        setFromSpherical(t) {
            return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
        }
        setFromSphericalCoords(t, e, n) {
            const s = Math.sin(e) * t;
            return this.x = s * Math.sin(n), this.y = Math.cos(e) * t, this.z = s * Math.cos(n), this;
        }
        setFromCylindrical(t) {
            return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
        }
        setFromCylindricalCoords(t, e, n) {
            return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this;
        }
        setFromMatrixPosition(t) {
            const e = t.elements;
            return this.x = e[12], this.y = e[13], this.z = e[14], this;
        }
        setFromMatrixScale(t) {
            const e = this.setFromMatrixColumn(t, 0).length(), n = this.setFromMatrixColumn(t, 1).length(), s = this.setFromMatrixColumn(t, 2).length();
            return this.x = e, this.y = n, this.z = s, this;
        }
        setFromMatrixColumn(t, e) {
            return this.fromArray(t.elements, e * 4);
        }
        setFromMatrix3Column(t, e) {
            return this.fromArray(t.elements, e * 3);
        }
        setFromEuler(t) {
            return this.x = t._x, this.y = t._y, this.z = t._z, this;
        }
        setFromColor(t) {
            return this.x = t.r, this.y = t.g, this.z = t.b, this;
        }
        equals(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z;
        }
        fromArray(t, e = 0) {
            return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this;
        }
        toArray(t = [], e = 0) {
            return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t;
        }
        fromBufferAttribute(t, e) {
            return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this;
        }
        random() {
            return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
        }
        randomDirection() {
            const t = Math.random() * Math.PI * 2, e = Math.random() * 2 - 1, n = Math.sqrt(1 - e * e);
            return this.x = n * Math.cos(t), this.y = e, this.z = n * Math.sin(t), this;
        }
        *[Symbol.iterator]() {
            yield this.x, yield this.y, yield this.z;
        }
    }
    const ro = new k, Zh = new Rn;
    class Cn {
        constructor(t = new k(1 / 0, 1 / 0, 1 / 0), e = new k(-1 / 0, -1 / 0, -1 / 0)){
            this.isBox3 = !0, this.min = t, this.max = e;
        }
        set(t, e) {
            return this.min.copy(t), this.max.copy(e), this;
        }
        setFromArray(t) {
            this.makeEmpty();
            for(let e = 0, n = t.length; e < n; e += 3)this.expandByPoint(xn.fromArray(t, e));
            return this;
        }
        setFromBufferAttribute(t) {
            this.makeEmpty();
            for(let e = 0, n = t.count; e < n; e++)this.expandByPoint(xn.fromBufferAttribute(t, e));
            return this;
        }
        setFromPoints(t) {
            this.makeEmpty();
            for(let e = 0, n = t.length; e < n; e++)this.expandByPoint(t[e]);
            return this;
        }
        setFromCenterAndSize(t, e) {
            const n = xn.copy(e).multiplyScalar(.5);
            return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
        }
        setFromObject(t, e = !1) {
            return this.makeEmpty(), this.expandByObject(t, e);
        }
        clone() {
            return new this.constructor().copy(this);
        }
        copy(t) {
            return this.min.copy(t.min), this.max.copy(t.max), this;
        }
        makeEmpty() {
            return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
        }
        isEmpty() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
        }
        getCenter(t) {
            return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5);
        }
        getSize(t) {
            return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min);
        }
        expandByPoint(t) {
            return this.min.min(t), this.max.max(t), this;
        }
        expandByVector(t) {
            return this.min.sub(t), this.max.add(t), this;
        }
        expandByScalar(t) {
            return this.min.addScalar(-t), this.max.addScalar(t), this;
        }
        expandByObject(t, e = !1) {
            t.updateWorldMatrix(!1, !1);
            const n = t.geometry;
            if (n !== void 0) {
                const r = n.getAttribute("position");
                if (e === !0 && r !== void 0 && t.isInstancedMesh !== !0) for(let a = 0, o = r.count; a < o; a++)t.isMesh === !0 ? t.getVertexPosition(a, xn) : xn.fromBufferAttribute(r, a), xn.applyMatrix4(t.matrixWorld), this.expandByPoint(xn);
                else t.boundingBox !== void 0 ? (t.boundingBox === null && t.computeBoundingBox(), Gr.copy(t.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(), Gr.copy(n.boundingBox)), Gr.applyMatrix4(t.matrixWorld), this.union(Gr);
            }
            const s = t.children;
            for(let r = 0, a = s.length; r < a; r++)this.expandByObject(s[r], e);
            return this;
        }
        containsPoint(t) {
            return t.x >= this.min.x && t.x <= this.max.x && t.y >= this.min.y && t.y <= this.max.y && t.z >= this.min.z && t.z <= this.max.z;
        }
        containsBox(t) {
            return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z;
        }
        getParameter(t, e) {
            return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z));
        }
        intersectsBox(t) {
            return t.max.x >= this.min.x && t.min.x <= this.max.x && t.max.y >= this.min.y && t.min.y <= this.max.y && t.max.z >= this.min.z && t.min.z <= this.max.z;
        }
        intersectsSphere(t) {
            return this.clampPoint(t.center, xn), xn.distanceToSquared(t.center) <= t.radius * t.radius;
        }
        intersectsPlane(t) {
            let e, n;
            return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant;
        }
        intersectsTriangle(t) {
            if (this.isEmpty()) return !1;
            this.getCenter($s), Hr.subVectors(this.max, $s), ns.subVectors(t.a, $s), is.subVectors(t.b, $s), ss.subVectors(t.c, $s), ri.subVectors(is, ns), ai.subVectors(ss, is), Mi.subVectors(ns, ss);
            let e = [
                0,
                -ri.z,
                ri.y,
                0,
                -ai.z,
                ai.y,
                0,
                -Mi.z,
                Mi.y,
                ri.z,
                0,
                -ri.x,
                ai.z,
                0,
                -ai.x,
                Mi.z,
                0,
                -Mi.x,
                -ri.y,
                ri.x,
                0,
                -ai.y,
                ai.x,
                0,
                -Mi.y,
                Mi.x,
                0
            ];
            return !ao(e, ns, is, ss, Hr) || (e = [
                1,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                1
            ], !ao(e, ns, is, ss, Hr)) ? !1 : (zr.crossVectors(ri, ai), e = [
                zr.x,
                zr.y,
                zr.z
            ], ao(e, ns, is, ss, Hr));
        }
        clampPoint(t, e) {
            return e.copy(t).clamp(this.min, this.max);
        }
        distanceToPoint(t) {
            return this.clampPoint(t, xn).distanceTo(t);
        }
        getBoundingSphere(t) {
            return this.isEmpty() ? t.makeEmpty() : (this.getCenter(t.center), t.radius = this.getSize(xn).length() * .5), t;
        }
        intersect(t) {
            return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this;
        }
        union(t) {
            return this.min.min(t.min), this.max.max(t.max), this;
        }
        applyMatrix4(t) {
            return this.isEmpty() ? this : (zn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), zn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), zn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), zn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), zn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), zn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), zn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), zn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(zn), this);
        }
        translate(t) {
            return this.min.add(t), this.max.add(t), this;
        }
        equals(t) {
            return t.min.equals(this.min) && t.max.equals(this.max);
        }
    }
    const zn = [
        new k,
        new k,
        new k,
        new k,
        new k,
        new k,
        new k,
        new k
    ], xn = new k, Gr = new Cn, ns = new k, is = new k, ss = new k, ri = new k, ai = new k, Mi = new k, $s = new k, Hr = new k, zr = new k, Ti = new k;
    function ao(i, t, e, n, s) {
        for(let r = 0, a = i.length - 3; r <= a; r += 3){
            Ti.fromArray(i, r);
            const o = s.x * Math.abs(Ti.x) + s.y * Math.abs(Ti.y) + s.z * Math.abs(Ti.z), c = t.dot(Ti), l = e.dot(Ti), h = n.dot(Ti);
            if (Math.max(-Math.max(c, l, h), Math.min(c, l, h)) > o) return !1;
        }
        return !0;
    }
    const Hg = new Cn, Ks = new k, oo = new k;
    class On {
        constructor(t = new k, e = -1){
            this.isSphere = !0, this.center = t, this.radius = e;
        }
        set(t, e) {
            return this.center.copy(t), this.radius = e, this;
        }
        setFromPoints(t, e) {
            const n = this.center;
            e !== void 0 ? n.copy(e) : Hg.setFromPoints(t).getCenter(n);
            let s = 0;
            for(let r = 0, a = t.length; r < a; r++)s = Math.max(s, n.distanceToSquared(t[r]));
            return this.radius = Math.sqrt(s), this;
        }
        copy(t) {
            return this.center.copy(t.center), this.radius = t.radius, this;
        }
        isEmpty() {
            return this.radius < 0;
        }
        makeEmpty() {
            return this.center.set(0, 0, 0), this.radius = -1, this;
        }
        containsPoint(t) {
            return t.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(t) {
            return t.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(t) {
            const e = this.radius + t.radius;
            return t.center.distanceToSquared(this.center) <= e * e;
        }
        intersectsBox(t) {
            return t.intersectsSphere(this);
        }
        intersectsPlane(t) {
            return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(t, e) {
            const n = this.center.distanceToSquared(t);
            return e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e;
        }
        getBoundingBox(t) {
            return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t);
        }
        applyMatrix4(t) {
            return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this;
        }
        translate(t) {
            return this.center.add(t), this;
        }
        expandByPoint(t) {
            if (this.isEmpty()) return this.center.copy(t), this.radius = 0, this;
            Ks.subVectors(t, this.center);
            const e = Ks.lengthSq();
            if (e > this.radius * this.radius) {
                const n = Math.sqrt(e), s = (n - this.radius) * .5;
                this.center.addScaledVector(Ks, s / n), this.radius += s;
            }
            return this;
        }
        union(t) {
            return t.isEmpty() ? this : this.isEmpty() ? (this.copy(t), this) : (this.center.equals(t.center) === !0 ? this.radius = Math.max(this.radius, t.radius) : (oo.subVectors(t.center, this.center).setLength(t.radius), this.expandByPoint(Ks.copy(t.center).add(oo)), this.expandByPoint(Ks.copy(t.center).sub(oo))), this);
        }
        equals(t) {
            return t.center.equals(this.center) && t.radius === this.radius;
        }
        clone() {
            return new this.constructor().copy(this);
        }
    }
    const Vn = new k, co = new k, Vr = new k, oi = new k, lo = new k, Wr = new k, ho = new k;
    class ja {
        constructor(t = new k, e = new k(0, 0, -1)){
            this.origin = t, this.direction = e;
        }
        set(t, e) {
            return this.origin.copy(t), this.direction.copy(e), this;
        }
        copy(t) {
            return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
        }
        at(t, e) {
            return e.copy(this.origin).addScaledVector(this.direction, t);
        }
        lookAt(t) {
            return this.direction.copy(t).sub(this.origin).normalize(), this;
        }
        recast(t) {
            return this.origin.copy(this.at(t, Vn)), this;
        }
        closestPointToPoint(t, e) {
            e.subVectors(t, this.origin);
            const n = e.dot(this.direction);
            return n < 0 ? e.copy(this.origin) : e.copy(this.origin).addScaledVector(this.direction, n);
        }
        distanceToPoint(t) {
            return Math.sqrt(this.distanceSqToPoint(t));
        }
        distanceSqToPoint(t) {
            const e = Vn.subVectors(t, this.origin).dot(this.direction);
            return e < 0 ? this.origin.distanceToSquared(t) : (Vn.copy(this.origin).addScaledVector(this.direction, e), Vn.distanceToSquared(t));
        }
        distanceSqToSegment(t, e, n, s) {
            co.copy(t).add(e).multiplyScalar(.5), Vr.copy(e).sub(t).normalize(), oi.copy(this.origin).sub(co);
            const r = t.distanceTo(e) * .5, a = -this.direction.dot(Vr), o = oi.dot(this.direction), c = -oi.dot(Vr), l = oi.lengthSq(), h = Math.abs(1 - a * a);
            let u, d, f, _;
            if (h > 0) if (u = a * c - o, d = a * o - c, _ = r * h, u >= 0) if (d >= -_) if (d <= _) {
                const g = 1 / h;
                u *= g, d *= g, f = u * (u + a * d + 2 * o) + d * (a * u + d + 2 * c) + l;
            } else d = r, u = Math.max(0, -(a * d + o)), f = -u * u + d * (d + 2 * c) + l;
            else d = -r, u = Math.max(0, -(a * d + o)), f = -u * u + d * (d + 2 * c) + l;
            else d <= -_ ? (u = Math.max(0, -(-a * r + o)), d = u > 0 ? -r : Math.min(Math.max(-r, -c), r), f = -u * u + d * (d + 2 * c) + l) : d <= _ ? (u = 0, d = Math.min(Math.max(-r, -c), r), f = d * (d + 2 * c) + l) : (u = Math.max(0, -(a * r + o)), d = u > 0 ? r : Math.min(Math.max(-r, -c), r), f = -u * u + d * (d + 2 * c) + l);
            else d = a > 0 ? -r : r, u = Math.max(0, -(a * d + o)), f = -u * u + d * (d + 2 * c) + l;
            return n && n.copy(this.origin).addScaledVector(this.direction, u), s && s.copy(co).addScaledVector(Vr, d), f;
        }
        intersectSphere(t, e) {
            Vn.subVectors(t.center, this.origin);
            const n = Vn.dot(this.direction), s = Vn.dot(Vn) - n * n, r = t.radius * t.radius;
            if (s > r) return null;
            const a = Math.sqrt(r - s), o = n - a, c = n + a;
            return c < 0 ? null : o < 0 ? this.at(c, e) : this.at(o, e);
        }
        intersectsSphere(t) {
            return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
        }
        distanceToPlane(t) {
            const e = t.normal.dot(this.direction);
            if (e === 0) return t.distanceToPoint(this.origin) === 0 ? 0 : null;
            const n = -(this.origin.dot(t.normal) + t.constant) / e;
            return n >= 0 ? n : null;
        }
        intersectPlane(t, e) {
            const n = this.distanceToPlane(t);
            return n === null ? null : this.at(n, e);
        }
        intersectsPlane(t) {
            const e = t.distanceToPoint(this.origin);
            return e === 0 || t.normal.dot(this.direction) * e < 0;
        }
        intersectBox(t, e) {
            let n, s, r, a, o, c;
            const l = 1 / this.direction.x, h = 1 / this.direction.y, u = 1 / this.direction.z, d = this.origin;
            return l >= 0 ? (n = (t.min.x - d.x) * l, s = (t.max.x - d.x) * l) : (n = (t.max.x - d.x) * l, s = (t.min.x - d.x) * l), h >= 0 ? (r = (t.min.y - d.y) * h, a = (t.max.y - d.y) * h) : (r = (t.max.y - d.y) * h, a = (t.min.y - d.y) * h), n > a || r > s || ((r > n || isNaN(n)) && (n = r), (a < s || isNaN(s)) && (s = a), u >= 0 ? (o = (t.min.z - d.z) * u, c = (t.max.z - d.z) * u) : (o = (t.max.z - d.z) * u, c = (t.min.z - d.z) * u), n > c || o > s) || ((o > n || n !== n) && (n = o), (c < s || s !== s) && (s = c), s < 0) ? null : this.at(n >= 0 ? n : s, e);
        }
        intersectsBox(t) {
            return this.intersectBox(t, Vn) !== null;
        }
        intersectTriangle(t, e, n, s, r) {
            lo.subVectors(e, t), Wr.subVectors(n, t), ho.crossVectors(lo, Wr);
            let a = this.direction.dot(ho), o;
            if (a > 0) {
                if (s) return null;
                o = 1;
            } else if (a < 0) o = -1, a = -a;
            else return null;
            oi.subVectors(this.origin, t);
            const c = o * this.direction.dot(Wr.crossVectors(oi, Wr));
            if (c < 0) return null;
            const l = o * this.direction.dot(lo.cross(oi));
            if (l < 0 || c + l > a) return null;
            const h = -o * oi.dot(ho);
            return h < 0 ? null : this.at(h / a, r);
        }
        applyMatrix4(t) {
            return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this;
        }
        equals(t) {
            return t.origin.equals(this.origin) && t.direction.equals(this.direction);
        }
        clone() {
            return new this.constructor().copy(this);
        }
    }
    class Ht {
        constructor(t, e, n, s, r, a, o, c, l, h, u, d, f, _, g, p){
            Ht.prototype.isMatrix4 = !0, this.elements = [
                1,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                1
            ], t !== void 0 && this.set(t, e, n, s, r, a, o, c, l, h, u, d, f, _, g, p);
        }
        set(t, e, n, s, r, a, o, c, l, h, u, d, f, _, g, p) {
            const m = this.elements;
            return m[0] = t, m[4] = e, m[8] = n, m[12] = s, m[1] = r, m[5] = a, m[9] = o, m[13] = c, m[2] = l, m[6] = h, m[10] = u, m[14] = d, m[3] = f, m[7] = _, m[11] = g, m[15] = p, this;
        }
        identity() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        clone() {
            return new Ht().fromArray(this.elements);
        }
        copy(t) {
            const e = this.elements, n = t.elements;
            return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this;
        }
        copyPosition(t) {
            const e = this.elements, n = t.elements;
            return e[12] = n[12], e[13] = n[13], e[14] = n[14], this;
        }
        setFromMatrix3(t) {
            const e = t.elements;
            return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this;
        }
        extractBasis(t, e, n) {
            return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
        }
        makeBasis(t, e, n) {
            return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this;
        }
        extractRotation(t) {
            const e = this.elements, n = t.elements, s = 1 / rs.setFromMatrixColumn(t, 0).length(), r = 1 / rs.setFromMatrixColumn(t, 1).length(), a = 1 / rs.setFromMatrixColumn(t, 2).length();
            return e[0] = n[0] * s, e[1] = n[1] * s, e[2] = n[2] * s, e[3] = 0, e[4] = n[4] * r, e[5] = n[5] * r, e[6] = n[6] * r, e[7] = 0, e[8] = n[8] * a, e[9] = n[9] * a, e[10] = n[10] * a, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
        }
        makeRotationFromEuler(t) {
            const e = this.elements, n = t.x, s = t.y, r = t.z, a = Math.cos(n), o = Math.sin(n), c = Math.cos(s), l = Math.sin(s), h = Math.cos(r), u = Math.sin(r);
            if (t.order === "XYZ") {
                const d = a * h, f = a * u, _ = o * h, g = o * u;
                e[0] = c * h, e[4] = -c * u, e[8] = l, e[1] = f + _ * l, e[5] = d - g * l, e[9] = -o * c, e[2] = g - d * l, e[6] = _ + f * l, e[10] = a * c;
            } else if (t.order === "YXZ") {
                const d = c * h, f = c * u, _ = l * h, g = l * u;
                e[0] = d + g * o, e[4] = _ * o - f, e[8] = a * l, e[1] = a * u, e[5] = a * h, e[9] = -o, e[2] = f * o - _, e[6] = g + d * o, e[10] = a * c;
            } else if (t.order === "ZXY") {
                const d = c * h, f = c * u, _ = l * h, g = l * u;
                e[0] = d - g * o, e[4] = -a * u, e[8] = _ + f * o, e[1] = f + _ * o, e[5] = a * h, e[9] = g - d * o, e[2] = -a * l, e[6] = o, e[10] = a * c;
            } else if (t.order === "ZYX") {
                const d = a * h, f = a * u, _ = o * h, g = o * u;
                e[0] = c * h, e[4] = _ * l - f, e[8] = d * l + g, e[1] = c * u, e[5] = g * l + d, e[9] = f * l - _, e[2] = -l, e[6] = o * c, e[10] = a * c;
            } else if (t.order === "YZX") {
                const d = a * c, f = a * l, _ = o * c, g = o * l;
                e[0] = c * h, e[4] = g - d * u, e[8] = _ * u + f, e[1] = u, e[5] = a * h, e[9] = -o * h, e[2] = -l * h, e[6] = f * u + _, e[10] = d - g * u;
            } else if (t.order === "XZY") {
                const d = a * c, f = a * l, _ = o * c, g = o * l;
                e[0] = c * h, e[4] = -u, e[8] = l * h, e[1] = d * u + g, e[5] = a * h, e[9] = f * u - _, e[2] = _ * u - f, e[6] = o * h, e[10] = g * u + d;
            }
            return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
        }
        makeRotationFromQuaternion(t) {
            return this.compose(zg, t, Vg);
        }
        lookAt(t, e, n) {
            const s = this.elements;
            return sn.subVectors(t, e), sn.lengthSq() === 0 && (sn.z = 1), sn.normalize(), ci.crossVectors(n, sn), ci.lengthSq() === 0 && (Math.abs(n.z) === 1 ? sn.x += 1e-4 : sn.z += 1e-4, sn.normalize(), ci.crossVectors(n, sn)), ci.normalize(), Xr.crossVectors(sn, ci), s[0] = ci.x, s[4] = Xr.x, s[8] = sn.x, s[1] = ci.y, s[5] = Xr.y, s[9] = sn.y, s[2] = ci.z, s[6] = Xr.z, s[10] = sn.z, this;
        }
        multiply(t) {
            return this.multiplyMatrices(this, t);
        }
        premultiply(t) {
            return this.multiplyMatrices(t, this);
        }
        multiplyMatrices(t, e) {
            const n = t.elements, s = e.elements, r = this.elements, a = n[0], o = n[4], c = n[8], l = n[12], h = n[1], u = n[5], d = n[9], f = n[13], _ = n[2], g = n[6], p = n[10], m = n[14], x = n[3], y = n[7], v = n[11], I = n[15], w = s[0], R = s[4], N = s[8], E = s[12], S = s[1], D = s[5], j = s[9], z = s[13], K = s[2], nt = s[6], b = s[10], C = s[14], A = s[3], U = s[7], B = s[11], V = s[15];
            return r[0] = a * w + o * S + c * K + l * A, r[4] = a * R + o * D + c * nt + l * U, r[8] = a * N + o * j + c * b + l * B, r[12] = a * E + o * z + c * C + l * V, r[1] = h * w + u * S + d * K + f * A, r[5] = h * R + u * D + d * nt + f * U, r[9] = h * N + u * j + d * b + f * B, r[13] = h * E + u * z + d * C + f * V, r[2] = _ * w + g * S + p * K + m * A, r[6] = _ * R + g * D + p * nt + m * U, r[10] = _ * N + g * j + p * b + m * B, r[14] = _ * E + g * z + p * C + m * V, r[3] = x * w + y * S + v * K + I * A, r[7] = x * R + y * D + v * nt + I * U, r[11] = x * N + y * j + v * b + I * B, r[15] = x * E + y * z + v * C + I * V, this;
        }
        multiplyScalar(t) {
            const e = this.elements;
            return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this;
        }
        determinant() {
            const t = this.elements, e = t[0], n = t[4], s = t[8], r = t[12], a = t[1], o = t[5], c = t[9], l = t[13], h = t[2], u = t[6], d = t[10], f = t[14], _ = t[3], g = t[7], p = t[11], m = t[15];
            return _ * (+r * c * u - s * l * u - r * o * d + n * l * d + s * o * f - n * c * f) + g * (+e * c * f - e * l * d + r * a * d - s * a * f + s * l * h - r * c * h) + p * (+e * l * u - e * o * f - r * a * u + n * a * f + r * o * h - n * l * h) + m * (-s * o * h - e * c * u + e * o * d + s * a * u - n * a * d + n * c * h);
        }
        transpose() {
            const t = this.elements;
            let e;
            return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this;
        }
        setPosition(t, e, n) {
            const s = this.elements;
            return t.isVector3 ? (s[12] = t.x, s[13] = t.y, s[14] = t.z) : (s[12] = t, s[13] = e, s[14] = n), this;
        }
        invert() {
            const t = this.elements, e = t[0], n = t[1], s = t[2], r = t[3], a = t[4], o = t[5], c = t[6], l = t[7], h = t[8], u = t[9], d = t[10], f = t[11], _ = t[12], g = t[13], p = t[14], m = t[15], x = u * p * l - g * d * l + g * c * f - o * p * f - u * c * m + o * d * m, y = _ * d * l - h * p * l - _ * c * f + a * p * f + h * c * m - a * d * m, v = h * g * l - _ * u * l + _ * o * f - a * g * f - h * o * m + a * u * m, I = _ * u * c - h * g * c - _ * o * d + a * g * d + h * o * p - a * u * p, w = e * x + n * y + s * v + r * I;
            if (w === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            const R = 1 / w;
            return t[0] = x * R, t[1] = (g * d * r - u * p * r - g * s * f + n * p * f + u * s * m - n * d * m) * R, t[2] = (o * p * r - g * c * r + g * s * l - n * p * l - o * s * m + n * c * m) * R, t[3] = (u * c * r - o * d * r - u * s * l + n * d * l + o * s * f - n * c * f) * R, t[4] = y * R, t[5] = (h * p * r - _ * d * r + _ * s * f - e * p * f - h * s * m + e * d * m) * R, t[6] = (_ * c * r - a * p * r - _ * s * l + e * p * l + a * s * m - e * c * m) * R, t[7] = (a * d * r - h * c * r + h * s * l - e * d * l - a * s * f + e * c * f) * R, t[8] = v * R, t[9] = (_ * u * r - h * g * r - _ * n * f + e * g * f + h * n * m - e * u * m) * R, t[10] = (a * g * r - _ * o * r + _ * n * l - e * g * l - a * n * m + e * o * m) * R, t[11] = (h * o * r - a * u * r - h * n * l + e * u * l + a * n * f - e * o * f) * R, t[12] = I * R, t[13] = (h * g * s - _ * u * s + _ * n * d - e * g * d - h * n * p + e * u * p) * R, t[14] = (_ * o * s - a * g * s - _ * n * c + e * g * c + a * n * p - e * o * p) * R, t[15] = (a * u * s - h * o * s + h * n * c - e * u * c - a * n * d + e * o * d) * R, this;
        }
        scale(t) {
            const e = this.elements, n = t.x, s = t.y, r = t.z;
            return e[0] *= n, e[4] *= s, e[8] *= r, e[1] *= n, e[5] *= s, e[9] *= r, e[2] *= n, e[6] *= s, e[10] *= r, e[3] *= n, e[7] *= s, e[11] *= r, this;
        }
        getMaxScaleOnAxis() {
            const t = this.elements, e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2], n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6], s = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
            return Math.sqrt(Math.max(e, n, s));
        }
        makeTranslation(t, e, n) {
            return t.isVector3 ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1) : this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this;
        }
        makeRotationX(t) {
            const e = Math.cos(t), n = Math.sin(t);
            return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this;
        }
        makeRotationY(t) {
            const e = Math.cos(t), n = Math.sin(t);
            return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this;
        }
        makeRotationZ(t) {
            const e = Math.cos(t), n = Math.sin(t);
            return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        makeRotationAxis(t, e) {
            const n = Math.cos(e), s = Math.sin(e), r = 1 - n, a = t.x, o = t.y, c = t.z, l = r * a, h = r * o;
            return this.set(l * a + n, l * o - s * c, l * c + s * o, 0, l * o + s * c, h * o + n, h * c - s * a, 0, l * c - s * o, h * c + s * a, r * c * c + n, 0, 0, 0, 0, 1), this;
        }
        makeScale(t, e, n) {
            return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
        }
        makeShear(t, e, n, s, r, a) {
            return this.set(1, n, r, 0, t, 1, a, 0, e, s, 1, 0, 0, 0, 0, 1), this;
        }
        compose(t, e, n) {
            const s = this.elements, r = e._x, a = e._y, o = e._z, c = e._w, l = r + r, h = a + a, u = o + o, d = r * l, f = r * h, _ = r * u, g = a * h, p = a * u, m = o * u, x = c * l, y = c * h, v = c * u, I = n.x, w = n.y, R = n.z;
            return s[0] = (1 - (g + m)) * I, s[1] = (f + v) * I, s[2] = (_ - y) * I, s[3] = 0, s[4] = (f - v) * w, s[5] = (1 - (d + m)) * w, s[6] = (p + x) * w, s[7] = 0, s[8] = (_ + y) * R, s[9] = (p - x) * R, s[10] = (1 - (d + g)) * R, s[11] = 0, s[12] = t.x, s[13] = t.y, s[14] = t.z, s[15] = 1, this;
        }
        decompose(t, e, n) {
            const s = this.elements;
            let r = rs.set(s[0], s[1], s[2]).length();
            const a = rs.set(s[4], s[5], s[6]).length(), o = rs.set(s[8], s[9], s[10]).length();
            this.determinant() < 0 && (r = -r), t.x = s[12], t.y = s[13], t.z = s[14], vn.copy(this);
            const l = 1 / r, h = 1 / a, u = 1 / o;
            return vn.elements[0] *= l, vn.elements[1] *= l, vn.elements[2] *= l, vn.elements[4] *= h, vn.elements[5] *= h, vn.elements[6] *= h, vn.elements[8] *= u, vn.elements[9] *= u, vn.elements[10] *= u, e.setFromRotationMatrix(vn), n.x = r, n.y = a, n.z = o, this;
        }
        makePerspective(t, e, n, s, r, a, o = Jn) {
            const c = this.elements, l = 2 * r / (e - t), h = 2 * r / (n - s), u = (e + t) / (e - t), d = (n + s) / (n - s);
            let f, _;
            if (o === Jn) f = -(a + r) / (a - r), _ = -2 * a * r / (a - r);
            else if (o === ka) f = -a / (a - r), _ = -a * r / (a - r);
            else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + o);
            return c[0] = l, c[4] = 0, c[8] = u, c[12] = 0, c[1] = 0, c[5] = h, c[9] = d, c[13] = 0, c[2] = 0, c[6] = 0, c[10] = f, c[14] = _, c[3] = 0, c[7] = 0, c[11] = -1, c[15] = 0, this;
        }
        makeOrthographic(t, e, n, s, r, a, o = Jn) {
            const c = this.elements, l = 1 / (e - t), h = 1 / (n - s), u = 1 / (a - r), d = (e + t) * l, f = (n + s) * h;
            let _, g;
            if (o === Jn) _ = (a + r) * u, g = -2 * u;
            else if (o === ka) _ = r * u, g = -1 * u;
            else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + o);
            return c[0] = 2 * l, c[4] = 0, c[8] = 0, c[12] = -d, c[1] = 0, c[5] = 2 * h, c[9] = 0, c[13] = -f, c[2] = 0, c[6] = 0, c[10] = g, c[14] = -_, c[3] = 0, c[7] = 0, c[11] = 0, c[15] = 1, this;
        }
        equals(t) {
            const e = this.elements, n = t.elements;
            for(let s = 0; s < 16; s++)if (e[s] !== n[s]) return !1;
            return !0;
        }
        fromArray(t, e = 0) {
            for(let n = 0; n < 16; n++)this.elements[n] = t[n + e];
            return this;
        }
        toArray(t = [], e = 0) {
            const n = this.elements;
            return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t;
        }
    }
    const rs = new k, vn = new Ht, zg = new k(0, 0, 0), Vg = new k(1, 1, 1), ci = new k, Xr = new k, sn = new k, Jh = new Ht, Qh = new Rn;
    class Fn {
        constructor(t = 0, e = 0, n = 0, s = Fn.DEFAULT_ORDER){
            this.isEuler = !0, this._x = t, this._y = e, this._z = n, this._order = s;
        }
        get x() {
            return this._x;
        }
        set x(t) {
            this._x = t, this._onChangeCallback();
        }
        get y() {
            return this._y;
        }
        set y(t) {
            this._y = t, this._onChangeCallback();
        }
        get z() {
            return this._z;
        }
        set z(t) {
            this._z = t, this._onChangeCallback();
        }
        get order() {
            return this._order;
        }
        set order(t) {
            this._order = t, this._onChangeCallback();
        }
        set(t, e, n, s = this._order) {
            return this._x = t, this._y = e, this._z = n, this._order = s, this._onChangeCallback(), this;
        }
        clone() {
            return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(t) {
            return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this;
        }
        setFromRotationMatrix(t, e = this._order, n = !0) {
            const s = t.elements, r = s[0], a = s[4], o = s[8], c = s[1], l = s[5], h = s[9], u = s[2], d = s[6], f = s[10];
            switch(e){
                case "XYZ":
                    this._y = Math.asin(Yt(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-h, f), this._z = Math.atan2(-a, r)) : (this._x = Math.atan2(d, l), this._z = 0);
                    break;
                case "YXZ":
                    this._x = Math.asin(-Yt(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(o, f), this._z = Math.atan2(c, l)) : (this._y = Math.atan2(-u, r), this._z = 0);
                    break;
                case "ZXY":
                    this._x = Math.asin(Yt(d, -1, 1)), Math.abs(d) < .9999999 ? (this._y = Math.atan2(-u, f), this._z = Math.atan2(-a, l)) : (this._y = 0, this._z = Math.atan2(c, r));
                    break;
                case "ZYX":
                    this._y = Math.asin(-Yt(u, -1, 1)), Math.abs(u) < .9999999 ? (this._x = Math.atan2(d, f), this._z = Math.atan2(c, r)) : (this._x = 0, this._z = Math.atan2(-a, l));
                    break;
                case "YZX":
                    this._z = Math.asin(Yt(c, -1, 1)), Math.abs(c) < .9999999 ? (this._x = Math.atan2(-h, l), this._y = Math.atan2(-u, r)) : (this._x = 0, this._y = Math.atan2(o, f));
                    break;
                case "XZY":
                    this._z = Math.asin(-Yt(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(d, l), this._y = Math.atan2(o, r)) : (this._x = Math.atan2(-h, f), this._y = 0);
                    break;
                default:
                    console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e);
            }
            return this._order = e, n === !0 && this._onChangeCallback(), this;
        }
        setFromQuaternion(t, e, n) {
            return Jh.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Jh, e, n);
        }
        setFromVector3(t, e = this._order) {
            return this.set(t.x, t.y, t.z, e);
        }
        reorder(t) {
            return Qh.setFromEuler(this), this.setFromQuaternion(Qh, t);
        }
        equals(t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order;
        }
        fromArray(t) {
            return this._x = t[0], this._y = t[1], this._z = t[2], t[3] !== void 0 && (this._order = t[3]), this._onChangeCallback(), this;
        }
        toArray(t = [], e = 0) {
            return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t;
        }
        _onChange(t) {
            return this._onChangeCallback = t, this;
        }
        _onChangeCallback() {}
        *[Symbol.iterator]() {
            yield this._x, yield this._y, yield this._z, yield this._order;
        }
    }
    Fn.DEFAULT_ORDER = "XYZ";
    class Ff {
        constructor(){
            this.mask = 1;
        }
        set(t) {
            this.mask = (1 << t | 0) >>> 0;
        }
        enable(t) {
            this.mask |= 1 << t | 0;
        }
        enableAll() {
            this.mask = -1;
        }
        toggle(t) {
            this.mask ^= 1 << t | 0;
        }
        disable(t) {
            this.mask &= ~(1 << t | 0);
        }
        disableAll() {
            this.mask = 0;
        }
        test(t) {
            return (this.mask & t.mask) !== 0;
        }
        isEnabled(t) {
            return (this.mask & (1 << t | 0)) !== 0;
        }
    }
    let Wg = 0;
    const tu = new k, as = new Rn, Wn = new Ht, Yr = new k, Zs = new k, Xg = new k, Yg = new Rn, eu = new k(1, 0, 0), nu = new k(0, 1, 0), iu = new k(0, 0, 1), su = {
        type: "added"
    }, qg = {
        type: "removed"
    }, os = {
        type: "childadded",
        child: null
    }, uo = {
        type: "childremoved",
        child: null
    };
    class ge extends $i {
        constructor(){
            super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
                value: Wg++
            }), this.uuid = wn(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = ge.DEFAULT_UP.clone();
            const t = new k, e = new Fn, n = new Rn, s = new k(1, 1, 1);
            function r() {
                n.setFromEuler(e, !1);
            }
            function a() {
                e.setFromQuaternion(n, void 0, !1);
            }
            e._onChange(r), n._onChange(a), Object.defineProperties(this, {
                position: {
                    configurable: !0,
                    enumerable: !0,
                    value: t
                },
                rotation: {
                    configurable: !0,
                    enumerable: !0,
                    value: e
                },
                quaternion: {
                    configurable: !0,
                    enumerable: !0,
                    value: n
                },
                scale: {
                    configurable: !0,
                    enumerable: !0,
                    value: s
                },
                modelViewMatrix: {
                    value: new Ht
                },
                normalMatrix: {
                    value: new Gt
                }
            }), this.matrix = new Ht, this.matrixWorld = new Ht, this.matrixAutoUpdate = ge.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = ge.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new Ff, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.customDepthMaterial = void 0, this.customDistanceMaterial = void 0, this.userData = {};
        }
        onBeforeShadow() {}
        onAfterShadow() {}
        onBeforeRender() {}
        onAfterRender() {}
        applyMatrix4(t) {
            this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale);
        }
        applyQuaternion(t) {
            return this.quaternion.premultiply(t), this;
        }
        setRotationFromAxisAngle(t, e) {
            this.quaternion.setFromAxisAngle(t, e);
        }
        setRotationFromEuler(t) {
            this.quaternion.setFromEuler(t, !0);
        }
        setRotationFromMatrix(t) {
            this.quaternion.setFromRotationMatrix(t);
        }
        setRotationFromQuaternion(t) {
            this.quaternion.copy(t);
        }
        rotateOnAxis(t, e) {
            return as.setFromAxisAngle(t, e), this.quaternion.multiply(as), this;
        }
        rotateOnWorldAxis(t, e) {
            return as.setFromAxisAngle(t, e), this.quaternion.premultiply(as), this;
        }
        rotateX(t) {
            return this.rotateOnAxis(eu, t);
        }
        rotateY(t) {
            return this.rotateOnAxis(nu, t);
        }
        rotateZ(t) {
            return this.rotateOnAxis(iu, t);
        }
        translateOnAxis(t, e) {
            return tu.copy(t).applyQuaternion(this.quaternion), this.position.add(tu.multiplyScalar(e)), this;
        }
        translateX(t) {
            return this.translateOnAxis(eu, t);
        }
        translateY(t) {
            return this.translateOnAxis(nu, t);
        }
        translateZ(t) {
            return this.translateOnAxis(iu, t);
        }
        localToWorld(t) {
            return this.updateWorldMatrix(!0, !1), t.applyMatrix4(this.matrixWorld);
        }
        worldToLocal(t) {
            return this.updateWorldMatrix(!0, !1), t.applyMatrix4(Wn.copy(this.matrixWorld).invert());
        }
        lookAt(t, e, n) {
            t.isVector3 ? Yr.copy(t) : Yr.set(t, e, n);
            const s = this.parent;
            this.updateWorldMatrix(!0, !1), Zs.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Wn.lookAt(Zs, Yr, this.up) : Wn.lookAt(Yr, Zs, this.up), this.quaternion.setFromRotationMatrix(Wn), s && (Wn.extractRotation(s.matrixWorld), as.setFromRotationMatrix(Wn), this.quaternion.premultiply(as.invert()));
        }
        add(t) {
            if (arguments.length > 1) {
                for(let e = 0; e < arguments.length; e++)this.add(arguments[e]);
                return this;
            }
            return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (t.removeFromParent(), t.parent = this, this.children.push(t), t.dispatchEvent(su), os.child = t, this.dispatchEvent(os), os.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this);
        }
        remove(t) {
            if (arguments.length > 1) {
                for(let n = 0; n < arguments.length; n++)this.remove(arguments[n]);
                return this;
            }
            const e = this.children.indexOf(t);
            return e !== -1 && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(qg), uo.child = t, this.dispatchEvent(uo), uo.child = null), this;
        }
        removeFromParent() {
            const t = this.parent;
            return t !== null && t.remove(this), this;
        }
        clear() {
            return this.remove(...this.children);
        }
        attach(t) {
            return this.updateWorldMatrix(!0, !1), Wn.copy(this.matrixWorld).invert(), t.parent !== null && (t.parent.updateWorldMatrix(!0, !1), Wn.multiply(t.parent.matrixWorld)), t.applyMatrix4(Wn), t.removeFromParent(), t.parent = this, this.children.push(t), t.updateWorldMatrix(!1, !0), t.dispatchEvent(su), os.child = t, this.dispatchEvent(os), os.child = null, this;
        }
        getObjectById(t) {
            return this.getObjectByProperty("id", t);
        }
        getObjectByName(t) {
            return this.getObjectByProperty("name", t);
        }
        getObjectByProperty(t, e) {
            if (this[t] === e) return this;
            for(let n = 0, s = this.children.length; n < s; n++){
                const a = this.children[n].getObjectByProperty(t, e);
                if (a !== void 0) return a;
            }
        }
        getObjectsByProperty(t, e, n = []) {
            this[t] === e && n.push(this);
            const s = this.children;
            for(let r = 0, a = s.length; r < a; r++)s[r].getObjectsByProperty(t, e, n);
            return n;
        }
        getWorldPosition(t) {
            return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld);
        }
        getWorldQuaternion(t) {
            return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Zs, t, Xg), t;
        }
        getWorldScale(t) {
            return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Zs, Yg, t), t;
        }
        getWorldDirection(t) {
            this.updateWorldMatrix(!0, !1);
            const e = this.matrixWorld.elements;
            return t.set(e[8], e[9], e[10]).normalize();
        }
        raycast() {}
        traverse(t) {
            t(this);
            const e = this.children;
            for(let n = 0, s = e.length; n < s; n++)e[n].traverse(t);
        }
        traverseVisible(t) {
            if (this.visible === !1) return;
            t(this);
            const e = this.children;
            for(let n = 0, s = e.length; n < s; n++)e[n].traverseVisible(t);
        }
        traverseAncestors(t) {
            const e = this.parent;
            e !== null && (t(e), e.traverseAncestors(t));
        }
        updateMatrix() {
            this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
        }
        updateMatrixWorld(t) {
            this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, t = !0);
            const e = this.children;
            for(let n = 0, s = e.length; n < s; n++)e[n].updateMatrixWorld(t);
        }
        updateWorldMatrix(t, e) {
            const n = this.parent;
            if (t === !0 && n !== null && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), e === !0) {
                const s = this.children;
                for(let r = 0, a = s.length; r < a; r++)s[r].updateWorldMatrix(!1, !0);
            }
        }
        toJSON(t) {
            const e = t === void 0 || typeof t == "string", n = {};
            e && (t = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {},
                skeletons: {},
                animations: {},
                nodes: {}
            }, n.metadata = {
                version: 4.6,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            const s = {};
            s.uuid = this.uuid, s.type = this.type, this.name !== "" && (s.name = this.name), this.castShadow === !0 && (s.castShadow = !0), this.receiveShadow === !0 && (s.receiveShadow = !0), this.visible === !1 && (s.visible = !1), this.frustumCulled === !1 && (s.frustumCulled = !1), this.renderOrder !== 0 && (s.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (s.userData = this.userData), s.layers = this.layers.mask, s.matrix = this.matrix.toArray(), s.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (s.matrixAutoUpdate = !1), this.isInstancedMesh && (s.type = "InstancedMesh", s.count = this.count, s.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (s.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (s.type = "BatchedMesh", s.perObjectFrustumCulled = this.perObjectFrustumCulled, s.sortObjects = this.sortObjects, s.drawRanges = this._drawRanges, s.reservedRanges = this._reservedRanges, s.visibility = this._visibility, s.active = this._active, s.bounds = this._bounds.map((o)=>({
                    boxInitialized: o.boxInitialized,
                    boxMin: o.box.min.toArray(),
                    boxMax: o.box.max.toArray(),
                    sphereInitialized: o.sphereInitialized,
                    sphereRadius: o.sphere.radius,
                    sphereCenter: o.sphere.center.toArray()
                })), s.maxInstanceCount = this._maxInstanceCount, s.maxVertexCount = this._maxVertexCount, s.maxIndexCount = this._maxIndexCount, s.geometryInitialized = this._geometryInitialized, s.geometryCount = this._geometryCount, s.matricesTexture = this._matricesTexture.toJSON(t), this._colorsTexture !== null && (s.colorsTexture = this._colorsTexture.toJSON(t)), this.boundingSphere !== null && (s.boundingSphere = {
                center: s.boundingSphere.center.toArray(),
                radius: s.boundingSphere.radius
            }), this.boundingBox !== null && (s.boundingBox = {
                min: s.boundingBox.min.toArray(),
                max: s.boundingBox.max.toArray()
            }));
            function r(o, c) {
                return o[c.uuid] === void 0 && (o[c.uuid] = c.toJSON(t)), c.uuid;
            }
            if (this.isScene) this.background && (this.background.isColor ? s.background = this.background.toJSON() : this.background.isTexture && (s.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (s.environment = this.environment.toJSON(t).uuid);
            else if (this.isMesh || this.isLine || this.isPoints) {
                s.geometry = r(t.geometries, this.geometry);
                const o = this.geometry.parameters;
                if (o !== void 0 && o.shapes !== void 0) {
                    const c = o.shapes;
                    if (Array.isArray(c)) for(let l = 0, h = c.length; l < h; l++){
                        const u = c[l];
                        r(t.shapes, u);
                    }
                    else r(t.shapes, c);
                }
            }
            if (this.isSkinnedMesh && (s.bindMode = this.bindMode, s.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (r(t.skeletons, this.skeleton), s.skeleton = this.skeleton.uuid)), this.material !== void 0) if (Array.isArray(this.material)) {
                const o = [];
                for(let c = 0, l = this.material.length; c < l; c++)o.push(r(t.materials, this.material[c]));
                s.material = o;
            } else s.material = r(t.materials, this.material);
            if (this.children.length > 0) {
                s.children = [];
                for(let o = 0; o < this.children.length; o++)s.children.push(this.children[o].toJSON(t).object);
            }
            if (this.animations.length > 0) {
                s.animations = [];
                for(let o = 0; o < this.animations.length; o++){
                    const c = this.animations[o];
                    s.animations.push(r(t.animations, c));
                }
            }
            if (e) {
                const o = a(t.geometries), c = a(t.materials), l = a(t.textures), h = a(t.images), u = a(t.shapes), d = a(t.skeletons), f = a(t.animations), _ = a(t.nodes);
                o.length > 0 && (n.geometries = o), c.length > 0 && (n.materials = c), l.length > 0 && (n.textures = l), h.length > 0 && (n.images = h), u.length > 0 && (n.shapes = u), d.length > 0 && (n.skeletons = d), f.length > 0 && (n.animations = f), _.length > 0 && (n.nodes = _);
            }
            return n.object = s, n;
            function a(o) {
                const c = [];
                for(const l in o){
                    const h = o[l];
                    delete h.metadata, c.push(h);
                }
                return c;
            }
        }
        clone(t) {
            return new this.constructor().copy(this, t);
        }
        copy(t, e = !0) {
            if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.animations = t.animations.slice(), this.userData = JSON.parse(JSON.stringify(t.userData)), e === !0) for(let n = 0; n < t.children.length; n++){
                const s = t.children[n];
                this.add(s.clone());
            }
            return this;
        }
    }
    ge.DEFAULT_UP = new k(0, 1, 0);
    ge.DEFAULT_MATRIX_AUTO_UPDATE = !0;
    ge.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
    const yn = new k, Xn = new k, fo = new k, Yn = new k, cs = new k, ls = new k, ru = new k, po = new k, mo = new k, _o = new k, go = new ne, xo = new ne, vo = new ne;
    class En {
        constructor(t = new k, e = new k, n = new k){
            this.a = t, this.b = e, this.c = n;
        }
        static getNormal(t, e, n, s) {
            s.subVectors(n, e), yn.subVectors(t, e), s.cross(yn);
            const r = s.lengthSq();
            return r > 0 ? s.multiplyScalar(1 / Math.sqrt(r)) : s.set(0, 0, 0);
        }
        static getBarycoord(t, e, n, s, r) {
            yn.subVectors(s, e), Xn.subVectors(n, e), fo.subVectors(t, e);
            const a = yn.dot(yn), o = yn.dot(Xn), c = yn.dot(fo), l = Xn.dot(Xn), h = Xn.dot(fo), u = a * l - o * o;
            if (u === 0) return r.set(0, 0, 0), null;
            const d = 1 / u, f = (l * c - o * h) * d, _ = (a * h - o * c) * d;
            return r.set(1 - f - _, _, f);
        }
        static containsPoint(t, e, n, s) {
            return this.getBarycoord(t, e, n, s, Yn) === null ? !1 : Yn.x >= 0 && Yn.y >= 0 && Yn.x + Yn.y <= 1;
        }
        static getInterpolation(t, e, n, s, r, a, o, c) {
            return this.getBarycoord(t, e, n, s, Yn) === null ? (c.x = 0, c.y = 0, "z" in c && (c.z = 0), "w" in c && (c.w = 0), null) : (c.setScalar(0), c.addScaledVector(r, Yn.x), c.addScaledVector(a, Yn.y), c.addScaledVector(o, Yn.z), c);
        }
        static getInterpolatedAttribute(t, e, n, s, r, a) {
            return go.setScalar(0), xo.setScalar(0), vo.setScalar(0), go.fromBufferAttribute(t, e), xo.fromBufferAttribute(t, n), vo.fromBufferAttribute(t, s), a.setScalar(0), a.addScaledVector(go, r.x), a.addScaledVector(xo, r.y), a.addScaledVector(vo, r.z), a;
        }
        static isFrontFacing(t, e, n, s) {
            return yn.subVectors(n, e), Xn.subVectors(t, e), yn.cross(Xn).dot(s) < 0;
        }
        set(t, e, n) {
            return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
        }
        setFromPointsAndIndices(t, e, n, s) {
            return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[s]), this;
        }
        setFromAttributeAndIndices(t, e, n, s) {
            return this.a.fromBufferAttribute(t, e), this.b.fromBufferAttribute(t, n), this.c.fromBufferAttribute(t, s), this;
        }
        clone() {
            return new this.constructor().copy(this);
        }
        copy(t) {
            return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
        }
        getArea() {
            return yn.subVectors(this.c, this.b), Xn.subVectors(this.a, this.b), yn.cross(Xn).length() * .5;
        }
        getMidpoint(t) {
            return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
        }
        getNormal(t) {
            return En.getNormal(this.a, this.b, this.c, t);
        }
        getPlane(t) {
            return t.setFromCoplanarPoints(this.a, this.b, this.c);
        }
        getBarycoord(t, e) {
            return En.getBarycoord(t, this.a, this.b, this.c, e);
        }
        getInterpolation(t, e, n, s, r) {
            return En.getInterpolation(t, this.a, this.b, this.c, e, n, s, r);
        }
        containsPoint(t) {
            return En.containsPoint(t, this.a, this.b, this.c);
        }
        isFrontFacing(t) {
            return En.isFrontFacing(this.a, this.b, this.c, t);
        }
        intersectsBox(t) {
            return t.intersectsTriangle(this);
        }
        closestPointToPoint(t, e) {
            const n = this.a, s = this.b, r = this.c;
            let a, o;
            cs.subVectors(s, n), ls.subVectors(r, n), po.subVectors(t, n);
            const c = cs.dot(po), l = ls.dot(po);
            if (c <= 0 && l <= 0) return e.copy(n);
            mo.subVectors(t, s);
            const h = cs.dot(mo), u = ls.dot(mo);
            if (h >= 0 && u <= h) return e.copy(s);
            const d = c * u - h * l;
            if (d <= 0 && c >= 0 && h <= 0) return a = c / (c - h), e.copy(n).addScaledVector(cs, a);
            _o.subVectors(t, r);
            const f = cs.dot(_o), _ = ls.dot(_o);
            if (_ >= 0 && f <= _) return e.copy(r);
            const g = f * l - c * _;
            if (g <= 0 && l >= 0 && _ <= 0) return o = l / (l - _), e.copy(n).addScaledVector(ls, o);
            const p = h * _ - f * u;
            if (p <= 0 && u - h >= 0 && f - _ >= 0) return ru.subVectors(r, s), o = (u - h) / (u - h + (f - _)), e.copy(s).addScaledVector(ru, o);
            const m = 1 / (p + g + d);
            return a = g * m, o = d * m, e.copy(n).addScaledVector(cs, a).addScaledVector(ls, o);
        }
        equals(t) {
            return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
        }
    }
    const Of = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    }, li = {
        h: 0,
        s: 0,
        l: 0
    }, qr = {
        h: 0,
        s: 0,
        l: 0
    };
    function yo(i, t, e) {
        return e < 0 && (e += 1), e > 1 && (e -= 1), e < 1 / 6 ? i + (t - i) * 6 * e : e < 1 / 2 ? t : e < 2 / 3 ? i + (t - i) * 6 * (2 / 3 - e) : i;
    }
    let Bt = class {
        constructor(t, e, n){
            return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(t, e, n);
        }
        set(t, e, n) {
            if (e === void 0 && n === void 0) {
                const s = t;
                s && s.isColor ? this.copy(s) : typeof s == "number" ? this.setHex(s) : typeof s == "string" && this.setStyle(s);
            } else this.setRGB(t, e, n);
            return this;
        }
        setScalar(t) {
            return this.r = t, this.g = t, this.b = t, this;
        }
        setHex(t, e = De) {
            return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (t & 255) / 255, $t.toWorkingColorSpace(this, e), this;
        }
        setRGB(t, e, n, s = $t.workingColorSpace) {
            return this.r = t, this.g = e, this.b = n, $t.toWorkingColorSpace(this, s), this;
        }
        setHSL(t, e, n, s = $t.workingColorSpace) {
            if (t = Xl(t, 1), e = Yt(e, 0, 1), n = Yt(n, 0, 1), e === 0) this.r = this.g = this.b = n;
            else {
                const r = n <= .5 ? n * (1 + e) : n + e - n * e, a = 2 * n - r;
                this.r = yo(a, r, t + 1 / 3), this.g = yo(a, r, t), this.b = yo(a, r, t - 1 / 3);
            }
            return $t.toWorkingColorSpace(this, s), this;
        }
        setStyle(t, e = De) {
            function n(r) {
                r !== void 0 && parseFloat(r) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.");
            }
            let s;
            if (s = /^(\w+)\(([^\)]*)\)/.exec(t)) {
                let r;
                const a = s[1], o = s[2];
                switch(a){
                    case "rgb":
                    case "rgba":
                        if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return n(r[4]), this.setRGB(Math.min(255, parseInt(r[1], 10)) / 255, Math.min(255, parseInt(r[2], 10)) / 255, Math.min(255, parseInt(r[3], 10)) / 255, e);
                        if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return n(r[4]), this.setRGB(Math.min(100, parseInt(r[1], 10)) / 100, Math.min(100, parseInt(r[2], 10)) / 100, Math.min(100, parseInt(r[3], 10)) / 100, e);
                        break;
                    case "hsl":
                    case "hsla":
                        if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return n(r[4]), this.setHSL(parseFloat(r[1]) / 360, parseFloat(r[2]) / 100, parseFloat(r[3]) / 100, e);
                        break;
                    default:
                        console.warn("THREE.Color: Unknown color model " + t);
                }
            } else if (s = /^\#([A-Fa-f\d]+)$/.exec(t)) {
                const r = s[1], a = r.length;
                if (a === 3) return this.setRGB(parseInt(r.charAt(0), 16) / 15, parseInt(r.charAt(1), 16) / 15, parseInt(r.charAt(2), 16) / 15, e);
                if (a === 6) return this.setHex(parseInt(r, 16), e);
                console.warn("THREE.Color: Invalid hex color " + t);
            } else if (t && t.length > 0) return this.setColorName(t, e);
            return this;
        }
        setColorName(t, e = De) {
            const n = Of[t.toLowerCase()];
            return n !== void 0 ? this.setHex(n, e) : console.warn("THREE.Color: Unknown color " + t), this;
        }
        clone() {
            return new this.constructor(this.r, this.g, this.b);
        }
        copy(t) {
            return this.r = t.r, this.g = t.g, this.b = t.b, this;
        }
        copySRGBToLinear(t) {
            return this.r = Qn(t.r), this.g = Qn(t.g), this.b = Qn(t.b), this;
        }
        copyLinearToSRGB(t) {
            return this.r = Es(t.r), this.g = Es(t.g), this.b = Es(t.b), this;
        }
        convertSRGBToLinear() {
            return this.copySRGBToLinear(this), this;
        }
        convertLinearToSRGB() {
            return this.copyLinearToSRGB(this), this;
        }
        getHex(t = De) {
            return $t.fromWorkingColorSpace(ke.copy(this), t), Math.round(Yt(ke.r * 255, 0, 255)) * 65536 + Math.round(Yt(ke.g * 255, 0, 255)) * 256 + Math.round(Yt(ke.b * 255, 0, 255));
        }
        getHexString(t = De) {
            return ("000000" + this.getHex(t).toString(16)).slice(-6);
        }
        getHSL(t, e = $t.workingColorSpace) {
            $t.fromWorkingColorSpace(ke.copy(this), e);
            const n = ke.r, s = ke.g, r = ke.b, a = Math.max(n, s, r), o = Math.min(n, s, r);
            let c, l;
            const h = (o + a) / 2;
            if (o === a) c = 0, l = 0;
            else {
                const u = a - o;
                switch(l = h <= .5 ? u / (a + o) : u / (2 - a - o), a){
                    case n:
                        c = (s - r) / u + (s < r ? 6 : 0);
                        break;
                    case s:
                        c = (r - n) / u + 2;
                        break;
                    case r:
                        c = (n - s) / u + 4;
                        break;
                }
                c /= 6;
            }
            return t.h = c, t.s = l, t.l = h, t;
        }
        getRGB(t, e = $t.workingColorSpace) {
            return $t.fromWorkingColorSpace(ke.copy(this), e), t.r = ke.r, t.g = ke.g, t.b = ke.b, t;
        }
        getStyle(t = De) {
            $t.fromWorkingColorSpace(ke.copy(this), t);
            const e = ke.r, n = ke.g, s = ke.b;
            return t !== De ? `color(${t} ${e.toFixed(3)} ${n.toFixed(3)} ${s.toFixed(3)})` : `rgb(${Math.round(e * 255)},${Math.round(n * 255)},${Math.round(s * 255)})`;
        }
        offsetHSL(t, e, n) {
            return this.getHSL(li), this.setHSL(li.h + t, li.s + e, li.l + n);
        }
        add(t) {
            return this.r += t.r, this.g += t.g, this.b += t.b, this;
        }
        addColors(t, e) {
            return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this;
        }
        addScalar(t) {
            return this.r += t, this.g += t, this.b += t, this;
        }
        sub(t) {
            return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this;
        }
        multiply(t) {
            return this.r *= t.r, this.g *= t.g, this.b *= t.b, this;
        }
        multiplyScalar(t) {
            return this.r *= t, this.g *= t, this.b *= t, this;
        }
        lerp(t, e) {
            return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this;
        }
        lerpColors(t, e, n) {
            return this.r = t.r + (e.r - t.r) * n, this.g = t.g + (e.g - t.g) * n, this.b = t.b + (e.b - t.b) * n, this;
        }
        lerpHSL(t, e) {
            this.getHSL(li), t.getHSL(qr);
            const n = mr(li.h, qr.h, e), s = mr(li.s, qr.s, e), r = mr(li.l, qr.l, e);
            return this.setHSL(n, s, r), this;
        }
        setFromVector3(t) {
            return this.r = t.x, this.g = t.y, this.b = t.z, this;
        }
        applyMatrix3(t) {
            const e = this.r, n = this.g, s = this.b, r = t.elements;
            return this.r = r[0] * e + r[3] * n + r[6] * s, this.g = r[1] * e + r[4] * n + r[7] * s, this.b = r[2] * e + r[5] * n + r[8] * s, this;
        }
        equals(t) {
            return t.r === this.r && t.g === this.g && t.b === this.b;
        }
        fromArray(t, e = 0) {
            return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this;
        }
        toArray(t = [], e = 0) {
            return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t;
        }
        fromBufferAttribute(t, e) {
            return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), this;
        }
        toJSON() {
            return this.getHex();
        }
        *[Symbol.iterator]() {
            yield this.r, yield this.g, yield this.b;
        }
    };
    const ke = new Bt;
    Bt.NAMES = Of;
    let jg = 0;
    class Bn extends $i {
        constructor(){
            super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
                value: jg++
            }), this.uuid = wn(), this.name = "", this.type = "Material", this.blending = Ts, this.side = ii, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = yc, this.blendDst = bc, this.blendEquation = Fi, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Bt(0, 0, 0), this.blendAlpha = 0, this.depthFunc = Rs, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = Xh, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = ts, this.stencilZFail = ts, this.stencilZPass = ts, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.allowOverride = !0, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
        }
        get alphaTest() {
            return this._alphaTest;
        }
        set alphaTest(t) {
            this._alphaTest > 0 != t > 0 && this.version++, this._alphaTest = t;
        }
        onBeforeRender() {}
        onBeforeCompile() {}
        customProgramCacheKey() {
            return this.onBeforeCompile.toString();
        }
        setValues(t) {
            if (t !== void 0) for(const e in t){
                const n = t[e];
                if (n === void 0) {
                    console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);
                    continue;
                }
                const s = this[e];
                if (s === void 0) {
                    console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`);
                    continue;
                }
                s && s.isColor ? s.set(n) : s && s.isVector3 && n && n.isVector3 ? s.copy(n) : this[e] = n;
            }
        }
        toJSON(t) {
            const e = t === void 0 || typeof t == "string";
            e && (t = {
                textures: {},
                images: {}
            });
            const n = {
                metadata: {
                    version: 4.6,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };
            n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (n.dispersion = this.dispersion), this.iridescence !== void 0 && (n.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(t).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(t).uuid), this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(t).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapRotation !== void 0 && (n.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== Ts && (n.blending = this.blending), this.side !== ii && (n.side = this.side), this.vertexColors === !0 && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = !0), this.blendSrc !== yc && (n.blendSrc = this.blendSrc), this.blendDst !== bc && (n.blendDst = this.blendDst), this.blendEquation !== Fi && (n.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha), this.depthFunc !== Rs && (n.depthFunc = this.depthFunc), this.depthTest === !1 && (n.depthTest = this.depthTest), this.depthWrite === !1 && (n.depthWrite = this.depthWrite), this.colorWrite === !1 && (n.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== Xh && (n.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (n.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== ts && (n.stencilFail = this.stencilFail), this.stencilZFail !== ts && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== ts && (n.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaHash === !0 && (n.alphaHash = !0), this.alphaToCoverage === !0 && (n.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0), this.forceSinglePass === !0 && (n.forceSinglePass = !0), this.wireframe === !0 && (n.wireframe = !0), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (n.flatShading = !0), this.visible === !1 && (n.visible = !1), this.toneMapped === !1 && (n.toneMapped = !1), this.fog === !1 && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData);
            function s(r) {
                const a = [];
                for(const o in r){
                    const c = r[o];
                    delete c.metadata, a.push(c);
                }
                return a;
            }
            if (e) {
                const r = s(t.textures), a = s(t.images);
                r.length > 0 && (n.textures = r), a.length > 0 && (n.images = a);
            }
            return n;
        }
        clone() {
            return new this.constructor().copy(this);
        }
        copy(t) {
            this.name = t.name, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.blendColor.copy(t.blendColor), this.blendAlpha = t.blendAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
            const e = t.clippingPlanes;
            let n = null;
            if (e !== null) {
                const s = e.length;
                n = new Array(s);
                for(let r = 0; r !== s; ++r)n[r] = e[r].clone();
            }
            return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaHash = t.alphaHash, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.forceSinglePass = t.forceSinglePass, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this;
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            });
        }
        set needsUpdate(t) {
            t === !0 && this.version++;
        }
        onBuild() {
            console.warn("Material: onBuild() has been removed.");
        }
    }
    class ki extends Bn {
        constructor(t){
            super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Bt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Fn, this.combine = yf, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(t);
        }
        copy(t) {
            return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.fog = t.fog, this;
        }
    }
    const Te = new k, jr = new Kt;
    let $g = 0;
    class je {
        constructor(t, e, n = !1){
            if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.isBufferAttribute = !0, Object.defineProperty(this, "id", {
                value: $g++
            }), this.name = "", this.array = t, this.itemSize = e, this.count = t !== void 0 ? t.length / e : 0, this.normalized = n, this.usage = rl, this.updateRanges = [], this.gpuType = An, this.version = 0;
        }
        onUploadCallback() {}
        set needsUpdate(t) {
            t === !0 && this.version++;
        }
        setUsage(t) {
            return this.usage = t, this;
        }
        addUpdateRange(t, e) {
            this.updateRanges.push({
                start: t,
                count: e
            });
        }
        clearUpdateRanges() {
            this.updateRanges.length = 0;
        }
        copy(t) {
            return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this.gpuType = t.gpuType, this;
        }
        copyAt(t, e, n) {
            t *= this.itemSize, n *= e.itemSize;
            for(let s = 0, r = this.itemSize; s < r; s++)this.array[t + s] = e.array[n + s];
            return this;
        }
        copyArray(t) {
            return this.array.set(t), this;
        }
        applyMatrix3(t) {
            if (this.itemSize === 2) for(let e = 0, n = this.count; e < n; e++)jr.fromBufferAttribute(this, e), jr.applyMatrix3(t), this.setXY(e, jr.x, jr.y);
            else if (this.itemSize === 3) for(let e = 0, n = this.count; e < n; e++)Te.fromBufferAttribute(this, e), Te.applyMatrix3(t), this.setXYZ(e, Te.x, Te.y, Te.z);
            return this;
        }
        applyMatrix4(t) {
            for(let e = 0, n = this.count; e < n; e++)Te.fromBufferAttribute(this, e), Te.applyMatrix4(t), this.setXYZ(e, Te.x, Te.y, Te.z);
            return this;
        }
        applyNormalMatrix(t) {
            for(let e = 0, n = this.count; e < n; e++)Te.fromBufferAttribute(this, e), Te.applyNormalMatrix(t), this.setXYZ(e, Te.x, Te.y, Te.z);
            return this;
        }
        transformDirection(t) {
            for(let e = 0, n = this.count; e < n; e++)Te.fromBufferAttribute(this, e), Te.transformDirection(t), this.setXYZ(e, Te.x, Te.y, Te.z);
            return this;
        }
        set(t, e = 0) {
            return this.array.set(t, e), this;
        }
        getComponent(t, e) {
            let n = this.array[t * this.itemSize + e];
            return this.normalized && (n = Tn(n, this.array)), n;
        }
        setComponent(t, e, n) {
            return this.normalized && (n = oe(n, this.array)), this.array[t * this.itemSize + e] = n, this;
        }
        getX(t) {
            let e = this.array[t * this.itemSize];
            return this.normalized && (e = Tn(e, this.array)), e;
        }
        setX(t, e) {
            return this.normalized && (e = oe(e, this.array)), this.array[t * this.itemSize] = e, this;
        }
        getY(t) {
            let e = this.array[t * this.itemSize + 1];
            return this.normalized && (e = Tn(e, this.array)), e;
        }
        setY(t, e) {
            return this.normalized && (e = oe(e, this.array)), this.array[t * this.itemSize + 1] = e, this;
        }
        getZ(t) {
            let e = this.array[t * this.itemSize + 2];
            return this.normalized && (e = Tn(e, this.array)), e;
        }
        setZ(t, e) {
            return this.normalized && (e = oe(e, this.array)), this.array[t * this.itemSize + 2] = e, this;
        }
        getW(t) {
            let e = this.array[t * this.itemSize + 3];
            return this.normalized && (e = Tn(e, this.array)), e;
        }
        setW(t, e) {
            return this.normalized && (e = oe(e, this.array)), this.array[t * this.itemSize + 3] = e, this;
        }
        setXY(t, e, n) {
            return t *= this.itemSize, this.normalized && (e = oe(e, this.array), n = oe(n, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this;
        }
        setXYZ(t, e, n, s) {
            return t *= this.itemSize, this.normalized && (e = oe(e, this.array), n = oe(n, this.array), s = oe(s, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = s, this;
        }
        setXYZW(t, e, n, s, r) {
            return t *= this.itemSize, this.normalized && (e = oe(e, this.array), n = oe(n, this.array), s = oe(s, this.array), r = oe(r, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = s, this.array[t + 3] = r, this;
        }
        onUpload(t) {
            return this.onUploadCallback = t, this;
        }
        clone() {
            return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
            const t = {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: Array.from(this.array),
                normalized: this.normalized
            };
            return this.name !== "" && (t.name = this.name), this.usage !== rl && (t.usage = this.usage), t;
        }
    }
    class kf extends je {
        constructor(t, e, n){
            super(new Uint16Array(t), e, n);
        }
    }
    class Gf extends je {
        constructor(t, e, n){
            super(new Uint32Array(t), e, n);
        }
    }
    class ti extends je {
        constructor(t, e, n){
            super(new Float32Array(t), e, n);
        }
    }
    let Kg = 0;
    const hn = new Ht, bo = new ge, hs = new k, rn = new Cn, Js = new Cn, we = new k;
    class kn extends $i {
        constructor(){
            super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
                value: Kg++
            }), this.uuid = wn(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                start: 0,
                count: 1 / 0
            }, this.userData = {};
        }
        getIndex() {
            return this.index;
        }
        setIndex(t) {
            return Array.isArray(t) ? this.index = new (Nf(t) ? Gf : kf)(t, 1) : this.index = t, this;
        }
        setIndirect(t) {
            return this.indirect = t, this;
        }
        getIndirect() {
            return this.indirect;
        }
        getAttribute(t) {
            return this.attributes[t];
        }
        setAttribute(t, e) {
            return this.attributes[t] = e, this;
        }
        deleteAttribute(t) {
            return delete this.attributes[t], this;
        }
        hasAttribute(t) {
            return this.attributes[t] !== void 0;
        }
        addGroup(t, e, n = 0) {
            this.groups.push({
                start: t,
                count: e,
                materialIndex: n
            });
        }
        clearGroups() {
            this.groups = [];
        }
        setDrawRange(t, e) {
            this.drawRange.start = t, this.drawRange.count = e;
        }
        applyMatrix4(t) {
            const e = this.attributes.position;
            e !== void 0 && (e.applyMatrix4(t), e.needsUpdate = !0);
            const n = this.attributes.normal;
            if (n !== void 0) {
                const r = new Gt().getNormalMatrix(t);
                n.applyNormalMatrix(r), n.needsUpdate = !0;
            }
            const s = this.attributes.tangent;
            return s !== void 0 && (s.transformDirection(t), s.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
        }
        applyQuaternion(t) {
            return hn.makeRotationFromQuaternion(t), this.applyMatrix4(hn), this;
        }
        rotateX(t) {
            return hn.makeRotationX(t), this.applyMatrix4(hn), this;
        }
        rotateY(t) {
            return hn.makeRotationY(t), this.applyMatrix4(hn), this;
        }
        rotateZ(t) {
            return hn.makeRotationZ(t), this.applyMatrix4(hn), this;
        }
        translate(t, e, n) {
            return hn.makeTranslation(t, e, n), this.applyMatrix4(hn), this;
        }
        scale(t, e, n) {
            return hn.makeScale(t, e, n), this.applyMatrix4(hn), this;
        }
        lookAt(t) {
            return bo.lookAt(t), bo.updateMatrix(), this.applyMatrix4(bo.matrix), this;
        }
        center() {
            return this.computeBoundingBox(), this.boundingBox.getCenter(hs).negate(), this.translate(hs.x, hs.y, hs.z), this;
        }
        setFromPoints(t) {
            const e = this.getAttribute("position");
            if (e === void 0) {
                const n = [];
                for(let s = 0, r = t.length; s < r; s++){
                    const a = t[s];
                    n.push(a.x, a.y, a.z || 0);
                }
                this.setAttribute("position", new ti(n, 3));
            } else {
                const n = Math.min(t.length, e.count);
                for(let s = 0; s < n; s++){
                    const r = t[s];
                    e.setXYZ(s, r.x, r.y, r.z || 0);
                }
                t.length > e.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), e.needsUpdate = !0;
            }
            return this;
        }
        computeBoundingBox() {
            this.boundingBox === null && (this.boundingBox = new Cn);
            const t = this.attributes.position, e = this.morphAttributes.position;
            if (t && t.isGLBufferAttribute) {
                console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(new k(-1 / 0, -1 / 0, -1 / 0), new k(1 / 0, 1 / 0, 1 / 0));
                return;
            }
            if (t !== void 0) {
                if (this.boundingBox.setFromBufferAttribute(t), e) for(let n = 0, s = e.length; n < s; n++){
                    const r = e[n];
                    rn.setFromBufferAttribute(r), this.morphTargetsRelative ? (we.addVectors(this.boundingBox.min, rn.min), this.boundingBox.expandByPoint(we), we.addVectors(this.boundingBox.max, rn.max), this.boundingBox.expandByPoint(we)) : (this.boundingBox.expandByPoint(rn.min), this.boundingBox.expandByPoint(rn.max));
                }
            } else this.boundingBox.makeEmpty();
            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
        }
        computeBoundingSphere() {
            this.boundingSphere === null && (this.boundingSphere = new On);
            const t = this.attributes.position, e = this.morphAttributes.position;
            if (t && t.isGLBufferAttribute) {
                console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new k, 1 / 0);
                return;
            }
            if (t) {
                const n = this.boundingSphere.center;
                if (rn.setFromBufferAttribute(t), e) for(let r = 0, a = e.length; r < a; r++){
                    const o = e[r];
                    Js.setFromBufferAttribute(o), this.morphTargetsRelative ? (we.addVectors(rn.min, Js.min), rn.expandByPoint(we), we.addVectors(rn.max, Js.max), rn.expandByPoint(we)) : (rn.expandByPoint(Js.min), rn.expandByPoint(Js.max));
                }
                rn.getCenter(n);
                let s = 0;
                for(let r = 0, a = t.count; r < a; r++)we.fromBufferAttribute(t, r), s = Math.max(s, n.distanceToSquared(we));
                if (e) for(let r = 0, a = e.length; r < a; r++){
                    const o = e[r], c = this.morphTargetsRelative;
                    for(let l = 0, h = o.count; l < h; l++)we.fromBufferAttribute(o, l), c && (hs.fromBufferAttribute(t, l), we.add(hs)), s = Math.max(s, n.distanceToSquared(we));
                }
                this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
            }
        }
        computeTangents() {
            const t = this.index, e = this.attributes;
            if (t === null || e.position === void 0 || e.normal === void 0 || e.uv === void 0) {
                console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                return;
            }
            const n = e.position, s = e.normal, r = e.uv;
            this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new je(new Float32Array(4 * n.count), 4));
            const a = this.getAttribute("tangent"), o = [], c = [];
            for(let N = 0; N < n.count; N++)o[N] = new k, c[N] = new k;
            const l = new k, h = new k, u = new k, d = new Kt, f = new Kt, _ = new Kt, g = new k, p = new k;
            function m(N, E, S) {
                l.fromBufferAttribute(n, N), h.fromBufferAttribute(n, E), u.fromBufferAttribute(n, S), d.fromBufferAttribute(r, N), f.fromBufferAttribute(r, E), _.fromBufferAttribute(r, S), h.sub(l), u.sub(l), f.sub(d), _.sub(d);
                const D = 1 / (f.x * _.y - _.x * f.y);
                isFinite(D) && (g.copy(h).multiplyScalar(_.y).addScaledVector(u, -f.y).multiplyScalar(D), p.copy(u).multiplyScalar(f.x).addScaledVector(h, -_.x).multiplyScalar(D), o[N].add(g), o[E].add(g), o[S].add(g), c[N].add(p), c[E].add(p), c[S].add(p));
            }
            let x = this.groups;
            x.length === 0 && (x = [
                {
                    start: 0,
                    count: t.count
                }
            ]);
            for(let N = 0, E = x.length; N < E; ++N){
                const S = x[N], D = S.start, j = S.count;
                for(let z = D, K = D + j; z < K; z += 3)m(t.getX(z + 0), t.getX(z + 1), t.getX(z + 2));
            }
            const y = new k, v = new k, I = new k, w = new k;
            function R(N) {
                I.fromBufferAttribute(s, N), w.copy(I);
                const E = o[N];
                y.copy(E), y.sub(I.multiplyScalar(I.dot(E))).normalize(), v.crossVectors(w, E);
                const D = v.dot(c[N]) < 0 ? -1 : 1;
                a.setXYZW(N, y.x, y.y, y.z, D);
            }
            for(let N = 0, E = x.length; N < E; ++N){
                const S = x[N], D = S.start, j = S.count;
                for(let z = D, K = D + j; z < K; z += 3)R(t.getX(z + 0)), R(t.getX(z + 1)), R(t.getX(z + 2));
            }
        }
        computeVertexNormals() {
            const t = this.index, e = this.getAttribute("position");
            if (e !== void 0) {
                let n = this.getAttribute("normal");
                if (n === void 0) n = new je(new Float32Array(e.count * 3), 3), this.setAttribute("normal", n);
                else for(let d = 0, f = n.count; d < f; d++)n.setXYZ(d, 0, 0, 0);
                const s = new k, r = new k, a = new k, o = new k, c = new k, l = new k, h = new k, u = new k;
                if (t) for(let d = 0, f = t.count; d < f; d += 3){
                    const _ = t.getX(d + 0), g = t.getX(d + 1), p = t.getX(d + 2);
                    s.fromBufferAttribute(e, _), r.fromBufferAttribute(e, g), a.fromBufferAttribute(e, p), h.subVectors(a, r), u.subVectors(s, r), h.cross(u), o.fromBufferAttribute(n, _), c.fromBufferAttribute(n, g), l.fromBufferAttribute(n, p), o.add(h), c.add(h), l.add(h), n.setXYZ(_, o.x, o.y, o.z), n.setXYZ(g, c.x, c.y, c.z), n.setXYZ(p, l.x, l.y, l.z);
                }
                else for(let d = 0, f = e.count; d < f; d += 3)s.fromBufferAttribute(e, d + 0), r.fromBufferAttribute(e, d + 1), a.fromBufferAttribute(e, d + 2), h.subVectors(a, r), u.subVectors(s, r), h.cross(u), n.setXYZ(d + 0, h.x, h.y, h.z), n.setXYZ(d + 1, h.x, h.y, h.z), n.setXYZ(d + 2, h.x, h.y, h.z);
                this.normalizeNormals(), n.needsUpdate = !0;
            }
        }
        normalizeNormals() {
            const t = this.attributes.normal;
            for(let e = 0, n = t.count; e < n; e++)we.fromBufferAttribute(t, e), we.normalize(), t.setXYZ(e, we.x, we.y, we.z);
        }
        toNonIndexed() {
            function t(o, c) {
                const l = o.array, h = o.itemSize, u = o.normalized, d = new l.constructor(c.length * h);
                let f = 0, _ = 0;
                for(let g = 0, p = c.length; g < p; g++){
                    o.isInterleavedBufferAttribute ? f = c[g] * o.data.stride + o.offset : f = c[g] * h;
                    for(let m = 0; m < h; m++)d[_++] = l[f++];
                }
                return new je(d, h, u);
            }
            if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
            const e = new kn, n = this.index.array, s = this.attributes;
            for(const o in s){
                const c = s[o], l = t(c, n);
                e.setAttribute(o, l);
            }
            const r = this.morphAttributes;
            for(const o in r){
                const c = [], l = r[o];
                for(let h = 0, u = l.length; h < u; h++){
                    const d = l[h], f = t(d, n);
                    c.push(f);
                }
                e.morphAttributes[o] = c;
            }
            e.morphTargetsRelative = this.morphTargetsRelative;
            const a = this.groups;
            for(let o = 0, c = a.length; o < c; o++){
                const l = a[o];
                e.addGroup(l.start, l.count, l.materialIndex);
            }
            return e;
        }
        toJSON() {
            const t = {
                metadata: {
                    version: 4.6,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (t.uuid = this.uuid, t.type = this.type, this.name !== "" && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), this.parameters !== void 0) {
                const c = this.parameters;
                for(const l in c)c[l] !== void 0 && (t[l] = c[l]);
                return t;
            }
            t.data = {
                attributes: {}
            };
            const e = this.index;
            e !== null && (t.data.index = {
                type: e.array.constructor.name,
                array: Array.prototype.slice.call(e.array)
            });
            const n = this.attributes;
            for(const c in n){
                const l = n[c];
                t.data.attributes[c] = l.toJSON(t.data);
            }
            const s = {};
            let r = !1;
            for(const c in this.morphAttributes){
                const l = this.morphAttributes[c], h = [];
                for(let u = 0, d = l.length; u < d; u++){
                    const f = l[u];
                    h.push(f.toJSON(t.data));
                }
                h.length > 0 && (s[c] = h, r = !0);
            }
            r && (t.data.morphAttributes = s, t.data.morphTargetsRelative = this.morphTargetsRelative);
            const a = this.groups;
            a.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(a)));
            const o = this.boundingSphere;
            return o !== null && (t.data.boundingSphere = {
                center: o.center.toArray(),
                radius: o.radius
            }), t;
        }
        clone() {
            return new this.constructor().copy(this);
        }
        copy(t) {
            this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
            const e = {};
            this.name = t.name;
            const n = t.index;
            n !== null && this.setIndex(n.clone());
            const s = t.attributes;
            for(const l in s){
                const h = s[l];
                this.setAttribute(l, h.clone(e));
            }
            const r = t.morphAttributes;
            for(const l in r){
                const h = [], u = r[l];
                for(let d = 0, f = u.length; d < f; d++)h.push(u[d].clone(e));
                this.morphAttributes[l] = h;
            }
            this.morphTargetsRelative = t.morphTargetsRelative;
            const a = t.groups;
            for(let l = 0, h = a.length; l < h; l++){
                const u = a[l];
                this.addGroup(u.start, u.count, u.materialIndex);
            }
            const o = t.boundingBox;
            o !== null && (this.boundingBox = o.clone());
            const c = t.boundingSphere;
            return c !== null && (this.boundingSphere = c.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this;
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            });
        }
    }
    const au = new Ht, Ei = new ja, $r = new On, ou = new k, Kr = new k, Zr = new k, Jr = new k, So = new k, Qr = new k, cu = new k, ta = new k;
    class Le extends ge {
        constructor(t = new kn, e = new ki){
            super(), this.isMesh = !0, this.type = "Mesh", this.geometry = t, this.material = e, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets();
        }
        copy(t, e) {
            return super.copy(t, e), t.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), t.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this;
        }
        updateMorphTargets() {
            const e = this.geometry.morphAttributes, n = Object.keys(e);
            if (n.length > 0) {
                const s = e[n[0]];
                if (s !== void 0) {
                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                    for(let r = 0, a = s.length; r < a; r++){
                        const o = s[r].name || String(r);
                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = r;
                    }
                }
            }
        }
        getVertexPosition(t, e) {
            const n = this.geometry, s = n.attributes.position, r = n.morphAttributes.position, a = n.morphTargetsRelative;
            e.fromBufferAttribute(s, t);
            const o = this.morphTargetInfluences;
            if (r && o) {
                Qr.set(0, 0, 0);
                for(let c = 0, l = r.length; c < l; c++){
                    const h = o[c], u = r[c];
                    h !== 0 && (So.fromBufferAttribute(u, t), a ? Qr.addScaledVector(So, h) : Qr.addScaledVector(So.sub(e), h));
                }
                e.add(Qr);
            }
            return e;
        }
        raycast(t, e) {
            const n = this.geometry, s = this.material, r = this.matrixWorld;
            s !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(), $r.copy(n.boundingSphere), $r.applyMatrix4(r), Ei.copy(t.ray).recast(t.near), !($r.containsPoint(Ei.origin) === !1 && (Ei.intersectSphere($r, ou) === null || Ei.origin.distanceToSquared(ou) > (t.far - t.near) ** 2)) && (au.copy(r).invert(), Ei.copy(t.ray).applyMatrix4(au), !(n.boundingBox !== null && Ei.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(t, e, Ei)));
        }
        _computeIntersections(t, e, n) {
            let s;
            const r = this.geometry, a = this.material, o = r.index, c = r.attributes.position, l = r.attributes.uv, h = r.attributes.uv1, u = r.attributes.normal, d = r.groups, f = r.drawRange;
            if (o !== null) if (Array.isArray(a)) for(let _ = 0, g = d.length; _ < g; _++){
                const p = d[_], m = a[p.materialIndex], x = Math.max(p.start, f.start), y = Math.min(o.count, Math.min(p.start + p.count, f.start + f.count));
                for(let v = x, I = y; v < I; v += 3){
                    const w = o.getX(v), R = o.getX(v + 1), N = o.getX(v + 2);
                    s = ea(this, m, t, n, l, h, u, w, R, N), s && (s.faceIndex = Math.floor(v / 3), s.face.materialIndex = p.materialIndex, e.push(s));
                }
            }
            else {
                const _ = Math.max(0, f.start), g = Math.min(o.count, f.start + f.count);
                for(let p = _, m = g; p < m; p += 3){
                    const x = o.getX(p), y = o.getX(p + 1), v = o.getX(p + 2);
                    s = ea(this, a, t, n, l, h, u, x, y, v), s && (s.faceIndex = Math.floor(p / 3), e.push(s));
                }
            }
            else if (c !== void 0) if (Array.isArray(a)) for(let _ = 0, g = d.length; _ < g; _++){
                const p = d[_], m = a[p.materialIndex], x = Math.max(p.start, f.start), y = Math.min(c.count, Math.min(p.start + p.count, f.start + f.count));
                for(let v = x, I = y; v < I; v += 3){
                    const w = v, R = v + 1, N = v + 2;
                    s = ea(this, m, t, n, l, h, u, w, R, N), s && (s.faceIndex = Math.floor(v / 3), s.face.materialIndex = p.materialIndex, e.push(s));
                }
            }
            else {
                const _ = Math.max(0, f.start), g = Math.min(c.count, f.start + f.count);
                for(let p = _, m = g; p < m; p += 3){
                    const x = p, y = p + 1, v = p + 2;
                    s = ea(this, a, t, n, l, h, u, x, y, v), s && (s.faceIndex = Math.floor(p / 3), e.push(s));
                }
            }
        }
    }
    function Zg(i, t, e, n, s, r, a, o) {
        let c;
        if (t.side === Qe ? c = n.intersectTriangle(a, r, s, !0, o) : c = n.intersectTriangle(s, r, a, t.side === ii, o), c === null) return null;
        ta.copy(o), ta.applyMatrix4(i.matrixWorld);
        const l = e.ray.origin.distanceTo(ta);
        return l < e.near || l > e.far ? null : {
            distance: l,
            point: ta.clone(),
            object: i
        };
    }
    function ea(i, t, e, n, s, r, a, o, c, l) {
        i.getVertexPosition(o, Kr), i.getVertexPosition(c, Zr), i.getVertexPosition(l, Jr);
        const h = Zg(i, t, e, n, Kr, Zr, Jr, cu);
        if (h) {
            const u = new k;
            En.getBarycoord(cu, Kr, Zr, Jr, u), s && (h.uv = En.getInterpolatedAttribute(s, o, c, l, u, new Kt)), r && (h.uv1 = En.getInterpolatedAttribute(r, o, c, l, u, new Kt)), a && (h.normal = En.getInterpolatedAttribute(a, o, c, l, u, new k), h.normal.dot(n.direction) > 0 && h.normal.multiplyScalar(-1));
            const d = {
                a: o,
                b: c,
                c: l,
                normal: new k,
                materialIndex: 0
            };
            En.getNormal(Kr, Zr, Jr, d.normal), h.face = d, h.barycoord = u;
        }
        return h;
    }
    class Hs extends kn {
        constructor(t = 1, e = 1, n = 1, s = 1, r = 1, a = 1){
            super(), this.type = "BoxGeometry", this.parameters = {
                width: t,
                height: e,
                depth: n,
                widthSegments: s,
                heightSegments: r,
                depthSegments: a
            };
            const o = this;
            s = Math.floor(s), r = Math.floor(r), a = Math.floor(a);
            const c = [], l = [], h = [], u = [];
            let d = 0, f = 0;
            _("z", "y", "x", -1, -1, n, e, t, a, r, 0), _("z", "y", "x", 1, -1, n, e, -t, a, r, 1), _("x", "z", "y", 1, 1, t, n, e, s, a, 2), _("x", "z", "y", 1, -1, t, n, -e, s, a, 3), _("x", "y", "z", 1, -1, t, e, n, s, r, 4), _("x", "y", "z", -1, -1, t, e, -n, s, r, 5), this.setIndex(c), this.setAttribute("position", new ti(l, 3)), this.setAttribute("normal", new ti(h, 3)), this.setAttribute("uv", new ti(u, 2));
            function _(g, p, m, x, y, v, I, w, R, N, E) {
                const S = v / R, D = I / N, j = v / 2, z = I / 2, K = w / 2, nt = R + 1, b = N + 1;
                let C = 0, A = 0;
                const U = new k;
                for(let B = 0; B < b; B++){
                    const V = B * D - z;
                    for(let q = 0; q < nt; q++){
                        const et = q * S - j;
                        U[g] = et * x, U[p] = V * y, U[m] = K, l.push(U.x, U.y, U.z), U[g] = 0, U[p] = 0, U[m] = w > 0 ? 1 : -1, h.push(U.x, U.y, U.z), u.push(q / R), u.push(1 - B / N), C += 1;
                    }
                }
                for(let B = 0; B < N; B++)for(let V = 0; V < R; V++){
                    const q = d + V + nt * B, et = d + V + nt * (B + 1), H = d + (V + 1) + nt * (B + 1), $ = d + (V + 1) + nt * B;
                    c.push(q, et, $), c.push(et, H, $), A += 6;
                }
                o.addGroup(f, A, E), f += A, d += C;
            }
        }
        copy(t) {
            return super.copy(t), this.parameters = Object.assign({}, t.parameters), this;
        }
        static fromJSON(t) {
            return new Hs(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments);
        }
    }
    function Ls(i) {
        const t = {};
        for(const e in i){
            t[e] = {};
            for(const n in i[e]){
                const s = i[e][n];
                s && (s.isColor || s.isMatrix3 || s.isMatrix4 || s.isVector2 || s.isVector3 || s.isVector4 || s.isTexture || s.isQuaternion) ? s.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), t[e][n] = null) : t[e][n] = s.clone() : Array.isArray(s) ? t[e][n] = s.slice() : t[e][n] = s;
            }
        }
        return t;
    }
    function Ve(i) {
        const t = {};
        for(let e = 0; e < i.length; e++){
            const n = Ls(i[e]);
            for(const s in n)t[s] = n[s];
        }
        return t;
    }
    function Jg(i) {
        const t = [];
        for(let e = 0; e < i.length; e++)t.push(i[e].clone());
        return t;
    }
    function Hf(i) {
        const t = i.getRenderTarget();
        return t === null ? i.outputColorSpace : t.isXRRenderTarget === !0 ? t.texture.colorSpace : $t.workingColorSpace;
    }
    const Qg = {
        clone: Ls,
        merge: Ve
    };
    var tx = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, ex = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
    class yi extends Bn {
        constructor(t){
            super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = tx, this.fragmentShader = ex, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
                clipCullDistance: !1,
                multiDraw: !1
            }, this.defaultAttributeValues = {
                color: [
                    1,
                    1,
                    1
                ],
                uv: [
                    0,
                    0
                ],
                uv1: [
                    0,
                    0
                ]
            }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, t !== void 0 && this.setValues(t);
        }
        copy(t) {
            return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Ls(t.uniforms), this.uniformsGroups = Jg(t.uniformsGroups), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.fog = t.fog, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this;
        }
        toJSON(t) {
            const e = super.toJSON(t);
            e.glslVersion = this.glslVersion, e.uniforms = {};
            for(const s in this.uniforms){
                const a = this.uniforms[s].value;
                a && a.isTexture ? e.uniforms[s] = {
                    type: "t",
                    value: a.toJSON(t).uuid
                } : a && a.isColor ? e.uniforms[s] = {
                    type: "c",
                    value: a.getHex()
                } : a && a.isVector2 ? e.uniforms[s] = {
                    type: "v2",
                    value: a.toArray()
                } : a && a.isVector3 ? e.uniforms[s] = {
                    type: "v3",
                    value: a.toArray()
                } : a && a.isVector4 ? e.uniforms[s] = {
                    type: "v4",
                    value: a.toArray()
                } : a && a.isMatrix3 ? e.uniforms[s] = {
                    type: "m3",
                    value: a.toArray()
                } : a && a.isMatrix4 ? e.uniforms[s] = {
                    type: "m4",
                    value: a.toArray()
                } : e.uniforms[s] = {
                    value: a
                };
            }
            Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e.lights = this.lights, e.clipping = this.clipping;
            const n = {};
            for(const s in this.extensions)this.extensions[s] === !0 && (n[s] = !0);
            return Object.keys(n).length > 0 && (e.extensions = n), e;
        }
    }
    class zf extends ge {
        constructor(){
            super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Ht, this.projectionMatrix = new Ht, this.projectionMatrixInverse = new Ht, this.coordinateSystem = Jn;
        }
        copy(t, e) {
            return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this.coordinateSystem = t.coordinateSystem, this;
        }
        getWorldDirection(t) {
            return super.getWorldDirection(t).negate();
        }
        updateMatrixWorld(t) {
            super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        updateWorldMatrix(t, e) {
            super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        clone() {
            return new this.constructor().copy(this);
        }
    }
    const hi = new k, lu = new Kt, hu = new Kt;
    class We extends zf {
        constructor(t = 50, e = 1, n = .1, s = 2e3){
            super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = n, this.far = s, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
        }
        copy(t, e) {
            return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = t.view === null ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this;
        }
        setFocalLength(t) {
            const e = .5 * this.getFilmHeight() / t;
            this.fov = Ds * 2 * Math.atan(e), this.updateProjectionMatrix();
        }
        getFocalLength() {
            const t = Math.tan(pr * .5 * this.fov);
            return .5 * this.getFilmHeight() / t;
        }
        getEffectiveFOV() {
            return Ds * 2 * Math.atan(Math.tan(pr * .5 * this.fov) / this.zoom);
        }
        getFilmWidth() {
            return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
            return this.filmGauge / Math.max(this.aspect, 1);
        }
        getViewBounds(t, e, n) {
            hi.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse), e.set(hi.x, hi.y).multiplyScalar(-t / hi.z), hi.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse), n.set(hi.x, hi.y).multiplyScalar(-t / hi.z);
        }
        getViewSize(t, e) {
            return this.getViewBounds(t, lu, hu), e.subVectors(hu, lu);
        }
        setViewOffset(t, e, n, s, r, a) {
            this.aspect = t / e, this.view === null && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = s, this.view.width = r, this.view.height = a, this.updateProjectionMatrix();
        }
        clearViewOffset() {
            this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
            const t = this.near;
            let e = t * Math.tan(pr * .5 * this.fov) / this.zoom, n = 2 * e, s = this.aspect * n, r = -.5 * s;
            const a = this.view;
            if (this.view !== null && this.view.enabled) {
                const c = a.fullWidth, l = a.fullHeight;
                r += a.offsetX * s / c, e -= a.offsetY * n / l, s *= a.width / c, n *= a.height / l;
            }
            const o = this.filmOffset;
            o !== 0 && (r += t * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + s, e, e - n, t, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(t) {
            const e = super.toJSON(t);
            return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, this.view !== null && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e;
        }
    }
    const us = -90, ds = 1;
    class nx extends ge {
        constructor(t, e, n){
            super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0;
            const s = new We(us, ds, t, e);
            s.layers = this.layers, this.add(s);
            const r = new We(us, ds, t, e);
            r.layers = this.layers, this.add(r);
            const a = new We(us, ds, t, e);
            a.layers = this.layers, this.add(a);
            const o = new We(us, ds, t, e);
            o.layers = this.layers, this.add(o);
            const c = new We(us, ds, t, e);
            c.layers = this.layers, this.add(c);
            const l = new We(us, ds, t, e);
            l.layers = this.layers, this.add(l);
        }
        updateCoordinateSystem() {
            const t = this.coordinateSystem, e = this.children.concat(), [n, s, r, a, o, c] = e;
            for (const l of e)this.remove(l);
            if (t === Jn) n.up.set(0, 1, 0), n.lookAt(1, 0, 0), s.up.set(0, 1, 0), s.lookAt(-1, 0, 0), r.up.set(0, 0, -1), r.lookAt(0, 1, 0), a.up.set(0, 0, 1), a.lookAt(0, -1, 0), o.up.set(0, 1, 0), o.lookAt(0, 0, 1), c.up.set(0, 1, 0), c.lookAt(0, 0, -1);
            else if (t === ka) n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), s.up.set(0, -1, 0), s.lookAt(1, 0, 0), r.up.set(0, 0, 1), r.lookAt(0, 1, 0), a.up.set(0, 0, -1), a.lookAt(0, -1, 0), o.up.set(0, -1, 0), o.lookAt(0, 0, 1), c.up.set(0, -1, 0), c.lookAt(0, 0, -1);
            else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + t);
            for (const l of e)this.add(l), l.updateMatrixWorld();
        }
        update(t, e) {
            this.parent === null && this.updateMatrixWorld();
            const { renderTarget: n, activeMipmapLevel: s } = this;
            this.coordinateSystem !== t.coordinateSystem && (this.coordinateSystem = t.coordinateSystem, this.updateCoordinateSystem());
            const [r, a, o, c, l, h] = this.children, u = t.getRenderTarget(), d = t.getActiveCubeFace(), f = t.getActiveMipmapLevel(), _ = t.xr.enabled;
            t.xr.enabled = !1;
            const g = n.texture.generateMipmaps;
            n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0, s), t.render(e, r), t.setRenderTarget(n, 1, s), t.render(e, a), t.setRenderTarget(n, 2, s), t.render(e, o), t.setRenderTarget(n, 3, s), t.render(e, c), t.setRenderTarget(n, 4, s), t.render(e, l), n.texture.generateMipmaps = g, t.setRenderTarget(n, 5, s), t.render(e, h), t.setRenderTarget(u, d, f), t.xr.enabled = _, n.texture.needsPMREMUpdate = !0;
        }
    }
    class Vf extends tn {
        constructor(t = [], e = Cs, n, s, r, a, o, c, l, h){
            super(t, e, n, s, r, a, o, c, l, h), this.isCubeTexture = !0, this.flipY = !1;
        }
        get images() {
            return this.image;
        }
        set images(t) {
            this.image = t;
        }
    }
    class ix extends Wi {
        constructor(t = 1, e = {}){
            super(t, t, e), this.isWebGLCubeRenderTarget = !0;
            const n = {
                width: t,
                height: t,
                depth: 1
            }, s = [
                n,
                n,
                n,
                n,
                n,
                n
            ];
            this.texture = new Vf(s, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = e.generateMipmaps !== void 0 ? e.generateMipmaps : !1, this.texture.minFilter = e.minFilter !== void 0 ? e.minFilter : on;
        }
        fromEquirectangularTexture(t, e) {
            this.texture.type = e.type, this.texture.colorSpace = e.colorSpace, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
            const n = {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
                fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
            }, s = new Hs(5, 5, 5), r = new yi({
                name: "CubemapFromEquirect",
                uniforms: Ls(n.uniforms),
                vertexShader: n.vertexShader,
                fragmentShader: n.fragmentShader,
                side: Qe,
                blending: _i
            });
            r.uniforms.tEquirect.value = e;
            const a = new Le(s, r), o = e.minFilter;
            return e.minFilter === Zn && (e.minFilter = on), new nx(1, 10, this).update(t, a), e.minFilter = o, a.geometry.dispose(), a.material.dispose(), this;
        }
        clear(t, e = !0, n = !0, s = !0) {
            const r = t.getRenderTarget();
            for(let a = 0; a < 6; a++)t.setRenderTarget(this, a), t.clear(e, n, s);
            t.setRenderTarget(r);
        }
    }
    class Gi extends ge {
        constructor(){
            super(), this.isGroup = !0, this.type = "Group";
        }
    }
    const sx = {
        type: "move"
    };
    class Mo {
        constructor(){
            this._targetRay = null, this._grip = null, this._hand = null;
        }
        getHandSpace() {
            return this._hand === null && (this._hand = new Gi, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
                pinching: !1
            }), this._hand;
        }
        getTargetRaySpace() {
            return this._targetRay === null && (this._targetRay = new Gi, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new k, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new k), this._targetRay;
        }
        getGripSpace() {
            return this._grip === null && (this._grip = new Gi, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new k, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new k), this._grip;
        }
        dispatchEvent(t) {
            return this._targetRay !== null && this._targetRay.dispatchEvent(t), this._grip !== null && this._grip.dispatchEvent(t), this._hand !== null && this._hand.dispatchEvent(t), this;
        }
        connect(t) {
            if (t && t.hand) {
                const e = this._hand;
                if (e) for (const n of t.hand.values())this._getHandJoint(e, n);
            }
            return this.dispatchEvent({
                type: "connected",
                data: t
            }), this;
        }
        disconnect(t) {
            return this.dispatchEvent({
                type: "disconnected",
                data: t
            }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
        }
        update(t, e, n) {
            let s = null, r = null, a = null;
            const o = this._targetRay, c = this._grip, l = this._hand;
            if (t && e.session.visibilityState !== "visible-blurred") {
                if (l && t.hand) {
                    a = !0;
                    for (const g of t.hand.values()){
                        const p = e.getJointPose(g, n), m = this._getHandJoint(l, g);
                        p !== null && (m.matrix.fromArray(p.transform.matrix), m.matrix.decompose(m.position, m.rotation, m.scale), m.matrixWorldNeedsUpdate = !0, m.jointRadius = p.radius), m.visible = p !== null;
                    }
                    const h = l.joints["index-finger-tip"], u = l.joints["thumb-tip"], d = h.position.distanceTo(u.position), f = .02, _ = .005;
                    l.inputState.pinching && d > f + _ ? (l.inputState.pinching = !1, this.dispatchEvent({
                        type: "pinchend",
                        handedness: t.handedness,
                        target: this
                    })) : !l.inputState.pinching && d <= f - _ && (l.inputState.pinching = !0, this.dispatchEvent({
                        type: "pinchstart",
                        handedness: t.handedness,
                        target: this
                    }));
                } else c !== null && t.gripSpace && (r = e.getPose(t.gripSpace, n), r !== null && (c.matrix.fromArray(r.transform.matrix), c.matrix.decompose(c.position, c.rotation, c.scale), c.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (c.hasLinearVelocity = !0, c.linearVelocity.copy(r.linearVelocity)) : c.hasLinearVelocity = !1, r.angularVelocity ? (c.hasAngularVelocity = !0, c.angularVelocity.copy(r.angularVelocity)) : c.hasAngularVelocity = !1));
                o !== null && (s = e.getPose(t.targetRaySpace, n), s === null && r !== null && (s = r), s !== null && (o.matrix.fromArray(s.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.matrixWorldNeedsUpdate = !0, s.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(s.linearVelocity)) : o.hasLinearVelocity = !1, s.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(s.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent(sx)));
            }
            return o !== null && (o.visible = s !== null), c !== null && (c.visible = r !== null), l !== null && (l.visible = a !== null), this;
        }
        _getHandJoint(t, e) {
            if (t.joints[e.jointName] === void 0) {
                const n = new Gi;
                n.matrixAutoUpdate = !1, n.visible = !1, t.joints[e.jointName] = n, t.add(n);
            }
            return t.joints[e.jointName];
        }
    }
    class rx extends ge {
        constructor(){
            super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new Fn, this.environmentIntensity = 1, this.environmentRotation = new Fn, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                detail: this
            }));
        }
        copy(t, e) {
            return super.copy(t, e), t.background !== null && (this.background = t.background.clone()), t.environment !== null && (this.environment = t.environment.clone()), t.fog !== null && (this.fog = t.fog.clone()), this.backgroundBlurriness = t.backgroundBlurriness, this.backgroundIntensity = t.backgroundIntensity, this.backgroundRotation.copy(t.backgroundRotation), this.environmentIntensity = t.environmentIntensity, this.environmentRotation.copy(t.environmentRotation), t.overrideMaterial !== null && (this.overrideMaterial = t.overrideMaterial.clone()), this.matrixAutoUpdate = t.matrixAutoUpdate, this;
        }
        toJSON(t) {
            const e = super.toJSON(t);
            return this.fog !== null && (e.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (e.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (e.object.backgroundIntensity = this.backgroundIntensity), e.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (e.object.environmentIntensity = this.environmentIntensity), e.object.environmentRotation = this.environmentRotation.toArray(), e;
        }
    }
    class ax {
        constructor(t, e){
            this.isInterleavedBuffer = !0, this.array = t, this.stride = e, this.count = t !== void 0 ? t.length / e : 0, this.usage = rl, this.updateRanges = [], this.version = 0, this.uuid = wn();
        }
        onUploadCallback() {}
        set needsUpdate(t) {
            t === !0 && this.version++;
        }
        setUsage(t) {
            return this.usage = t, this;
        }
        addUpdateRange(t, e) {
            this.updateRanges.push({
                start: t,
                count: e
            });
        }
        clearUpdateRanges() {
            this.updateRanges.length = 0;
        }
        copy(t) {
            return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this;
        }
        copyAt(t, e, n) {
            t *= this.stride, n *= e.stride;
            for(let s = 0, r = this.stride; s < r; s++)this.array[t + s] = e.array[n + s];
            return this;
        }
        set(t, e = 0) {
            return this.array.set(t, e), this;
        }
        clone(t) {
            t.arrayBuffers === void 0 && (t.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = wn()), t.arrayBuffers[this.array.buffer._uuid] === void 0 && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
            const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]), n = new this.constructor(e, this.stride);
            return n.setUsage(this.usage), n;
        }
        onUpload(t) {
            return this.onUploadCallback = t, this;
        }
        toJSON(t) {
            return t.arrayBuffers === void 0 && (t.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = wn()), t.arrayBuffers[this.array.buffer._uuid] === void 0 && (t.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
                uuid: this.uuid,
                buffer: this.array.buffer._uuid,
                type: this.array.constructor.name,
                stride: this.stride
            };
        }
    }
    const ze = new k;
    class ql {
        constructor(t, e, n, s = !1){
            this.isInterleavedBufferAttribute = !0, this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = s;
        }
        get count() {
            return this.data.count;
        }
        get array() {
            return this.data.array;
        }
        set needsUpdate(t) {
            this.data.needsUpdate = t;
        }
        applyMatrix4(t) {
            for(let e = 0, n = this.data.count; e < n; e++)ze.fromBufferAttribute(this, e), ze.applyMatrix4(t), this.setXYZ(e, ze.x, ze.y, ze.z);
            return this;
        }
        applyNormalMatrix(t) {
            for(let e = 0, n = this.count; e < n; e++)ze.fromBufferAttribute(this, e), ze.applyNormalMatrix(t), this.setXYZ(e, ze.x, ze.y, ze.z);
            return this;
        }
        transformDirection(t) {
            for(let e = 0, n = this.count; e < n; e++)ze.fromBufferAttribute(this, e), ze.transformDirection(t), this.setXYZ(e, ze.x, ze.y, ze.z);
            return this;
        }
        getComponent(t, e) {
            let n = this.array[t * this.data.stride + this.offset + e];
            return this.normalized && (n = Tn(n, this.array)), n;
        }
        setComponent(t, e, n) {
            return this.normalized && (n = oe(n, this.array)), this.data.array[t * this.data.stride + this.offset + e] = n, this;
        }
        setX(t, e) {
            return this.normalized && (e = oe(e, this.array)), this.data.array[t * this.data.stride + this.offset] = e, this;
        }
        setY(t, e) {
            return this.normalized && (e = oe(e, this.array)), this.data.array[t * this.data.stride + this.offset + 1] = e, this;
        }
        setZ(t, e) {
            return this.normalized && (e = oe(e, this.array)), this.data.array[t * this.data.stride + this.offset + 2] = e, this;
        }
        setW(t, e) {
            return this.normalized && (e = oe(e, this.array)), this.data.array[t * this.data.stride + this.offset + 3] = e, this;
        }
        getX(t) {
            let e = this.data.array[t * this.data.stride + this.offset];
            return this.normalized && (e = Tn(e, this.array)), e;
        }
        getY(t) {
            let e = this.data.array[t * this.data.stride + this.offset + 1];
            return this.normalized && (e = Tn(e, this.array)), e;
        }
        getZ(t) {
            let e = this.data.array[t * this.data.stride + this.offset + 2];
            return this.normalized && (e = Tn(e, this.array)), e;
        }
        getW(t) {
            let e = this.data.array[t * this.data.stride + this.offset + 3];
            return this.normalized && (e = Tn(e, this.array)), e;
        }
        setXY(t, e, n) {
            return t = t * this.data.stride + this.offset, this.normalized && (e = oe(e, this.array), n = oe(n, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this;
        }
        setXYZ(t, e, n, s) {
            return t = t * this.data.stride + this.offset, this.normalized && (e = oe(e, this.array), n = oe(n, this.array), s = oe(s, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = s, this;
        }
        setXYZW(t, e, n, s, r) {
            return t = t * this.data.stride + this.offset, this.normalized && (e = oe(e, this.array), n = oe(n, this.array), s = oe(s, this.array), r = oe(r, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = s, this.data.array[t + 3] = r, this;
        }
        clone(t) {
            if (t === void 0) {
                console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
                const e = [];
                for(let n = 0; n < this.count; n++){
                    const s = n * this.data.stride + this.offset;
                    for(let r = 0; r < this.itemSize; r++)e.push(this.data.array[s + r]);
                }
                return new je(new this.array.constructor(e), this.itemSize, this.normalized);
            } else return t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}), t.interleavedBuffers[this.data.uuid] === void 0 && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new ql(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
        }
        toJSON(t) {
            if (t === void 0) {
                console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
                const e = [];
                for(let n = 0; n < this.count; n++){
                    const s = n * this.data.stride + this.offset;
                    for(let r = 0; r < this.itemSize; r++)e.push(this.data.array[s + r]);
                }
                return {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: e,
                    normalized: this.normalized
                };
            } else return t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}), t.interleavedBuffers[this.data.uuid] === void 0 && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            };
        }
    }
    const uu = new k, du = new ne, fu = new ne, ox = new k, pu = new Ht, na = new k, To = new On, mu = new Ht, Eo = new ja;
    class cx extends Le {
        constructor(t, e){
            super(t, e), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = Wh, this.bindMatrix = new Ht, this.bindMatrixInverse = new Ht, this.boundingBox = null, this.boundingSphere = null;
        }
        computeBoundingBox() {
            const t = this.geometry;
            this.boundingBox === null && (this.boundingBox = new Cn), this.boundingBox.makeEmpty();
            const e = t.getAttribute("position");
            for(let n = 0; n < e.count; n++)this.getVertexPosition(n, na), this.boundingBox.expandByPoint(na);
        }
        computeBoundingSphere() {
            const t = this.geometry;
            this.boundingSphere === null && (this.boundingSphere = new On), this.boundingSphere.makeEmpty();
            const e = t.getAttribute("position");
            for(let n = 0; n < e.count; n++)this.getVertexPosition(n, na), this.boundingSphere.expandByPoint(na);
        }
        copy(t, e) {
            return super.copy(t, e), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()), t.boundingSphere !== null && (this.boundingSphere = t.boundingSphere.clone()), this;
        }
        raycast(t, e) {
            const n = this.material, s = this.matrixWorld;
            n !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), To.copy(this.boundingSphere), To.applyMatrix4(s), t.ray.intersectsSphere(To) !== !1 && (mu.copy(s).invert(), Eo.copy(t.ray).applyMatrix4(mu), !(this.boundingBox !== null && Eo.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(t, e, Eo)));
        }
        getVertexPosition(t, e) {
            return super.getVertexPosition(t, e), this.applyBoneTransform(t, e), e;
        }
        bind(t, e) {
            this.skeleton = t, e === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert();
        }
        pose() {
            this.skeleton.pose();
        }
        normalizeSkinWeights() {
            const t = new ne, e = this.geometry.attributes.skinWeight;
            for(let n = 0, s = e.count; n < s; n++){
                t.fromBufferAttribute(e, n);
                const r = 1 / t.manhattanLength();
                r !== 1 / 0 ? t.multiplyScalar(r) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w);
            }
        }
        updateMatrixWorld(t) {
            super.updateMatrixWorld(t), this.bindMode === Wh ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === Q_ ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
        }
        applyBoneTransform(t, e) {
            const n = this.skeleton, s = this.geometry;
            du.fromBufferAttribute(s.attributes.skinIndex, t), fu.fromBufferAttribute(s.attributes.skinWeight, t), uu.copy(e).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
            for(let r = 0; r < 4; r++){
                const a = fu.getComponent(r);
                if (a !== 0) {
                    const o = du.getComponent(r);
                    pu.multiplyMatrices(n.bones[o].matrixWorld, n.boneInverses[o]), e.addScaledVector(ox.copy(uu).applyMatrix4(pu), a);
                }
            }
            return e.applyMatrix4(this.bindMatrixInverse);
        }
    }
    class Wf extends ge {
        constructor(){
            super(), this.isBone = !0, this.type = "Bone";
        }
    }
    class Xf extends tn {
        constructor(t = null, e = 1, n = 1, s, r, a, o, c, l = qe, h = qe, u, d){
            super(null, a, o, c, l, h, s, r, u, d), this.isDataTexture = !0, this.image = {
                data: t,
                width: e,
                height: n
            }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
        }
    }
    const _u = new Ht, lx = new Ht;
    class jl {
        constructor(t = [], e = []){
            this.uuid = wn(), this.bones = t.slice(0), this.boneInverses = e, this.boneMatrices = null, this.boneTexture = null, this.init();
        }
        init() {
            const t = this.bones, e = this.boneInverses;
            if (this.boneMatrices = new Float32Array(t.length * 16), e.length === 0) this.calculateInverses();
            else if (t.length !== e.length) {
                console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
                for(let n = 0, s = this.bones.length; n < s; n++)this.boneInverses.push(new Ht);
            }
        }
        calculateInverses() {
            this.boneInverses.length = 0;
            for(let t = 0, e = this.bones.length; t < e; t++){
                const n = new Ht;
                this.bones[t] && n.copy(this.bones[t].matrixWorld).invert(), this.boneInverses.push(n);
            }
        }
        pose() {
            for(let t = 0, e = this.bones.length; t < e; t++){
                const n = this.bones[t];
                n && n.matrixWorld.copy(this.boneInverses[t]).invert();
            }
            for(let t = 0, e = this.bones.length; t < e; t++){
                const n = this.bones[t];
                n && (n.parent && n.parent.isBone ? (n.matrix.copy(n.parent.matrixWorld).invert(), n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld), n.matrix.decompose(n.position, n.quaternion, n.scale));
            }
        }
        update() {
            const t = this.bones, e = this.boneInverses, n = this.boneMatrices, s = this.boneTexture;
            for(let r = 0, a = t.length; r < a; r++){
                const o = t[r] ? t[r].matrixWorld : lx;
                _u.multiplyMatrices(o, e[r]), _u.toArray(n, r * 16);
            }
            s !== null && (s.needsUpdate = !0);
        }
        clone() {
            return new jl(this.bones, this.boneInverses);
        }
        computeBoneTexture() {
            let t = Math.sqrt(this.bones.length * 4);
            t = Math.ceil(t / 4) * 4, t = Math.max(t, 4);
            const e = new Float32Array(t * t * 4);
            e.set(this.boneMatrices);
            const n = new Xf(e, t, t, fn, An);
            return n.needsUpdate = !0, this.boneMatrices = e, this.boneTexture = n, this;
        }
        getBoneByName(t) {
            for(let e = 0, n = this.bones.length; e < n; e++){
                const s = this.bones[e];
                if (s.name === t) return s;
            }
        }
        dispose() {
            this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
        }
        fromJSON(t, e) {
            this.uuid = t.uuid;
            for(let n = 0, s = t.bones.length; n < s; n++){
                const r = t.bones[n];
                let a = e[r];
                a === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", r), a = new Wf), this.bones.push(a), this.boneInverses.push(new Ht().fromArray(t.boneInverses[n]));
            }
            return this.init(), this;
        }
        toJSON() {
            const t = {
                metadata: {
                    version: 4.6,
                    type: "Skeleton",
                    generator: "Skeleton.toJSON"
                },
                bones: [],
                boneInverses: []
            };
            t.uuid = this.uuid;
            const e = this.bones, n = this.boneInverses;
            for(let s = 0, r = e.length; s < r; s++){
                const a = e[s];
                t.bones.push(a.uuid);
                const o = n[s];
                t.boneInverses.push(o.toArray());
            }
            return t;
        }
    }
    class al extends je {
        constructor(t, e, n, s = 1){
            super(t, e, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = s;
        }
        copy(t) {
            return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this;
        }
        toJSON() {
            const t = super.toJSON();
            return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t;
        }
    }
    const fs = new Ht, gu = new Ht, ia = [], xu = new Cn, hx = new Ht, Qs = new Le, tr = new On;
    class ux extends Le {
        constructor(t, e, n){
            super(t, e), this.isInstancedMesh = !0, this.instanceMatrix = new al(new Float32Array(n * 16), 16), this.instanceColor = null, this.morphTexture = null, this.count = n, this.boundingBox = null, this.boundingSphere = null;
            for(let s = 0; s < n; s++)this.setMatrixAt(s, hx);
        }
        computeBoundingBox() {
            const t = this.geometry, e = this.count;
            this.boundingBox === null && (this.boundingBox = new Cn), t.boundingBox === null && t.computeBoundingBox(), this.boundingBox.makeEmpty();
            for(let n = 0; n < e; n++)this.getMatrixAt(n, fs), xu.copy(t.boundingBox).applyMatrix4(fs), this.boundingBox.union(xu);
        }
        computeBoundingSphere() {
            const t = this.geometry, e = this.count;
            this.boundingSphere === null && (this.boundingSphere = new On), t.boundingSphere === null && t.computeBoundingSphere(), this.boundingSphere.makeEmpty();
            for(let n = 0; n < e; n++)this.getMatrixAt(n, fs), tr.copy(t.boundingSphere).applyMatrix4(fs), this.boundingSphere.union(tr);
        }
        copy(t, e) {
            return super.copy(t, e), this.instanceMatrix.copy(t.instanceMatrix), t.morphTexture !== null && (this.morphTexture = t.morphTexture.clone()), t.instanceColor !== null && (this.instanceColor = t.instanceColor.clone()), this.count = t.count, t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()), t.boundingSphere !== null && (this.boundingSphere = t.boundingSphere.clone()), this;
        }
        getColorAt(t, e) {
            e.fromArray(this.instanceColor.array, t * 3);
        }
        getMatrixAt(t, e) {
            e.fromArray(this.instanceMatrix.array, t * 16);
        }
        getMorphAt(t, e) {
            const n = e.morphTargetInfluences, s = this.morphTexture.source.data.data, r = n.length + 1, a = t * r + 1;
            for(let o = 0; o < n.length; o++)n[o] = s[a + o];
        }
        raycast(t, e) {
            const n = this.matrixWorld, s = this.count;
            if (Qs.geometry = this.geometry, Qs.material = this.material, Qs.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), tr.copy(this.boundingSphere), tr.applyMatrix4(n), t.ray.intersectsSphere(tr) !== !1)) for(let r = 0; r < s; r++){
                this.getMatrixAt(r, fs), gu.multiplyMatrices(n, fs), Qs.matrixWorld = gu, Qs.raycast(t, ia);
                for(let a = 0, o = ia.length; a < o; a++){
                    const c = ia[a];
                    c.instanceId = r, c.object = this, e.push(c);
                }
                ia.length = 0;
            }
        }
        setColorAt(t, e) {
            this.instanceColor === null && (this.instanceColor = new al(new Float32Array(this.instanceMatrix.count * 3).fill(1), 3)), e.toArray(this.instanceColor.array, t * 3);
        }
        setMatrixAt(t, e) {
            e.toArray(this.instanceMatrix.array, t * 16);
        }
        setMorphAt(t, e) {
            const n = e.morphTargetInfluences, s = n.length + 1;
            this.morphTexture === null && (this.morphTexture = new Xf(new Float32Array(s * this.count), s, this.count, Gl, An));
            const r = this.morphTexture.source.data.data;
            let a = 0;
            for(let l = 0; l < n.length; l++)a += n[l];
            const o = this.geometry.morphTargetsRelative ? 1 : 1 - a, c = s * t;
            r[c] = o, r.set(n, c + 1);
        }
        updateMorphTargets() {}
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            }), this.morphTexture !== null && (this.morphTexture.dispose(), this.morphTexture = null);
        }
    }
    const Ao = new k, dx = new k, fx = new Gt;
    class Ii {
        constructor(t = new k(1, 0, 0), e = 0){
            this.isPlane = !0, this.normal = t, this.constant = e;
        }
        set(t, e) {
            return this.normal.copy(t), this.constant = e, this;
        }
        setComponents(t, e, n, s) {
            return this.normal.set(t, e, n), this.constant = s, this;
        }
        setFromNormalAndCoplanarPoint(t, e) {
            return this.normal.copy(t), this.constant = -e.dot(this.normal), this;
        }
        setFromCoplanarPoints(t, e, n) {
            const s = Ao.subVectors(n, e).cross(dx.subVectors(t, e)).normalize();
            return this.setFromNormalAndCoplanarPoint(s, t), this;
        }
        copy(t) {
            return this.normal.copy(t.normal), this.constant = t.constant, this;
        }
        normalize() {
            const t = 1 / this.normal.length();
            return this.normal.multiplyScalar(t), this.constant *= t, this;
        }
        negate() {
            return this.constant *= -1, this.normal.negate(), this;
        }
        distanceToPoint(t) {
            return this.normal.dot(t) + this.constant;
        }
        distanceToSphere(t) {
            return this.distanceToPoint(t.center) - t.radius;
        }
        projectPoint(t, e) {
            return e.copy(t).addScaledVector(this.normal, -this.distanceToPoint(t));
        }
        intersectLine(t, e) {
            const n = t.delta(Ao), s = this.normal.dot(n);
            if (s === 0) return this.distanceToPoint(t.start) === 0 ? e.copy(t.start) : null;
            const r = -(t.start.dot(this.normal) + this.constant) / s;
            return r < 0 || r > 1 ? null : e.copy(t.start).addScaledVector(n, r);
        }
        intersectsLine(t) {
            const e = this.distanceToPoint(t.start), n = this.distanceToPoint(t.end);
            return e < 0 && n > 0 || n < 0 && e > 0;
        }
        intersectsBox(t) {
            return t.intersectsPlane(this);
        }
        intersectsSphere(t) {
            return t.intersectsPlane(this);
        }
        coplanarPoint(t) {
            return t.copy(this.normal).multiplyScalar(-this.constant);
        }
        applyMatrix4(t, e) {
            const n = e || fx.getNormalMatrix(t), s = this.coplanarPoint(Ao).applyMatrix4(t), r = this.normal.applyMatrix3(n).normalize();
            return this.constant = -s.dot(r), this;
        }
        translate(t) {
            return this.constant -= t.dot(this.normal), this;
        }
        equals(t) {
            return t.normal.equals(this.normal) && t.constant === this.constant;
        }
        clone() {
            return new this.constructor().copy(this);
        }
    }
    const Ai = new On, sa = new k;
    class $l {
        constructor(t = new Ii, e = new Ii, n = new Ii, s = new Ii, r = new Ii, a = new Ii){
            this.planes = [
                t,
                e,
                n,
                s,
                r,
                a
            ];
        }
        set(t, e, n, s, r, a) {
            const o = this.planes;
            return o[0].copy(t), o[1].copy(e), o[2].copy(n), o[3].copy(s), o[4].copy(r), o[5].copy(a), this;
        }
        copy(t) {
            const e = this.planes;
            for(let n = 0; n < 6; n++)e[n].copy(t.planes[n]);
            return this;
        }
        setFromProjectionMatrix(t, e = Jn) {
            const n = this.planes, s = t.elements, r = s[0], a = s[1], o = s[2], c = s[3], l = s[4], h = s[5], u = s[6], d = s[7], f = s[8], _ = s[9], g = s[10], p = s[11], m = s[12], x = s[13], y = s[14], v = s[15];
            if (n[0].setComponents(c - r, d - l, p - f, v - m).normalize(), n[1].setComponents(c + r, d + l, p + f, v + m).normalize(), n[2].setComponents(c + a, d + h, p + _, v + x).normalize(), n[3].setComponents(c - a, d - h, p - _, v - x).normalize(), n[4].setComponents(c - o, d - u, p - g, v - y).normalize(), e === Jn) n[5].setComponents(c + o, d + u, p + g, v + y).normalize();
            else if (e === ka) n[5].setComponents(o, u, g, y).normalize();
            else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + e);
            return this;
        }
        intersectsObject(t) {
            if (t.boundingSphere !== void 0) t.boundingSphere === null && t.computeBoundingSphere(), Ai.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);
            else {
                const e = t.geometry;
                e.boundingSphere === null && e.computeBoundingSphere(), Ai.copy(e.boundingSphere).applyMatrix4(t.matrixWorld);
            }
            return this.intersectsSphere(Ai);
        }
        intersectsSprite(t) {
            return Ai.center.set(0, 0, 0), Ai.radius = .7071067811865476, Ai.applyMatrix4(t.matrixWorld), this.intersectsSphere(Ai);
        }
        intersectsSphere(t) {
            const e = this.planes, n = t.center, s = -t.radius;
            for(let r = 0; r < 6; r++)if (e[r].distanceToPoint(n) < s) return !1;
            return !0;
        }
        intersectsBox(t) {
            const e = this.planes;
            for(let n = 0; n < 6; n++){
                const s = e[n];
                if (sa.x = s.normal.x > 0 ? t.max.x : t.min.x, sa.y = s.normal.y > 0 ? t.max.y : t.min.y, sa.z = s.normal.z > 0 ? t.max.z : t.min.z, s.distanceToPoint(sa) < 0) return !1;
            }
            return !0;
        }
        containsPoint(t) {
            const e = this.planes;
            for(let n = 0; n < 6; n++)if (e[n].distanceToPoint(t) < 0) return !1;
            return !0;
        }
        clone() {
            return new this.constructor().copy(this);
        }
    }
    class Yf extends Bn {
        constructor(t){
            super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new Bt(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(t);
        }
        copy(t) {
            return super.copy(t), this.color.copy(t.color), this.map = t.map, this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.fog = t.fog, this;
        }
    }
    const Ga = new k, Ha = new k, vu = new Ht, er = new ja, ra = new On, wo = new k, yu = new k;
    class Kl extends ge {
        constructor(t = new kn, e = new Yf){
            super(), this.isLine = !0, this.type = "Line", this.geometry = t, this.material = e, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets();
        }
        copy(t, e) {
            return super.copy(t, e), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this;
        }
        computeLineDistances() {
            const t = this.geometry;
            if (t.index === null) {
                const e = t.attributes.position, n = [
                    0
                ];
                for(let s = 1, r = e.count; s < r; s++)Ga.fromBufferAttribute(e, s - 1), Ha.fromBufferAttribute(e, s), n[s] = n[s - 1], n[s] += Ga.distanceTo(Ha);
                t.setAttribute("lineDistance", new ti(n, 1));
            } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            return this;
        }
        raycast(t, e) {
            const n = this.geometry, s = this.matrixWorld, r = t.params.Line.threshold, a = n.drawRange;
            if (n.boundingSphere === null && n.computeBoundingSphere(), ra.copy(n.boundingSphere), ra.applyMatrix4(s), ra.radius += r, t.ray.intersectsSphere(ra) === !1) return;
            vu.copy(s).invert(), er.copy(t.ray).applyMatrix4(vu);
            const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), c = o * o, l = this.isLineSegments ? 2 : 1, h = n.index, d = n.attributes.position;
            if (h !== null) {
                const f = Math.max(0, a.start), _ = Math.min(h.count, a.start + a.count);
                for(let g = f, p = _ - 1; g < p; g += l){
                    const m = h.getX(g), x = h.getX(g + 1), y = aa(this, t, er, c, m, x, g);
                    y && e.push(y);
                }
                if (this.isLineLoop) {
                    const g = h.getX(_ - 1), p = h.getX(f), m = aa(this, t, er, c, g, p, _ - 1);
                    m && e.push(m);
                }
            } else {
                const f = Math.max(0, a.start), _ = Math.min(d.count, a.start + a.count);
                for(let g = f, p = _ - 1; g < p; g += l){
                    const m = aa(this, t, er, c, g, g + 1, g);
                    m && e.push(m);
                }
                if (this.isLineLoop) {
                    const g = aa(this, t, er, c, _ - 1, f, _ - 1);
                    g && e.push(g);
                }
            }
        }
        updateMorphTargets() {
            const e = this.geometry.morphAttributes, n = Object.keys(e);
            if (n.length > 0) {
                const s = e[n[0]];
                if (s !== void 0) {
                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                    for(let r = 0, a = s.length; r < a; r++){
                        const o = s[r].name || String(r);
                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = r;
                    }
                }
            }
        }
    }
    function aa(i, t, e, n, s, r, a) {
        const o = i.geometry.attributes.position;
        if (Ga.fromBufferAttribute(o, s), Ha.fromBufferAttribute(o, r), e.distanceSqToSegment(Ga, Ha, wo, yu) > n) return;
        wo.applyMatrix4(i.matrixWorld);
        const l = t.ray.origin.distanceTo(wo);
        if (!(l < t.near || l > t.far)) return {
            distance: l,
            point: yu.clone().applyMatrix4(i.matrixWorld),
            index: a,
            face: null,
            faceIndex: null,
            barycoord: null,
            object: i
        };
    }
    const bu = new k, Su = new k;
    class px extends Kl {
        constructor(t, e){
            super(t, e), this.isLineSegments = !0, this.type = "LineSegments";
        }
        computeLineDistances() {
            const t = this.geometry;
            if (t.index === null) {
                const e = t.attributes.position, n = [];
                for(let s = 0, r = e.count; s < r; s += 2)bu.fromBufferAttribute(e, s), Su.fromBufferAttribute(e, s + 1), n[s] = s === 0 ? 0 : n[s - 1], n[s + 1] = n[s] + bu.distanceTo(Su);
                t.setAttribute("lineDistance", new ti(n, 1));
            } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            return this;
        }
    }
    class mx extends Kl {
        constructor(t, e){
            super(t, e), this.isLineLoop = !0, this.type = "LineLoop";
        }
    }
    class qf extends Bn {
        constructor(t){
            super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new Bt(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(t);
        }
        copy(t) {
            return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.fog = t.fog, this;
        }
    }
    const Mu = new Ht, ol = new ja, oa = new On, ca = new k;
    class _x extends ge {
        constructor(t = new kn, e = new qf){
            super(), this.isPoints = !0, this.type = "Points", this.geometry = t, this.material = e, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets();
        }
        copy(t, e) {
            return super.copy(t, e), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this;
        }
        raycast(t, e) {
            const n = this.geometry, s = this.matrixWorld, r = t.params.Points.threshold, a = n.drawRange;
            if (n.boundingSphere === null && n.computeBoundingSphere(), oa.copy(n.boundingSphere), oa.applyMatrix4(s), oa.radius += r, t.ray.intersectsSphere(oa) === !1) return;
            Mu.copy(s).invert(), ol.copy(t.ray).applyMatrix4(Mu);
            const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), c = o * o, l = n.index, u = n.attributes.position;
            if (l !== null) {
                const d = Math.max(0, a.start), f = Math.min(l.count, a.start + a.count);
                for(let _ = d, g = f; _ < g; _++){
                    const p = l.getX(_);
                    ca.fromBufferAttribute(u, p), Tu(ca, p, c, s, t, e, this);
                }
            } else {
                const d = Math.max(0, a.start), f = Math.min(u.count, a.start + a.count);
                for(let _ = d, g = f; _ < g; _++)ca.fromBufferAttribute(u, _), Tu(ca, _, c, s, t, e, this);
            }
        }
        updateMorphTargets() {
            const e = this.geometry.morphAttributes, n = Object.keys(e);
            if (n.length > 0) {
                const s = e[n[0]];
                if (s !== void 0) {
                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                    for(let r = 0, a = s.length; r < a; r++){
                        const o = s[r].name || String(r);
                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = r;
                    }
                }
            }
        }
    }
    function Tu(i, t, e, n, s, r, a) {
        const o = ol.distanceSqToPoint(i);
        if (o < e) {
            const c = new k;
            ol.closestPointToPoint(i, c), c.applyMatrix4(n);
            const l = s.ray.origin.distanceTo(c);
            if (l < s.near || l > s.far) return;
            r.push({
                distance: l,
                distanceToRay: Math.sqrt(o),
                point: c,
                index: t,
                face: null,
                faceIndex: null,
                barycoord: null,
                object: a
            });
        }
    }
    class jf extends tn {
        constructor(t, e, n = Vi, s, r, a, o = qe, c = qe, l, h = Ar){
            if (h !== Ar && h !== wr) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
            super(null, s, r, a, o, c, h, n, l), this.isDepthTexture = !0, this.image = {
                width: t,
                height: e
            }, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
        }
        copy(t) {
            return super.copy(t), this.source = new Yl(Object.assign({}, t.image)), this.compareFunction = t.compareFunction, this;
        }
        toJSON(t) {
            const e = super.toJSON(t);
            return this.compareFunction !== null && (e.compareFunction = this.compareFunction), e;
        }
    }
    class zs extends kn {
        constructor(t = 1, e = 1, n = 1, s = 1){
            super(), this.type = "PlaneGeometry", this.parameters = {
                width: t,
                height: e,
                widthSegments: n,
                heightSegments: s
            };
            const r = t / 2, a = e / 2, o = Math.floor(n), c = Math.floor(s), l = o + 1, h = c + 1, u = t / o, d = e / c, f = [], _ = [], g = [], p = [];
            for(let m = 0; m < h; m++){
                const x = m * d - a;
                for(let y = 0; y < l; y++){
                    const v = y * u - r;
                    _.push(v, -x, 0), g.push(0, 0, 1), p.push(y / o), p.push(1 - m / c);
                }
            }
            for(let m = 0; m < c; m++)for(let x = 0; x < o; x++){
                const y = x + l * m, v = x + l * (m + 1), I = x + 1 + l * (m + 1), w = x + 1 + l * m;
                f.push(y, v, w), f.push(v, I, w);
            }
            this.setIndex(f), this.setAttribute("position", new ti(_, 3)), this.setAttribute("normal", new ti(g, 3)), this.setAttribute("uv", new ti(p, 2));
        }
        copy(t) {
            return super.copy(t), this.parameters = Object.assign({}, t.parameters), this;
        }
        static fromJSON(t) {
            return new zs(t.width, t.height, t.widthSegments, t.heightSegments);
        }
    }
    class Us extends Bn {
        constructor(t){
            super(), this.isMeshStandardMaterial = !0, this.type = "MeshStandardMaterial", this.defines = {
                STANDARD: ""
            }, this.color = new Bt(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Bt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Lf, this.normalScale = new Kt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Fn, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(t);
        }
        copy(t) {
            return super.copy(t), this.defines = {
                STANDARD: ""
            }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.envMapIntensity = t.envMapIntensity, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this;
        }
    }
    class Gn extends Us {
        constructor(t){
            super(), this.isMeshPhysicalMaterial = !0, this.defines = {
                STANDARD: "",
                PHYSICAL: ""
            }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Kt(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
                get: function() {
                    return Yt(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
                },
                set: function(e) {
                    this.ior = (1 + .4 * e) / (1 - .4 * e);
                }
            }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [
                100,
                400
            ], this.iridescenceThicknessMap = null, this.sheenColor = new Bt(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Bt(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Bt(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(t);
        }
        get anisotropy() {
            return this._anisotropy;
        }
        set anisotropy(t) {
            this._anisotropy > 0 != t > 0 && this.version++, this._anisotropy = t;
        }
        get clearcoat() {
            return this._clearcoat;
        }
        set clearcoat(t) {
            this._clearcoat > 0 != t > 0 && this.version++, this._clearcoat = t;
        }
        get iridescence() {
            return this._iridescence;
        }
        set iridescence(t) {
            this._iridescence > 0 != t > 0 && this.version++, this._iridescence = t;
        }
        get dispersion() {
            return this._dispersion;
        }
        set dispersion(t) {
            this._dispersion > 0 != t > 0 && this.version++, this._dispersion = t;
        }
        get sheen() {
            return this._sheen;
        }
        set sheen(t) {
            this._sheen > 0 != t > 0 && this.version++, this._sheen = t;
        }
        get transmission() {
            return this._transmission;
        }
        set transmission(t) {
            this._transmission > 0 != t > 0 && this.version++, this._transmission = t;
        }
        copy(t) {
            return super.copy(t), this.defines = {
                STANDARD: "",
                PHYSICAL: ""
            }, this.anisotropy = t.anisotropy, this.anisotropyRotation = t.anisotropyRotation, this.anisotropyMap = t.anisotropyMap, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.dispersion = t.dispersion, this.ior = t.ior, this.iridescence = t.iridescence, this.iridescenceMap = t.iridescenceMap, this.iridescenceIOR = t.iridescenceIOR, this.iridescenceThicknessRange = [
                ...t.iridescenceThicknessRange
            ], this.iridescenceThicknessMap = t.iridescenceThicknessMap, this.sheen = t.sheen, this.sheenColor.copy(t.sheenColor), this.sheenColorMap = t.sheenColorMap, this.sheenRoughness = t.sheenRoughness, this.sheenRoughnessMap = t.sheenRoughnessMap, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this.thickness = t.thickness, this.thicknessMap = t.thicknessMap, this.attenuationDistance = t.attenuationDistance, this.attenuationColor.copy(t.attenuationColor), this.specularIntensity = t.specularIntensity, this.specularIntensityMap = t.specularIntensityMap, this.specularColor.copy(t.specularColor), this.specularColorMap = t.specularColorMap, this;
        }
    }
    class gx extends Bn {
        constructor(t){
            super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = sg, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(t);
        }
        copy(t) {
            return super.copy(t), this.depthPacking = t.depthPacking, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this;
        }
    }
    class xx extends Bn {
        constructor(t){
            super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(t);
        }
        copy(t) {
            return super.copy(t), this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this;
        }
    }
    function la(i, t) {
        return !i || i.constructor === t ? i : typeof t.BYTES_PER_ELEMENT == "number" ? new t(i) : Array.prototype.slice.call(i);
    }
    function vx(i) {
        return ArrayBuffer.isView(i) && !(i instanceof DataView);
    }
    function yx(i) {
        function t(s, r) {
            return i[s] - i[r];
        }
        const e = i.length, n = new Array(e);
        for(let s = 0; s !== e; ++s)n[s] = s;
        return n.sort(t), n;
    }
    function Eu(i, t, e) {
        const n = i.length, s = new i.constructor(n);
        for(let r = 0, a = 0; a !== n; ++r){
            const o = e[r] * t;
            for(let c = 0; c !== t; ++c)s[a++] = i[o + c];
        }
        return s;
    }
    function $f(i, t, e, n) {
        let s = 1, r = i[0];
        for(; r !== void 0 && r[n] === void 0;)r = i[s++];
        if (r === void 0) return;
        let a = r[n];
        if (a !== void 0) if (Array.isArray(a)) do a = r[n], a !== void 0 && (t.push(r.time), e.push(...a)), r = i[s++];
        while (r !== void 0);
        else if (a.toArray !== void 0) do a = r[n], a !== void 0 && (t.push(r.time), a.toArray(e, e.length)), r = i[s++];
        while (r !== void 0);
        else do a = r[n], a !== void 0 && (t.push(r.time), e.push(a)), r = i[s++];
        while (r !== void 0);
    }
    class Nr {
        constructor(t, e, n, s){
            this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = s !== void 0 ? s : new e.constructor(n), this.sampleValues = e, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {};
        }
        evaluate(t) {
            const e = this.parameterPositions;
            let n = this._cachedIndex, s = e[n], r = e[n - 1];
            t: {
                e: {
                    let a;
                    n: {
                        i: if (!(t < s)) {
                            for(let o = n + 2;;){
                                if (s === void 0) {
                                    if (t < r) break i;
                                    return n = e.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
                                }
                                if (n === o) break;
                                if (r = s, s = e[++n], t < s) break e;
                            }
                            a = e.length;
                            break n;
                        }
                        if (!(t >= r)) {
                            const o = e[1];
                            t < o && (n = 2, r = o);
                            for(let c = n - 2;;){
                                if (r === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
                                if (n === c) break;
                                if (s = r, r = e[--n - 1], t >= r) break e;
                            }
                            a = n, n = 0;
                            break n;
                        }
                        break t;
                    }
                    for(; n < a;){
                        const o = n + a >>> 1;
                        t < e[o] ? a = o : n = o + 1;
                    }
                    if (s = e[n], r = e[n - 1], r === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
                    if (s === void 0) return n = e.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
                }
                this._cachedIndex = n, this.intervalChanged_(n, r, s);
            }
            return this.interpolate_(n, r, t, s);
        }
        getSettings_() {
            return this.settings || this.DefaultSettings_;
        }
        copySampleValue_(t) {
            const e = this.resultBuffer, n = this.sampleValues, s = this.valueSize, r = t * s;
            for(let a = 0; a !== s; ++a)e[a] = n[r + a];
            return e;
        }
        interpolate_() {
            throw new Error("call to abstract method");
        }
        intervalChanged_() {}
    }
    class bx extends Nr {
        constructor(t, e, n, s){
            super(t, e, n, s), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
                endingStart: ys,
                endingEnd: ys
            };
        }
        intervalChanged_(t, e, n) {
            const s = this.parameterPositions;
            let r = t - 2, a = t + 1, o = s[r], c = s[a];
            if (o === void 0) switch(this.getSettings_().endingStart){
                case bs:
                    r = t, o = 2 * e - n;
                    break;
                case Fa:
                    r = s.length - 2, o = e + s[r] - s[r + 1];
                    break;
                default:
                    r = t, o = n;
            }
            if (c === void 0) switch(this.getSettings_().endingEnd){
                case bs:
                    a = t, c = 2 * n - e;
                    break;
                case Fa:
                    a = 1, c = n + s[1] - s[0];
                    break;
                default:
                    a = t - 1, c = e;
            }
            const l = (n - e) * .5, h = this.valueSize;
            this._weightPrev = l / (e - o), this._weightNext = l / (c - n), this._offsetPrev = r * h, this._offsetNext = a * h;
        }
        interpolate_(t, e, n, s) {
            const r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, c = t * o, l = c - o, h = this._offsetPrev, u = this._offsetNext, d = this._weightPrev, f = this._weightNext, _ = (n - e) / (s - e), g = _ * _, p = g * _, m = -d * p + 2 * d * g - d * _, x = (1 + d) * p + (-1.5 - 2 * d) * g + (-.5 + d) * _ + 1, y = (-1 - f) * p + (1.5 + f) * g + .5 * _, v = f * p - f * g;
            for(let I = 0; I !== o; ++I)r[I] = m * a[h + I] + x * a[l + I] + y * a[c + I] + v * a[u + I];
            return r;
        }
    }
    class Kf extends Nr {
        constructor(t, e, n, s){
            super(t, e, n, s);
        }
        interpolate_(t, e, n, s) {
            const r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, c = t * o, l = c - o, h = (n - e) / (s - e), u = 1 - h;
            for(let d = 0; d !== o; ++d)r[d] = a[l + d] * u + a[c + d] * h;
            return r;
        }
    }
    class Sx extends Nr {
        constructor(t, e, n, s){
            super(t, e, n, s);
        }
        interpolate_(t) {
            return this.copySampleValue_(t - 1);
        }
    }
    class Pn {
        constructor(t, e, n, s){
            if (t === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
            if (e === void 0 || e.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
            this.name = t, this.times = la(e, this.TimeBufferType), this.values = la(n, this.ValueBufferType), this.setInterpolation(s || this.DefaultInterpolation);
        }
        static toJSON(t) {
            const e = t.constructor;
            let n;
            if (e.toJSON !== this.toJSON) n = e.toJSON(t);
            else {
                n = {
                    name: t.name,
                    times: la(t.times, Array),
                    values: la(t.values, Array)
                };
                const s = t.getInterpolation();
                s !== t.DefaultInterpolation && (n.interpolation = s);
            }
            return n.type = t.ValueTypeName, n;
        }
        InterpolantFactoryMethodDiscrete(t) {
            return new Sx(this.times, this.values, this.getValueSize(), t);
        }
        InterpolantFactoryMethodLinear(t) {
            return new Kf(this.times, this.values, this.getValueSize(), t);
        }
        InterpolantFactoryMethodSmooth(t) {
            return new bx(this.times, this.values, this.getValueSize(), t);
        }
        setInterpolation(t) {
            let e;
            switch(t){
                case Rr:
                    e = this.InterpolantFactoryMethodDiscrete;
                    break;
                case Cr:
                    e = this.InterpolantFactoryMethodLinear;
                    break;
                case no:
                    e = this.InterpolantFactoryMethodSmooth;
                    break;
            }
            if (e === void 0) {
                const n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                if (this.createInterpolant === void 0) if (t !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
                else throw new Error(n);
                return console.warn("THREE.KeyframeTrack:", n), this;
            }
            return this.createInterpolant = e, this;
        }
        getInterpolation() {
            switch(this.createInterpolant){
                case this.InterpolantFactoryMethodDiscrete:
                    return Rr;
                case this.InterpolantFactoryMethodLinear:
                    return Cr;
                case this.InterpolantFactoryMethodSmooth:
                    return no;
            }
        }
        getValueSize() {
            return this.values.length / this.times.length;
        }
        shift(t) {
            if (t !== 0) {
                const e = this.times;
                for(let n = 0, s = e.length; n !== s; ++n)e[n] += t;
            }
            return this;
        }
        scale(t) {
            if (t !== 1) {
                const e = this.times;
                for(let n = 0, s = e.length; n !== s; ++n)e[n] *= t;
            }
            return this;
        }
        trim(t, e) {
            const n = this.times, s = n.length;
            let r = 0, a = s - 1;
            for(; r !== s && n[r] < t;)++r;
            for(; a !== -1 && n[a] > e;)--a;
            if (++a, r !== 0 || a !== s) {
                r >= a && (a = Math.max(a, 1), r = a - 1);
                const o = this.getValueSize();
                this.times = n.slice(r, a), this.values = this.values.slice(r * o, a * o);
            }
            return this;
        }
        validate() {
            let t = !0;
            const e = this.getValueSize();
            e - Math.floor(e) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
            const n = this.times, s = this.values, r = n.length;
            r === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
            let a = null;
            for(let o = 0; o !== r; o++){
                const c = n[o];
                if (typeof c == "number" && isNaN(c)) {
                    console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, c), t = !1;
                    break;
                }
                if (a !== null && a > c) {
                    console.error("THREE.KeyframeTrack: Out of order keys.", this, o, c, a), t = !1;
                    break;
                }
                a = c;
            }
            if (s !== void 0 && vx(s)) for(let o = 0, c = s.length; o !== c; ++o){
                const l = s[o];
                if (isNaN(l)) {
                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, l), t = !1;
                    break;
                }
            }
            return t;
        }
        optimize() {
            const t = this.times.slice(), e = this.values.slice(), n = this.getValueSize(), s = this.getInterpolation() === no, r = t.length - 1;
            let a = 1;
            for(let o = 1; o < r; ++o){
                let c = !1;
                const l = t[o], h = t[o + 1];
                if (l !== h && (o !== 1 || l !== t[0])) if (s) c = !0;
                else {
                    const u = o * n, d = u - n, f = u + n;
                    for(let _ = 0; _ !== n; ++_){
                        const g = e[u + _];
                        if (g !== e[d + _] || g !== e[f + _]) {
                            c = !0;
                            break;
                        }
                    }
                }
                if (c) {
                    if (o !== a) {
                        t[a] = t[o];
                        const u = o * n, d = a * n;
                        for(let f = 0; f !== n; ++f)e[d + f] = e[u + f];
                    }
                    ++a;
                }
            }
            if (r > 0) {
                t[a] = t[r];
                for(let o = r * n, c = a * n, l = 0; l !== n; ++l)e[c + l] = e[o + l];
                ++a;
            }
            return a !== t.length ? (this.times = t.slice(0, a), this.values = e.slice(0, a * n)) : (this.times = t, this.values = e), this;
        }
        clone() {
            const t = this.times.slice(), e = this.values.slice(), n = this.constructor, s = new n(this.name, t, e);
            return s.createInterpolant = this.createInterpolant, s;
        }
    }
    Pn.prototype.ValueTypeName = "";
    Pn.prototype.TimeBufferType = Float32Array;
    Pn.prototype.ValueBufferType = Float32Array;
    Pn.prototype.DefaultInterpolation = Cr;
    class Vs extends Pn {
        constructor(t, e, n){
            super(t, e, n);
        }
    }
    Vs.prototype.ValueTypeName = "bool";
    Vs.prototype.ValueBufferType = Array;
    Vs.prototype.DefaultInterpolation = Rr;
    Vs.prototype.InterpolantFactoryMethodLinear = void 0;
    Vs.prototype.InterpolantFactoryMethodSmooth = void 0;
    class Zf extends Pn {
        constructor(t, e, n, s){
            super(t, e, n, s);
        }
    }
    Zf.prototype.ValueTypeName = "color";
    class Ns extends Pn {
        constructor(t, e, n, s){
            super(t, e, n, s);
        }
    }
    Ns.prototype.ValueTypeName = "number";
    class Mx extends Nr {
        constructor(t, e, n, s){
            super(t, e, n, s);
        }
        interpolate_(t, e, n, s) {
            const r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, c = (n - e) / (s - e);
            let l = t * o;
            for(let h = l + o; l !== h; l += 4)Rn.slerpFlat(r, 0, a, l - o, a, l, c);
            return r;
        }
    }
    class Bs extends Pn {
        constructor(t, e, n, s){
            super(t, e, n, s);
        }
        InterpolantFactoryMethodLinear(t) {
            return new Mx(this.times, this.values, this.getValueSize(), t);
        }
    }
    Bs.prototype.ValueTypeName = "quaternion";
    Bs.prototype.InterpolantFactoryMethodSmooth = void 0;
    class Ws extends Pn {
        constructor(t, e, n){
            super(t, e, n);
        }
    }
    Ws.prototype.ValueTypeName = "string";
    Ws.prototype.ValueBufferType = Array;
    Ws.prototype.DefaultInterpolation = Rr;
    Ws.prototype.InterpolantFactoryMethodLinear = void 0;
    Ws.prototype.InterpolantFactoryMethodSmooth = void 0;
    class Fs extends Pn {
        constructor(t, e, n, s){
            super(t, e, n, s);
        }
    }
    Fs.prototype.ValueTypeName = "vector";
    class cl {
        constructor(t = "", e = -1, n = [], s = Wl){
            this.name = t, this.tracks = n, this.duration = e, this.blendMode = s, this.uuid = wn(), this.duration < 0 && this.resetDuration();
        }
        static parse(t) {
            const e = [], n = t.tracks, s = 1 / (t.fps || 1);
            for(let a = 0, o = n.length; a !== o; ++a)e.push(Ex(n[a]).scale(s));
            const r = new this(t.name, t.duration, e, t.blendMode);
            return r.uuid = t.uuid, r;
        }
        static toJSON(t) {
            const e = [], n = t.tracks, s = {
                name: t.name,
                duration: t.duration,
                tracks: e,
                uuid: t.uuid,
                blendMode: t.blendMode
            };
            for(let r = 0, a = n.length; r !== a; ++r)e.push(Pn.toJSON(n[r]));
            return s;
        }
        static CreateFromMorphTargetSequence(t, e, n, s) {
            const r = e.length, a = [];
            for(let o = 0; o < r; o++){
                let c = [], l = [];
                c.push((o + r - 1) % r, o, (o + 1) % r), l.push(0, 1, 0);
                const h = yx(c);
                c = Eu(c, 1, h), l = Eu(l, 1, h), !s && c[0] === 0 && (c.push(r), l.push(l[0])), a.push(new Ns(".morphTargetInfluences[" + e[o].name + "]", c, l).scale(1 / n));
            }
            return new this(t, -1, a);
        }
        static findByName(t, e) {
            let n = t;
            if (!Array.isArray(t)) {
                const s = t;
                n = s.geometry && s.geometry.animations || s.animations;
            }
            for(let s = 0; s < n.length; s++)if (n[s].name === e) return n[s];
            return null;
        }
        static CreateClipsFromMorphTargetSequences(t, e, n) {
            const s = {}, r = /^([\w-]*?)([\d]+)$/;
            for(let o = 0, c = t.length; o < c; o++){
                const l = t[o], h = l.name.match(r);
                if (h && h.length > 1) {
                    const u = h[1];
                    let d = s[u];
                    d || (s[u] = d = []), d.push(l);
                }
            }
            const a = [];
            for(const o in s)a.push(this.CreateFromMorphTargetSequence(o, s[o], e, n));
            return a;
        }
        static parseAnimation(t, e) {
            if (console.warn("THREE.AnimationClip: parseAnimation() is deprecated and will be removed with r185"), !t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
            const n = function(u, d, f, _, g) {
                if (f.length !== 0) {
                    const p = [], m = [];
                    $f(f, p, m, _), p.length !== 0 && g.push(new u(d, p, m));
                }
            }, s = [], r = t.name || "default", a = t.fps || 30, o = t.blendMode;
            let c = t.length || -1;
            const l = t.hierarchy || [];
            for(let u = 0; u < l.length; u++){
                const d = l[u].keys;
                if (!(!d || d.length === 0)) if (d[0].morphTargets) {
                    const f = {};
                    let _;
                    for(_ = 0; _ < d.length; _++)if (d[_].morphTargets) for(let g = 0; g < d[_].morphTargets.length; g++)f[d[_].morphTargets[g]] = -1;
                    for(const g in f){
                        const p = [], m = [];
                        for(let x = 0; x !== d[_].morphTargets.length; ++x){
                            const y = d[_];
                            p.push(y.time), m.push(y.morphTarget === g ? 1 : 0);
                        }
                        s.push(new Ns(".morphTargetInfluence[" + g + "]", p, m));
                    }
                    c = f.length * a;
                } else {
                    const f = ".bones[" + e[u].name + "]";
                    n(Fs, f + ".position", d, "pos", s), n(Bs, f + ".quaternion", d, "rot", s), n(Fs, f + ".scale", d, "scl", s);
                }
            }
            return s.length === 0 ? null : new this(r, c, s, o);
        }
        resetDuration() {
            const t = this.tracks;
            let e = 0;
            for(let n = 0, s = t.length; n !== s; ++n){
                const r = this.tracks[n];
                e = Math.max(e, r.times[r.times.length - 1]);
            }
            return this.duration = e, this;
        }
        trim() {
            for(let t = 0; t < this.tracks.length; t++)this.tracks[t].trim(0, this.duration);
            return this;
        }
        validate() {
            let t = !0;
            for(let e = 0; e < this.tracks.length; e++)t = t && this.tracks[e].validate();
            return t;
        }
        optimize() {
            for(let t = 0; t < this.tracks.length; t++)this.tracks[t].optimize();
            return this;
        }
        clone() {
            const t = [];
            for(let e = 0; e < this.tracks.length; e++)t.push(this.tracks[e].clone());
            return new this.constructor(this.name, this.duration, t, this.blendMode);
        }
        toJSON() {
            return this.constructor.toJSON(this);
        }
    }
    function Tx(i) {
        switch(i.toLowerCase()){
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
                return Ns;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
                return Fs;
            case "color":
                return Zf;
            case "quaternion":
                return Bs;
            case "bool":
            case "boolean":
                return Vs;
            case "string":
                return Ws;
        }
        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + i);
    }
    function Ex(i) {
        if (i.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
        const t = Tx(i.type);
        if (i.times === void 0) {
            const e = [], n = [];
            $f(i.keys, e, n, "value"), i.times = e, i.values = n;
        }
        return t.parse !== void 0 ? t.parse(i) : new t(i.name, i.times, i.values, i.interpolation);
    }
    const pi = {
        enabled: !1,
        files: {},
        add: function(i, t) {
            this.enabled !== !1 && (this.files[i] = t);
        },
        get: function(i) {
            if (this.enabled !== !1) return this.files[i];
        },
        remove: function(i) {
            delete this.files[i];
        },
        clear: function() {
            this.files = {};
        }
    };
    class Ax {
        constructor(t, e, n){
            const s = this;
            let r = !1, a = 0, o = 0, c;
            const l = [];
            this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function(h) {
                o++, r === !1 && s.onStart !== void 0 && s.onStart(h, a, o), r = !0;
            }, this.itemEnd = function(h) {
                a++, s.onProgress !== void 0 && s.onProgress(h, a, o), a === o && (r = !1, s.onLoad !== void 0 && s.onLoad());
            }, this.itemError = function(h) {
                s.onError !== void 0 && s.onError(h);
            }, this.resolveURL = function(h) {
                return c ? c(h) : h;
            }, this.setURLModifier = function(h) {
                return c = h, this;
            }, this.addHandler = function(h, u) {
                return l.push(h, u), this;
            }, this.removeHandler = function(h) {
                const u = l.indexOf(h);
                return u !== -1 && l.splice(u, 2), this;
            }, this.getHandler = function(h) {
                for(let u = 0, d = l.length; u < d; u += 2){
                    const f = l[u], _ = l[u + 1];
                    if (f.global && (f.lastIndex = 0), f.test(h)) return _;
                }
                return null;
            };
        }
    }
    const wx = new Ax;
    class Xs {
        constructor(t){
            this.manager = t !== void 0 ? t : wx, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
        }
        load() {}
        loadAsync(t, e) {
            const n = this;
            return new Promise(function(s, r) {
                n.load(t, s, e, r);
            });
        }
        parse() {}
        setCrossOrigin(t) {
            return this.crossOrigin = t, this;
        }
        setWithCredentials(t) {
            return this.withCredentials = t, this;
        }
        setPath(t) {
            return this.path = t, this;
        }
        setResourcePath(t) {
            return this.resourcePath = t, this;
        }
        setRequestHeader(t) {
            return this.requestHeader = t, this;
        }
    }
    Xs.DEFAULT_MATERIAL_NAME = "__DEFAULT";
    const qn = {};
    class Rx extends Error {
        constructor(t, e){
            super(t), this.response = e;
        }
    }
    class Jf extends Xs {
        constructor(t){
            super(t), this.mimeType = "", this.responseType = "";
        }
        load(t, e, n, s) {
            t === void 0 && (t = ""), this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
            const r = pi.get(t);
            if (r !== void 0) return this.manager.itemStart(t), setTimeout(()=>{
                e && e(r), this.manager.itemEnd(t);
            }, 0), r;
            if (qn[t] !== void 0) {
                qn[t].push({
                    onLoad: e,
                    onProgress: n,
                    onError: s
                });
                return;
            }
            qn[t] = [], qn[t].push({
                onLoad: e,
                onProgress: n,
                onError: s
            });
            const a = new Request(t, {
                headers: new Headers(this.requestHeader),
                credentials: this.withCredentials ? "include" : "same-origin"
            }), o = this.mimeType, c = this.responseType;
            fetch(a).then((l)=>{
                if (l.status === 200 || l.status === 0) {
                    if (l.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || l.body === void 0 || l.body.getReader === void 0) return l;
                    const h = qn[t], u = l.body.getReader(), d = l.headers.get("X-File-Size") || l.headers.get("Content-Length"), f = d ? parseInt(d) : 0, _ = f !== 0;
                    let g = 0;
                    const p = new ReadableStream({
                        start (m) {
                            x();
                            function x() {
                                u.read().then(({ done: y, value: v })=>{
                                    if (y) m.close();
                                    else {
                                        g += v.byteLength;
                                        const I = new ProgressEvent("progress", {
                                            lengthComputable: _,
                                            loaded: g,
                                            total: f
                                        });
                                        for(let w = 0, R = h.length; w < R; w++){
                                            const N = h[w];
                                            N.onProgress && N.onProgress(I);
                                        }
                                        m.enqueue(v), x();
                                    }
                                }, (y)=>{
                                    m.error(y);
                                });
                            }
                        }
                    });
                    return new Response(p);
                } else throw new Rx(`fetch for "${l.url}" responded with ${l.status}: ${l.statusText}`, l);
            }).then((l)=>{
                switch(c){
                    case "arraybuffer":
                        return l.arrayBuffer();
                    case "blob":
                        return l.blob();
                    case "document":
                        return l.text().then((h)=>new DOMParser().parseFromString(h, o));
                    case "json":
                        return l.json();
                    default:
                        if (o === "") return l.text();
                        {
                            const u = /charset="?([^;"\s]*)"?/i.exec(o), d = u && u[1] ? u[1].toLowerCase() : void 0, f = new TextDecoder(d);
                            return l.arrayBuffer().then((_)=>f.decode(_));
                        }
                }
            }).then((l)=>{
                pi.add(t, l);
                const h = qn[t];
                delete qn[t];
                for(let u = 0, d = h.length; u < d; u++){
                    const f = h[u];
                    f.onLoad && f.onLoad(l);
                }
            }).catch((l)=>{
                const h = qn[t];
                if (h === void 0) throw this.manager.itemError(t), l;
                delete qn[t];
                for(let u = 0, d = h.length; u < d; u++){
                    const f = h[u];
                    f.onError && f.onError(l);
                }
                this.manager.itemError(t);
            }).finally(()=>{
                this.manager.itemEnd(t);
            }), this.manager.itemStart(t);
        }
        setResponseType(t) {
            return this.responseType = t, this;
        }
        setMimeType(t) {
            return this.mimeType = t, this;
        }
    }
    class Cx extends Xs {
        constructor(t){
            super(t);
        }
        load(t, e, n, s) {
            this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
            const r = this, a = pi.get(t);
            if (a !== void 0) return r.manager.itemStart(t), setTimeout(function() {
                e && e(a), r.manager.itemEnd(t);
            }, 0), a;
            const o = Pr("img");
            function c() {
                h(), pi.add(t, this), e && e(this), r.manager.itemEnd(t);
            }
            function l(u) {
                h(), s && s(u), r.manager.itemError(t), r.manager.itemEnd(t);
            }
            function h() {
                o.removeEventListener("load", c, !1), o.removeEventListener("error", l, !1);
            }
            return o.addEventListener("load", c, !1), o.addEventListener("error", l, !1), t.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (o.crossOrigin = this.crossOrigin), r.manager.itemStart(t), o.src = t, o;
        }
    }
    class ll extends Xs {
        constructor(t){
            super(t);
        }
        load(t, e, n, s) {
            const r = new tn, a = new Cx(this.manager);
            return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(t, function(o) {
                r.image = o, r.needsUpdate = !0, e !== void 0 && e(r);
            }, n, s), r;
        }
    }
    class $a extends ge {
        constructor(t, e = 1){
            super(), this.isLight = !0, this.type = "Light", this.color = new Bt(t), this.intensity = e;
        }
        dispose() {}
        copy(t, e) {
            return super.copy(t, e), this.color.copy(t.color), this.intensity = t.intensity, this;
        }
        toJSON(t) {
            const e = super.toJSON(t);
            return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, this.groundColor !== void 0 && (e.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (e.object.distance = this.distance), this.angle !== void 0 && (e.object.angle = this.angle), this.decay !== void 0 && (e.object.decay = this.decay), this.penumbra !== void 0 && (e.object.penumbra = this.penumbra), this.shadow !== void 0 && (e.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (e.object.target = this.target.uuid), e;
        }
    }
    const Ro = new Ht, Au = new k, wu = new k;
    class Zl {
        constructor(t){
            this.camera = t, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Kt(512, 512), this.map = null, this.mapPass = null, this.matrix = new Ht, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new $l, this._frameExtents = new Kt(1, 1), this._viewportCount = 1, this._viewports = [
                new ne(0, 0, 1, 1)
            ];
        }
        getViewportCount() {
            return this._viewportCount;
        }
        getFrustum() {
            return this._frustum;
        }
        updateMatrices(t) {
            const e = this.camera, n = this.matrix;
            Au.setFromMatrixPosition(t.matrixWorld), e.position.copy(Au), wu.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(wu), e.updateMatrixWorld(), Ro.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Ro), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(Ro);
        }
        getViewport(t) {
            return this._viewports[t];
        }
        getFrameExtents() {
            return this._frameExtents;
        }
        dispose() {
            this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
        }
        copy(t) {
            return this.camera = t.camera.clone(), this.intensity = t.intensity, this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this;
        }
        clone() {
            return new this.constructor().copy(this);
        }
        toJSON() {
            const t = {};
            return this.intensity !== 1 && (t.intensity = this.intensity), this.bias !== 0 && (t.bias = this.bias), this.normalBias !== 0 && (t.normalBias = this.normalBias), this.radius !== 1 && (t.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t;
        }
    }
    class Px extends Zl {
        constructor(){
            super(new We(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
        }
        updateMatrices(t) {
            const e = this.camera, n = Ds * 2 * t.angle * this.focus, s = this.mapSize.width / this.mapSize.height, r = t.distance || e.far;
            (n !== e.fov || s !== e.aspect || r !== e.far) && (e.fov = n, e.aspect = s, e.far = r, e.updateProjectionMatrix()), super.updateMatrices(t);
        }
        copy(t) {
            return super.copy(t), this.focus = t.focus, this;
        }
    }
    class Ix extends $a {
        constructor(t, e, n = 0, s = Math.PI / 3, r = 0, a = 2){
            super(t, e), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(ge.DEFAULT_UP), this.updateMatrix(), this.target = new ge, this.distance = n, this.angle = s, this.penumbra = r, this.decay = a, this.map = null, this.shadow = new Px;
        }
        get power() {
            return this.intensity * Math.PI;
        }
        set power(t) {
            this.intensity = t / Math.PI;
        }
        dispose() {
            this.shadow.dispose();
        }
        copy(t, e) {
            return super.copy(t, e), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
        }
    }
    const Ru = new Ht, nr = new k, Co = new k;
    class Dx extends Zl {
        constructor(){
            super(new We(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new Kt(4, 2), this._viewportCount = 6, this._viewports = [
                new ne(2, 1, 1, 1),
                new ne(0, 1, 1, 1),
                new ne(3, 1, 1, 1),
                new ne(1, 1, 1, 1),
                new ne(3, 0, 1, 1),
                new ne(1, 0, 1, 1)
            ], this._cubeDirections = [
                new k(1, 0, 0),
                new k(-1, 0, 0),
                new k(0, 0, 1),
                new k(0, 0, -1),
                new k(0, 1, 0),
                new k(0, -1, 0)
            ], this._cubeUps = [
                new k(0, 1, 0),
                new k(0, 1, 0),
                new k(0, 1, 0),
                new k(0, 1, 0),
                new k(0, 0, 1),
                new k(0, 0, -1)
            ];
        }
        updateMatrices(t, e = 0) {
            const n = this.camera, s = this.matrix, r = t.distance || n.far;
            r !== n.far && (n.far = r, n.updateProjectionMatrix()), nr.setFromMatrixPosition(t.matrixWorld), n.position.copy(nr), Co.copy(n.position), Co.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(Co), n.updateMatrixWorld(), s.makeTranslation(-nr.x, -nr.y, -nr.z), Ru.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Ru);
        }
    }
    class Lx extends $a {
        constructor(t, e, n = 0, s = 2){
            super(t, e), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = s, this.shadow = new Dx;
        }
        get power() {
            return this.intensity * 4 * Math.PI;
        }
        set power(t) {
            this.intensity = t / (4 * Math.PI);
        }
        dispose() {
            this.shadow.dispose();
        }
        copy(t, e) {
            return super.copy(t, e), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this;
        }
    }
    class Jl extends zf {
        constructor(t = -1, e = 1, n = 1, s = -1, r = .1, a = 2e3){
            super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = s, this.near = r, this.far = a, this.updateProjectionMatrix();
        }
        copy(t, e) {
            return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = t.view === null ? null : Object.assign({}, t.view), this;
        }
        setViewOffset(t, e, n, s, r, a) {
            this.view === null && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = s, this.view.width = r, this.view.height = a, this.updateProjectionMatrix();
        }
        clearViewOffset() {
            this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
            const t = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, s = (this.top + this.bottom) / 2;
            let r = n - t, a = n + t, o = s + e, c = s - e;
            if (this.view !== null && this.view.enabled) {
                const l = (this.right - this.left) / this.view.fullWidth / this.zoom, h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                r += l * this.view.offsetX, a = r + l * this.view.width, o -= h * this.view.offsetY, c = o - h * this.view.height;
            }
            this.projectionMatrix.makeOrthographic(r, a, o, c, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(t) {
            const e = super.toJSON(t);
            return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, this.view !== null && (e.object.view = Object.assign({}, this.view)), e;
        }
    }
    class Ux extends Zl {
        constructor(){
            super(new Jl(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0;
        }
    }
    class Ql extends $a {
        constructor(t, e){
            super(t, e), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(ge.DEFAULT_UP), this.updateMatrix(), this.target = new ge, this.shadow = new Ux;
        }
        dispose() {
            this.shadow.dispose();
        }
        copy(t) {
            return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
        }
    }
    class Qf extends $a {
        constructor(t, e){
            super(t, e), this.isAmbientLight = !0, this.type = "AmbientLight";
        }
    }
    class _r {
        static extractUrlBase(t) {
            const e = t.lastIndexOf("/");
            return e === -1 ? "./" : t.slice(0, e + 1);
        }
        static resolveURL(t, e) {
            return typeof t != "string" || t === "" ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t);
        }
    }
    class Nx extends Xs {
        constructor(t){
            super(t), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
                premultiplyAlpha: "none"
            };
        }
        setOptions(t) {
            return this.options = t, this;
        }
        load(t, e, n, s) {
            t === void 0 && (t = ""), this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
            const r = this, a = pi.get(t);
            if (a !== void 0) {
                if (r.manager.itemStart(t), a.then) {
                    a.then((l)=>{
                        e && e(l), r.manager.itemEnd(t);
                    }).catch((l)=>{
                        s && s(l);
                    });
                    return;
                }
                return setTimeout(function() {
                    e && e(a), r.manager.itemEnd(t);
                }, 0), a;
            }
            const o = {};
            o.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", o.headers = this.requestHeader;
            const c = fetch(t, o).then(function(l) {
                return l.blob();
            }).then(function(l) {
                return createImageBitmap(l, Object.assign(r.options, {
                    colorSpaceConversion: "none"
                }));
            }).then(function(l) {
                return pi.add(t, l), e && e(l), r.manager.itemEnd(t), l;
            }).catch(function(l) {
                s && s(l), pi.remove(t), r.manager.itemError(t), r.manager.itemEnd(t);
            });
            pi.add(t, c), r.manager.itemStart(t);
        }
    }
    class Bx extends We {
        constructor(t = []){
            super(), this.isArrayCamera = !0, this.cameras = t, this.index = 0;
        }
    }
    class Fx {
        constructor(t = !0){
            this.autoStart = t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
        }
        start() {
            this.startTime = Cu(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
        }
        stop() {
            this.getElapsedTime(), this.running = !1, this.autoStart = !1;
        }
        getElapsedTime() {
            return this.getDelta(), this.elapsedTime;
        }
        getDelta() {
            let t = 0;
            if (this.autoStart && !this.running) return this.start(), 0;
            if (this.running) {
                const e = Cu();
                t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t;
            }
            return t;
        }
    }
    function Cu() {
        return performance.now();
    }
    class Ox {
        constructor(t, e, n){
            this.binding = t, this.valueSize = n;
            let s, r, a;
            switch(e){
                case "quaternion":
                    s = this._slerp, r = this._slerpAdditive, a = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(n * 6), this._workIndex = 5;
                    break;
                case "string":
                case "bool":
                    s = this._select, r = this._select, a = this._setAdditiveIdentityOther, this.buffer = new Array(n * 5);
                    break;
                default:
                    s = this._lerp, r = this._lerpAdditive, a = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(n * 5);
            }
            this._mixBufferRegion = s, this._mixBufferRegionAdditive = r, this._setIdentity = a, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
        }
        accumulate(t, e) {
            const n = this.buffer, s = this.valueSize, r = t * s + s;
            let a = this.cumulativeWeight;
            if (a === 0) {
                for(let o = 0; o !== s; ++o)n[r + o] = n[o];
                a = e;
            } else {
                a += e;
                const o = e / a;
                this._mixBufferRegion(n, r, 0, o, s);
            }
            this.cumulativeWeight = a;
        }
        accumulateAdditive(t) {
            const e = this.buffer, n = this.valueSize, s = n * this._addIndex;
            this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(e, s, 0, t, n), this.cumulativeWeightAdditive += t;
        }
        apply(t) {
            const e = this.valueSize, n = this.buffer, s = t * e + e, r = this.cumulativeWeight, a = this.cumulativeWeightAdditive, o = this.binding;
            if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
                const c = e * this._origIndex;
                this._mixBufferRegion(n, s, c, 1 - r, e);
            }
            a > 0 && this._mixBufferRegionAdditive(n, s, this._addIndex * e, 1, e);
            for(let c = e, l = e + e; c !== l; ++c)if (n[c] !== n[c + e]) {
                o.setValue(n, s);
                break;
            }
        }
        saveOriginalState() {
            const t = this.binding, e = this.buffer, n = this.valueSize, s = n * this._origIndex;
            t.getValue(e, s);
            for(let r = n, a = s; r !== a; ++r)e[r] = e[s + r % n];
            this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
        }
        restoreOriginalState() {
            const t = this.valueSize * 3;
            this.binding.setValue(this.buffer, t);
        }
        _setAdditiveIdentityNumeric() {
            const t = this._addIndex * this.valueSize, e = t + this.valueSize;
            for(let n = t; n < e; n++)this.buffer[n] = 0;
        }
        _setAdditiveIdentityQuaternion() {
            this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
        }
        _setAdditiveIdentityOther() {
            const t = this._origIndex * this.valueSize, e = this._addIndex * this.valueSize;
            for(let n = 0; n < this.valueSize; n++)this.buffer[e + n] = this.buffer[t + n];
        }
        _select(t, e, n, s, r) {
            if (s >= .5) for(let a = 0; a !== r; ++a)t[e + a] = t[n + a];
        }
        _slerp(t, e, n, s) {
            Rn.slerpFlat(t, e, t, e, t, n, s);
        }
        _slerpAdditive(t, e, n, s, r) {
            const a = this._workIndex * r;
            Rn.multiplyQuaternionsFlat(t, a, t, e, t, n), Rn.slerpFlat(t, e, t, e, t, a, s);
        }
        _lerp(t, e, n, s, r) {
            const a = 1 - s;
            for(let o = 0; o !== r; ++o){
                const c = e + o;
                t[c] = t[c] * a + t[n + o] * s;
            }
        }
        _lerpAdditive(t, e, n, s, r) {
            for(let a = 0; a !== r; ++a){
                const o = e + a;
                t[o] = t[o] + t[n + a] * s;
            }
        }
    }
    const th = "\\[\\]\\.:\\/", kx = new RegExp("[" + th + "]", "g"), eh = "[^" + th + "]", Gx = "[^" + th.replace("\\.", "") + "]", Hx = /((?:WC+[\/:])*)/.source.replace("WC", eh), zx = /(WCOD+)?/.source.replace("WCOD", Gx), Vx = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", eh), Wx = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", eh), Xx = new RegExp("^" + Hx + zx + Vx + Wx + "$"), Yx = [
        "material",
        "materials",
        "bones",
        "map"
    ];
    class qx {
        constructor(t, e, n){
            const s = n || re.parseTrackName(e);
            this._targetGroup = t, this._bindings = t.subscribe_(e, s);
        }
        getValue(t, e) {
            this.bind();
            const n = this._targetGroup.nCachedObjects_, s = this._bindings[n];
            s !== void 0 && s.getValue(t, e);
        }
        setValue(t, e) {
            const n = this._bindings;
            for(let s = this._targetGroup.nCachedObjects_, r = n.length; s !== r; ++s)n[s].setValue(t, e);
        }
        bind() {
            const t = this._bindings;
            for(let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)t[e].bind();
        }
        unbind() {
            const t = this._bindings;
            for(let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)t[e].unbind();
        }
    }
    class re {
        constructor(t, e, n){
            this.path = e, this.parsedPath = n || re.parseTrackName(e), this.node = re.findNode(t, this.parsedPath.nodeName), this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
        }
        static create(t, e, n) {
            return t && t.isAnimationObjectGroup ? new re.Composite(t, e, n) : new re(t, e, n);
        }
        static sanitizeNodeName(t) {
            return t.replace(/\s/g, "_").replace(kx, "");
        }
        static parseTrackName(t) {
            const e = Xx.exec(t);
            if (e === null) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
            const n = {
                nodeName: e[2],
                objectName: e[3],
                objectIndex: e[4],
                propertyName: e[5],
                propertyIndex: e[6]
            }, s = n.nodeName && n.nodeName.lastIndexOf(".");
            if (s !== void 0 && s !== -1) {
                const r = n.nodeName.substring(s + 1);
                Yx.indexOf(r) !== -1 && (n.nodeName = n.nodeName.substring(0, s), n.objectName = r);
            }
            if (n.propertyName === null || n.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
            return n;
        }
        static findNode(t, e) {
            if (e === void 0 || e === "" || e === "." || e === -1 || e === t.name || e === t.uuid) return t;
            if (t.skeleton) {
                const n = t.skeleton.getBoneByName(e);
                if (n !== void 0) return n;
            }
            if (t.children) {
                const n = function(r) {
                    for(let a = 0; a < r.length; a++){
                        const o = r[a];
                        if (o.name === e || o.uuid === e) return o;
                        const c = n(o.children);
                        if (c) return c;
                    }
                    return null;
                }, s = n(t.children);
                if (s) return s;
            }
            return null;
        }
        _getValue_unavailable() {}
        _setValue_unavailable() {}
        _getValue_direct(t, e) {
            t[e] = this.targetObject[this.propertyName];
        }
        _getValue_array(t, e) {
            const n = this.resolvedProperty;
            for(let s = 0, r = n.length; s !== r; ++s)t[e++] = n[s];
        }
        _getValue_arrayElement(t, e) {
            t[e] = this.resolvedProperty[this.propertyIndex];
        }
        _getValue_toArray(t, e) {
            this.resolvedProperty.toArray(t, e);
        }
        _setValue_direct(t, e) {
            this.targetObject[this.propertyName] = t[e];
        }
        _setValue_direct_setNeedsUpdate(t, e) {
            this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0;
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
            this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0;
        }
        _setValue_array(t, e) {
            const n = this.resolvedProperty;
            for(let s = 0, r = n.length; s !== r; ++s)n[s] = t[e++];
        }
        _setValue_array_setNeedsUpdate(t, e) {
            const n = this.resolvedProperty;
            for(let s = 0, r = n.length; s !== r; ++s)n[s] = t[e++];
            this.targetObject.needsUpdate = !0;
        }
        _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
            const n = this.resolvedProperty;
            for(let s = 0, r = n.length; s !== r; ++s)n[s] = t[e++];
            this.targetObject.matrixWorldNeedsUpdate = !0;
        }
        _setValue_arrayElement(t, e) {
            this.resolvedProperty[this.propertyIndex] = t[e];
        }
        _setValue_arrayElement_setNeedsUpdate(t, e) {
            this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0;
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
            this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0;
        }
        _setValue_fromArray(t, e) {
            this.resolvedProperty.fromArray(t, e);
        }
        _setValue_fromArray_setNeedsUpdate(t, e) {
            this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0;
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
            this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0;
        }
        _getValue_unbound(t, e) {
            this.bind(), this.getValue(t, e);
        }
        _setValue_unbound(t, e) {
            this.bind(), this.setValue(t, e);
        }
        bind() {
            let t = this.node;
            const e = this.parsedPath, n = e.objectName, s = e.propertyName;
            let r = e.propertyIndex;
            if (t || (t = re.findNode(this.rootNode, e.nodeName), this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) {
                console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
                return;
            }
            if (n) {
                let l = e.objectIndex;
                switch(n){
                    case "materials":
                        if (!t.material) {
                            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            return;
                        }
                        if (!t.material.materials) {
                            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                            return;
                        }
                        t = t.material.materials;
                        break;
                    case "bones":
                        if (!t.skeleton) {
                            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                            return;
                        }
                        t = t.skeleton.bones;
                        for(let h = 0; h < t.length; h++)if (t[h].name === l) {
                            l = h;
                            break;
                        }
                        break;
                    case "map":
                        if ("map" in t) {
                            t = t.map;
                            break;
                        }
                        if (!t.material) {
                            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            return;
                        }
                        if (!t.material.map) {
                            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                            return;
                        }
                        t = t.material.map;
                        break;
                    default:
                        if (t[n] === void 0) {
                            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                            return;
                        }
                        t = t[n];
                }
                if (l !== void 0) {
                    if (t[l] === void 0) {
                        console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                        return;
                    }
                    t = t[l];
                }
            }
            const a = t[s];
            if (a === void 0) {
                const l = e.nodeName;
                console.error("THREE.PropertyBinding: Trying to update property for track: " + l + "." + s + " but it wasn't found.", t);
                return;
            }
            let o = this.Versioning.None;
            this.targetObject = t, t.isMaterial === !0 ? o = this.Versioning.NeedsUpdate : t.isObject3D === !0 && (o = this.Versioning.MatrixWorldNeedsUpdate);
            let c = this.BindingType.Direct;
            if (r !== void 0) {
                if (s === "morphTargetInfluences") {
                    if (!t.geometry) {
                        console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                        return;
                    }
                    if (!t.geometry.morphAttributes) {
                        console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                        return;
                    }
                    t.morphTargetDictionary[r] !== void 0 && (r = t.morphTargetDictionary[r]);
                }
                c = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = r;
            } else a.fromArray !== void 0 && a.toArray !== void 0 ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = a) : Array.isArray(a) ? (c = this.BindingType.EntireArray, this.resolvedProperty = a) : this.propertyName = s;
            this.getValue = this.GetterByBindingType[c], this.setValue = this.SetterByBindingTypeAndVersioning[c][o];
        }
        unbind() {
            this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
        }
    }
    re.Composite = qx;
    re.prototype.BindingType = {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3
    };
    re.prototype.Versioning = {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2
    };
    re.prototype.GetterByBindingType = [
        re.prototype._getValue_direct,
        re.prototype._getValue_array,
        re.prototype._getValue_arrayElement,
        re.prototype._getValue_toArray
    ];
    re.prototype.SetterByBindingTypeAndVersioning = [
        [
            re.prototype._setValue_direct,
            re.prototype._setValue_direct_setNeedsUpdate,
            re.prototype._setValue_direct_setMatrixWorldNeedsUpdate
        ],
        [
            re.prototype._setValue_array,
            re.prototype._setValue_array_setNeedsUpdate,
            re.prototype._setValue_array_setMatrixWorldNeedsUpdate
        ],
        [
            re.prototype._setValue_arrayElement,
            re.prototype._setValue_arrayElement_setNeedsUpdate,
            re.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
        ],
        [
            re.prototype._setValue_fromArray,
            re.prototype._setValue_fromArray_setNeedsUpdate,
            re.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
        ]
    ];
    class jx {
        constructor(t, e, n = null, s = e.blendMode){
            this._mixer = t, this._clip = e, this._localRoot = n, this.blendMode = s;
            const r = e.tracks, a = r.length, o = new Array(a), c = {
                endingStart: ys,
                endingEnd: ys
            };
            for(let l = 0; l !== a; ++l){
                const h = r[l].createInterpolant(null);
                o[l] = h, h.settings = c;
            }
            this._interpolantSettings = c, this._interpolants = o, this._propertyBindings = new Array(a), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = il, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
        }
        play() {
            return this._mixer._activateAction(this), this;
        }
        stop() {
            return this._mixer._deactivateAction(this), this.reset();
        }
        reset() {
            return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
        }
        isRunning() {
            return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
        }
        isScheduled() {
            return this._mixer._isActiveAction(this);
        }
        startAt(t) {
            return this._startTime = t, this;
        }
        setLoop(t, e) {
            return this.loop = t, this.repetitions = e, this;
        }
        setEffectiveWeight(t) {
            return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading();
        }
        getEffectiveWeight() {
            return this._effectiveWeight;
        }
        fadeIn(t) {
            return this._scheduleFading(t, 0, 1);
        }
        fadeOut(t) {
            return this._scheduleFading(t, 1, 0);
        }
        crossFadeFrom(t, e, n = !1) {
            if (t.fadeOut(e), this.fadeIn(e), n === !0) {
                const s = this._clip.duration, r = t._clip.duration, a = r / s, o = s / r;
                t.warp(1, a, e), this.warp(o, 1, e);
            }
            return this;
        }
        crossFadeTo(t, e, n = !1) {
            return t.crossFadeFrom(this, e, n);
        }
        stopFading() {
            const t = this._weightInterpolant;
            return t !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this;
        }
        setEffectiveTimeScale(t) {
            return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping();
        }
        getEffectiveTimeScale() {
            return this._effectiveTimeScale;
        }
        setDuration(t) {
            return this.timeScale = this._clip.duration / t, this.stopWarping();
        }
        syncWith(t) {
            return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping();
        }
        halt(t) {
            return this.warp(this._effectiveTimeScale, 0, t);
        }
        warp(t, e, n) {
            const s = this._mixer, r = s.time, a = this.timeScale;
            let o = this._timeScaleInterpolant;
            o === null && (o = s._lendControlInterpolant(), this._timeScaleInterpolant = o);
            const c = o.parameterPositions, l = o.sampleValues;
            return c[0] = r, c[1] = r + n, l[0] = t / a, l[1] = e / a, this;
        }
        stopWarping() {
            const t = this._timeScaleInterpolant;
            return t !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this;
        }
        getMixer() {
            return this._mixer;
        }
        getClip() {
            return this._clip;
        }
        getRoot() {
            return this._localRoot || this._mixer._root;
        }
        _update(t, e, n, s) {
            if (!this.enabled) {
                this._updateWeight(t);
                return;
            }
            const r = this._startTime;
            if (r !== null) {
                const c = (t - r) * n;
                c < 0 || n === 0 ? e = 0 : (this._startTime = null, e = n * c);
            }
            e *= this._updateTimeScale(t);
            const a = this._updateTime(e), o = this._updateWeight(t);
            if (o > 0) {
                const c = this._interpolants, l = this._propertyBindings;
                switch(this.blendMode){
                    case ng:
                        for(let h = 0, u = c.length; h !== u; ++h)c[h].evaluate(a), l[h].accumulateAdditive(o);
                        break;
                    case Wl:
                    default:
                        for(let h = 0, u = c.length; h !== u; ++h)c[h].evaluate(a), l[h].accumulate(s, o);
                }
            }
        }
        _updateWeight(t) {
            let e = 0;
            if (this.enabled) {
                e = this.weight;
                const n = this._weightInterpolant;
                if (n !== null) {
                    const s = n.evaluate(t)[0];
                    e *= s, t > n.parameterPositions[1] && (this.stopFading(), s === 0 && (this.enabled = !1));
                }
            }
            return this._effectiveWeight = e, e;
        }
        _updateTimeScale(t) {
            let e = 0;
            if (!this.paused) {
                e = this.timeScale;
                const n = this._timeScaleInterpolant;
                if (n !== null) {
                    const s = n.evaluate(t)[0];
                    e *= s, t > n.parameterPositions[1] && (this.stopWarping(), e === 0 ? this.paused = !0 : this.timeScale = e);
                }
            }
            return this._effectiveTimeScale = e, e;
        }
        _updateTime(t) {
            const e = this._clip.duration, n = this.loop;
            let s = this.time + t, r = this._loopCount;
            const a = n === eg;
            if (t === 0) return r === -1 ? s : a && (r & 1) === 1 ? e - s : s;
            if (n === tg) {
                r === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                t: {
                    if (s >= e) s = e;
                    else if (s < 0) s = 0;
                    else {
                        this.time = s;
                        break t;
                    }
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = s, this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: t < 0 ? -1 : 1
                    });
                }
            } else {
                if (r === -1 && (t >= 0 ? (r = 0, this._setEndings(!0, this.repetitions === 0, a)) : this._setEndings(this.repetitions === 0, !0, a)), s >= e || s < 0) {
                    const o = Math.floor(s / e);
                    s -= e * o, r += Math.abs(o);
                    const c = this.repetitions - r;
                    if (c <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, s = t > 0 ? e : 0, this.time = s, this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: t > 0 ? 1 : -1
                    });
                    else {
                        if (c === 1) {
                            const l = t < 0;
                            this._setEndings(l, !l, a);
                        } else this._setEndings(!1, !1, a);
                        this._loopCount = r, this.time = s, this._mixer.dispatchEvent({
                            type: "loop",
                            action: this,
                            loopDelta: o
                        });
                    }
                } else this.time = s;
                if (a && (r & 1) === 1) return e - s;
            }
            return s;
        }
        _setEndings(t, e, n) {
            const s = this._interpolantSettings;
            n ? (s.endingStart = bs, s.endingEnd = bs) : (t ? s.endingStart = this.zeroSlopeAtStart ? bs : ys : s.endingStart = Fa, e ? s.endingEnd = this.zeroSlopeAtEnd ? bs : ys : s.endingEnd = Fa);
        }
        _scheduleFading(t, e, n) {
            const s = this._mixer, r = s.time;
            let a = this._weightInterpolant;
            a === null && (a = s._lendControlInterpolant(), this._weightInterpolant = a);
            const o = a.parameterPositions, c = a.sampleValues;
            return o[0] = r, c[0] = e, o[1] = r + t, c[1] = n, this;
        }
    }
    const $x = new Float32Array(1);
    class Kx extends $i {
        constructor(t){
            super(), this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
        }
        _bindAction(t, e) {
            const n = t._localRoot || this._root, s = t._clip.tracks, r = s.length, a = t._propertyBindings, o = t._interpolants, c = n.uuid, l = this._bindingsByRootAndName;
            let h = l[c];
            h === void 0 && (h = {}, l[c] = h);
            for(let u = 0; u !== r; ++u){
                const d = s[u], f = d.name;
                let _ = h[f];
                if (_ !== void 0) ++_.referenceCount, a[u] = _;
                else {
                    if (_ = a[u], _ !== void 0) {
                        _._cacheIndex === null && (++_.referenceCount, this._addInactiveBinding(_, c, f));
                        continue;
                    }
                    const g = e && e._propertyBindings[u].binding.parsedPath;
                    _ = new Ox(re.create(n, f, g), d.ValueTypeName, d.getValueSize()), ++_.referenceCount, this._addInactiveBinding(_, c, f), a[u] = _;
                }
                o[u].resultBuffer = _.buffer;
            }
        }
        _activateAction(t) {
            if (!this._isActiveAction(t)) {
                if (t._cacheIndex === null) {
                    const n = (t._localRoot || this._root).uuid, s = t._clip.uuid, r = this._actionsByClip[s];
                    this._bindAction(t, r && r.knownActions[0]), this._addInactiveAction(t, s, n);
                }
                const e = t._propertyBindings;
                for(let n = 0, s = e.length; n !== s; ++n){
                    const r = e[n];
                    r.useCount++ === 0 && (this._lendBinding(r), r.saveOriginalState());
                }
                this._lendAction(t);
            }
        }
        _deactivateAction(t) {
            if (this._isActiveAction(t)) {
                const e = t._propertyBindings;
                for(let n = 0, s = e.length; n !== s; ++n){
                    const r = e[n];
                    --r.useCount === 0 && (r.restoreOriginalState(), this._takeBackBinding(r));
                }
                this._takeBackAction(t);
            }
        }
        _initMemoryManager() {
            this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
            const t = this;
            this.stats = {
                actions: {
                    get total () {
                        return t._actions.length;
                    },
                    get inUse () {
                        return t._nActiveActions;
                    }
                },
                bindings: {
                    get total () {
                        return t._bindings.length;
                    },
                    get inUse () {
                        return t._nActiveBindings;
                    }
                },
                controlInterpolants: {
                    get total () {
                        return t._controlInterpolants.length;
                    },
                    get inUse () {
                        return t._nActiveControlInterpolants;
                    }
                }
            };
        }
        _isActiveAction(t) {
            const e = t._cacheIndex;
            return e !== null && e < this._nActiveActions;
        }
        _addInactiveAction(t, e, n) {
            const s = this._actions, r = this._actionsByClip;
            let a = r[e];
            if (a === void 0) a = {
                knownActions: [
                    t
                ],
                actionByRoot: {}
            }, t._byClipCacheIndex = 0, r[e] = a;
            else {
                const o = a.knownActions;
                t._byClipCacheIndex = o.length, o.push(t);
            }
            t._cacheIndex = s.length, s.push(t), a.actionByRoot[n] = t;
        }
        _removeInactiveAction(t) {
            const e = this._actions, n = e[e.length - 1], s = t._cacheIndex;
            n._cacheIndex = s, e[s] = n, e.pop(), t._cacheIndex = null;
            const r = t._clip.uuid, a = this._actionsByClip, o = a[r], c = o.knownActions, l = c[c.length - 1], h = t._byClipCacheIndex;
            l._byClipCacheIndex = h, c[h] = l, c.pop(), t._byClipCacheIndex = null;
            const u = o.actionByRoot, d = (t._localRoot || this._root).uuid;
            delete u[d], c.length === 0 && delete a[r], this._removeInactiveBindingsForAction(t);
        }
        _removeInactiveBindingsForAction(t) {
            const e = t._propertyBindings;
            for(let n = 0, s = e.length; n !== s; ++n){
                const r = e[n];
                --r.referenceCount === 0 && this._removeInactiveBinding(r);
            }
        }
        _lendAction(t) {
            const e = this._actions, n = t._cacheIndex, s = this._nActiveActions++, r = e[s];
            t._cacheIndex = s, e[s] = t, r._cacheIndex = n, e[n] = r;
        }
        _takeBackAction(t) {
            const e = this._actions, n = t._cacheIndex, s = --this._nActiveActions, r = e[s];
            t._cacheIndex = s, e[s] = t, r._cacheIndex = n, e[n] = r;
        }
        _addInactiveBinding(t, e, n) {
            const s = this._bindingsByRootAndName, r = this._bindings;
            let a = s[e];
            a === void 0 && (a = {}, s[e] = a), a[n] = t, t._cacheIndex = r.length, r.push(t);
        }
        _removeInactiveBinding(t) {
            const e = this._bindings, n = t.binding, s = n.rootNode.uuid, r = n.path, a = this._bindingsByRootAndName, o = a[s], c = e[e.length - 1], l = t._cacheIndex;
            c._cacheIndex = l, e[l] = c, e.pop(), delete o[r], Object.keys(o).length === 0 && delete a[s];
        }
        _lendBinding(t) {
            const e = this._bindings, n = t._cacheIndex, s = this._nActiveBindings++, r = e[s];
            t._cacheIndex = s, e[s] = t, r._cacheIndex = n, e[n] = r;
        }
        _takeBackBinding(t) {
            const e = this._bindings, n = t._cacheIndex, s = --this._nActiveBindings, r = e[s];
            t._cacheIndex = s, e[s] = t, r._cacheIndex = n, e[n] = r;
        }
        _lendControlInterpolant() {
            const t = this._controlInterpolants, e = this._nActiveControlInterpolants++;
            let n = t[e];
            return n === void 0 && (n = new Kf(new Float32Array(2), new Float32Array(2), 1, $x), n.__cacheIndex = e, t[e] = n), n;
        }
        _takeBackControlInterpolant(t) {
            const e = this._controlInterpolants, n = t.__cacheIndex, s = --this._nActiveControlInterpolants, r = e[s];
            t.__cacheIndex = s, e[s] = t, r.__cacheIndex = n, e[n] = r;
        }
        clipAction(t, e, n) {
            const s = e || this._root, r = s.uuid;
            let a = typeof t == "string" ? cl.findByName(s, t) : t;
            const o = a !== null ? a.uuid : t, c = this._actionsByClip[o];
            let l = null;
            if (n === void 0 && (a !== null ? n = a.blendMode : n = Wl), c !== void 0) {
                const u = c.actionByRoot[r];
                if (u !== void 0 && u.blendMode === n) return u;
                l = c.knownActions[0], a === null && (a = l._clip);
            }
            if (a === null) return null;
            const h = new jx(this, a, e, n);
            return this._bindAction(h, l), this._addInactiveAction(h, o, r), h;
        }
        existingAction(t, e) {
            const n = e || this._root, s = n.uuid, r = typeof t == "string" ? cl.findByName(n, t) : t, a = r ? r.uuid : t, o = this._actionsByClip[a];
            return o !== void 0 && o.actionByRoot[s] || null;
        }
        stopAllAction() {
            const t = this._actions, e = this._nActiveActions;
            for(let n = e - 1; n >= 0; --n)t[n].stop();
            return this;
        }
        update(t) {
            t *= this.timeScale;
            const e = this._actions, n = this._nActiveActions, s = this.time += t, r = Math.sign(t), a = this._accuIndex ^= 1;
            for(let l = 0; l !== n; ++l)e[l]._update(s, t, r, a);
            const o = this._bindings, c = this._nActiveBindings;
            for(let l = 0; l !== c; ++l)o[l].apply(a);
            return this;
        }
        setTime(t) {
            this.time = 0;
            for(let e = 0; e < this._actions.length; e++)this._actions[e].time = 0;
            return this.update(t);
        }
        getRoot() {
            return this._root;
        }
        uncacheClip(t) {
            const e = this._actions, n = t.uuid, s = this._actionsByClip, r = s[n];
            if (r !== void 0) {
                const a = r.knownActions;
                for(let o = 0, c = a.length; o !== c; ++o){
                    const l = a[o];
                    this._deactivateAction(l);
                    const h = l._cacheIndex, u = e[e.length - 1];
                    l._cacheIndex = null, l._byClipCacheIndex = null, u._cacheIndex = h, e[h] = u, e.pop(), this._removeInactiveBindingsForAction(l);
                }
                delete s[n];
            }
        }
        uncacheRoot(t) {
            const e = t.uuid, n = this._actionsByClip;
            for(const a in n){
                const o = n[a].actionByRoot, c = o[e];
                c !== void 0 && (this._deactivateAction(c), this._removeInactiveAction(c));
            }
            const s = this._bindingsByRootAndName, r = s[e];
            if (r !== void 0) for(const a in r){
                const o = r[a];
                o.restoreOriginalState(), this._removeInactiveBinding(o);
            }
        }
        uncacheAction(t, e) {
            const n = this.existingAction(t, e);
            n !== null && (this._deactivateAction(n), this._removeInactiveAction(n));
        }
    }
    function Pu(i, t, e, n) {
        const s = Zx(n);
        switch(e){
            case Af:
                return i * t;
            case Rf:
                return i * t;
            case Cf:
                return i * t * 2;
            case Gl:
                return i * t / s.components * s.byteLength;
            case Hl:
                return i * t / s.components * s.byteLength;
            case Pf:
                return i * t * 2 / s.components * s.byteLength;
            case zl:
                return i * t * 2 / s.components * s.byteLength;
            case wf:
                return i * t * 3 / s.components * s.byteLength;
            case fn:
                return i * t * 4 / s.components * s.byteLength;
            case Vl:
                return i * t * 4 / s.components * s.byteLength;
            case Ea:
            case Aa:
                return Math.floor((i + 3) / 4) * Math.floor((t + 3) / 4) * 8;
            case wa:
            case Ra:
                return Math.floor((i + 3) / 4) * Math.floor((t + 3) / 4) * 16;
            case Dc:
            case Uc:
                return Math.max(i, 16) * Math.max(t, 8) / 4;
            case Ic:
            case Lc:
                return Math.max(i, 8) * Math.max(t, 8) / 2;
            case Nc:
            case Bc:
                return Math.floor((i + 3) / 4) * Math.floor((t + 3) / 4) * 8;
            case Fc:
                return Math.floor((i + 3) / 4) * Math.floor((t + 3) / 4) * 16;
            case Oc:
                return Math.floor((i + 3) / 4) * Math.floor((t + 3) / 4) * 16;
            case kc:
                return Math.floor((i + 4) / 5) * Math.floor((t + 3) / 4) * 16;
            case Gc:
                return Math.floor((i + 4) / 5) * Math.floor((t + 4) / 5) * 16;
            case Hc:
                return Math.floor((i + 5) / 6) * Math.floor((t + 4) / 5) * 16;
            case zc:
                return Math.floor((i + 5) / 6) * Math.floor((t + 5) / 6) * 16;
            case Vc:
                return Math.floor((i + 7) / 8) * Math.floor((t + 4) / 5) * 16;
            case Wc:
                return Math.floor((i + 7) / 8) * Math.floor((t + 5) / 6) * 16;
            case Xc:
                return Math.floor((i + 7) / 8) * Math.floor((t + 7) / 8) * 16;
            case Yc:
                return Math.floor((i + 9) / 10) * Math.floor((t + 4) / 5) * 16;
            case qc:
                return Math.floor((i + 9) / 10) * Math.floor((t + 5) / 6) * 16;
            case jc:
                return Math.floor((i + 9) / 10) * Math.floor((t + 7) / 8) * 16;
            case $c:
                return Math.floor((i + 9) / 10) * Math.floor((t + 9) / 10) * 16;
            case Kc:
                return Math.floor((i + 11) / 12) * Math.floor((t + 9) / 10) * 16;
            case Zc:
                return Math.floor((i + 11) / 12) * Math.floor((t + 11) / 12) * 16;
            case Ca:
            case Jc:
            case Qc:
                return Math.ceil(i / 4) * Math.ceil(t / 4) * 16;
            case If:
            case tl:
                return Math.ceil(i / 4) * Math.ceil(t / 4) * 8;
            case el:
            case nl:
                return Math.ceil(i / 4) * Math.ceil(t / 4) * 16;
        }
        throw new Error(`Unable to determine texture byte length for ${e} format.`);
    }
    function Zx(i) {
        switch(i){
            case si:
            case Mf:
                return {
                    byteLength: 1,
                    components: 1
                };
            case Tr:
            case Tf:
            case Ur:
                return {
                    byteLength: 2,
                    components: 1
                };
            case Ol:
            case kl:
                return {
                    byteLength: 2,
                    components: 4
                };
            case Vi:
            case Fl:
            case An:
                return {
                    byteLength: 4,
                    components: 1
                };
            case Ef:
                return {
                    byteLength: 4,
                    components: 3
                };
        }
        throw new Error(`Unknown texture type ${i}.`);
    }
    typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
        detail: {
            revision: Bl
        }
    }));
    typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Bl);
    function tp() {
        let i = null, t = !1, e = null, n = null;
        function s(r, a) {
            e(r, a), n = i.requestAnimationFrame(s);
        }
        return {
            start: function() {
                t !== !0 && e !== null && (n = i.requestAnimationFrame(s), t = !0);
            },
            stop: function() {
                i.cancelAnimationFrame(n), t = !1;
            },
            setAnimationLoop: function(r) {
                e = r;
            },
            setContext: function(r) {
                i = r;
            }
        };
    }
    function Jx(i) {
        const t = new WeakMap;
        function e(o, c) {
            const l = o.array, h = o.usage, u = l.byteLength, d = i.createBuffer();
            i.bindBuffer(c, d), i.bufferData(c, l, h), o.onUploadCallback();
            let f;
            if (l instanceof Float32Array) f = i.FLOAT;
            else if (l instanceof Uint16Array) o.isFloat16BufferAttribute ? f = i.HALF_FLOAT : f = i.UNSIGNED_SHORT;
            else if (l instanceof Int16Array) f = i.SHORT;
            else if (l instanceof Uint32Array) f = i.UNSIGNED_INT;
            else if (l instanceof Int32Array) f = i.INT;
            else if (l instanceof Int8Array) f = i.BYTE;
            else if (l instanceof Uint8Array) f = i.UNSIGNED_BYTE;
            else if (l instanceof Uint8ClampedArray) f = i.UNSIGNED_BYTE;
            else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + l);
            return {
                buffer: d,
                type: f,
                bytesPerElement: l.BYTES_PER_ELEMENT,
                version: o.version,
                size: u
            };
        }
        function n(o, c, l) {
            const h = c.array, u = c.updateRanges;
            if (i.bindBuffer(l, o), u.length === 0) i.bufferSubData(l, 0, h);
            else {
                u.sort((f, _)=>f.start - _.start);
                let d = 0;
                for(let f = 1; f < u.length; f++){
                    const _ = u[d], g = u[f];
                    g.start <= _.start + _.count + 1 ? _.count = Math.max(_.count, g.start + g.count - _.start) : (++d, u[d] = g);
                }
                u.length = d + 1;
                for(let f = 0, _ = u.length; f < _; f++){
                    const g = u[f];
                    i.bufferSubData(l, g.start * h.BYTES_PER_ELEMENT, h, g.start, g.count);
                }
                c.clearUpdateRanges();
            }
            c.onUploadCallback();
        }
        function s(o) {
            return o.isInterleavedBufferAttribute && (o = o.data), t.get(o);
        }
        function r(o) {
            o.isInterleavedBufferAttribute && (o = o.data);
            const c = t.get(o);
            c && (i.deleteBuffer(c.buffer), t.delete(o));
        }
        function a(o, c) {
            if (o.isInterleavedBufferAttribute && (o = o.data), o.isGLBufferAttribute) {
                const h = t.get(o);
                (!h || h.version < o.version) && t.set(o, {
                    buffer: o.buffer,
                    type: o.type,
                    bytesPerElement: o.elementSize,
                    version: o.version
                });
                return;
            }
            const l = t.get(o);
            if (l === void 0) t.set(o, e(o, c));
            else if (l.version < o.version) {
                if (l.size !== o.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
                n(l.buffer, o, c), l.version = o.version;
            }
        }
        return {
            get: s,
            remove: r,
            update: a
        };
    }
    var Qx = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, t0 = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, e0 = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, n0 = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, i0 = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, s0 = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, r0 = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, a0 = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, o0 = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`, c0 = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`, l0 = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, h0 = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, u0 = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, d0 = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, f0 = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, p0 = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, m0 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, _0 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, g0 = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, x0 = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, v0 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, y0 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`, b0 = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`, S0 = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, M0 = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, T0 = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, E0 = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, A0 = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, w0 = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, R0 = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, C0 = "gl_FragColor = linearToOutputTexel( gl_FragColor );", P0 = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, I0 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, D0 = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, L0 = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, U0 = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, N0 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, B0 = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, F0 = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, O0 = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, k0 = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, G0 = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, H0 = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, z0 = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, V0 = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, W0 = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, X0 = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, Y0 = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, q0 = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, j0 = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, $0 = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, K0 = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, Z0 = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, J0 = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, Q0 = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, tv = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, ev = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, nv = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, iv = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, sv = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, rv = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, av = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, ov = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, cv = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, lv = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, hv = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, uv = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, dv = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, fv = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, pv = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`, mv = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, _v = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, gv = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, xv = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, vv = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, yv = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, bv = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, Sv = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, Mv = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, Tv = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, Ev = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, Av = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, wv = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, Rv = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, Cv = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, Pv = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, Iv = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, Dv = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, Lv = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, Uv = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`, Nv = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, Bv = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, Fv = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, Ov = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, kv = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, Gv = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, Hv = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, zv = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, Vv = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, Wv = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, Xv = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, Yv = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, qv = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, jv = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, $v = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, Kv = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, Zv = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
    const Jv = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, Qv = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, ty = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, ey = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, ny = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, iy = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, sy = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, ry = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`, ay = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, oy = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, cy = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, ly = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, hy = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, uy = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, dy = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, fy = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, py = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, my = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, _y = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, gy = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, xy = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, vy = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, yy = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, by = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Sy = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, My = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Ty = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Ey = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Ay = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, wy = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, Ry = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Cy = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, Py = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, Iy = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, Vt = {
        alphahash_fragment: Qx,
        alphahash_pars_fragment: t0,
        alphamap_fragment: e0,
        alphamap_pars_fragment: n0,
        alphatest_fragment: i0,
        alphatest_pars_fragment: s0,
        aomap_fragment: r0,
        aomap_pars_fragment: a0,
        batching_pars_vertex: o0,
        batching_vertex: c0,
        begin_vertex: l0,
        beginnormal_vertex: h0,
        bsdfs: u0,
        iridescence_fragment: d0,
        bumpmap_pars_fragment: f0,
        clipping_planes_fragment: p0,
        clipping_planes_pars_fragment: m0,
        clipping_planes_pars_vertex: _0,
        clipping_planes_vertex: g0,
        color_fragment: x0,
        color_pars_fragment: v0,
        color_pars_vertex: y0,
        color_vertex: b0,
        common: S0,
        cube_uv_reflection_fragment: M0,
        defaultnormal_vertex: T0,
        displacementmap_pars_vertex: E0,
        displacementmap_vertex: A0,
        emissivemap_fragment: w0,
        emissivemap_pars_fragment: R0,
        colorspace_fragment: C0,
        colorspace_pars_fragment: P0,
        envmap_fragment: I0,
        envmap_common_pars_fragment: D0,
        envmap_pars_fragment: L0,
        envmap_pars_vertex: U0,
        envmap_physical_pars_fragment: X0,
        envmap_vertex: N0,
        fog_vertex: B0,
        fog_pars_vertex: F0,
        fog_fragment: O0,
        fog_pars_fragment: k0,
        gradientmap_pars_fragment: G0,
        lightmap_pars_fragment: H0,
        lights_lambert_fragment: z0,
        lights_lambert_pars_fragment: V0,
        lights_pars_begin: W0,
        lights_toon_fragment: Y0,
        lights_toon_pars_fragment: q0,
        lights_phong_fragment: j0,
        lights_phong_pars_fragment: $0,
        lights_physical_fragment: K0,
        lights_physical_pars_fragment: Z0,
        lights_fragment_begin: J0,
        lights_fragment_maps: Q0,
        lights_fragment_end: tv,
        logdepthbuf_fragment: ev,
        logdepthbuf_pars_fragment: nv,
        logdepthbuf_pars_vertex: iv,
        logdepthbuf_vertex: sv,
        map_fragment: rv,
        map_pars_fragment: av,
        map_particle_fragment: ov,
        map_particle_pars_fragment: cv,
        metalnessmap_fragment: lv,
        metalnessmap_pars_fragment: hv,
        morphinstance_vertex: uv,
        morphcolor_vertex: dv,
        morphnormal_vertex: fv,
        morphtarget_pars_vertex: pv,
        morphtarget_vertex: mv,
        normal_fragment_begin: _v,
        normal_fragment_maps: gv,
        normal_pars_fragment: xv,
        normal_pars_vertex: vv,
        normal_vertex: yv,
        normalmap_pars_fragment: bv,
        clearcoat_normal_fragment_begin: Sv,
        clearcoat_normal_fragment_maps: Mv,
        clearcoat_pars_fragment: Tv,
        iridescence_pars_fragment: Ev,
        opaque_fragment: Av,
        packing: wv,
        premultiplied_alpha_fragment: Rv,
        project_vertex: Cv,
        dithering_fragment: Pv,
        dithering_pars_fragment: Iv,
        roughnessmap_fragment: Dv,
        roughnessmap_pars_fragment: Lv,
        shadowmap_pars_fragment: Uv,
        shadowmap_pars_vertex: Nv,
        shadowmap_vertex: Bv,
        shadowmask_pars_fragment: Fv,
        skinbase_vertex: Ov,
        skinning_pars_vertex: kv,
        skinning_vertex: Gv,
        skinnormal_vertex: Hv,
        specularmap_fragment: zv,
        specularmap_pars_fragment: Vv,
        tonemapping_fragment: Wv,
        tonemapping_pars_fragment: Xv,
        transmission_fragment: Yv,
        transmission_pars_fragment: qv,
        uv_pars_fragment: jv,
        uv_pars_vertex: $v,
        uv_vertex: Kv,
        worldpos_vertex: Zv,
        background_vert: Jv,
        background_frag: Qv,
        backgroundCube_vert: ty,
        backgroundCube_frag: ey,
        cube_vert: ny,
        cube_frag: iy,
        depth_vert: sy,
        depth_frag: ry,
        distanceRGBA_vert: ay,
        distanceRGBA_frag: oy,
        equirect_vert: cy,
        equirect_frag: ly,
        linedashed_vert: hy,
        linedashed_frag: uy,
        meshbasic_vert: dy,
        meshbasic_frag: fy,
        meshlambert_vert: py,
        meshlambert_frag: my,
        meshmatcap_vert: _y,
        meshmatcap_frag: gy,
        meshnormal_vert: xy,
        meshnormal_frag: vy,
        meshphong_vert: yy,
        meshphong_frag: by,
        meshphysical_vert: Sy,
        meshphysical_frag: My,
        meshtoon_vert: Ty,
        meshtoon_frag: Ey,
        points_vert: Ay,
        points_frag: wy,
        shadow_vert: Ry,
        shadow_frag: Cy,
        sprite_vert: Py,
        sprite_frag: Iy
    }, ut = {
        common: {
            diffuse: {
                value: new Bt(16777215)
            },
            opacity: {
                value: 1
            },
            map: {
                value: null
            },
            mapTransform: {
                value: new Gt
            },
            alphaMap: {
                value: null
            },
            alphaMapTransform: {
                value: new Gt
            },
            alphaTest: {
                value: 0
            }
        },
        specularmap: {
            specularMap: {
                value: null
            },
            specularMapTransform: {
                value: new Gt
            }
        },
        envmap: {
            envMap: {
                value: null
            },
            envMapRotation: {
                value: new Gt
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1
            },
            ior: {
                value: 1.5
            },
            refractionRatio: {
                value: .98
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            },
            aoMapTransform: {
                value: new Gt
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            },
            lightMapTransform: {
                value: new Gt
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpMapTransform: {
                value: new Gt
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalMapTransform: {
                value: new Gt
            },
            normalScale: {
                value: new Kt(1, 1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementMapTransform: {
                value: new Gt
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            },
            emissiveMapTransform: {
                value: new Gt
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            },
            metalnessMapTransform: {
                value: new Gt
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            },
            roughnessMapTransform: {
                value: new Gt
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 25e-5
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2e3
            },
            fogColor: {
                value: new Bt(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            lightProbe: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {},
                    color: {}
                }
            },
            directionalLightShadows: {
                value: [],
                properties: {
                    shadowIntensity: 1,
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {}
                }
            },
            spotLightShadows: {
                value: [],
                properties: {
                    shadowIntensity: 1,
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotLightMap: {
                value: []
            },
            spotShadowMap: {
                value: []
            },
            spotLightMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {}
                }
            },
            pointLightShadows: {
                value: [],
                properties: {
                    shadowIntensity: 1,
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            },
            rectAreaLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            },
            ltc_1: {
                value: null
            },
            ltc_2: {
                value: null
            }
        },
        points: {
            diffuse: {
                value: new Bt(16777215)
            },
            opacity: {
                value: 1
            },
            size: {
                value: 1
            },
            scale: {
                value: 1
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            alphaMapTransform: {
                value: new Gt
            },
            alphaTest: {
                value: 0
            },
            uvTransform: {
                value: new Gt
            }
        },
        sprite: {
            diffuse: {
                value: new Bt(16777215)
            },
            opacity: {
                value: 1
            },
            center: {
                value: new Kt(.5, .5)
            },
            rotation: {
                value: 0
            },
            map: {
                value: null
            },
            mapTransform: {
                value: new Gt
            },
            alphaMap: {
                value: null
            },
            alphaMapTransform: {
                value: new Gt
            },
            alphaTest: {
                value: 0
            }
        }
    }, Nn = {
        basic: {
            uniforms: Ve([
                ut.common,
                ut.specularmap,
                ut.envmap,
                ut.aomap,
                ut.lightmap,
                ut.fog
            ]),
            vertexShader: Vt.meshbasic_vert,
            fragmentShader: Vt.meshbasic_frag
        },
        lambert: {
            uniforms: Ve([
                ut.common,
                ut.specularmap,
                ut.envmap,
                ut.aomap,
                ut.lightmap,
                ut.emissivemap,
                ut.bumpmap,
                ut.normalmap,
                ut.displacementmap,
                ut.fog,
                ut.lights,
                {
                    emissive: {
                        value: new Bt(0)
                    }
                }
            ]),
            vertexShader: Vt.meshlambert_vert,
            fragmentShader: Vt.meshlambert_frag
        },
        phong: {
            uniforms: Ve([
                ut.common,
                ut.specularmap,
                ut.envmap,
                ut.aomap,
                ut.lightmap,
                ut.emissivemap,
                ut.bumpmap,
                ut.normalmap,
                ut.displacementmap,
                ut.fog,
                ut.lights,
                {
                    emissive: {
                        value: new Bt(0)
                    },
                    specular: {
                        value: new Bt(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }
            ]),
            vertexShader: Vt.meshphong_vert,
            fragmentShader: Vt.meshphong_frag
        },
        standard: {
            uniforms: Ve([
                ut.common,
                ut.envmap,
                ut.aomap,
                ut.lightmap,
                ut.emissivemap,
                ut.bumpmap,
                ut.normalmap,
                ut.displacementmap,
                ut.roughnessmap,
                ut.metalnessmap,
                ut.fog,
                ut.lights,
                {
                    emissive: {
                        value: new Bt(0)
                    },
                    roughness: {
                        value: 1
                    },
                    metalness: {
                        value: 0
                    },
                    envMapIntensity: {
                        value: 1
                    }
                }
            ]),
            vertexShader: Vt.meshphysical_vert,
            fragmentShader: Vt.meshphysical_frag
        },
        toon: {
            uniforms: Ve([
                ut.common,
                ut.aomap,
                ut.lightmap,
                ut.emissivemap,
                ut.bumpmap,
                ut.normalmap,
                ut.displacementmap,
                ut.gradientmap,
                ut.fog,
                ut.lights,
                {
                    emissive: {
                        value: new Bt(0)
                    }
                }
            ]),
            vertexShader: Vt.meshtoon_vert,
            fragmentShader: Vt.meshtoon_frag
        },
        matcap: {
            uniforms: Ve([
                ut.common,
                ut.bumpmap,
                ut.normalmap,
                ut.displacementmap,
                ut.fog,
                {
                    matcap: {
                        value: null
                    }
                }
            ]),
            vertexShader: Vt.meshmatcap_vert,
            fragmentShader: Vt.meshmatcap_frag
        },
        points: {
            uniforms: Ve([
                ut.points,
                ut.fog
            ]),
            vertexShader: Vt.points_vert,
            fragmentShader: Vt.points_frag
        },
        dashed: {
            uniforms: Ve([
                ut.common,
                ut.fog,
                {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }
            ]),
            vertexShader: Vt.linedashed_vert,
            fragmentShader: Vt.linedashed_frag
        },
        depth: {
            uniforms: Ve([
                ut.common,
                ut.displacementmap
            ]),
            vertexShader: Vt.depth_vert,
            fragmentShader: Vt.depth_frag
        },
        normal: {
            uniforms: Ve([
                ut.common,
                ut.bumpmap,
                ut.normalmap,
                ut.displacementmap,
                {
                    opacity: {
                        value: 1
                    }
                }
            ]),
            vertexShader: Vt.meshnormal_vert,
            fragmentShader: Vt.meshnormal_frag
        },
        sprite: {
            uniforms: Ve([
                ut.sprite,
                ut.fog
            ]),
            vertexShader: Vt.sprite_vert,
            fragmentShader: Vt.sprite_frag
        },
        background: {
            uniforms: {
                uvTransform: {
                    value: new Gt
                },
                t2D: {
                    value: null
                },
                backgroundIntensity: {
                    value: 1
                }
            },
            vertexShader: Vt.background_vert,
            fragmentShader: Vt.background_frag
        },
        backgroundCube: {
            uniforms: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                },
                backgroundBlurriness: {
                    value: 0
                },
                backgroundIntensity: {
                    value: 1
                },
                backgroundRotation: {
                    value: new Gt
                }
            },
            vertexShader: Vt.backgroundCube_vert,
            fragmentShader: Vt.backgroundCube_frag
        },
        cube: {
            uniforms: {
                tCube: {
                    value: null
                },
                tFlip: {
                    value: -1
                },
                opacity: {
                    value: 1
                }
            },
            vertexShader: Vt.cube_vert,
            fragmentShader: Vt.cube_frag
        },
        equirect: {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: Vt.equirect_vert,
            fragmentShader: Vt.equirect_frag
        },
        distanceRGBA: {
            uniforms: Ve([
                ut.common,
                ut.displacementmap,
                {
                    referencePosition: {
                        value: new k
                    },
                    nearDistance: {
                        value: 1
                    },
                    farDistance: {
                        value: 1e3
                    }
                }
            ]),
            vertexShader: Vt.distanceRGBA_vert,
            fragmentShader: Vt.distanceRGBA_frag
        },
        shadow: {
            uniforms: Ve([
                ut.lights,
                ut.fog,
                {
                    color: {
                        value: new Bt(0)
                    },
                    opacity: {
                        value: 1
                    }
                }
            ]),
            vertexShader: Vt.shadow_vert,
            fragmentShader: Vt.shadow_frag
        }
    };
    Nn.physical = {
        uniforms: Ve([
            Nn.standard.uniforms,
            {
                clearcoat: {
                    value: 0
                },
                clearcoatMap: {
                    value: null
                },
                clearcoatMapTransform: {
                    value: new Gt
                },
                clearcoatNormalMap: {
                    value: null
                },
                clearcoatNormalMapTransform: {
                    value: new Gt
                },
                clearcoatNormalScale: {
                    value: new Kt(1, 1)
                },
                clearcoatRoughness: {
                    value: 0
                },
                clearcoatRoughnessMap: {
                    value: null
                },
                clearcoatRoughnessMapTransform: {
                    value: new Gt
                },
                dispersion: {
                    value: 0
                },
                iridescence: {
                    value: 0
                },
                iridescenceMap: {
                    value: null
                },
                iridescenceMapTransform: {
                    value: new Gt
                },
                iridescenceIOR: {
                    value: 1.3
                },
                iridescenceThicknessMinimum: {
                    value: 100
                },
                iridescenceThicknessMaximum: {
                    value: 400
                },
                iridescenceThicknessMap: {
                    value: null
                },
                iridescenceThicknessMapTransform: {
                    value: new Gt
                },
                sheen: {
                    value: 0
                },
                sheenColor: {
                    value: new Bt(0)
                },
                sheenColorMap: {
                    value: null
                },
                sheenColorMapTransform: {
                    value: new Gt
                },
                sheenRoughness: {
                    value: 1
                },
                sheenRoughnessMap: {
                    value: null
                },
                sheenRoughnessMapTransform: {
                    value: new Gt
                },
                transmission: {
                    value: 0
                },
                transmissionMap: {
                    value: null
                },
                transmissionMapTransform: {
                    value: new Gt
                },
                transmissionSamplerSize: {
                    value: new Kt
                },
                transmissionSamplerMap: {
                    value: null
                },
                thickness: {
                    value: 0
                },
                thicknessMap: {
                    value: null
                },
                thicknessMapTransform: {
                    value: new Gt
                },
                attenuationDistance: {
                    value: 0
                },
                attenuationColor: {
                    value: new Bt(0)
                },
                specularColor: {
                    value: new Bt(1, 1, 1)
                },
                specularColorMap: {
                    value: null
                },
                specularColorMapTransform: {
                    value: new Gt
                },
                specularIntensity: {
                    value: 1
                },
                specularIntensityMap: {
                    value: null
                },
                specularIntensityMapTransform: {
                    value: new Gt
                },
                anisotropyVector: {
                    value: new Kt
                },
                anisotropyMap: {
                    value: null
                },
                anisotropyMapTransform: {
                    value: new Gt
                }
            }
        ]),
        vertexShader: Vt.meshphysical_vert,
        fragmentShader: Vt.meshphysical_frag
    };
    const ha = {
        r: 0,
        b: 0,
        g: 0
    }, wi = new Fn, Dy = new Ht;
    function Ly(i, t, e, n, s, r, a) {
        const o = new Bt(0);
        let c = r === !0 ? 0 : 1, l, h, u = null, d = 0, f = null;
        function _(y) {
            let v = y.isScene === !0 ? y.background : null;
            return v && v.isTexture && (v = (y.backgroundBlurriness > 0 ? e : t).get(v)), v;
        }
        function g(y) {
            let v = !1;
            const I = _(y);
            I === null ? m(o, c) : I && I.isColor && (m(I, 1), v = !0);
            const w = i.xr.getEnvironmentBlendMode();
            w === "additive" ? n.buffers.color.setClear(0, 0, 0, 1, a) : w === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, a), (i.autoClear || v) && (n.buffers.depth.setTest(!0), n.buffers.depth.setMask(!0), n.buffers.color.setMask(!0), i.clear(i.autoClearColor, i.autoClearDepth, i.autoClearStencil));
        }
        function p(y, v) {
            const I = _(v);
            I && (I.isCubeTexture || I.mapping === qa) ? (h === void 0 && (h = new Le(new Hs(1, 1, 1), new yi({
                name: "BackgroundCubeMaterial",
                uniforms: Ls(Nn.backgroundCube.uniforms),
                vertexShader: Nn.backgroundCube.vertexShader,
                fragmentShader: Nn.backgroundCube.fragmentShader,
                side: Qe,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
                allowOverride: !1
            })), h.geometry.deleteAttribute("normal"), h.geometry.deleteAttribute("uv"), h.onBeforeRender = function(w, R, N) {
                this.matrixWorld.copyPosition(N.matrixWorld);
            }, Object.defineProperty(h.material, "envMap", {
                get: function() {
                    return this.uniforms.envMap.value;
                }
            }), s.update(h)), wi.copy(v.backgroundRotation), wi.x *= -1, wi.y *= -1, wi.z *= -1, I.isCubeTexture && I.isRenderTargetTexture === !1 && (wi.y *= -1, wi.z *= -1), h.material.uniforms.envMap.value = I, h.material.uniforms.flipEnvMap.value = I.isCubeTexture && I.isRenderTargetTexture === !1 ? -1 : 1, h.material.uniforms.backgroundBlurriness.value = v.backgroundBlurriness, h.material.uniforms.backgroundIntensity.value = v.backgroundIntensity, h.material.uniforms.backgroundRotation.value.setFromMatrix4(Dy.makeRotationFromEuler(wi)), h.material.toneMapped = $t.getTransfer(I.colorSpace) !== ce, (u !== I || d !== I.version || f !== i.toneMapping) && (h.material.needsUpdate = !0, u = I, d = I.version, f = i.toneMapping), h.layers.enableAll(), y.unshift(h, h.geometry, h.material, 0, 0, null)) : I && I.isTexture && (l === void 0 && (l = new Le(new zs(2, 2), new yi({
                name: "BackgroundMaterial",
                uniforms: Ls(Nn.background.uniforms),
                vertexShader: Nn.background.vertexShader,
                fragmentShader: Nn.background.fragmentShader,
                side: ii,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
                allowOverride: !1
            })), l.geometry.deleteAttribute("normal"), Object.defineProperty(l.material, "map", {
                get: function() {
                    return this.uniforms.t2D.value;
                }
            }), s.update(l)), l.material.uniforms.t2D.value = I, l.material.uniforms.backgroundIntensity.value = v.backgroundIntensity, l.material.toneMapped = $t.getTransfer(I.colorSpace) !== ce, I.matrixAutoUpdate === !0 && I.updateMatrix(), l.material.uniforms.uvTransform.value.copy(I.matrix), (u !== I || d !== I.version || f !== i.toneMapping) && (l.material.needsUpdate = !0, u = I, d = I.version, f = i.toneMapping), l.layers.enableAll(), y.unshift(l, l.geometry, l.material, 0, 0, null));
        }
        function m(y, v) {
            y.getRGB(ha, Hf(i)), n.buffers.color.setClear(ha.r, ha.g, ha.b, v, a);
        }
        function x() {
            h !== void 0 && (h.geometry.dispose(), h.material.dispose(), h = void 0), l !== void 0 && (l.geometry.dispose(), l.material.dispose(), l = void 0);
        }
        return {
            getClearColor: function() {
                return o;
            },
            setClearColor: function(y, v = 1) {
                o.set(y), c = v, m(o, c);
            },
            getClearAlpha: function() {
                return c;
            },
            setClearAlpha: function(y) {
                c = y, m(o, c);
            },
            render: g,
            addToRenderList: p,
            dispose: x
        };
    }
    function Uy(i, t) {
        const e = i.getParameter(i.MAX_VERTEX_ATTRIBS), n = {}, s = d(null);
        let r = s, a = !1;
        function o(S, D, j, z, K) {
            let nt = !1;
            const b = u(z, j, D);
            r !== b && (r = b, l(r.object)), nt = f(S, z, j, K), nt && _(S, z, j, K), K !== null && t.update(K, i.ELEMENT_ARRAY_BUFFER), (nt || a) && (a = !1, v(S, D, j, z), K !== null && i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, t.get(K).buffer));
        }
        function c() {
            return i.createVertexArray();
        }
        function l(S) {
            return i.bindVertexArray(S);
        }
        function h(S) {
            return i.deleteVertexArray(S);
        }
        function u(S, D, j) {
            const z = j.wireframe === !0;
            let K = n[S.id];
            K === void 0 && (K = {}, n[S.id] = K);
            let nt = K[D.id];
            nt === void 0 && (nt = {}, K[D.id] = nt);
            let b = nt[z];
            return b === void 0 && (b = d(c()), nt[z] = b), b;
        }
        function d(S) {
            const D = [], j = [], z = [];
            for(let K = 0; K < e; K++)D[K] = 0, j[K] = 0, z[K] = 0;
            return {
                geometry: null,
                program: null,
                wireframe: !1,
                newAttributes: D,
                enabledAttributes: j,
                attributeDivisors: z,
                object: S,
                attributes: {},
                index: null
            };
        }
        function f(S, D, j, z) {
            const K = r.attributes, nt = D.attributes;
            let b = 0;
            const C = j.getAttributes();
            for(const A in C)if (C[A].location >= 0) {
                const B = K[A];
                let V = nt[A];
                if (V === void 0 && (A === "instanceMatrix" && S.instanceMatrix && (V = S.instanceMatrix), A === "instanceColor" && S.instanceColor && (V = S.instanceColor)), B === void 0 || B.attribute !== V || V && B.data !== V.data) return !0;
                b++;
            }
            return r.attributesNum !== b || r.index !== z;
        }
        function _(S, D, j, z) {
            const K = {}, nt = D.attributes;
            let b = 0;
            const C = j.getAttributes();
            for(const A in C)if (C[A].location >= 0) {
                let B = nt[A];
                B === void 0 && (A === "instanceMatrix" && S.instanceMatrix && (B = S.instanceMatrix), A === "instanceColor" && S.instanceColor && (B = S.instanceColor));
                const V = {};
                V.attribute = B, B && B.data && (V.data = B.data), K[A] = V, b++;
            }
            r.attributes = K, r.attributesNum = b, r.index = z;
        }
        function g() {
            const S = r.newAttributes;
            for(let D = 0, j = S.length; D < j; D++)S[D] = 0;
        }
        function p(S) {
            m(S, 0);
        }
        function m(S, D) {
            const j = r.newAttributes, z = r.enabledAttributes, K = r.attributeDivisors;
            j[S] = 1, z[S] === 0 && (i.enableVertexAttribArray(S), z[S] = 1), K[S] !== D && (i.vertexAttribDivisor(S, D), K[S] = D);
        }
        function x() {
            const S = r.newAttributes, D = r.enabledAttributes;
            for(let j = 0, z = D.length; j < z; j++)D[j] !== S[j] && (i.disableVertexAttribArray(j), D[j] = 0);
        }
        function y(S, D, j, z, K, nt, b) {
            b === !0 ? i.vertexAttribIPointer(S, D, j, K, nt) : i.vertexAttribPointer(S, D, j, z, K, nt);
        }
        function v(S, D, j, z) {
            g();
            const K = z.attributes, nt = j.getAttributes(), b = D.defaultAttributeValues;
            for(const C in nt){
                const A = nt[C];
                if (A.location >= 0) {
                    let U = K[C];
                    if (U === void 0 && (C === "instanceMatrix" && S.instanceMatrix && (U = S.instanceMatrix), C === "instanceColor" && S.instanceColor && (U = S.instanceColor)), U !== void 0) {
                        const B = U.normalized, V = U.itemSize, q = t.get(U);
                        if (q === void 0) continue;
                        const et = q.buffer, H = q.type, $ = q.bytesPerElement, ot = H === i.INT || H === i.UNSIGNED_INT || U.gpuType === Fl;
                        if (U.isInterleavedBufferAttribute) {
                            const it = U.data, lt = it.stride, wt = U.offset;
                            if (it.isInstancedInterleavedBuffer) {
                                for(let ht = 0; ht < A.locationSize; ht++)m(A.location + ht, it.meshPerAttribute);
                                S.isInstancedMesh !== !0 && z._maxInstanceCount === void 0 && (z._maxInstanceCount = it.meshPerAttribute * it.count);
                            } else for(let ht = 0; ht < A.locationSize; ht++)p(A.location + ht);
                            i.bindBuffer(i.ARRAY_BUFFER, et);
                            for(let ht = 0; ht < A.locationSize; ht++)y(A.location + ht, V / A.locationSize, H, B, lt * $, (wt + V / A.locationSize * ht) * $, ot);
                        } else {
                            if (U.isInstancedBufferAttribute) {
                                for(let it = 0; it < A.locationSize; it++)m(A.location + it, U.meshPerAttribute);
                                S.isInstancedMesh !== !0 && z._maxInstanceCount === void 0 && (z._maxInstanceCount = U.meshPerAttribute * U.count);
                            } else for(let it = 0; it < A.locationSize; it++)p(A.location + it);
                            i.bindBuffer(i.ARRAY_BUFFER, et);
                            for(let it = 0; it < A.locationSize; it++)y(A.location + it, V / A.locationSize, H, B, V * $, V / A.locationSize * it * $, ot);
                        }
                    } else if (b !== void 0) {
                        const B = b[C];
                        if (B !== void 0) switch(B.length){
                            case 2:
                                i.vertexAttrib2fv(A.location, B);
                                break;
                            case 3:
                                i.vertexAttrib3fv(A.location, B);
                                break;
                            case 4:
                                i.vertexAttrib4fv(A.location, B);
                                break;
                            default:
                                i.vertexAttrib1fv(A.location, B);
                        }
                    }
                }
            }
            x();
        }
        function I() {
            N();
            for(const S in n){
                const D = n[S];
                for(const j in D){
                    const z = D[j];
                    for(const K in z)h(z[K].object), delete z[K];
                    delete D[j];
                }
                delete n[S];
            }
        }
        function w(S) {
            if (n[S.id] === void 0) return;
            const D = n[S.id];
            for(const j in D){
                const z = D[j];
                for(const K in z)h(z[K].object), delete z[K];
                delete D[j];
            }
            delete n[S.id];
        }
        function R(S) {
            for(const D in n){
                const j = n[D];
                if (j[S.id] === void 0) continue;
                const z = j[S.id];
                for(const K in z)h(z[K].object), delete z[K];
                delete j[S.id];
            }
        }
        function N() {
            E(), a = !0, r !== s && (r = s, l(r.object));
        }
        function E() {
            s.geometry = null, s.program = null, s.wireframe = !1;
        }
        return {
            setup: o,
            reset: N,
            resetDefaultState: E,
            dispose: I,
            releaseStatesOfGeometry: w,
            releaseStatesOfProgram: R,
            initAttributes: g,
            enableAttribute: p,
            disableUnusedAttributes: x
        };
    }
    function Ny(i, t, e) {
        let n;
        function s(l) {
            n = l;
        }
        function r(l, h) {
            i.drawArrays(n, l, h), e.update(h, n, 1);
        }
        function a(l, h, u) {
            u !== 0 && (i.drawArraysInstanced(n, l, h, u), e.update(h, n, u));
        }
        function o(l, h, u) {
            if (u === 0) return;
            t.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n, l, 0, h, 0, u);
            let f = 0;
            for(let _ = 0; _ < u; _++)f += h[_];
            e.update(f, n, 1);
        }
        function c(l, h, u, d) {
            if (u === 0) return;
            const f = t.get("WEBGL_multi_draw");
            if (f === null) for(let _ = 0; _ < l.length; _++)a(l[_], h[_], d[_]);
            else {
                f.multiDrawArraysInstancedWEBGL(n, l, 0, h, 0, d, 0, u);
                let _ = 0;
                for(let g = 0; g < u; g++)_ += h[g] * d[g];
                e.update(_, n, 1);
            }
        }
        this.setMode = s, this.render = r, this.renderInstances = a, this.renderMultiDraw = o, this.renderMultiDrawInstances = c;
    }
    function By(i, t, e, n) {
        let s;
        function r() {
            if (s !== void 0) return s;
            if (t.has("EXT_texture_filter_anisotropic") === !0) {
                const R = t.get("EXT_texture_filter_anisotropic");
                s = i.getParameter(R.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
            } else s = 0;
            return s;
        }
        function a(R) {
            return !(R !== fn && n.convert(R) !== i.getParameter(i.IMPLEMENTATION_COLOR_READ_FORMAT));
        }
        function o(R) {
            const N = R === Ur && (t.has("EXT_color_buffer_half_float") || t.has("EXT_color_buffer_float"));
            return !(R !== si && n.convert(R) !== i.getParameter(i.IMPLEMENTATION_COLOR_READ_TYPE) && R !== An && !N);
        }
        function c(R) {
            if (R === "highp") {
                if (i.getShaderPrecisionFormat(i.VERTEX_SHADER, i.HIGH_FLOAT).precision > 0 && i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.HIGH_FLOAT).precision > 0) return "highp";
                R = "mediump";
            }
            return R === "mediump" && i.getShaderPrecisionFormat(i.VERTEX_SHADER, i.MEDIUM_FLOAT).precision > 0 && i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
        }
        let l = e.precision !== void 0 ? e.precision : "highp";
        const h = c(l);
        h !== l && (console.warn("THREE.WebGLRenderer:", l, "not supported, using", h, "instead."), l = h);
        const u = e.logarithmicDepthBuffer === !0, d = e.reverseDepthBuffer === !0 && t.has("EXT_clip_control"), f = i.getParameter(i.MAX_TEXTURE_IMAGE_UNITS), _ = i.getParameter(i.MAX_VERTEX_TEXTURE_IMAGE_UNITS), g = i.getParameter(i.MAX_TEXTURE_SIZE), p = i.getParameter(i.MAX_CUBE_MAP_TEXTURE_SIZE), m = i.getParameter(i.MAX_VERTEX_ATTRIBS), x = i.getParameter(i.MAX_VERTEX_UNIFORM_VECTORS), y = i.getParameter(i.MAX_VARYING_VECTORS), v = i.getParameter(i.MAX_FRAGMENT_UNIFORM_VECTORS), I = _ > 0, w = i.getParameter(i.MAX_SAMPLES);
        return {
            isWebGL2: !0,
            getMaxAnisotropy: r,
            getMaxPrecision: c,
            textureFormatReadable: a,
            textureTypeReadable: o,
            precision: l,
            logarithmicDepthBuffer: u,
            reverseDepthBuffer: d,
            maxTextures: f,
            maxVertexTextures: _,
            maxTextureSize: g,
            maxCubemapSize: p,
            maxAttributes: m,
            maxVertexUniforms: x,
            maxVaryings: y,
            maxFragmentUniforms: v,
            vertexTextures: I,
            maxSamples: w
        };
    }
    function Fy(i) {
        const t = this;
        let e = null, n = 0, s = !1, r = !1;
        const a = new Ii, o = new Gt, c = {
            value: null,
            needsUpdate: !1
        };
        this.uniform = c, this.numPlanes = 0, this.numIntersection = 0, this.init = function(u, d) {
            const f = u.length !== 0 || d || n !== 0 || s;
            return s = d, n = u.length, f;
        }, this.beginShadows = function() {
            r = !0, h(null);
        }, this.endShadows = function() {
            r = !1;
        }, this.setGlobalState = function(u, d) {
            e = h(u, d, 0);
        }, this.setState = function(u, d, f) {
            const _ = u.clippingPlanes, g = u.clipIntersection, p = u.clipShadows, m = i.get(u);
            if (!s || _ === null || _.length === 0 || r && !p) r ? h(null) : l();
            else {
                const x = r ? 0 : n, y = x * 4;
                let v = m.clippingState || null;
                c.value = v, v = h(_, d, y, f);
                for(let I = 0; I !== y; ++I)v[I] = e[I];
                m.clippingState = v, this.numIntersection = g ? this.numPlanes : 0, this.numPlanes += x;
            }
        };
        function l() {
            c.value !== e && (c.value = e, c.needsUpdate = n > 0), t.numPlanes = n, t.numIntersection = 0;
        }
        function h(u, d, f, _) {
            const g = u !== null ? u.length : 0;
            let p = null;
            if (g !== 0) {
                if (p = c.value, _ !== !0 || p === null) {
                    const m = f + g * 4, x = d.matrixWorldInverse;
                    o.getNormalMatrix(x), (p === null || p.length < m) && (p = new Float32Array(m));
                    for(let y = 0, v = f; y !== g; ++y, v += 4)a.copy(u[y]).applyMatrix4(x, o), a.normal.toArray(p, v), p[v + 3] = a.constant;
                }
                c.value = p, c.needsUpdate = !0;
            }
            return t.numPlanes = g, t.numIntersection = 0, p;
        }
    }
    function Oy(i) {
        let t = new WeakMap;
        function e(a, o) {
            return o === Cc ? a.mapping = Cs : o === Pc && (a.mapping = Ps), a;
        }
        function n(a) {
            if (a && a.isTexture) {
                const o = a.mapping;
                if (o === Cc || o === Pc) if (t.has(a)) {
                    const c = t.get(a).texture;
                    return e(c, a.mapping);
                } else {
                    const c = a.image;
                    if (c && c.height > 0) {
                        const l = new ix(c.height);
                        return l.fromEquirectangularTexture(i, a), t.set(a, l), a.addEventListener("dispose", s), e(l.texture, a.mapping);
                    } else return null;
                }
            }
            return a;
        }
        function s(a) {
            const o = a.target;
            o.removeEventListener("dispose", s);
            const c = t.get(o);
            c !== void 0 && (t.delete(o), c.dispose());
        }
        function r() {
            t = new WeakMap;
        }
        return {
            get: n,
            dispose: r
        };
    }
    const Ss = 4, Iu = [
        .125,
        .215,
        .35,
        .446,
        .526,
        .582
    ], Oi = 20, Po = new Jl, Du = new Bt;
    let Io = null, Do = 0, Lo = 0, Uo = !1;
    const Di = (1 + Math.sqrt(5)) / 2, ps = 1 / Di, Lu = [
        new k(-Di, ps, 0),
        new k(Di, ps, 0),
        new k(-ps, 0, Di),
        new k(ps, 0, Di),
        new k(0, Di, -ps),
        new k(0, Di, ps),
        new k(-1, 1, -1),
        new k(1, 1, -1),
        new k(-1, 1, 1),
        new k(1, 1, 1)
    ], ky = new k;
    class Uu {
        constructor(t){
            this._renderer = t, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
        }
        fromScene(t, e = 0, n = .1, s = 100, r = {}) {
            const { size: a = 256, position: o = ky } = r;
            Io = this._renderer.getRenderTarget(), Do = this._renderer.getActiveCubeFace(), Lo = this._renderer.getActiveMipmapLevel(), Uo = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(a);
            const c = this._allocateTargets();
            return c.depthBuffer = !0, this._sceneToCubeUV(t, n, s, c, o), e > 0 && this._blur(c, 0, 0, e), this._applyPMREM(c), this._cleanup(c), c;
        }
        fromEquirectangular(t, e = null) {
            return this._fromTexture(t, e);
        }
        fromCubemap(t, e = null) {
            return this._fromTexture(t, e);
        }
        compileCubemapShader() {
            this._cubemapMaterial === null && (this._cubemapMaterial = Fu(), this._compileMaterial(this._cubemapMaterial));
        }
        compileEquirectangularShader() {
            this._equirectMaterial === null && (this._equirectMaterial = Bu(), this._compileMaterial(this._equirectMaterial));
        }
        dispose() {
            this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
        }
        _setSize(t) {
            this._lodMax = Math.floor(Math.log2(t)), this._cubeSize = Math.pow(2, this._lodMax);
        }
        _dispose() {
            this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
            for(let t = 0; t < this._lodPlanes.length; t++)this._lodPlanes[t].dispose();
        }
        _cleanup(t) {
            this._renderer.setRenderTarget(Io, Do, Lo), this._renderer.xr.enabled = Uo, t.scissorTest = !1, ua(t, 0, 0, t.width, t.height);
        }
        _fromTexture(t, e) {
            t.mapping === Cs || t.mapping === Ps ? this._setSize(t.image.length === 0 ? 16 : t.image[0].width || t.image[0].image.width) : this._setSize(t.image.width / 4), Io = this._renderer.getRenderTarget(), Do = this._renderer.getActiveCubeFace(), Lo = this._renderer.getActiveMipmapLevel(), Uo = this._renderer.xr.enabled, this._renderer.xr.enabled = !1;
            const n = e || this._allocateTargets();
            return this._textureToCubeUV(t, n), this._applyPMREM(n), this._cleanup(n), n;
        }
        _allocateTargets() {
            const t = 3 * Math.max(this._cubeSize, 112), e = 4 * this._cubeSize, n = {
                magFilter: on,
                minFilter: on,
                generateMipmaps: !1,
                type: Ur,
                format: fn,
                colorSpace: Ke,
                depthBuffer: !1
            }, s = Nu(t, e, n);
            if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== t || this._pingPongRenderTarget.height !== e) {
                this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = Nu(t, e, n);
                const { _lodMax: r } = this;
                ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = Gy(r)), this._blurMaterial = Hy(r, t, e);
            }
            return s;
        }
        _compileMaterial(t) {
            const e = new Le(this._lodPlanes[0], t);
            this._renderer.compile(e, Po);
        }
        _sceneToCubeUV(t, e, n, s, r) {
            const c = new We(90, 1, e, n), l = [
                1,
                -1,
                1,
                1,
                1,
                1
            ], h = [
                1,
                1,
                1,
                -1,
                -1,
                -1
            ], u = this._renderer, d = u.autoClear, f = u.toneMapping;
            u.getClearColor(Du), u.toneMapping = gi, u.autoClear = !1;
            const _ = new ki({
                name: "PMREM.Background",
                side: Qe,
                depthWrite: !1,
                depthTest: !1
            }), g = new Le(new Hs, _);
            let p = !1;
            const m = t.background;
            m ? m.isColor && (_.color.copy(m), t.background = null, p = !0) : (_.color.copy(Du), p = !0);
            for(let x = 0; x < 6; x++){
                const y = x % 3;
                y === 0 ? (c.up.set(0, l[x], 0), c.position.set(r.x, r.y, r.z), c.lookAt(r.x + h[x], r.y, r.z)) : y === 1 ? (c.up.set(0, 0, l[x]), c.position.set(r.x, r.y, r.z), c.lookAt(r.x, r.y + h[x], r.z)) : (c.up.set(0, l[x], 0), c.position.set(r.x, r.y, r.z), c.lookAt(r.x, r.y, r.z + h[x]));
                const v = this._cubeSize;
                ua(s, y * v, x > 2 ? v : 0, v, v), u.setRenderTarget(s), p && u.render(g, c), u.render(t, c);
            }
            g.geometry.dispose(), g.material.dispose(), u.toneMapping = f, u.autoClear = d, t.background = m;
        }
        _textureToCubeUV(t, e) {
            const n = this._renderer, s = t.mapping === Cs || t.mapping === Ps;
            s ? (this._cubemapMaterial === null && (this._cubemapMaterial = Fu()), this._cubemapMaterial.uniforms.flipEnvMap.value = t.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = Bu());
            const r = s ? this._cubemapMaterial : this._equirectMaterial, a = new Le(this._lodPlanes[0], r), o = r.uniforms;
            o.envMap.value = t;
            const c = this._cubeSize;
            ua(e, 0, 0, 3 * c, 2 * c), n.setRenderTarget(e), n.render(a, Po);
        }
        _applyPMREM(t) {
            const e = this._renderer, n = e.autoClear;
            e.autoClear = !1;
            const s = this._lodPlanes.length;
            for(let r = 1; r < s; r++){
                const a = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1]), o = Lu[(s - r - 1) % Lu.length];
                this._blur(t, r - 1, r, a, o);
            }
            e.autoClear = n;
        }
        _blur(t, e, n, s, r) {
            const a = this._pingPongRenderTarget;
            this._halfBlur(t, a, e, n, s, "latitudinal", r), this._halfBlur(a, t, n, n, s, "longitudinal", r);
        }
        _halfBlur(t, e, n, s, r, a, o) {
            const c = this._renderer, l = this._blurMaterial;
            a !== "latitudinal" && a !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
            const h = 3, u = new Le(this._lodPlanes[s], l), d = l.uniforms, f = this._sizeLods[n] - 1, _ = isFinite(r) ? Math.PI / (2 * f) : 2 * Math.PI / (2 * Oi - 1), g = r / _, p = isFinite(r) ? 1 + Math.floor(h * g) : Oi;
            p > Oi && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${p} samples when the maximum is set to ${Oi}`);
            const m = [];
            let x = 0;
            for(let R = 0; R < Oi; ++R){
                const N = R / g, E = Math.exp(-N * N / 2);
                m.push(E), R === 0 ? x += E : R < p && (x += 2 * E);
            }
            for(let R = 0; R < m.length; R++)m[R] = m[R] / x;
            d.envMap.value = t.texture, d.samples.value = p, d.weights.value = m, d.latitudinal.value = a === "latitudinal", o && (d.poleAxis.value = o);
            const { _lodMax: y } = this;
            d.dTheta.value = _, d.mipInt.value = y - n;
            const v = this._sizeLods[s], I = 3 * v * (s > y - Ss ? s - y + Ss : 0), w = 4 * (this._cubeSize - v);
            ua(e, I, w, 3 * v, 2 * v), c.setRenderTarget(e), c.render(u, Po);
        }
    }
    function Gy(i) {
        const t = [], e = [], n = [];
        let s = i;
        const r = i - Ss + 1 + Iu.length;
        for(let a = 0; a < r; a++){
            const o = Math.pow(2, s);
            e.push(o);
            let c = 1 / o;
            a > i - Ss ? c = Iu[a - i + Ss - 1] : a === 0 && (c = 0), n.push(c);
            const l = 1 / (o - 2), h = -l, u = 1 + l, d = [
                h,
                h,
                u,
                h,
                u,
                u,
                h,
                h,
                u,
                u,
                h,
                u
            ], f = 6, _ = 6, g = 3, p = 2, m = 1, x = new Float32Array(g * _ * f), y = new Float32Array(p * _ * f), v = new Float32Array(m * _ * f);
            for(let w = 0; w < f; w++){
                const R = w % 3 * 2 / 3 - 1, N = w > 2 ? 0 : -1, E = [
                    R,
                    N,
                    0,
                    R + 2 / 3,
                    N,
                    0,
                    R + 2 / 3,
                    N + 1,
                    0,
                    R,
                    N,
                    0,
                    R + 2 / 3,
                    N + 1,
                    0,
                    R,
                    N + 1,
                    0
                ];
                x.set(E, g * _ * w), y.set(d, p * _ * w);
                const S = [
                    w,
                    w,
                    w,
                    w,
                    w,
                    w
                ];
                v.set(S, m * _ * w);
            }
            const I = new kn;
            I.setAttribute("position", new je(x, g)), I.setAttribute("uv", new je(y, p)), I.setAttribute("faceIndex", new je(v, m)), t.push(I), s > Ss && s--;
        }
        return {
            lodPlanes: t,
            sizeLods: e,
            sigmas: n
        };
    }
    function Nu(i, t, e) {
        const n = new Wi(i, t, e);
        return n.texture.mapping = qa, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n;
    }
    function ua(i, t, e, n, s) {
        i.viewport.set(t, e, n, s), i.scissor.set(t, e, n, s);
    }
    function Hy(i, t, e) {
        const n = new Float32Array(Oi), s = new k(0, 1, 0);
        return new yi({
            name: "SphericalGaussianBlur",
            defines: {
                n: Oi,
                CUBEUV_TEXEL_WIDTH: 1 / t,
                CUBEUV_TEXEL_HEIGHT: 1 / e,
                CUBEUV_MAX_MIP: `${i}.0`
            },
            uniforms: {
                envMap: {
                    value: null
                },
                samples: {
                    value: 1
                },
                weights: {
                    value: n
                },
                latitudinal: {
                    value: !1
                },
                dTheta: {
                    value: 0
                },
                mipInt: {
                    value: 0
                },
                poleAxis: {
                    value: s
                }
            },
            vertexShader: nh(),
            fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
            blending: _i,
            depthTest: !1,
            depthWrite: !1
        });
    }
    function Bu() {
        return new yi({
            name: "EquirectangularToCubeUV",
            uniforms: {
                envMap: {
                    value: null
                }
            },
            vertexShader: nh(),
            fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
            blending: _i,
            depthTest: !1,
            depthWrite: !1
        });
    }
    function Fu() {
        return new yi({
            name: "CubemapToCubeUV",
            uniforms: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                }
            },
            vertexShader: nh(),
            fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
            blending: _i,
            depthTest: !1,
            depthWrite: !1
        });
    }
    function nh() {
        return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
    }
    function zy(i) {
        let t = new WeakMap, e = null;
        function n(o) {
            if (o && o.isTexture) {
                const c = o.mapping, l = c === Cc || c === Pc, h = c === Cs || c === Ps;
                if (l || h) {
                    let u = t.get(o);
                    const d = u !== void 0 ? u.texture.pmremVersion : 0;
                    if (o.isRenderTargetTexture && o.pmremVersion !== d) return e === null && (e = new Uu(i)), u = l ? e.fromEquirectangular(o, u) : e.fromCubemap(o, u), u.texture.pmremVersion = o.pmremVersion, t.set(o, u), u.texture;
                    if (u !== void 0) return u.texture;
                    {
                        const f = o.image;
                        return l && f && f.height > 0 || h && f && s(f) ? (e === null && (e = new Uu(i)), u = l ? e.fromEquirectangular(o) : e.fromCubemap(o), u.texture.pmremVersion = o.pmremVersion, t.set(o, u), o.addEventListener("dispose", r), u.texture) : null;
                    }
                }
            }
            return o;
        }
        function s(o) {
            let c = 0;
            const l = 6;
            for(let h = 0; h < l; h++)o[h] !== void 0 && c++;
            return c === l;
        }
        function r(o) {
            const c = o.target;
            c.removeEventListener("dispose", r);
            const l = t.get(c);
            l !== void 0 && (t.delete(c), l.dispose());
        }
        function a() {
            t = new WeakMap, e !== null && (e.dispose(), e = null);
        }
        return {
            get: n,
            dispose: a
        };
    }
    function Vy(i) {
        const t = {};
        function e(n) {
            if (t[n] !== void 0) return t[n];
            let s;
            switch(n){
                case "WEBGL_depth_texture":
                    s = i.getExtension("WEBGL_depth_texture") || i.getExtension("MOZ_WEBGL_depth_texture") || i.getExtension("WEBKIT_WEBGL_depth_texture");
                    break;
                case "EXT_texture_filter_anisotropic":
                    s = i.getExtension("EXT_texture_filter_anisotropic") || i.getExtension("MOZ_EXT_texture_filter_anisotropic") || i.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;
                case "WEBGL_compressed_texture_s3tc":
                    s = i.getExtension("WEBGL_compressed_texture_s3tc") || i.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;
                case "WEBGL_compressed_texture_pvrtc":
                    s = i.getExtension("WEBGL_compressed_texture_pvrtc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;
                default:
                    s = i.getExtension(n);
            }
            return t[n] = s, s;
        }
        return {
            has: function(n) {
                return e(n) !== null;
            },
            init: function() {
                e("EXT_color_buffer_float"), e("WEBGL_clip_cull_distance"), e("OES_texture_float_linear"), e("EXT_color_buffer_half_float"), e("WEBGL_multisampled_render_to_texture"), e("WEBGL_render_shared_exponent");
            },
            get: function(n) {
                const s = e(n);
                return s === null && Pa("THREE.WebGLRenderer: " + n + " extension not supported."), s;
            }
        };
    }
    function Wy(i, t, e, n) {
        const s = {}, r = new WeakMap;
        function a(u) {
            const d = u.target;
            d.index !== null && t.remove(d.index);
            for(const _ in d.attributes)t.remove(d.attributes[_]);
            d.removeEventListener("dispose", a), delete s[d.id];
            const f = r.get(d);
            f && (t.remove(f), r.delete(d)), n.releaseStatesOfGeometry(d), d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount, e.memory.geometries--;
        }
        function o(u, d) {
            return s[d.id] === !0 || (d.addEventListener("dispose", a), s[d.id] = !0, e.memory.geometries++), d;
        }
        function c(u) {
            const d = u.attributes;
            for(const f in d)t.update(d[f], i.ARRAY_BUFFER);
        }
        function l(u) {
            const d = [], f = u.index, _ = u.attributes.position;
            let g = 0;
            if (f !== null) {
                const x = f.array;
                g = f.version;
                for(let y = 0, v = x.length; y < v; y += 3){
                    const I = x[y + 0], w = x[y + 1], R = x[y + 2];
                    d.push(I, w, w, R, R, I);
                }
            } else if (_ !== void 0) {
                const x = _.array;
                g = _.version;
                for(let y = 0, v = x.length / 3 - 1; y < v; y += 3){
                    const I = y + 0, w = y + 1, R = y + 2;
                    d.push(I, w, w, R, R, I);
                }
            } else return;
            const p = new (Nf(d) ? Gf : kf)(d, 1);
            p.version = g;
            const m = r.get(u);
            m && t.remove(m), r.set(u, p);
        }
        function h(u) {
            const d = r.get(u);
            if (d) {
                const f = u.index;
                f !== null && d.version < f.version && l(u);
            } else l(u);
            return r.get(u);
        }
        return {
            get: o,
            update: c,
            getWireframeAttribute: h
        };
    }
    function Xy(i, t, e) {
        let n;
        function s(d) {
            n = d;
        }
        let r, a;
        function o(d) {
            r = d.type, a = d.bytesPerElement;
        }
        function c(d, f) {
            i.drawElements(n, f, r, d * a), e.update(f, n, 1);
        }
        function l(d, f, _) {
            _ !== 0 && (i.drawElementsInstanced(n, f, r, d * a, _), e.update(f, n, _));
        }
        function h(d, f, _) {
            if (_ === 0) return;
            t.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n, f, 0, r, d, 0, _);
            let p = 0;
            for(let m = 0; m < _; m++)p += f[m];
            e.update(p, n, 1);
        }
        function u(d, f, _, g) {
            if (_ === 0) return;
            const p = t.get("WEBGL_multi_draw");
            if (p === null) for(let m = 0; m < d.length; m++)l(d[m] / a, f[m], g[m]);
            else {
                p.multiDrawElementsInstancedWEBGL(n, f, 0, r, d, 0, g, 0, _);
                let m = 0;
                for(let x = 0; x < _; x++)m += f[x] * g[x];
                e.update(m, n, 1);
            }
        }
        this.setMode = s, this.setIndex = o, this.render = c, this.renderInstances = l, this.renderMultiDraw = h, this.renderMultiDrawInstances = u;
    }
    function Yy(i) {
        const t = {
            geometries: 0,
            textures: 0
        }, e = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
        };
        function n(r, a, o) {
            switch(e.calls++, a){
                case i.TRIANGLES:
                    e.triangles += o * (r / 3);
                    break;
                case i.LINES:
                    e.lines += o * (r / 2);
                    break;
                case i.LINE_STRIP:
                    e.lines += o * (r - 1);
                    break;
                case i.LINE_LOOP:
                    e.lines += o * r;
                    break;
                case i.POINTS:
                    e.points += o * r;
                    break;
                default:
                    console.error("THREE.WebGLInfo: Unknown draw mode:", a);
                    break;
            }
        }
        function s() {
            e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0;
        }
        return {
            memory: t,
            render: e,
            programs: null,
            autoReset: !0,
            reset: s,
            update: n
        };
    }
    function qy(i, t, e) {
        const n = new WeakMap, s = new ne;
        function r(a, o, c) {
            const l = a.morphTargetInfluences, h = o.morphAttributes.position || o.morphAttributes.normal || o.morphAttributes.color, u = h !== void 0 ? h.length : 0;
            let d = n.get(o);
            if (d === void 0 || d.count !== u) {
                let E = function() {
                    R.dispose(), n.delete(o), o.removeEventListener("dispose", E);
                };
                d !== void 0 && d.texture.dispose();
                const f = o.morphAttributes.position !== void 0, _ = o.morphAttributes.normal !== void 0, g = o.morphAttributes.color !== void 0, p = o.morphAttributes.position || [], m = o.morphAttributes.normal || [], x = o.morphAttributes.color || [];
                let y = 0;
                f === !0 && (y = 1), _ === !0 && (y = 2), g === !0 && (y = 3);
                let v = o.attributes.position.count * y, I = 1;
                v > t.maxTextureSize && (I = Math.ceil(v / t.maxTextureSize), v = t.maxTextureSize);
                const w = new Float32Array(v * I * 4 * u), R = new Bf(w, v, I, u);
                R.type = An, R.needsUpdate = !0;
                const N = y * 4;
                for(let S = 0; S < u; S++){
                    const D = p[S], j = m[S], z = x[S], K = v * I * 4 * S;
                    for(let nt = 0; nt < D.count; nt++){
                        const b = nt * N;
                        f === !0 && (s.fromBufferAttribute(D, nt), w[K + b + 0] = s.x, w[K + b + 1] = s.y, w[K + b + 2] = s.z, w[K + b + 3] = 0), _ === !0 && (s.fromBufferAttribute(j, nt), w[K + b + 4] = s.x, w[K + b + 5] = s.y, w[K + b + 6] = s.z, w[K + b + 7] = 0), g === !0 && (s.fromBufferAttribute(z, nt), w[K + b + 8] = s.x, w[K + b + 9] = s.y, w[K + b + 10] = s.z, w[K + b + 11] = z.itemSize === 4 ? s.w : 1);
                    }
                }
                d = {
                    count: u,
                    texture: R,
                    size: new Kt(v, I)
                }, n.set(o, d), o.addEventListener("dispose", E);
            }
            if (a.isInstancedMesh === !0 && a.morphTexture !== null) c.getUniforms().setValue(i, "morphTexture", a.morphTexture, e);
            else {
                let f = 0;
                for(let g = 0; g < l.length; g++)f += l[g];
                const _ = o.morphTargetsRelative ? 1 : 1 - f;
                c.getUniforms().setValue(i, "morphTargetBaseInfluence", _), c.getUniforms().setValue(i, "morphTargetInfluences", l);
            }
            c.getUniforms().setValue(i, "morphTargetsTexture", d.texture, e), c.getUniforms().setValue(i, "morphTargetsTextureSize", d.size);
        }
        return {
            update: r
        };
    }
    function jy(i, t, e, n) {
        let s = new WeakMap;
        function r(c) {
            const l = n.render.frame, h = c.geometry, u = t.get(c, h);
            if (s.get(u) !== l && (t.update(u), s.set(u, l)), c.isInstancedMesh && (c.hasEventListener("dispose", o) === !1 && c.addEventListener("dispose", o), s.get(c) !== l && (e.update(c.instanceMatrix, i.ARRAY_BUFFER), c.instanceColor !== null && e.update(c.instanceColor, i.ARRAY_BUFFER), s.set(c, l))), c.isSkinnedMesh) {
                const d = c.skeleton;
                s.get(d) !== l && (d.update(), s.set(d, l));
            }
            return u;
        }
        function a() {
            s = new WeakMap;
        }
        function o(c) {
            const l = c.target;
            l.removeEventListener("dispose", o), e.remove(l.instanceMatrix), l.instanceColor !== null && e.remove(l.instanceColor);
        }
        return {
            update: r,
            dispose: a
        };
    }
    const ep = new tn, Ou = new jf(1, 1), np = new Bf, ip = new Gg, sp = new Vf, ku = [], Gu = [], Hu = new Float32Array(16), zu = new Float32Array(9), Vu = new Float32Array(4);
    function Ys(i, t, e) {
        const n = i[0];
        if (n <= 0 || n > 0) return i;
        const s = t * e;
        let r = ku[s];
        if (r === void 0 && (r = new Float32Array(s), ku[s] = r), t !== 0) {
            n.toArray(r, 0);
            for(let a = 1, o = 0; a !== t; ++a)o += e, i[a].toArray(r, o);
        }
        return r;
    }
    function Ee(i, t) {
        if (i.length !== t.length) return !1;
        for(let e = 0, n = i.length; e < n; e++)if (i[e] !== t[e]) return !1;
        return !0;
    }
    function Ae(i, t) {
        for(let e = 0, n = t.length; e < n; e++)i[e] = t[e];
    }
    function Ka(i, t) {
        let e = Gu[t];
        e === void 0 && (e = new Int32Array(t), Gu[t] = e);
        for(let n = 0; n !== t; ++n)e[n] = i.allocateTextureUnit();
        return e;
    }
    function $y(i, t) {
        const e = this.cache;
        e[0] !== t && (i.uniform1f(this.addr, t), e[0] = t);
    }
    function Ky(i, t) {
        const e = this.cache;
        if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y) && (i.uniform2f(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y);
        else {
            if (Ee(e, t)) return;
            i.uniform2fv(this.addr, t), Ae(e, t);
        }
    }
    function Zy(i, t) {
        const e = this.cache;
        if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) && (i.uniform3f(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z);
        else if (t.r !== void 0) (e[0] !== t.r || e[1] !== t.g || e[2] !== t.b) && (i.uniform3f(this.addr, t.r, t.g, t.b), e[0] = t.r, e[1] = t.g, e[2] = t.b);
        else {
            if (Ee(e, t)) return;
            i.uniform3fv(this.addr, t), Ae(e, t);
        }
    }
    function Jy(i, t) {
        const e = this.cache;
        if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) && (i.uniform4f(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w);
        else {
            if (Ee(e, t)) return;
            i.uniform4fv(this.addr, t), Ae(e, t);
        }
    }
    function Qy(i, t) {
        const e = this.cache, n = t.elements;
        if (n === void 0) {
            if (Ee(e, t)) return;
            i.uniformMatrix2fv(this.addr, !1, t), Ae(e, t);
        } else {
            if (Ee(e, n)) return;
            Vu.set(n), i.uniformMatrix2fv(this.addr, !1, Vu), Ae(e, n);
        }
    }
    function tb(i, t) {
        const e = this.cache, n = t.elements;
        if (n === void 0) {
            if (Ee(e, t)) return;
            i.uniformMatrix3fv(this.addr, !1, t), Ae(e, t);
        } else {
            if (Ee(e, n)) return;
            zu.set(n), i.uniformMatrix3fv(this.addr, !1, zu), Ae(e, n);
        }
    }
    function eb(i, t) {
        const e = this.cache, n = t.elements;
        if (n === void 0) {
            if (Ee(e, t)) return;
            i.uniformMatrix4fv(this.addr, !1, t), Ae(e, t);
        } else {
            if (Ee(e, n)) return;
            Hu.set(n), i.uniformMatrix4fv(this.addr, !1, Hu), Ae(e, n);
        }
    }
    function nb(i, t) {
        const e = this.cache;
        e[0] !== t && (i.uniform1i(this.addr, t), e[0] = t);
    }
    function ib(i, t) {
        const e = this.cache;
        if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y) && (i.uniform2i(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y);
        else {
            if (Ee(e, t)) return;
            i.uniform2iv(this.addr, t), Ae(e, t);
        }
    }
    function sb(i, t) {
        const e = this.cache;
        if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) && (i.uniform3i(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z);
        else {
            if (Ee(e, t)) return;
            i.uniform3iv(this.addr, t), Ae(e, t);
        }
    }
    function rb(i, t) {
        const e = this.cache;
        if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) && (i.uniform4i(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w);
        else {
            if (Ee(e, t)) return;
            i.uniform4iv(this.addr, t), Ae(e, t);
        }
    }
    function ab(i, t) {
        const e = this.cache;
        e[0] !== t && (i.uniform1ui(this.addr, t), e[0] = t);
    }
    function ob(i, t) {
        const e = this.cache;
        if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y) && (i.uniform2ui(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y);
        else {
            if (Ee(e, t)) return;
            i.uniform2uiv(this.addr, t), Ae(e, t);
        }
    }
    function cb(i, t) {
        const e = this.cache;
        if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) && (i.uniform3ui(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z);
        else {
            if (Ee(e, t)) return;
            i.uniform3uiv(this.addr, t), Ae(e, t);
        }
    }
    function lb(i, t) {
        const e = this.cache;
        if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) && (i.uniform4ui(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w);
        else {
            if (Ee(e, t)) return;
            i.uniform4uiv(this.addr, t), Ae(e, t);
        }
    }
    function hb(i, t, e) {
        const n = this.cache, s = e.allocateTextureUnit();
        n[0] !== s && (i.uniform1i(this.addr, s), n[0] = s);
        let r;
        this.type === i.SAMPLER_2D_SHADOW ? (Ou.compareFunction = Uf, r = Ou) : r = ep, e.setTexture2D(t || r, s);
    }
    function ub(i, t, e) {
        const n = this.cache, s = e.allocateTextureUnit();
        n[0] !== s && (i.uniform1i(this.addr, s), n[0] = s), e.setTexture3D(t || ip, s);
    }
    function db(i, t, e) {
        const n = this.cache, s = e.allocateTextureUnit();
        n[0] !== s && (i.uniform1i(this.addr, s), n[0] = s), e.setTextureCube(t || sp, s);
    }
    function fb(i, t, e) {
        const n = this.cache, s = e.allocateTextureUnit();
        n[0] !== s && (i.uniform1i(this.addr, s), n[0] = s), e.setTexture2DArray(t || np, s);
    }
    function pb(i) {
        switch(i){
            case 5126:
                return $y;
            case 35664:
                return Ky;
            case 35665:
                return Zy;
            case 35666:
                return Jy;
            case 35674:
                return Qy;
            case 35675:
                return tb;
            case 35676:
                return eb;
            case 5124:
            case 35670:
                return nb;
            case 35667:
            case 35671:
                return ib;
            case 35668:
            case 35672:
                return sb;
            case 35669:
            case 35673:
                return rb;
            case 5125:
                return ab;
            case 36294:
                return ob;
            case 36295:
                return cb;
            case 36296:
                return lb;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
                return hb;
            case 35679:
            case 36299:
            case 36307:
                return ub;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
                return db;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
                return fb;
        }
    }
    function mb(i, t) {
        i.uniform1fv(this.addr, t);
    }
    function _b(i, t) {
        const e = Ys(t, this.size, 2);
        i.uniform2fv(this.addr, e);
    }
    function gb(i, t) {
        const e = Ys(t, this.size, 3);
        i.uniform3fv(this.addr, e);
    }
    function xb(i, t) {
        const e = Ys(t, this.size, 4);
        i.uniform4fv(this.addr, e);
    }
    function vb(i, t) {
        const e = Ys(t, this.size, 4);
        i.uniformMatrix2fv(this.addr, !1, e);
    }
    function yb(i, t) {
        const e = Ys(t, this.size, 9);
        i.uniformMatrix3fv(this.addr, !1, e);
    }
    function bb(i, t) {
        const e = Ys(t, this.size, 16);
        i.uniformMatrix4fv(this.addr, !1, e);
    }
    function Sb(i, t) {
        i.uniform1iv(this.addr, t);
    }
    function Mb(i, t) {
        i.uniform2iv(this.addr, t);
    }
    function Tb(i, t) {
        i.uniform3iv(this.addr, t);
    }
    function Eb(i, t) {
        i.uniform4iv(this.addr, t);
    }
    function Ab(i, t) {
        i.uniform1uiv(this.addr, t);
    }
    function wb(i, t) {
        i.uniform2uiv(this.addr, t);
    }
    function Rb(i, t) {
        i.uniform3uiv(this.addr, t);
    }
    function Cb(i, t) {
        i.uniform4uiv(this.addr, t);
    }
    function Pb(i, t, e) {
        const n = this.cache, s = t.length, r = Ka(e, s);
        Ee(n, r) || (i.uniform1iv(this.addr, r), Ae(n, r));
        for(let a = 0; a !== s; ++a)e.setTexture2D(t[a] || ep, r[a]);
    }
    function Ib(i, t, e) {
        const n = this.cache, s = t.length, r = Ka(e, s);
        Ee(n, r) || (i.uniform1iv(this.addr, r), Ae(n, r));
        for(let a = 0; a !== s; ++a)e.setTexture3D(t[a] || ip, r[a]);
    }
    function Db(i, t, e) {
        const n = this.cache, s = t.length, r = Ka(e, s);
        Ee(n, r) || (i.uniform1iv(this.addr, r), Ae(n, r));
        for(let a = 0; a !== s; ++a)e.setTextureCube(t[a] || sp, r[a]);
    }
    function Lb(i, t, e) {
        const n = this.cache, s = t.length, r = Ka(e, s);
        Ee(n, r) || (i.uniform1iv(this.addr, r), Ae(n, r));
        for(let a = 0; a !== s; ++a)e.setTexture2DArray(t[a] || np, r[a]);
    }
    function Ub(i) {
        switch(i){
            case 5126:
                return mb;
            case 35664:
                return _b;
            case 35665:
                return gb;
            case 35666:
                return xb;
            case 35674:
                return vb;
            case 35675:
                return yb;
            case 35676:
                return bb;
            case 5124:
            case 35670:
                return Sb;
            case 35667:
            case 35671:
                return Mb;
            case 35668:
            case 35672:
                return Tb;
            case 35669:
            case 35673:
                return Eb;
            case 5125:
                return Ab;
            case 36294:
                return wb;
            case 36295:
                return Rb;
            case 36296:
                return Cb;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
                return Pb;
            case 35679:
            case 36299:
            case 36307:
                return Ib;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
                return Db;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
                return Lb;
        }
    }
    class Nb {
        constructor(t, e, n){
            this.id = t, this.addr = n, this.cache = [], this.type = e.type, this.setValue = pb(e.type);
        }
    }
    class Bb {
        constructor(t, e, n){
            this.id = t, this.addr = n, this.cache = [], this.type = e.type, this.size = e.size, this.setValue = Ub(e.type);
        }
    }
    class Fb {
        constructor(t){
            this.id = t, this.seq = [], this.map = {};
        }
        setValue(t, e, n) {
            const s = this.seq;
            for(let r = 0, a = s.length; r !== a; ++r){
                const o = s[r];
                o.setValue(t, e[o.id], n);
            }
        }
    }
    const No = /(\w+)(\])?(\[|\.)?/g;
    function Wu(i, t) {
        i.seq.push(t), i.map[t.id] = t;
    }
    function Ob(i, t, e) {
        const n = i.name, s = n.length;
        for(No.lastIndex = 0;;){
            const r = No.exec(n), a = No.lastIndex;
            let o = r[1];
            const c = r[2] === "]", l = r[3];
            if (c && (o = o | 0), l === void 0 || l === "[" && a + 2 === s) {
                Wu(e, l === void 0 ? new Nb(o, i, t) : new Bb(o, i, t));
                break;
            } else {
                let u = e.map[o];
                u === void 0 && (u = new Fb(o), Wu(e, u)), e = u;
            }
        }
    }
    class Da {
        constructor(t, e){
            this.seq = [], this.map = {};
            const n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
            for(let s = 0; s < n; ++s){
                const r = t.getActiveUniform(e, s), a = t.getUniformLocation(e, r.name);
                Ob(r, a, this);
            }
        }
        setValue(t, e, n, s) {
            const r = this.map[e];
            r !== void 0 && r.setValue(t, n, s);
        }
        setOptional(t, e, n) {
            const s = e[n];
            s !== void 0 && this.setValue(t, n, s);
        }
        static upload(t, e, n, s) {
            for(let r = 0, a = e.length; r !== a; ++r){
                const o = e[r], c = n[o.id];
                c.needsUpdate !== !1 && o.setValue(t, c.value, s);
            }
        }
        static seqWithValue(t, e) {
            const n = [];
            for(let s = 0, r = t.length; s !== r; ++s){
                const a = t[s];
                a.id in e && n.push(a);
            }
            return n;
        }
    }
    function Xu(i, t, e) {
        const n = i.createShader(t);
        return i.shaderSource(n, e), i.compileShader(n), n;
    }
    const kb = 37297;
    let Gb = 0;
    function Hb(i, t) {
        const e = i.split(`
`), n = [], s = Math.max(t - 6, 0), r = Math.min(t + 6, e.length);
        for(let a = s; a < r; a++){
            const o = a + 1;
            n.push(`${o === t ? ">" : " "} ${o}: ${e[a]}`);
        }
        return n.join(`
`);
    }
    const Yu = new Gt;
    function zb(i) {
        $t._getMatrix(Yu, $t.workingColorSpace, i);
        const t = `mat3( ${Yu.elements.map((e)=>e.toFixed(4))} )`;
        switch($t.getTransfer(i)){
            case Oa:
                return [
                    t,
                    "LinearTransferOETF"
                ];
            case ce:
                return [
                    t,
                    "sRGBTransferOETF"
                ];
            default:
                return console.warn("THREE.WebGLProgram: Unsupported color space: ", i), [
                    t,
                    "LinearTransferOETF"
                ];
        }
    }
    function qu(i, t, e) {
        const n = i.getShaderParameter(t, i.COMPILE_STATUS), s = i.getShaderInfoLog(t).trim();
        if (n && s === "") return "";
        const r = /ERROR: 0:(\d+)/.exec(s);
        if (r) {
            const a = parseInt(r[1]);
            return e.toUpperCase() + `

` + s + `

` + Hb(i.getShaderSource(t), a);
        } else return s;
    }
    function Vb(i, t) {
        const e = zb(t);
        return [
            `vec4 ${i}( vec4 value ) {`,
            `	return ${e[1]}( vec4( value.rgb * ${e[0]}, value.a ) );`,
            "}"
        ].join(`
`);
    }
    function Wb(i, t) {
        let e;
        switch(t){
            case Y_:
                e = "Linear";
                break;
            case q_:
                e = "Reinhard";
                break;
            case j_:
                e = "Cineon";
                break;
            case $_:
                e = "ACESFilmic";
                break;
            case Z_:
                e = "AgX";
                break;
            case J_:
                e = "Neutral";
                break;
            case K_:
                e = "Custom";
                break;
            default:
                console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), e = "Linear";
        }
        return "vec3 " + i + "( vec3 color ) { return " + e + "ToneMapping( color ); }";
    }
    const da = new k;
    function Xb() {
        $t.getLuminanceCoefficients(da);
        const i = da.x.toFixed(4), t = da.y.toFixed(4), e = da.z.toFixed(4);
        return [
            "float luminance( const in vec3 rgb ) {",
            `	const vec3 weights = vec3( ${i}, ${t}, ${e} );`,
            "	return dot( weights, rgb );",
            "}"
        ].join(`
`);
    }
    function Yb(i) {
        return [
            i.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
            i.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
        ].filter(hr).join(`
`);
    }
    function qb(i) {
        const t = [];
        for(const e in i){
            const n = i[e];
            n !== !1 && t.push("#define " + e + " " + n);
        }
        return t.join(`
`);
    }
    function jb(i, t) {
        const e = {}, n = i.getProgramParameter(t, i.ACTIVE_ATTRIBUTES);
        for(let s = 0; s < n; s++){
            const r = i.getActiveAttrib(t, s), a = r.name;
            let o = 1;
            r.type === i.FLOAT_MAT2 && (o = 2), r.type === i.FLOAT_MAT3 && (o = 3), r.type === i.FLOAT_MAT4 && (o = 4), e[a] = {
                type: r.type,
                location: i.getAttribLocation(t, a),
                locationSize: o
            };
        }
        return e;
    }
    function hr(i) {
        return i !== "";
    }
    function ju(i, t) {
        const e = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
        return i.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, e).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows);
    }
    function $u(i, t) {
        return i.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection);
    }
    const $b = /^[ \t]*#include +<([\w\d./]+)>/gm;
    function hl(i) {
        return i.replace($b, Zb);
    }
    const Kb = new Map;
    function Zb(i, t) {
        let e = Vt[t];
        if (e === void 0) {
            const n = Kb.get(t);
            if (n !== void 0) e = Vt[n], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', t, n);
            else throw new Error("Can not resolve #include <" + t + ">");
        }
        return hl(e);
    }
    const Jb = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
    function Ku(i) {
        return i.replace(Jb, Qb);
    }
    function Qb(i, t, e, n) {
        let s = "";
        for(let r = parseInt(t); r < parseInt(e); r++)s += n.replace(/\[\s*i\s*\]/g, "[ " + r + " ]").replace(/UNROLLED_LOOP_INDEX/g, r);
        return s;
    }
    function Zu(i) {
        let t = `precision ${i.precision} float;
	precision ${i.precision} int;
	precision ${i.precision} sampler2D;
	precision ${i.precision} samplerCube;
	precision ${i.precision} sampler3D;
	precision ${i.precision} sampler2DArray;
	precision ${i.precision} sampler2DShadow;
	precision ${i.precision} samplerCubeShadow;
	precision ${i.precision} sampler2DArrayShadow;
	precision ${i.precision} isampler2D;
	precision ${i.precision} isampler3D;
	precision ${i.precision} isamplerCube;
	precision ${i.precision} isampler2DArray;
	precision ${i.precision} usampler2D;
	precision ${i.precision} usampler3D;
	precision ${i.precision} usamplerCube;
	precision ${i.precision} usampler2DArray;
	`;
        return i.precision === "highp" ? t += `
#define HIGH_PRECISION` : i.precision === "mediump" ? t += `
#define MEDIUM_PRECISION` : i.precision === "lowp" && (t += `
#define LOW_PRECISION`), t;
    }
    function tS(i) {
        let t = "SHADOWMAP_TYPE_BASIC";
        return i.shadowMapType === vf ? t = "SHADOWMAP_TYPE_PCF" : i.shadowMapType === E_ ? t = "SHADOWMAP_TYPE_PCF_SOFT" : i.shadowMapType === $n && (t = "SHADOWMAP_TYPE_VSM"), t;
    }
    function eS(i) {
        let t = "ENVMAP_TYPE_CUBE";
        if (i.envMap) switch(i.envMapMode){
            case Cs:
            case Ps:
                t = "ENVMAP_TYPE_CUBE";
                break;
            case qa:
                t = "ENVMAP_TYPE_CUBE_UV";
                break;
        }
        return t;
    }
    function nS(i) {
        let t = "ENVMAP_MODE_REFLECTION";
        if (i.envMap) switch(i.envMapMode){
            case Ps:
                t = "ENVMAP_MODE_REFRACTION";
                break;
        }
        return t;
    }
    function iS(i) {
        let t = "ENVMAP_BLENDING_NONE";
        if (i.envMap) switch(i.combine){
            case yf:
                t = "ENVMAP_BLENDING_MULTIPLY";
                break;
            case W_:
                t = "ENVMAP_BLENDING_MIX";
                break;
            case X_:
                t = "ENVMAP_BLENDING_ADD";
                break;
        }
        return t;
    }
    function sS(i) {
        const t = i.envMapCubeUVHeight;
        if (t === null) return null;
        const e = Math.log2(t) - 2, n = 1 / t;
        return {
            texelWidth: 1 / (3 * Math.max(Math.pow(2, e), 7 * 16)),
            texelHeight: n,
            maxMip: e
        };
    }
    function rS(i, t, e, n) {
        const s = i.getContext(), r = e.defines;
        let a = e.vertexShader, o = e.fragmentShader;
        const c = tS(e), l = eS(e), h = nS(e), u = iS(e), d = sS(e), f = Yb(e), _ = qb(r), g = s.createProgram();
        let p, m, x = e.glslVersion ? "#version " + e.glslVersion + `
` : "";
        e.isRawShaderMaterial ? (p = [
            "#define SHADER_TYPE " + e.shaderType,
            "#define SHADER_NAME " + e.shaderName,
            _
        ].filter(hr).join(`
`), p.length > 0 && (p += `
`), m = [
            "#define SHADER_TYPE " + e.shaderType,
            "#define SHADER_NAME " + e.shaderName,
            _
        ].filter(hr).join(`
`), m.length > 0 && (m += `
`)) : (p = [
            Zu(e),
            "#define SHADER_TYPE " + e.shaderType,
            "#define SHADER_NAME " + e.shaderName,
            _,
            e.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
            e.batching ? "#define USE_BATCHING" : "",
            e.batchingColor ? "#define USE_BATCHING_COLOR" : "",
            e.instancing ? "#define USE_INSTANCING" : "",
            e.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
            e.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
            e.useFog && e.fog ? "#define USE_FOG" : "",
            e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "",
            e.map ? "#define USE_MAP" : "",
            e.envMap ? "#define USE_ENVMAP" : "",
            e.envMap ? "#define " + h : "",
            e.lightMap ? "#define USE_LIGHTMAP" : "",
            e.aoMap ? "#define USE_AOMAP" : "",
            e.bumpMap ? "#define USE_BUMPMAP" : "",
            e.normalMap ? "#define USE_NORMALMAP" : "",
            e.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
            e.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
            e.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
            e.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
            e.anisotropy ? "#define USE_ANISOTROPY" : "",
            e.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
            e.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
            e.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
            e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
            e.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
            e.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
            e.specularMap ? "#define USE_SPECULARMAP" : "",
            e.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
            e.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
            e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
            e.metalnessMap ? "#define USE_METALNESSMAP" : "",
            e.alphaMap ? "#define USE_ALPHAMAP" : "",
            e.alphaHash ? "#define USE_ALPHAHASH" : "",
            e.transmission ? "#define USE_TRANSMISSION" : "",
            e.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
            e.thicknessMap ? "#define USE_THICKNESSMAP" : "",
            e.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
            e.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
            e.mapUv ? "#define MAP_UV " + e.mapUv : "",
            e.alphaMapUv ? "#define ALPHAMAP_UV " + e.alphaMapUv : "",
            e.lightMapUv ? "#define LIGHTMAP_UV " + e.lightMapUv : "",
            e.aoMapUv ? "#define AOMAP_UV " + e.aoMapUv : "",
            e.emissiveMapUv ? "#define EMISSIVEMAP_UV " + e.emissiveMapUv : "",
            e.bumpMapUv ? "#define BUMPMAP_UV " + e.bumpMapUv : "",
            e.normalMapUv ? "#define NORMALMAP_UV " + e.normalMapUv : "",
            e.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + e.displacementMapUv : "",
            e.metalnessMapUv ? "#define METALNESSMAP_UV " + e.metalnessMapUv : "",
            e.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + e.roughnessMapUv : "",
            e.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + e.anisotropyMapUv : "",
            e.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + e.clearcoatMapUv : "",
            e.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + e.clearcoatNormalMapUv : "",
            e.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + e.clearcoatRoughnessMapUv : "",
            e.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + e.iridescenceMapUv : "",
            e.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + e.iridescenceThicknessMapUv : "",
            e.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + e.sheenColorMapUv : "",
            e.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + e.sheenRoughnessMapUv : "",
            e.specularMapUv ? "#define SPECULARMAP_UV " + e.specularMapUv : "",
            e.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + e.specularColorMapUv : "",
            e.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + e.specularIntensityMapUv : "",
            e.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + e.transmissionMapUv : "",
            e.thicknessMapUv ? "#define THICKNESSMAP_UV " + e.thicknessMapUv : "",
            e.vertexTangents && e.flatShading === !1 ? "#define USE_TANGENT" : "",
            e.vertexColors ? "#define USE_COLOR" : "",
            e.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
            e.vertexUv1s ? "#define USE_UV1" : "",
            e.vertexUv2s ? "#define USE_UV2" : "",
            e.vertexUv3s ? "#define USE_UV3" : "",
            e.pointsUvs ? "#define USE_POINTS_UV" : "",
            e.flatShading ? "#define FLAT_SHADED" : "",
            e.skinning ? "#define USE_SKINNING" : "",
            e.morphTargets ? "#define USE_MORPHTARGETS" : "",
            e.morphNormals && e.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
            e.morphColors ? "#define USE_MORPHCOLORS" : "",
            e.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + e.morphTextureStride : "",
            e.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + e.morphTargetsCount : "",
            e.doubleSided ? "#define DOUBLE_SIDED" : "",
            e.flipSided ? "#define FLIP_SIDED" : "",
            e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
            e.shadowMapEnabled ? "#define " + c : "",
            e.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
            e.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
            e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
            e.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
            "uniform mat4 modelMatrix;",
            "uniform mat4 modelViewMatrix;",
            "uniform mat4 projectionMatrix;",
            "uniform mat4 viewMatrix;",
            "uniform mat3 normalMatrix;",
            "uniform vec3 cameraPosition;",
            "uniform bool isOrthographic;",
            "#ifdef USE_INSTANCING",
            "	attribute mat4 instanceMatrix;",
            "#endif",
            "#ifdef USE_INSTANCING_COLOR",
            "	attribute vec3 instanceColor;",
            "#endif",
            "#ifdef USE_INSTANCING_MORPH",
            "	uniform sampler2D morphTexture;",
            "#endif",
            "attribute vec3 position;",
            "attribute vec3 normal;",
            "attribute vec2 uv;",
            "#ifdef USE_UV1",
            "	attribute vec2 uv1;",
            "#endif",
            "#ifdef USE_UV2",
            "	attribute vec2 uv2;",
            "#endif",
            "#ifdef USE_UV3",
            "	attribute vec2 uv3;",
            "#endif",
            "#ifdef USE_TANGENT",
            "	attribute vec4 tangent;",
            "#endif",
            "#if defined( USE_COLOR_ALPHA )",
            "	attribute vec4 color;",
            "#elif defined( USE_COLOR )",
            "	attribute vec3 color;",
            "#endif",
            "#ifdef USE_SKINNING",
            "	attribute vec4 skinIndex;",
            "	attribute vec4 skinWeight;",
            "#endif",
            `
`
        ].filter(hr).join(`
`), m = [
            Zu(e),
            "#define SHADER_TYPE " + e.shaderType,
            "#define SHADER_NAME " + e.shaderName,
            _,
            e.useFog && e.fog ? "#define USE_FOG" : "",
            e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "",
            e.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
            e.map ? "#define USE_MAP" : "",
            e.matcap ? "#define USE_MATCAP" : "",
            e.envMap ? "#define USE_ENVMAP" : "",
            e.envMap ? "#define " + l : "",
            e.envMap ? "#define " + h : "",
            e.envMap ? "#define " + u : "",
            d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "",
            d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "",
            d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "",
            e.lightMap ? "#define USE_LIGHTMAP" : "",
            e.aoMap ? "#define USE_AOMAP" : "",
            e.bumpMap ? "#define USE_BUMPMAP" : "",
            e.normalMap ? "#define USE_NORMALMAP" : "",
            e.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
            e.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
            e.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
            e.anisotropy ? "#define USE_ANISOTROPY" : "",
            e.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
            e.clearcoat ? "#define USE_CLEARCOAT" : "",
            e.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
            e.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
            e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
            e.dispersion ? "#define USE_DISPERSION" : "",
            e.iridescence ? "#define USE_IRIDESCENCE" : "",
            e.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
            e.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
            e.specularMap ? "#define USE_SPECULARMAP" : "",
            e.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
            e.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
            e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
            e.metalnessMap ? "#define USE_METALNESSMAP" : "",
            e.alphaMap ? "#define USE_ALPHAMAP" : "",
            e.alphaTest ? "#define USE_ALPHATEST" : "",
            e.alphaHash ? "#define USE_ALPHAHASH" : "",
            e.sheen ? "#define USE_SHEEN" : "",
            e.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
            e.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
            e.transmission ? "#define USE_TRANSMISSION" : "",
            e.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
            e.thicknessMap ? "#define USE_THICKNESSMAP" : "",
            e.vertexTangents && e.flatShading === !1 ? "#define USE_TANGENT" : "",
            e.vertexColors || e.instancingColor || e.batchingColor ? "#define USE_COLOR" : "",
            e.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
            e.vertexUv1s ? "#define USE_UV1" : "",
            e.vertexUv2s ? "#define USE_UV2" : "",
            e.vertexUv3s ? "#define USE_UV3" : "",
            e.pointsUvs ? "#define USE_POINTS_UV" : "",
            e.gradientMap ? "#define USE_GRADIENTMAP" : "",
            e.flatShading ? "#define FLAT_SHADED" : "",
            e.doubleSided ? "#define DOUBLE_SIDED" : "",
            e.flipSided ? "#define FLIP_SIDED" : "",
            e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
            e.shadowMapEnabled ? "#define " + c : "",
            e.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
            e.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
            e.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
            e.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "",
            e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
            e.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
            "uniform mat4 viewMatrix;",
            "uniform vec3 cameraPosition;",
            "uniform bool isOrthographic;",
            e.toneMapping !== gi ? "#define TONE_MAPPING" : "",
            e.toneMapping !== gi ? Vt.tonemapping_pars_fragment : "",
            e.toneMapping !== gi ? Wb("toneMapping", e.toneMapping) : "",
            e.dithering ? "#define DITHERING" : "",
            e.opaque ? "#define OPAQUE" : "",
            Vt.colorspace_pars_fragment,
            Vb("linearToOutputTexel", e.outputColorSpace),
            Xb(),
            e.useDepthPacking ? "#define DEPTH_PACKING " + e.depthPacking : "",
            `
`
        ].filter(hr).join(`
`)), a = hl(a), a = ju(a, e), a = $u(a, e), o = hl(o), o = ju(o, e), o = $u(o, e), a = Ku(a), o = Ku(o), e.isRawShaderMaterial !== !0 && (x = `#version 300 es
`, p = [
            f,
            "#define attribute in",
            "#define varying out",
            "#define texture2D texture"
        ].join(`
`) + `
` + p, m = [
            "#define varying in",
            e.glslVersion === Yh ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
            e.glslVersion === Yh ? "" : "#define gl_FragColor pc_fragColor",
            "#define gl_FragDepthEXT gl_FragDepth",
            "#define texture2D texture",
            "#define textureCube texture",
            "#define texture2DProj textureProj",
            "#define texture2DLodEXT textureLod",
            "#define texture2DProjLodEXT textureProjLod",
            "#define textureCubeLodEXT textureLod",
            "#define texture2DGradEXT textureGrad",
            "#define texture2DProjGradEXT textureProjGrad",
            "#define textureCubeGradEXT textureGrad"
        ].join(`
`) + `
` + m);
        const y = x + p + a, v = x + m + o, I = Xu(s, s.VERTEX_SHADER, y), w = Xu(s, s.FRAGMENT_SHADER, v);
        s.attachShader(g, I), s.attachShader(g, w), e.index0AttributeName !== void 0 ? s.bindAttribLocation(g, 0, e.index0AttributeName) : e.morphTargets === !0 && s.bindAttribLocation(g, 0, "position"), s.linkProgram(g);
        function R(D) {
            if (i.debug.checkShaderErrors) {
                const j = s.getProgramInfoLog(g).trim(), z = s.getShaderInfoLog(I).trim(), K = s.getShaderInfoLog(w).trim();
                let nt = !0, b = !0;
                if (s.getProgramParameter(g, s.LINK_STATUS) === !1) if (nt = !1, typeof i.debug.onShaderError == "function") i.debug.onShaderError(s, g, I, w);
                else {
                    const C = qu(s, I, "vertex"), A = qu(s, w, "fragment");
                    console.error("THREE.WebGLProgram: Shader Error " + s.getError() + " - VALIDATE_STATUS " + s.getProgramParameter(g, s.VALIDATE_STATUS) + `

Material Name: ` + D.name + `
Material Type: ` + D.type + `

Program Info Log: ` + j + `
` + C + `
` + A);
                }
                else j !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", j) : (z === "" || K === "") && (b = !1);
                b && (D.diagnostics = {
                    runnable: nt,
                    programLog: j,
                    vertexShader: {
                        log: z,
                        prefix: p
                    },
                    fragmentShader: {
                        log: K,
                        prefix: m
                    }
                });
            }
            s.deleteShader(I), s.deleteShader(w), N = new Da(s, g), E = jb(s, g);
        }
        let N;
        this.getUniforms = function() {
            return N === void 0 && R(this), N;
        };
        let E;
        this.getAttributes = function() {
            return E === void 0 && R(this), E;
        };
        let S = e.rendererExtensionParallelShaderCompile === !1;
        return this.isReady = function() {
            return S === !1 && (S = s.getProgramParameter(g, kb)), S;
        }, this.destroy = function() {
            n.releaseStatesOfProgram(this), s.deleteProgram(g), this.program = void 0;
        }, this.type = e.shaderType, this.name = e.shaderName, this.id = Gb++, this.cacheKey = t, this.usedTimes = 1, this.program = g, this.vertexShader = I, this.fragmentShader = w, this;
    }
    let aS = 0;
    class oS {
        constructor(){
            this.shaderCache = new Map, this.materialCache = new Map;
        }
        update(t) {
            const e = t.vertexShader, n = t.fragmentShader, s = this._getShaderStage(e), r = this._getShaderStage(n), a = this._getShaderCacheForMaterial(t);
            return a.has(s) === !1 && (a.add(s), s.usedTimes++), a.has(r) === !1 && (a.add(r), r.usedTimes++), this;
        }
        remove(t) {
            const e = this.materialCache.get(t);
            for (const n of e)n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
            return this.materialCache.delete(t), this;
        }
        getVertexShaderID(t) {
            return this._getShaderStage(t.vertexShader).id;
        }
        getFragmentShaderID(t) {
            return this._getShaderStage(t.fragmentShader).id;
        }
        dispose() {
            this.shaderCache.clear(), this.materialCache.clear();
        }
        _getShaderCacheForMaterial(t) {
            const e = this.materialCache;
            let n = e.get(t);
            return n === void 0 && (n = new Set, e.set(t, n)), n;
        }
        _getShaderStage(t) {
            const e = this.shaderCache;
            let n = e.get(t);
            return n === void 0 && (n = new cS(t), e.set(t, n)), n;
        }
    }
    class cS {
        constructor(t){
            this.id = aS++, this.code = t, this.usedTimes = 0;
        }
    }
    function lS(i, t, e, n, s, r, a) {
        const o = new Ff, c = new oS, l = new Set, h = [], u = s.logarithmicDepthBuffer, d = s.vertexTextures;
        let f = s.precision;
        const _ = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "toon",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            MeshMatcapMaterial: "matcap",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow",
            SpriteMaterial: "sprite"
        };
        function g(E) {
            return l.add(E), E === 0 ? "uv" : `uv${E}`;
        }
        function p(E, S, D, j, z) {
            const K = j.fog, nt = z.geometry, b = E.isMeshStandardMaterial ? j.environment : null, C = (E.isMeshStandardMaterial ? e : t).get(E.envMap || b), A = C && C.mapping === qa ? C.image.height : null, U = _[E.type];
            E.precision !== null && (f = s.getMaxPrecision(E.precision), f !== E.precision && console.warn("THREE.WebGLProgram.getParameters:", E.precision, "not supported, using", f, "instead."));
            const B = nt.morphAttributes.position || nt.morphAttributes.normal || nt.morphAttributes.color, V = B !== void 0 ? B.length : 0;
            let q = 0;
            nt.morphAttributes.position !== void 0 && (q = 1), nt.morphAttributes.normal !== void 0 && (q = 2), nt.morphAttributes.color !== void 0 && (q = 3);
            let et, H, $, ot;
            if (U) {
                const ae = Nn[U];
                et = ae.vertexShader, H = ae.fragmentShader;
            } else et = E.vertexShader, H = E.fragmentShader, c.update(E), $ = c.getVertexShaderID(E), ot = c.getFragmentShaderID(E);
            const it = i.getRenderTarget(), lt = i.state.buffers.depth.getReversed(), wt = z.isInstancedMesh === !0, ht = z.isBatchedMesh === !0, ee = !!E.map, Wt = !!E.matcap, Lt = !!C, L = !!E.aoMap, Ct = !!E.lightMap, gt = !!E.bumpMap, Xt = !!E.normalMap, Et = !!E.displacementMap, le = !!E.emissiveMap, At = !!E.metalnessMap, P = !!E.roughnessMap, M = E.anisotropy > 0, W = E.clearcoat > 0, Q = E.dispersion > 0, rt = E.iridescence > 0, J = E.sheen > 0, Tt = E.transmission > 0, ft = M && !!E.anisotropyMap, vt = W && !!E.clearcoatMap, Zt = W && !!E.clearcoatNormalMap, ct = W && !!E.clearcoatRoughnessMap, yt = rt && !!E.iridescenceMap, It = rt && !!E.iridescenceThicknessMap, Ut = J && !!E.sheenColorMap, bt = J && !!E.sheenRoughnessMap, jt = !!E.specularMap, zt = !!E.specularColorMap, he = !!E.specularIntensityMap, F = Tt && !!E.transmissionMap, pt = Tt && !!E.thicknessMap, Z = !!E.gradientMap, tt = !!E.alphaMap, _t = E.alphaTest > 0, mt = !!E.alphaHash, kt = !!E.extensions;
            let xe = gi;
            E.toneMapped && (it === null || it.isXRRenderTarget === !0) && (xe = i.toneMapping);
            const Fe = {
                shaderID: U,
                shaderType: E.type,
                shaderName: E.name,
                vertexShader: et,
                fragmentShader: H,
                defines: E.defines,
                customVertexShaderID: $,
                customFragmentShaderID: ot,
                isRawShaderMaterial: E.isRawShaderMaterial === !0,
                glslVersion: E.glslVersion,
                precision: f,
                batching: ht,
                batchingColor: ht && z._colorsTexture !== null,
                instancing: wt,
                instancingColor: wt && z.instanceColor !== null,
                instancingMorph: wt && z.morphTexture !== null,
                supportsVertexTextures: d,
                outputColorSpace: it === null ? i.outputColorSpace : it.isXRRenderTarget === !0 ? it.texture.colorSpace : Ke,
                alphaToCoverage: !!E.alphaToCoverage,
                map: ee,
                matcap: Wt,
                envMap: Lt,
                envMapMode: Lt && C.mapping,
                envMapCubeUVHeight: A,
                aoMap: L,
                lightMap: Ct,
                bumpMap: gt,
                normalMap: Xt,
                displacementMap: d && Et,
                emissiveMap: le,
                normalMapObjectSpace: Xt && E.normalMapType === ag,
                normalMapTangentSpace: Xt && E.normalMapType === Lf,
                metalnessMap: At,
                roughnessMap: P,
                anisotropy: M,
                anisotropyMap: ft,
                clearcoat: W,
                clearcoatMap: vt,
                clearcoatNormalMap: Zt,
                clearcoatRoughnessMap: ct,
                dispersion: Q,
                iridescence: rt,
                iridescenceMap: yt,
                iridescenceThicknessMap: It,
                sheen: J,
                sheenColorMap: Ut,
                sheenRoughnessMap: bt,
                specularMap: jt,
                specularColorMap: zt,
                specularIntensityMap: he,
                transmission: Tt,
                transmissionMap: F,
                thicknessMap: pt,
                gradientMap: Z,
                opaque: E.transparent === !1 && E.blending === Ts && E.alphaToCoverage === !1,
                alphaMap: tt,
                alphaTest: _t,
                alphaHash: mt,
                combine: E.combine,
                mapUv: ee && g(E.map.channel),
                aoMapUv: L && g(E.aoMap.channel),
                lightMapUv: Ct && g(E.lightMap.channel),
                bumpMapUv: gt && g(E.bumpMap.channel),
                normalMapUv: Xt && g(E.normalMap.channel),
                displacementMapUv: Et && g(E.displacementMap.channel),
                emissiveMapUv: le && g(E.emissiveMap.channel),
                metalnessMapUv: At && g(E.metalnessMap.channel),
                roughnessMapUv: P && g(E.roughnessMap.channel),
                anisotropyMapUv: ft && g(E.anisotropyMap.channel),
                clearcoatMapUv: vt && g(E.clearcoatMap.channel),
                clearcoatNormalMapUv: Zt && g(E.clearcoatNormalMap.channel),
                clearcoatRoughnessMapUv: ct && g(E.clearcoatRoughnessMap.channel),
                iridescenceMapUv: yt && g(E.iridescenceMap.channel),
                iridescenceThicknessMapUv: It && g(E.iridescenceThicknessMap.channel),
                sheenColorMapUv: Ut && g(E.sheenColorMap.channel),
                sheenRoughnessMapUv: bt && g(E.sheenRoughnessMap.channel),
                specularMapUv: jt && g(E.specularMap.channel),
                specularColorMapUv: zt && g(E.specularColorMap.channel),
                specularIntensityMapUv: he && g(E.specularIntensityMap.channel),
                transmissionMapUv: F && g(E.transmissionMap.channel),
                thicknessMapUv: pt && g(E.thicknessMap.channel),
                alphaMapUv: tt && g(E.alphaMap.channel),
                vertexTangents: !!nt.attributes.tangent && (Xt || M),
                vertexColors: E.vertexColors,
                vertexAlphas: E.vertexColors === !0 && !!nt.attributes.color && nt.attributes.color.itemSize === 4,
                pointsUvs: z.isPoints === !0 && !!nt.attributes.uv && (ee || tt),
                fog: !!K,
                useFog: E.fog === !0,
                fogExp2: !!K && K.isFogExp2,
                flatShading: E.flatShading === !0,
                sizeAttenuation: E.sizeAttenuation === !0,
                logarithmicDepthBuffer: u,
                reverseDepthBuffer: lt,
                skinning: z.isSkinnedMesh === !0,
                morphTargets: nt.morphAttributes.position !== void 0,
                morphNormals: nt.morphAttributes.normal !== void 0,
                morphColors: nt.morphAttributes.color !== void 0,
                morphTargetsCount: V,
                morphTextureStride: q,
                numDirLights: S.directional.length,
                numPointLights: S.point.length,
                numSpotLights: S.spot.length,
                numSpotLightMaps: S.spotLightMap.length,
                numRectAreaLights: S.rectArea.length,
                numHemiLights: S.hemi.length,
                numDirLightShadows: S.directionalShadowMap.length,
                numPointLightShadows: S.pointShadowMap.length,
                numSpotLightShadows: S.spotShadowMap.length,
                numSpotLightShadowsWithMaps: S.numSpotLightShadowsWithMaps,
                numLightProbes: S.numLightProbes,
                numClippingPlanes: a.numPlanes,
                numClipIntersection: a.numIntersection,
                dithering: E.dithering,
                shadowMapEnabled: i.shadowMap.enabled && D.length > 0,
                shadowMapType: i.shadowMap.type,
                toneMapping: xe,
                decodeVideoTexture: ee && E.map.isVideoTexture === !0 && $t.getTransfer(E.map.colorSpace) === ce,
                decodeVideoTextureEmissive: le && E.emissiveMap.isVideoTexture === !0 && $t.getTransfer(E.emissiveMap.colorSpace) === ce,
                premultipliedAlpha: E.premultipliedAlpha,
                doubleSided: E.side === dn,
                flipSided: E.side === Qe,
                useDepthPacking: E.depthPacking >= 0,
                depthPacking: E.depthPacking || 0,
                index0AttributeName: E.index0AttributeName,
                extensionClipCullDistance: kt && E.extensions.clipCullDistance === !0 && n.has("WEBGL_clip_cull_distance"),
                extensionMultiDraw: (kt && E.extensions.multiDraw === !0 || ht) && n.has("WEBGL_multi_draw"),
                rendererExtensionParallelShaderCompile: n.has("KHR_parallel_shader_compile"),
                customProgramCacheKey: E.customProgramCacheKey()
            };
            return Fe.vertexUv1s = l.has(1), Fe.vertexUv2s = l.has(2), Fe.vertexUv3s = l.has(3), l.clear(), Fe;
        }
        function m(E) {
            const S = [];
            if (E.shaderID ? S.push(E.shaderID) : (S.push(E.customVertexShaderID), S.push(E.customFragmentShaderID)), E.defines !== void 0) for(const D in E.defines)S.push(D), S.push(E.defines[D]);
            return E.isRawShaderMaterial === !1 && (x(S, E), y(S, E), S.push(i.outputColorSpace)), S.push(E.customProgramCacheKey), S.join();
        }
        function x(E, S) {
            E.push(S.precision), E.push(S.outputColorSpace), E.push(S.envMapMode), E.push(S.envMapCubeUVHeight), E.push(S.mapUv), E.push(S.alphaMapUv), E.push(S.lightMapUv), E.push(S.aoMapUv), E.push(S.bumpMapUv), E.push(S.normalMapUv), E.push(S.displacementMapUv), E.push(S.emissiveMapUv), E.push(S.metalnessMapUv), E.push(S.roughnessMapUv), E.push(S.anisotropyMapUv), E.push(S.clearcoatMapUv), E.push(S.clearcoatNormalMapUv), E.push(S.clearcoatRoughnessMapUv), E.push(S.iridescenceMapUv), E.push(S.iridescenceThicknessMapUv), E.push(S.sheenColorMapUv), E.push(S.sheenRoughnessMapUv), E.push(S.specularMapUv), E.push(S.specularColorMapUv), E.push(S.specularIntensityMapUv), E.push(S.transmissionMapUv), E.push(S.thicknessMapUv), E.push(S.combine), E.push(S.fogExp2), E.push(S.sizeAttenuation), E.push(S.morphTargetsCount), E.push(S.morphAttributeCount), E.push(S.numDirLights), E.push(S.numPointLights), E.push(S.numSpotLights), E.push(S.numSpotLightMaps), E.push(S.numHemiLights), E.push(S.numRectAreaLights), E.push(S.numDirLightShadows), E.push(S.numPointLightShadows), E.push(S.numSpotLightShadows), E.push(S.numSpotLightShadowsWithMaps), E.push(S.numLightProbes), E.push(S.shadowMapType), E.push(S.toneMapping), E.push(S.numClippingPlanes), E.push(S.numClipIntersection), E.push(S.depthPacking);
        }
        function y(E, S) {
            o.disableAll(), S.supportsVertexTextures && o.enable(0), S.instancing && o.enable(1), S.instancingColor && o.enable(2), S.instancingMorph && o.enable(3), S.matcap && o.enable(4), S.envMap && o.enable(5), S.normalMapObjectSpace && o.enable(6), S.normalMapTangentSpace && o.enable(7), S.clearcoat && o.enable(8), S.iridescence && o.enable(9), S.alphaTest && o.enable(10), S.vertexColors && o.enable(11), S.vertexAlphas && o.enable(12), S.vertexUv1s && o.enable(13), S.vertexUv2s && o.enable(14), S.vertexUv3s && o.enable(15), S.vertexTangents && o.enable(16), S.anisotropy && o.enable(17), S.alphaHash && o.enable(18), S.batching && o.enable(19), S.dispersion && o.enable(20), S.batchingColor && o.enable(21), E.push(o.mask), o.disableAll(), S.fog && o.enable(0), S.useFog && o.enable(1), S.flatShading && o.enable(2), S.logarithmicDepthBuffer && o.enable(3), S.reverseDepthBuffer && o.enable(4), S.skinning && o.enable(5), S.morphTargets && o.enable(6), S.morphNormals && o.enable(7), S.morphColors && o.enable(8), S.premultipliedAlpha && o.enable(9), S.shadowMapEnabled && o.enable(10), S.doubleSided && o.enable(11), S.flipSided && o.enable(12), S.useDepthPacking && o.enable(13), S.dithering && o.enable(14), S.transmission && o.enable(15), S.sheen && o.enable(16), S.opaque && o.enable(17), S.pointsUvs && o.enable(18), S.decodeVideoTexture && o.enable(19), S.decodeVideoTextureEmissive && o.enable(20), S.alphaToCoverage && o.enable(21), E.push(o.mask);
        }
        function v(E) {
            const S = _[E.type];
            let D;
            if (S) {
                const j = Nn[S];
                D = Qg.clone(j.uniforms);
            } else D = E.uniforms;
            return D;
        }
        function I(E, S) {
            let D;
            for(let j = 0, z = h.length; j < z; j++){
                const K = h[j];
                if (K.cacheKey === S) {
                    D = K, ++D.usedTimes;
                    break;
                }
            }
            return D === void 0 && (D = new rS(i, S, E, r), h.push(D)), D;
        }
        function w(E) {
            if (--E.usedTimes === 0) {
                const S = h.indexOf(E);
                h[S] = h[h.length - 1], h.pop(), E.destroy();
            }
        }
        function R(E) {
            c.remove(E);
        }
        function N() {
            c.dispose();
        }
        return {
            getParameters: p,
            getProgramCacheKey: m,
            getUniforms: v,
            acquireProgram: I,
            releaseProgram: w,
            releaseShaderCache: R,
            programs: h,
            dispose: N
        };
    }
    function hS() {
        let i = new WeakMap;
        function t(a) {
            return i.has(a);
        }
        function e(a) {
            let o = i.get(a);
            return o === void 0 && (o = {}, i.set(a, o)), o;
        }
        function n(a) {
            i.delete(a);
        }
        function s(a, o, c) {
            i.get(a)[o] = c;
        }
        function r() {
            i = new WeakMap;
        }
        return {
            has: t,
            get: e,
            remove: n,
            update: s,
            dispose: r
        };
    }
    function uS(i, t) {
        return i.groupOrder !== t.groupOrder ? i.groupOrder - t.groupOrder : i.renderOrder !== t.renderOrder ? i.renderOrder - t.renderOrder : i.material.id !== t.material.id ? i.material.id - t.material.id : i.z !== t.z ? i.z - t.z : i.id - t.id;
    }
    function Ju(i, t) {
        return i.groupOrder !== t.groupOrder ? i.groupOrder - t.groupOrder : i.renderOrder !== t.renderOrder ? i.renderOrder - t.renderOrder : i.z !== t.z ? t.z - i.z : i.id - t.id;
    }
    function Qu() {
        const i = [];
        let t = 0;
        const e = [], n = [], s = [];
        function r() {
            t = 0, e.length = 0, n.length = 0, s.length = 0;
        }
        function a(u, d, f, _, g, p) {
            let m = i[t];
            return m === void 0 ? (m = {
                id: u.id,
                object: u,
                geometry: d,
                material: f,
                groupOrder: _,
                renderOrder: u.renderOrder,
                z: g,
                group: p
            }, i[t] = m) : (m.id = u.id, m.object = u, m.geometry = d, m.material = f, m.groupOrder = _, m.renderOrder = u.renderOrder, m.z = g, m.group = p), t++, m;
        }
        function o(u, d, f, _, g, p) {
            const m = a(u, d, f, _, g, p);
            f.transmission > 0 ? n.push(m) : f.transparent === !0 ? s.push(m) : e.push(m);
        }
        function c(u, d, f, _, g, p) {
            const m = a(u, d, f, _, g, p);
            f.transmission > 0 ? n.unshift(m) : f.transparent === !0 ? s.unshift(m) : e.unshift(m);
        }
        function l(u, d) {
            e.length > 1 && e.sort(u || uS), n.length > 1 && n.sort(d || Ju), s.length > 1 && s.sort(d || Ju);
        }
        function h() {
            for(let u = t, d = i.length; u < d; u++){
                const f = i[u];
                if (f.id === null) break;
                f.id = null, f.object = null, f.geometry = null, f.material = null, f.group = null;
            }
        }
        return {
            opaque: e,
            transmissive: n,
            transparent: s,
            init: r,
            push: o,
            unshift: c,
            finish: h,
            sort: l
        };
    }
    function dS() {
        let i = new WeakMap;
        function t(n, s) {
            const r = i.get(n);
            let a;
            return r === void 0 ? (a = new Qu, i.set(n, [
                a
            ])) : s >= r.length ? (a = new Qu, r.push(a)) : a = r[s], a;
        }
        function e() {
            i = new WeakMap;
        }
        return {
            get: t,
            dispose: e
        };
    }
    function fS() {
        const i = {};
        return {
            get: function(t) {
                if (i[t.id] !== void 0) return i[t.id];
                let e;
                switch(t.type){
                    case "DirectionalLight":
                        e = {
                            direction: new k,
                            color: new Bt
                        };
                        break;
                    case "SpotLight":
                        e = {
                            position: new k,
                            direction: new k,
                            color: new Bt,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0
                        };
                        break;
                    case "PointLight":
                        e = {
                            position: new k,
                            color: new Bt,
                            distance: 0,
                            decay: 0
                        };
                        break;
                    case "HemisphereLight":
                        e = {
                            direction: new k,
                            skyColor: new Bt,
                            groundColor: new Bt
                        };
                        break;
                    case "RectAreaLight":
                        e = {
                            color: new Bt,
                            position: new k,
                            halfWidth: new k,
                            halfHeight: new k
                        };
                        break;
                }
                return i[t.id] = e, e;
            }
        };
    }
    function pS() {
        const i = {};
        return {
            get: function(t) {
                if (i[t.id] !== void 0) return i[t.id];
                let e;
                switch(t.type){
                    case "DirectionalLight":
                        e = {
                            shadowIntensity: 1,
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new Kt
                        };
                        break;
                    case "SpotLight":
                        e = {
                            shadowIntensity: 1,
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new Kt
                        };
                        break;
                    case "PointLight":
                        e = {
                            shadowIntensity: 1,
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new Kt,
                            shadowCameraNear: 1,
                            shadowCameraFar: 1e3
                        };
                        break;
                }
                return i[t.id] = e, e;
            }
        };
    }
    let mS = 0;
    function _S(i, t) {
        return (t.castShadow ? 2 : 0) - (i.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (i.map ? 1 : 0);
    }
    function gS(i) {
        const t = new fS, e = pS(), n = {
            version: 0,
            hash: {
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1,
                numSpotMaps: -1,
                numLightProbes: -1
            },
            ambient: [
                0,
                0,
                0
            ],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotLightMap: [],
            spotShadow: [],
            spotShadowMap: [],
            spotLightMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
            numSpotLightShadowsWithMaps: 0,
            numLightProbes: 0
        };
        for(let l = 0; l < 9; l++)n.probe.push(new k);
        const s = new k, r = new Ht, a = new Ht;
        function o(l) {
            let h = 0, u = 0, d = 0;
            for(let E = 0; E < 9; E++)n.probe[E].set(0, 0, 0);
            let f = 0, _ = 0, g = 0, p = 0, m = 0, x = 0, y = 0, v = 0, I = 0, w = 0, R = 0;
            l.sort(_S);
            for(let E = 0, S = l.length; E < S; E++){
                const D = l[E], j = D.color, z = D.intensity, K = D.distance, nt = D.shadow && D.shadow.map ? D.shadow.map.texture : null;
                if (D.isAmbientLight) h += j.r * z, u += j.g * z, d += j.b * z;
                else if (D.isLightProbe) {
                    for(let b = 0; b < 9; b++)n.probe[b].addScaledVector(D.sh.coefficients[b], z);
                    R++;
                } else if (D.isDirectionalLight) {
                    const b = t.get(D);
                    if (b.color.copy(D.color).multiplyScalar(D.intensity), D.castShadow) {
                        const C = D.shadow, A = e.get(D);
                        A.shadowIntensity = C.intensity, A.shadowBias = C.bias, A.shadowNormalBias = C.normalBias, A.shadowRadius = C.radius, A.shadowMapSize = C.mapSize, n.directionalShadow[f] = A, n.directionalShadowMap[f] = nt, n.directionalShadowMatrix[f] = D.shadow.matrix, x++;
                    }
                    n.directional[f] = b, f++;
                } else if (D.isSpotLight) {
                    const b = t.get(D);
                    b.position.setFromMatrixPosition(D.matrixWorld), b.color.copy(j).multiplyScalar(z), b.distance = K, b.coneCos = Math.cos(D.angle), b.penumbraCos = Math.cos(D.angle * (1 - D.penumbra)), b.decay = D.decay, n.spot[g] = b;
                    const C = D.shadow;
                    if (D.map && (n.spotLightMap[I] = D.map, I++, C.updateMatrices(D), D.castShadow && w++), n.spotLightMatrix[g] = C.matrix, D.castShadow) {
                        const A = e.get(D);
                        A.shadowIntensity = C.intensity, A.shadowBias = C.bias, A.shadowNormalBias = C.normalBias, A.shadowRadius = C.radius, A.shadowMapSize = C.mapSize, n.spotShadow[g] = A, n.spotShadowMap[g] = nt, v++;
                    }
                    g++;
                } else if (D.isRectAreaLight) {
                    const b = t.get(D);
                    b.color.copy(j).multiplyScalar(z), b.halfWidth.set(D.width * .5, 0, 0), b.halfHeight.set(0, D.height * .5, 0), n.rectArea[p] = b, p++;
                } else if (D.isPointLight) {
                    const b = t.get(D);
                    if (b.color.copy(D.color).multiplyScalar(D.intensity), b.distance = D.distance, b.decay = D.decay, D.castShadow) {
                        const C = D.shadow, A = e.get(D);
                        A.shadowIntensity = C.intensity, A.shadowBias = C.bias, A.shadowNormalBias = C.normalBias, A.shadowRadius = C.radius, A.shadowMapSize = C.mapSize, A.shadowCameraNear = C.camera.near, A.shadowCameraFar = C.camera.far, n.pointShadow[_] = A, n.pointShadowMap[_] = nt, n.pointShadowMatrix[_] = D.shadow.matrix, y++;
                    }
                    n.point[_] = b, _++;
                } else if (D.isHemisphereLight) {
                    const b = t.get(D);
                    b.skyColor.copy(D.color).multiplyScalar(z), b.groundColor.copy(D.groundColor).multiplyScalar(z), n.hemi[m] = b, m++;
                }
            }
            p > 0 && (i.has("OES_texture_float_linear") === !0 ? (n.rectAreaLTC1 = ut.LTC_FLOAT_1, n.rectAreaLTC2 = ut.LTC_FLOAT_2) : (n.rectAreaLTC1 = ut.LTC_HALF_1, n.rectAreaLTC2 = ut.LTC_HALF_2)), n.ambient[0] = h, n.ambient[1] = u, n.ambient[2] = d;
            const N = n.hash;
            (N.directionalLength !== f || N.pointLength !== _ || N.spotLength !== g || N.rectAreaLength !== p || N.hemiLength !== m || N.numDirectionalShadows !== x || N.numPointShadows !== y || N.numSpotShadows !== v || N.numSpotMaps !== I || N.numLightProbes !== R) && (n.directional.length = f, n.spot.length = g, n.rectArea.length = p, n.point.length = _, n.hemi.length = m, n.directionalShadow.length = x, n.directionalShadowMap.length = x, n.pointShadow.length = y, n.pointShadowMap.length = y, n.spotShadow.length = v, n.spotShadowMap.length = v, n.directionalShadowMatrix.length = x, n.pointShadowMatrix.length = y, n.spotLightMatrix.length = v + I - w, n.spotLightMap.length = I, n.numSpotLightShadowsWithMaps = w, n.numLightProbes = R, N.directionalLength = f, N.pointLength = _, N.spotLength = g, N.rectAreaLength = p, N.hemiLength = m, N.numDirectionalShadows = x, N.numPointShadows = y, N.numSpotShadows = v, N.numSpotMaps = I, N.numLightProbes = R, n.version = mS++);
        }
        function c(l, h) {
            let u = 0, d = 0, f = 0, _ = 0, g = 0;
            const p = h.matrixWorldInverse;
            for(let m = 0, x = l.length; m < x; m++){
                const y = l[m];
                if (y.isDirectionalLight) {
                    const v = n.directional[u];
                    v.direction.setFromMatrixPosition(y.matrixWorld), s.setFromMatrixPosition(y.target.matrixWorld), v.direction.sub(s), v.direction.transformDirection(p), u++;
                } else if (y.isSpotLight) {
                    const v = n.spot[f];
                    v.position.setFromMatrixPosition(y.matrixWorld), v.position.applyMatrix4(p), v.direction.setFromMatrixPosition(y.matrixWorld), s.setFromMatrixPosition(y.target.matrixWorld), v.direction.sub(s), v.direction.transformDirection(p), f++;
                } else if (y.isRectAreaLight) {
                    const v = n.rectArea[_];
                    v.position.setFromMatrixPosition(y.matrixWorld), v.position.applyMatrix4(p), a.identity(), r.copy(y.matrixWorld), r.premultiply(p), a.extractRotation(r), v.halfWidth.set(y.width * .5, 0, 0), v.halfHeight.set(0, y.height * .5, 0), v.halfWidth.applyMatrix4(a), v.halfHeight.applyMatrix4(a), _++;
                } else if (y.isPointLight) {
                    const v = n.point[d];
                    v.position.setFromMatrixPosition(y.matrixWorld), v.position.applyMatrix4(p), d++;
                } else if (y.isHemisphereLight) {
                    const v = n.hemi[g];
                    v.direction.setFromMatrixPosition(y.matrixWorld), v.direction.transformDirection(p), g++;
                }
            }
        }
        return {
            setup: o,
            setupView: c,
            state: n
        };
    }
    function td(i) {
        const t = new gS(i), e = [], n = [];
        function s(h) {
            l.camera = h, e.length = 0, n.length = 0;
        }
        function r(h) {
            e.push(h);
        }
        function a(h) {
            n.push(h);
        }
        function o() {
            t.setup(e);
        }
        function c(h) {
            t.setupView(e, h);
        }
        const l = {
            lightsArray: e,
            shadowsArray: n,
            camera: null,
            lights: t,
            transmissionRenderTarget: {}
        };
        return {
            init: s,
            state: l,
            setupLights: o,
            setupLightsView: c,
            pushLight: r,
            pushShadow: a
        };
    }
    function xS(i) {
        let t = new WeakMap;
        function e(s, r = 0) {
            const a = t.get(s);
            let o;
            return a === void 0 ? (o = new td(i), t.set(s, [
                o
            ])) : r >= a.length ? (o = new td(i), a.push(o)) : o = a[r], o;
        }
        function n() {
            t = new WeakMap;
        }
        return {
            get: e,
            dispose: n
        };
    }
    const vS = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, yS = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
    function bS(i, t, e) {
        let n = new $l;
        const s = new Kt, r = new Kt, a = new ne, o = new gx({
            depthPacking: rg
        }), c = new xx, l = {}, h = e.maxTextureSize, u = {
            [ii]: Qe,
            [Qe]: ii,
            [dn]: dn
        }, d = new yi({
            defines: {
                VSM_SAMPLES: 8
            },
            uniforms: {
                shadow_pass: {
                    value: null
                },
                resolution: {
                    value: new Kt
                },
                radius: {
                    value: 4
                }
            },
            vertexShader: vS,
            fragmentShader: yS
        }), f = d.clone();
        f.defines.HORIZONTAL_PASS = 1;
        const _ = new kn;
        _.setAttribute("position", new je(new Float32Array([
            -1,
            -1,
            .5,
            3,
            -1,
            .5,
            -1,
            3,
            .5
        ]), 3));
        const g = new Le(_, d), p = this;
        this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = vf;
        let m = this.type;
        this.render = function(w, R, N) {
            if (p.enabled === !1 || p.autoUpdate === !1 && p.needsUpdate === !1 || w.length === 0) return;
            const E = i.getRenderTarget(), S = i.getActiveCubeFace(), D = i.getActiveMipmapLevel(), j = i.state;
            j.setBlending(_i), j.buffers.color.setClear(1, 1, 1, 1), j.buffers.depth.setTest(!0), j.setScissorTest(!1);
            const z = m !== $n && this.type === $n, K = m === $n && this.type !== $n;
            for(let nt = 0, b = w.length; nt < b; nt++){
                const C = w[nt], A = C.shadow;
                if (A === void 0) {
                    console.warn("THREE.WebGLShadowMap:", C, "has no shadow.");
                    continue;
                }
                if (A.autoUpdate === !1 && A.needsUpdate === !1) continue;
                s.copy(A.mapSize);
                const U = A.getFrameExtents();
                if (s.multiply(U), r.copy(A.mapSize), (s.x > h || s.y > h) && (s.x > h && (r.x = Math.floor(h / U.x), s.x = r.x * U.x, A.mapSize.x = r.x), s.y > h && (r.y = Math.floor(h / U.y), s.y = r.y * U.y, A.mapSize.y = r.y)), A.map === null || z === !0 || K === !0) {
                    const V = this.type !== $n ? {
                        minFilter: qe,
                        magFilter: qe
                    } : {};
                    A.map !== null && A.map.dispose(), A.map = new Wi(s.x, s.y, V), A.map.texture.name = C.name + ".shadowMap", A.camera.updateProjectionMatrix();
                }
                i.setRenderTarget(A.map), i.clear();
                const B = A.getViewportCount();
                for(let V = 0; V < B; V++){
                    const q = A.getViewport(V);
                    a.set(r.x * q.x, r.y * q.y, r.x * q.z, r.y * q.w), j.viewport(a), A.updateMatrices(C, V), n = A.getFrustum(), v(R, N, A.camera, C, this.type);
                }
                A.isPointLightShadow !== !0 && this.type === $n && x(A, N), A.needsUpdate = !1;
            }
            m = this.type, p.needsUpdate = !1, i.setRenderTarget(E, S, D);
        };
        function x(w, R) {
            const N = t.update(g);
            d.defines.VSM_SAMPLES !== w.blurSamples && (d.defines.VSM_SAMPLES = w.blurSamples, f.defines.VSM_SAMPLES = w.blurSamples, d.needsUpdate = !0, f.needsUpdate = !0), w.mapPass === null && (w.mapPass = new Wi(s.x, s.y)), d.uniforms.shadow_pass.value = w.map.texture, d.uniforms.resolution.value = w.mapSize, d.uniforms.radius.value = w.radius, i.setRenderTarget(w.mapPass), i.clear(), i.renderBufferDirect(R, null, N, d, g, null), f.uniforms.shadow_pass.value = w.mapPass.texture, f.uniforms.resolution.value = w.mapSize, f.uniforms.radius.value = w.radius, i.setRenderTarget(w.map), i.clear(), i.renderBufferDirect(R, null, N, f, g, null);
        }
        function y(w, R, N, E) {
            let S = null;
            const D = N.isPointLight === !0 ? w.customDistanceMaterial : w.customDepthMaterial;
            if (D !== void 0) S = D;
            else if (S = N.isPointLight === !0 ? c : o, i.localClippingEnabled && R.clipShadows === !0 && Array.isArray(R.clippingPlanes) && R.clippingPlanes.length !== 0 || R.displacementMap && R.displacementScale !== 0 || R.alphaMap && R.alphaTest > 0 || R.map && R.alphaTest > 0) {
                const j = S.uuid, z = R.uuid;
                let K = l[j];
                K === void 0 && (K = {}, l[j] = K);
                let nt = K[z];
                nt === void 0 && (nt = S.clone(), K[z] = nt, R.addEventListener("dispose", I)), S = nt;
            }
            if (S.visible = R.visible, S.wireframe = R.wireframe, E === $n ? S.side = R.shadowSide !== null ? R.shadowSide : R.side : S.side = R.shadowSide !== null ? R.shadowSide : u[R.side], S.alphaMap = R.alphaMap, S.alphaTest = R.alphaTest, S.map = R.map, S.clipShadows = R.clipShadows, S.clippingPlanes = R.clippingPlanes, S.clipIntersection = R.clipIntersection, S.displacementMap = R.displacementMap, S.displacementScale = R.displacementScale, S.displacementBias = R.displacementBias, S.wireframeLinewidth = R.wireframeLinewidth, S.linewidth = R.linewidth, N.isPointLight === !0 && S.isMeshDistanceMaterial === !0) {
                const j = i.properties.get(S);
                j.light = N;
            }
            return S;
        }
        function v(w, R, N, E, S) {
            if (w.visible === !1) return;
            if (w.layers.test(R.layers) && (w.isMesh || w.isLine || w.isPoints) && (w.castShadow || w.receiveShadow && S === $n) && (!w.frustumCulled || n.intersectsObject(w))) {
                w.modelViewMatrix.multiplyMatrices(N.matrixWorldInverse, w.matrixWorld);
                const z = t.update(w), K = w.material;
                if (Array.isArray(K)) {
                    const nt = z.groups;
                    for(let b = 0, C = nt.length; b < C; b++){
                        const A = nt[b], U = K[A.materialIndex];
                        if (U && U.visible) {
                            const B = y(w, U, E, S);
                            w.onBeforeShadow(i, w, R, N, z, B, A), i.renderBufferDirect(N, null, z, B, w, A), w.onAfterShadow(i, w, R, N, z, B, A);
                        }
                    }
                } else if (K.visible) {
                    const nt = y(w, K, E, S);
                    w.onBeforeShadow(i, w, R, N, z, nt, null), i.renderBufferDirect(N, null, z, nt, w, null), w.onAfterShadow(i, w, R, N, z, nt, null);
                }
            }
            const j = w.children;
            for(let z = 0, K = j.length; z < K; z++)v(j[z], R, N, E, S);
        }
        function I(w) {
            w.target.removeEventListener("dispose", I);
            for(const N in l){
                const E = l[N], S = w.target.uuid;
                S in E && (E[S].dispose(), delete E[S]);
            }
        }
    }
    const SS = {
        [Sc]: Mc,
        [Tc]: wc,
        [Ec]: Rc,
        [Rs]: Ac,
        [Mc]: Sc,
        [wc]: Tc,
        [Rc]: Ec,
        [Ac]: Rs
    };
    function MS(i, t) {
        function e() {
            let F = !1;
            const pt = new ne;
            let Z = null;
            const tt = new ne(0, 0, 0, 0);
            return {
                setMask: function(_t) {
                    Z !== _t && !F && (i.colorMask(_t, _t, _t, _t), Z = _t);
                },
                setLocked: function(_t) {
                    F = _t;
                },
                setClear: function(_t, mt, kt, xe, Fe) {
                    Fe === !0 && (_t *= xe, mt *= xe, kt *= xe), pt.set(_t, mt, kt, xe), tt.equals(pt) === !1 && (i.clearColor(_t, mt, kt, xe), tt.copy(pt));
                },
                reset: function() {
                    F = !1, Z = null, tt.set(-1, 0, 0, 0);
                }
            };
        }
        function n() {
            let F = !1, pt = !1, Z = null, tt = null, _t = null;
            return {
                setReversed: function(mt) {
                    if (pt !== mt) {
                        const kt = t.get("EXT_clip_control");
                        mt ? kt.clipControlEXT(kt.LOWER_LEFT_EXT, kt.ZERO_TO_ONE_EXT) : kt.clipControlEXT(kt.LOWER_LEFT_EXT, kt.NEGATIVE_ONE_TO_ONE_EXT), pt = mt;
                        const xe = _t;
                        _t = null, this.setClear(xe);
                    }
                },
                getReversed: function() {
                    return pt;
                },
                setTest: function(mt) {
                    mt ? it(i.DEPTH_TEST) : lt(i.DEPTH_TEST);
                },
                setMask: function(mt) {
                    Z !== mt && !F && (i.depthMask(mt), Z = mt);
                },
                setFunc: function(mt) {
                    if (pt && (mt = SS[mt]), tt !== mt) {
                        switch(mt){
                            case Sc:
                                i.depthFunc(i.NEVER);
                                break;
                            case Mc:
                                i.depthFunc(i.ALWAYS);
                                break;
                            case Tc:
                                i.depthFunc(i.LESS);
                                break;
                            case Rs:
                                i.depthFunc(i.LEQUAL);
                                break;
                            case Ec:
                                i.depthFunc(i.EQUAL);
                                break;
                            case Ac:
                                i.depthFunc(i.GEQUAL);
                                break;
                            case wc:
                                i.depthFunc(i.GREATER);
                                break;
                            case Rc:
                                i.depthFunc(i.NOTEQUAL);
                                break;
                            default:
                                i.depthFunc(i.LEQUAL);
                        }
                        tt = mt;
                    }
                },
                setLocked: function(mt) {
                    F = mt;
                },
                setClear: function(mt) {
                    _t !== mt && (pt && (mt = 1 - mt), i.clearDepth(mt), _t = mt);
                },
                reset: function() {
                    F = !1, Z = null, tt = null, _t = null, pt = !1;
                }
            };
        }
        function s() {
            let F = !1, pt = null, Z = null, tt = null, _t = null, mt = null, kt = null, xe = null, Fe = null;
            return {
                setTest: function(ae) {
                    F || (ae ? it(i.STENCIL_TEST) : lt(i.STENCIL_TEST));
                },
                setMask: function(ae) {
                    pt !== ae && !F && (i.stencilMask(ae), pt = ae);
                },
                setFunc: function(ae, _n, Hn) {
                    (Z !== ae || tt !== _n || _t !== Hn) && (i.stencilFunc(ae, _n, Hn), Z = ae, tt = _n, _t = Hn);
                },
                setOp: function(ae, _n, Hn) {
                    (mt !== ae || kt !== _n || xe !== Hn) && (i.stencilOp(ae, _n, Hn), mt = ae, kt = _n, xe = Hn);
                },
                setLocked: function(ae) {
                    F = ae;
                },
                setClear: function(ae) {
                    Fe !== ae && (i.clearStencil(ae), Fe = ae);
                },
                reset: function() {
                    F = !1, pt = null, Z = null, tt = null, _t = null, mt = null, kt = null, xe = null, Fe = null;
                }
            };
        }
        const r = new e, a = new n, o = new s, c = new WeakMap, l = new WeakMap;
        let h = {}, u = {}, d = new WeakMap, f = [], _ = null, g = !1, p = null, m = null, x = null, y = null, v = null, I = null, w = null, R = new Bt(0, 0, 0), N = 0, E = !1, S = null, D = null, j = null, z = null, K = null;
        const nt = i.getParameter(i.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        let b = !1, C = 0;
        const A = i.getParameter(i.VERSION);
        A.indexOf("WebGL") !== -1 ? (C = parseFloat(/^WebGL (\d)/.exec(A)[1]), b = C >= 1) : A.indexOf("OpenGL ES") !== -1 && (C = parseFloat(/^OpenGL ES (\d)/.exec(A)[1]), b = C >= 2);
        let U = null, B = {};
        const V = i.getParameter(i.SCISSOR_BOX), q = i.getParameter(i.VIEWPORT), et = new ne().fromArray(V), H = new ne().fromArray(q);
        function $(F, pt, Z, tt) {
            const _t = new Uint8Array(4), mt = i.createTexture();
            i.bindTexture(F, mt), i.texParameteri(F, i.TEXTURE_MIN_FILTER, i.NEAREST), i.texParameteri(F, i.TEXTURE_MAG_FILTER, i.NEAREST);
            for(let kt = 0; kt < Z; kt++)F === i.TEXTURE_3D || F === i.TEXTURE_2D_ARRAY ? i.texImage3D(pt, 0, i.RGBA, 1, 1, tt, 0, i.RGBA, i.UNSIGNED_BYTE, _t) : i.texImage2D(pt + kt, 0, i.RGBA, 1, 1, 0, i.RGBA, i.UNSIGNED_BYTE, _t);
            return mt;
        }
        const ot = {};
        ot[i.TEXTURE_2D] = $(i.TEXTURE_2D, i.TEXTURE_2D, 1), ot[i.TEXTURE_CUBE_MAP] = $(i.TEXTURE_CUBE_MAP, i.TEXTURE_CUBE_MAP_POSITIVE_X, 6), ot[i.TEXTURE_2D_ARRAY] = $(i.TEXTURE_2D_ARRAY, i.TEXTURE_2D_ARRAY, 1, 1), ot[i.TEXTURE_3D] = $(i.TEXTURE_3D, i.TEXTURE_3D, 1, 1), r.setClear(0, 0, 0, 1), a.setClear(1), o.setClear(0), it(i.DEPTH_TEST), a.setFunc(Rs), gt(!1), Xt(Gh), it(i.CULL_FACE), L(_i);
        function it(F) {
            h[F] !== !0 && (i.enable(F), h[F] = !0);
        }
        function lt(F) {
            h[F] !== !1 && (i.disable(F), h[F] = !1);
        }
        function wt(F, pt) {
            return u[F] !== pt ? (i.bindFramebuffer(F, pt), u[F] = pt, F === i.DRAW_FRAMEBUFFER && (u[i.FRAMEBUFFER] = pt), F === i.FRAMEBUFFER && (u[i.DRAW_FRAMEBUFFER] = pt), !0) : !1;
        }
        function ht(F, pt) {
            let Z = f, tt = !1;
            if (F) {
                Z = d.get(pt), Z === void 0 && (Z = [], d.set(pt, Z));
                const _t = F.textures;
                if (Z.length !== _t.length || Z[0] !== i.COLOR_ATTACHMENT0) {
                    for(let mt = 0, kt = _t.length; mt < kt; mt++)Z[mt] = i.COLOR_ATTACHMENT0 + mt;
                    Z.length = _t.length, tt = !0;
                }
            } else Z[0] !== i.BACK && (Z[0] = i.BACK, tt = !0);
            tt && i.drawBuffers(Z);
        }
        function ee(F) {
            return _ !== F ? (i.useProgram(F), _ = F, !0) : !1;
        }
        const Wt = {
            [Fi]: i.FUNC_ADD,
            [w_]: i.FUNC_SUBTRACT,
            [R_]: i.FUNC_REVERSE_SUBTRACT
        };
        Wt[C_] = i.MIN, Wt[P_] = i.MAX;
        const Lt = {
            [I_]: i.ZERO,
            [D_]: i.ONE,
            [L_]: i.SRC_COLOR,
            [yc]: i.SRC_ALPHA,
            [k_]: i.SRC_ALPHA_SATURATE,
            [F_]: i.DST_COLOR,
            [N_]: i.DST_ALPHA,
            [U_]: i.ONE_MINUS_SRC_COLOR,
            [bc]: i.ONE_MINUS_SRC_ALPHA,
            [O_]: i.ONE_MINUS_DST_COLOR,
            [B_]: i.ONE_MINUS_DST_ALPHA,
            [G_]: i.CONSTANT_COLOR,
            [H_]: i.ONE_MINUS_CONSTANT_COLOR,
            [z_]: i.CONSTANT_ALPHA,
            [V_]: i.ONE_MINUS_CONSTANT_ALPHA
        };
        function L(F, pt, Z, tt, _t, mt, kt, xe, Fe, ae) {
            if (F === _i) {
                g === !0 && (lt(i.BLEND), g = !1);
                return;
            }
            if (g === !1 && (it(i.BLEND), g = !0), F !== A_) {
                if (F !== p || ae !== E) {
                    if ((m !== Fi || v !== Fi) && (i.blendEquation(i.FUNC_ADD), m = Fi, v = Fi), ae) switch(F){
                        case Ts:
                            i.blendFuncSeparate(i.ONE, i.ONE_MINUS_SRC_ALPHA, i.ONE, i.ONE_MINUS_SRC_ALPHA);
                            break;
                        case Hh:
                            i.blendFunc(i.ONE, i.ONE);
                            break;
                        case zh:
                            i.blendFuncSeparate(i.ZERO, i.ONE_MINUS_SRC_COLOR, i.ZERO, i.ONE);
                            break;
                        case Vh:
                            i.blendFuncSeparate(i.ZERO, i.SRC_COLOR, i.ZERO, i.SRC_ALPHA);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", F);
                            break;
                    }
                    else switch(F){
                        case Ts:
                            i.blendFuncSeparate(i.SRC_ALPHA, i.ONE_MINUS_SRC_ALPHA, i.ONE, i.ONE_MINUS_SRC_ALPHA);
                            break;
                        case Hh:
                            i.blendFunc(i.SRC_ALPHA, i.ONE);
                            break;
                        case zh:
                            i.blendFuncSeparate(i.ZERO, i.ONE_MINUS_SRC_COLOR, i.ZERO, i.ONE);
                            break;
                        case Vh:
                            i.blendFunc(i.ZERO, i.SRC_COLOR);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", F);
                            break;
                    }
                    x = null, y = null, I = null, w = null, R.set(0, 0, 0), N = 0, p = F, E = ae;
                }
                return;
            }
            _t = _t || pt, mt = mt || Z, kt = kt || tt, (pt !== m || _t !== v) && (i.blendEquationSeparate(Wt[pt], Wt[_t]), m = pt, v = _t), (Z !== x || tt !== y || mt !== I || kt !== w) && (i.blendFuncSeparate(Lt[Z], Lt[tt], Lt[mt], Lt[kt]), x = Z, y = tt, I = mt, w = kt), (xe.equals(R) === !1 || Fe !== N) && (i.blendColor(xe.r, xe.g, xe.b, Fe), R.copy(xe), N = Fe), p = F, E = !1;
        }
        function Ct(F, pt) {
            F.side === dn ? lt(i.CULL_FACE) : it(i.CULL_FACE);
            let Z = F.side === Qe;
            pt && (Z = !Z), gt(Z), F.blending === Ts && F.transparent === !1 ? L(_i) : L(F.blending, F.blendEquation, F.blendSrc, F.blendDst, F.blendEquationAlpha, F.blendSrcAlpha, F.blendDstAlpha, F.blendColor, F.blendAlpha, F.premultipliedAlpha), a.setFunc(F.depthFunc), a.setTest(F.depthTest), a.setMask(F.depthWrite), r.setMask(F.colorWrite);
            const tt = F.stencilWrite;
            o.setTest(tt), tt && (o.setMask(F.stencilWriteMask), o.setFunc(F.stencilFunc, F.stencilRef, F.stencilFuncMask), o.setOp(F.stencilFail, F.stencilZFail, F.stencilZPass)), le(F.polygonOffset, F.polygonOffsetFactor, F.polygonOffsetUnits), F.alphaToCoverage === !0 ? it(i.SAMPLE_ALPHA_TO_COVERAGE) : lt(i.SAMPLE_ALPHA_TO_COVERAGE);
        }
        function gt(F) {
            S !== F && (F ? i.frontFace(i.CW) : i.frontFace(i.CCW), S = F);
        }
        function Xt(F) {
            F !== M_ ? (it(i.CULL_FACE), F !== D && (F === Gh ? i.cullFace(i.BACK) : F === T_ ? i.cullFace(i.FRONT) : i.cullFace(i.FRONT_AND_BACK))) : lt(i.CULL_FACE), D = F;
        }
        function Et(F) {
            F !== j && (b && i.lineWidth(F), j = F);
        }
        function le(F, pt, Z) {
            F ? (it(i.POLYGON_OFFSET_FILL), (z !== pt || K !== Z) && (i.polygonOffset(pt, Z), z = pt, K = Z)) : lt(i.POLYGON_OFFSET_FILL);
        }
        function At(F) {
            F ? it(i.SCISSOR_TEST) : lt(i.SCISSOR_TEST);
        }
        function P(F) {
            F === void 0 && (F = i.TEXTURE0 + nt - 1), U !== F && (i.activeTexture(F), U = F);
        }
        function M(F, pt, Z) {
            Z === void 0 && (U === null ? Z = i.TEXTURE0 + nt - 1 : Z = U);
            let tt = B[Z];
            tt === void 0 && (tt = {
                type: void 0,
                texture: void 0
            }, B[Z] = tt), (tt.type !== F || tt.texture !== pt) && (U !== Z && (i.activeTexture(Z), U = Z), i.bindTexture(F, pt || ot[F]), tt.type = F, tt.texture = pt);
        }
        function W() {
            const F = B[U];
            F !== void 0 && F.type !== void 0 && (i.bindTexture(F.type, null), F.type = void 0, F.texture = void 0);
        }
        function Q() {
            try {
                i.compressedTexImage2D(...arguments);
            } catch (F) {
                console.error("THREE.WebGLState:", F);
            }
        }
        function rt() {
            try {
                i.compressedTexImage3D(...arguments);
            } catch (F) {
                console.error("THREE.WebGLState:", F);
            }
        }
        function J() {
            try {
                i.texSubImage2D(...arguments);
            } catch (F) {
                console.error("THREE.WebGLState:", F);
            }
        }
        function Tt() {
            try {
                i.texSubImage3D(...arguments);
            } catch (F) {
                console.error("THREE.WebGLState:", F);
            }
        }
        function ft() {
            try {
                i.compressedTexSubImage2D(...arguments);
            } catch (F) {
                console.error("THREE.WebGLState:", F);
            }
        }
        function vt() {
            try {
                i.compressedTexSubImage3D(...arguments);
            } catch (F) {
                console.error("THREE.WebGLState:", F);
            }
        }
        function Zt() {
            try {
                i.texStorage2D(...arguments);
            } catch (F) {
                console.error("THREE.WebGLState:", F);
            }
        }
        function ct() {
            try {
                i.texStorage3D(...arguments);
            } catch (F) {
                console.error("THREE.WebGLState:", F);
            }
        }
        function yt() {
            try {
                i.texImage2D(...arguments);
            } catch (F) {
                console.error("THREE.WebGLState:", F);
            }
        }
        function It() {
            try {
                i.texImage3D(...arguments);
            } catch (F) {
                console.error("THREE.WebGLState:", F);
            }
        }
        function Ut(F) {
            et.equals(F) === !1 && (i.scissor(F.x, F.y, F.z, F.w), et.copy(F));
        }
        function bt(F) {
            H.equals(F) === !1 && (i.viewport(F.x, F.y, F.z, F.w), H.copy(F));
        }
        function jt(F, pt) {
            let Z = l.get(pt);
            Z === void 0 && (Z = new WeakMap, l.set(pt, Z));
            let tt = Z.get(F);
            tt === void 0 && (tt = i.getUniformBlockIndex(pt, F.name), Z.set(F, tt));
        }
        function zt(F, pt) {
            const tt = l.get(pt).get(F);
            c.get(pt) !== tt && (i.uniformBlockBinding(pt, tt, F.__bindingPointIndex), c.set(pt, tt));
        }
        function he() {
            i.disable(i.BLEND), i.disable(i.CULL_FACE), i.disable(i.DEPTH_TEST), i.disable(i.POLYGON_OFFSET_FILL), i.disable(i.SCISSOR_TEST), i.disable(i.STENCIL_TEST), i.disable(i.SAMPLE_ALPHA_TO_COVERAGE), i.blendEquation(i.FUNC_ADD), i.blendFunc(i.ONE, i.ZERO), i.blendFuncSeparate(i.ONE, i.ZERO, i.ONE, i.ZERO), i.blendColor(0, 0, 0, 0), i.colorMask(!0, !0, !0, !0), i.clearColor(0, 0, 0, 0), i.depthMask(!0), i.depthFunc(i.LESS), a.setReversed(!1), i.clearDepth(1), i.stencilMask(4294967295), i.stencilFunc(i.ALWAYS, 0, 4294967295), i.stencilOp(i.KEEP, i.KEEP, i.KEEP), i.clearStencil(0), i.cullFace(i.BACK), i.frontFace(i.CCW), i.polygonOffset(0, 0), i.activeTexture(i.TEXTURE0), i.bindFramebuffer(i.FRAMEBUFFER, null), i.bindFramebuffer(i.DRAW_FRAMEBUFFER, null), i.bindFramebuffer(i.READ_FRAMEBUFFER, null), i.useProgram(null), i.lineWidth(1), i.scissor(0, 0, i.canvas.width, i.canvas.height), i.viewport(0, 0, i.canvas.width, i.canvas.height), h = {}, U = null, B = {}, u = {}, d = new WeakMap, f = [], _ = null, g = !1, p = null, m = null, x = null, y = null, v = null, I = null, w = null, R = new Bt(0, 0, 0), N = 0, E = !1, S = null, D = null, j = null, z = null, K = null, et.set(0, 0, i.canvas.width, i.canvas.height), H.set(0, 0, i.canvas.width, i.canvas.height), r.reset(), a.reset(), o.reset();
        }
        return {
            buffers: {
                color: r,
                depth: a,
                stencil: o
            },
            enable: it,
            disable: lt,
            bindFramebuffer: wt,
            drawBuffers: ht,
            useProgram: ee,
            setBlending: L,
            setMaterial: Ct,
            setFlipSided: gt,
            setCullFace: Xt,
            setLineWidth: Et,
            setPolygonOffset: le,
            setScissorTest: At,
            activeTexture: P,
            bindTexture: M,
            unbindTexture: W,
            compressedTexImage2D: Q,
            compressedTexImage3D: rt,
            texImage2D: yt,
            texImage3D: It,
            updateUBOMapping: jt,
            uniformBlockBinding: zt,
            texStorage2D: Zt,
            texStorage3D: ct,
            texSubImage2D: J,
            texSubImage3D: Tt,
            compressedTexSubImage2D: ft,
            compressedTexSubImage3D: vt,
            scissor: Ut,
            viewport: bt,
            reset: he
        };
    }
    function TS(i, t, e, n, s, r, a) {
        const o = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null, c = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), l = new Kt, h = new WeakMap;
        let u;
        const d = new WeakMap;
        let f = !1;
        try {
            f = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
        } catch  {}
        function _(P, M) {
            return f ? new OffscreenCanvas(P, M) : Pr("canvas");
        }
        function g(P, M, W) {
            let Q = 1;
            const rt = At(P);
            if ((rt.width > W || rt.height > W) && (Q = W / Math.max(rt.width, rt.height)), Q < 1) if (typeof HTMLImageElement < "u" && P instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && P instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && P instanceof ImageBitmap || typeof VideoFrame < "u" && P instanceof VideoFrame) {
                const J = Math.floor(Q * rt.width), Tt = Math.floor(Q * rt.height);
                u === void 0 && (u = _(J, Tt));
                const ft = M ? _(J, Tt) : u;
                return ft.width = J, ft.height = Tt, ft.getContext("2d").drawImage(P, 0, 0, J, Tt), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + rt.width + "x" + rt.height + ") to (" + J + "x" + Tt + ")."), ft;
            } else return "data" in P && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + rt.width + "x" + rt.height + ")."), P;
            return P;
        }
        function p(P) {
            return P.generateMipmaps;
        }
        function m(P) {
            i.generateMipmap(P);
        }
        function x(P) {
            return P.isWebGLCubeRenderTarget ? i.TEXTURE_CUBE_MAP : P.isWebGL3DRenderTarget ? i.TEXTURE_3D : P.isWebGLArrayRenderTarget || P.isCompressedArrayTexture ? i.TEXTURE_2D_ARRAY : i.TEXTURE_2D;
        }
        function y(P, M, W, Q, rt = !1) {
            if (P !== null) {
                if (i[P] !== void 0) return i[P];
                console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + P + "'");
            }
            let J = M;
            if (M === i.RED && (W === i.FLOAT && (J = i.R32F), W === i.HALF_FLOAT && (J = i.R16F), W === i.UNSIGNED_BYTE && (J = i.R8)), M === i.RED_INTEGER && (W === i.UNSIGNED_BYTE && (J = i.R8UI), W === i.UNSIGNED_SHORT && (J = i.R16UI), W === i.UNSIGNED_INT && (J = i.R32UI), W === i.BYTE && (J = i.R8I), W === i.SHORT && (J = i.R16I), W === i.INT && (J = i.R32I)), M === i.RG && (W === i.FLOAT && (J = i.RG32F), W === i.HALF_FLOAT && (J = i.RG16F), W === i.UNSIGNED_BYTE && (J = i.RG8)), M === i.RG_INTEGER && (W === i.UNSIGNED_BYTE && (J = i.RG8UI), W === i.UNSIGNED_SHORT && (J = i.RG16UI), W === i.UNSIGNED_INT && (J = i.RG32UI), W === i.BYTE && (J = i.RG8I), W === i.SHORT && (J = i.RG16I), W === i.INT && (J = i.RG32I)), M === i.RGB_INTEGER && (W === i.UNSIGNED_BYTE && (J = i.RGB8UI), W === i.UNSIGNED_SHORT && (J = i.RGB16UI), W === i.UNSIGNED_INT && (J = i.RGB32UI), W === i.BYTE && (J = i.RGB8I), W === i.SHORT && (J = i.RGB16I), W === i.INT && (J = i.RGB32I)), M === i.RGBA_INTEGER && (W === i.UNSIGNED_BYTE && (J = i.RGBA8UI), W === i.UNSIGNED_SHORT && (J = i.RGBA16UI), W === i.UNSIGNED_INT && (J = i.RGBA32UI), W === i.BYTE && (J = i.RGBA8I), W === i.SHORT && (J = i.RGBA16I), W === i.INT && (J = i.RGBA32I)), M === i.RGB && W === i.UNSIGNED_INT_5_9_9_9_REV && (J = i.RGB9_E5), M === i.RGBA) {
                const Tt = rt ? Oa : $t.getTransfer(Q);
                W === i.FLOAT && (J = i.RGBA32F), W === i.HALF_FLOAT && (J = i.RGBA16F), W === i.UNSIGNED_BYTE && (J = Tt === ce ? i.SRGB8_ALPHA8 : i.RGBA8), W === i.UNSIGNED_SHORT_4_4_4_4 && (J = i.RGBA4), W === i.UNSIGNED_SHORT_5_5_5_1 && (J = i.RGB5_A1);
            }
            return (J === i.R16F || J === i.R32F || J === i.RG16F || J === i.RG32F || J === i.RGBA16F || J === i.RGBA32F) && t.get("EXT_color_buffer_float"), J;
        }
        function v(P, M) {
            let W;
            return P ? M === null || M === Vi || M === Er ? W = i.DEPTH24_STENCIL8 : M === An ? W = i.DEPTH32F_STENCIL8 : M === Tr && (W = i.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : M === null || M === Vi || M === Er ? W = i.DEPTH_COMPONENT24 : M === An ? W = i.DEPTH_COMPONENT32F : M === Tr && (W = i.DEPTH_COMPONENT16), W;
        }
        function I(P, M) {
            return p(P) === !0 || P.isFramebufferTexture && P.minFilter !== qe && P.minFilter !== on ? Math.log2(Math.max(M.width, M.height)) + 1 : P.mipmaps !== void 0 && P.mipmaps.length > 0 ? P.mipmaps.length : P.isCompressedTexture && Array.isArray(P.image) ? M.mipmaps.length : 1;
        }
        function w(P) {
            const M = P.target;
            M.removeEventListener("dispose", w), N(M), M.isVideoTexture && h.delete(M);
        }
        function R(P) {
            const M = P.target;
            M.removeEventListener("dispose", R), S(M);
        }
        function N(P) {
            const M = n.get(P);
            if (M.__webglInit === void 0) return;
            const W = P.source, Q = d.get(W);
            if (Q) {
                const rt = Q[M.__cacheKey];
                rt.usedTimes--, rt.usedTimes === 0 && E(P), Object.keys(Q).length === 0 && d.delete(W);
            }
            n.remove(P);
        }
        function E(P) {
            const M = n.get(P);
            i.deleteTexture(M.__webglTexture);
            const W = P.source, Q = d.get(W);
            delete Q[M.__cacheKey], a.memory.textures--;
        }
        function S(P) {
            const M = n.get(P);
            if (P.depthTexture && (P.depthTexture.dispose(), n.remove(P.depthTexture)), P.isWebGLCubeRenderTarget) for(let Q = 0; Q < 6; Q++){
                if (Array.isArray(M.__webglFramebuffer[Q])) for(let rt = 0; rt < M.__webglFramebuffer[Q].length; rt++)i.deleteFramebuffer(M.__webglFramebuffer[Q][rt]);
                else i.deleteFramebuffer(M.__webglFramebuffer[Q]);
                M.__webglDepthbuffer && i.deleteRenderbuffer(M.__webglDepthbuffer[Q]);
            }
            else {
                if (Array.isArray(M.__webglFramebuffer)) for(let Q = 0; Q < M.__webglFramebuffer.length; Q++)i.deleteFramebuffer(M.__webglFramebuffer[Q]);
                else i.deleteFramebuffer(M.__webglFramebuffer);
                if (M.__webglDepthbuffer && i.deleteRenderbuffer(M.__webglDepthbuffer), M.__webglMultisampledFramebuffer && i.deleteFramebuffer(M.__webglMultisampledFramebuffer), M.__webglColorRenderbuffer) for(let Q = 0; Q < M.__webglColorRenderbuffer.length; Q++)M.__webglColorRenderbuffer[Q] && i.deleteRenderbuffer(M.__webglColorRenderbuffer[Q]);
                M.__webglDepthRenderbuffer && i.deleteRenderbuffer(M.__webglDepthRenderbuffer);
            }
            const W = P.textures;
            for(let Q = 0, rt = W.length; Q < rt; Q++){
                const J = n.get(W[Q]);
                J.__webglTexture && (i.deleteTexture(J.__webglTexture), a.memory.textures--), n.remove(W[Q]);
            }
            n.remove(P);
        }
        let D = 0;
        function j() {
            D = 0;
        }
        function z() {
            const P = D;
            return P >= s.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + P + " texture units while this GPU supports only " + s.maxTextures), D += 1, P;
        }
        function K(P) {
            const M = [];
            return M.push(P.wrapS), M.push(P.wrapT), M.push(P.wrapR || 0), M.push(P.magFilter), M.push(P.minFilter), M.push(P.anisotropy), M.push(P.internalFormat), M.push(P.format), M.push(P.type), M.push(P.generateMipmaps), M.push(P.premultiplyAlpha), M.push(P.flipY), M.push(P.unpackAlignment), M.push(P.colorSpace), M.join();
        }
        function nt(P, M) {
            const W = n.get(P);
            if (P.isVideoTexture && Et(P), P.isRenderTargetTexture === !1 && P.version > 0 && W.__version !== P.version) {
                const Q = P.image;
                if (Q === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
                else if (Q.complete === !1) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
                else {
                    H(W, P, M);
                    return;
                }
            }
            e.bindTexture(i.TEXTURE_2D, W.__webglTexture, i.TEXTURE0 + M);
        }
        function b(P, M) {
            const W = n.get(P);
            if (P.version > 0 && W.__version !== P.version) {
                H(W, P, M);
                return;
            }
            e.bindTexture(i.TEXTURE_2D_ARRAY, W.__webglTexture, i.TEXTURE0 + M);
        }
        function C(P, M) {
            const W = n.get(P);
            if (P.version > 0 && W.__version !== P.version) {
                H(W, P, M);
                return;
            }
            e.bindTexture(i.TEXTURE_3D, W.__webglTexture, i.TEXTURE0 + M);
        }
        function A(P, M) {
            const W = n.get(P);
            if (P.version > 0 && W.__version !== P.version) {
                $(W, P, M);
                return;
            }
            e.bindTexture(i.TEXTURE_CUBE_MAP, W.__webglTexture, i.TEXTURE0 + M);
        }
        const U = {
            [Is]: i.REPEAT,
            [fi]: i.CLAMP_TO_EDGE,
            [Ba]: i.MIRRORED_REPEAT
        }, B = {
            [qe]: i.NEAREST,
            [Sf]: i.NEAREST_MIPMAP_NEAREST,
            [lr]: i.NEAREST_MIPMAP_LINEAR,
            [on]: i.LINEAR,
            [Ta]: i.LINEAR_MIPMAP_NEAREST,
            [Zn]: i.LINEAR_MIPMAP_LINEAR
        }, V = {
            [og]: i.NEVER,
            [fg]: i.ALWAYS,
            [cg]: i.LESS,
            [Uf]: i.LEQUAL,
            [lg]: i.EQUAL,
            [dg]: i.GEQUAL,
            [hg]: i.GREATER,
            [ug]: i.NOTEQUAL
        };
        function q(P, M) {
            if (M.type === An && t.has("OES_texture_float_linear") === !1 && (M.magFilter === on || M.magFilter === Ta || M.magFilter === lr || M.magFilter === Zn || M.minFilter === on || M.minFilter === Ta || M.minFilter === lr || M.minFilter === Zn) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), i.texParameteri(P, i.TEXTURE_WRAP_S, U[M.wrapS]), i.texParameteri(P, i.TEXTURE_WRAP_T, U[M.wrapT]), (P === i.TEXTURE_3D || P === i.TEXTURE_2D_ARRAY) && i.texParameteri(P, i.TEXTURE_WRAP_R, U[M.wrapR]), i.texParameteri(P, i.TEXTURE_MAG_FILTER, B[M.magFilter]), i.texParameteri(P, i.TEXTURE_MIN_FILTER, B[M.minFilter]), M.compareFunction && (i.texParameteri(P, i.TEXTURE_COMPARE_MODE, i.COMPARE_REF_TO_TEXTURE), i.texParameteri(P, i.TEXTURE_COMPARE_FUNC, V[M.compareFunction])), t.has("EXT_texture_filter_anisotropic") === !0) {
                if (M.magFilter === qe || M.minFilter !== lr && M.minFilter !== Zn || M.type === An && t.has("OES_texture_float_linear") === !1) return;
                if (M.anisotropy > 1 || n.get(M).__currentAnisotropy) {
                    const W = t.get("EXT_texture_filter_anisotropic");
                    i.texParameterf(P, W.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(M.anisotropy, s.getMaxAnisotropy())), n.get(M).__currentAnisotropy = M.anisotropy;
                }
            }
        }
        function et(P, M) {
            let W = !1;
            P.__webglInit === void 0 && (P.__webglInit = !0, M.addEventListener("dispose", w));
            const Q = M.source;
            let rt = d.get(Q);
            rt === void 0 && (rt = {}, d.set(Q, rt));
            const J = K(M);
            if (J !== P.__cacheKey) {
                rt[J] === void 0 && (rt[J] = {
                    texture: i.createTexture(),
                    usedTimes: 0
                }, a.memory.textures++, W = !0), rt[J].usedTimes++;
                const Tt = rt[P.__cacheKey];
                Tt !== void 0 && (rt[P.__cacheKey].usedTimes--, Tt.usedTimes === 0 && E(M)), P.__cacheKey = J, P.__webglTexture = rt[J].texture;
            }
            return W;
        }
        function H(P, M, W) {
            let Q = i.TEXTURE_2D;
            (M.isDataArrayTexture || M.isCompressedArrayTexture) && (Q = i.TEXTURE_2D_ARRAY), M.isData3DTexture && (Q = i.TEXTURE_3D);
            const rt = et(P, M), J = M.source;
            e.bindTexture(Q, P.__webglTexture, i.TEXTURE0 + W);
            const Tt = n.get(J);
            if (J.version !== Tt.__version || rt === !0) {
                e.activeTexture(i.TEXTURE0 + W);
                const ft = $t.getPrimaries($t.workingColorSpace), vt = M.colorSpace === di ? null : $t.getPrimaries(M.colorSpace), Zt = M.colorSpace === di || ft === vt ? i.NONE : i.BROWSER_DEFAULT_WEBGL;
                i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, M.flipY), i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, M.premultiplyAlpha), i.pixelStorei(i.UNPACK_ALIGNMENT, M.unpackAlignment), i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL, Zt);
                let ct = g(M.image, !1, s.maxTextureSize);
                ct = le(M, ct);
                const yt = r.convert(M.format, M.colorSpace), It = r.convert(M.type);
                let Ut = y(M.internalFormat, yt, It, M.colorSpace, M.isVideoTexture);
                q(Q, M);
                let bt;
                const jt = M.mipmaps, zt = M.isVideoTexture !== !0, he = Tt.__version === void 0 || rt === !0, F = J.dataReady, pt = I(M, ct);
                if (M.isDepthTexture) Ut = v(M.format === wr, M.type), he && (zt ? e.texStorage2D(i.TEXTURE_2D, 1, Ut, ct.width, ct.height) : e.texImage2D(i.TEXTURE_2D, 0, Ut, ct.width, ct.height, 0, yt, It, null));
                else if (M.isDataTexture) if (jt.length > 0) {
                    zt && he && e.texStorage2D(i.TEXTURE_2D, pt, Ut, jt[0].width, jt[0].height);
                    for(let Z = 0, tt = jt.length; Z < tt; Z++)bt = jt[Z], zt ? F && e.texSubImage2D(i.TEXTURE_2D, Z, 0, 0, bt.width, bt.height, yt, It, bt.data) : e.texImage2D(i.TEXTURE_2D, Z, Ut, bt.width, bt.height, 0, yt, It, bt.data);
                    M.generateMipmaps = !1;
                } else zt ? (he && e.texStorage2D(i.TEXTURE_2D, pt, Ut, ct.width, ct.height), F && e.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, ct.width, ct.height, yt, It, ct.data)) : e.texImage2D(i.TEXTURE_2D, 0, Ut, ct.width, ct.height, 0, yt, It, ct.data);
                else if (M.isCompressedTexture) if (M.isCompressedArrayTexture) {
                    zt && he && e.texStorage3D(i.TEXTURE_2D_ARRAY, pt, Ut, jt[0].width, jt[0].height, ct.depth);
                    for(let Z = 0, tt = jt.length; Z < tt; Z++)if (bt = jt[Z], M.format !== fn) if (yt !== null) if (zt) {
                        if (F) if (M.layerUpdates.size > 0) {
                            const _t = Pu(bt.width, bt.height, M.format, M.type);
                            for (const mt of M.layerUpdates){
                                const kt = bt.data.subarray(mt * _t / bt.data.BYTES_PER_ELEMENT, (mt + 1) * _t / bt.data.BYTES_PER_ELEMENT);
                                e.compressedTexSubImage3D(i.TEXTURE_2D_ARRAY, Z, 0, 0, mt, bt.width, bt.height, 1, yt, kt);
                            }
                            M.clearLayerUpdates();
                        } else e.compressedTexSubImage3D(i.TEXTURE_2D_ARRAY, Z, 0, 0, 0, bt.width, bt.height, ct.depth, yt, bt.data);
                    } else e.compressedTexImage3D(i.TEXTURE_2D_ARRAY, Z, Ut, bt.width, bt.height, ct.depth, 0, bt.data, 0, 0);
                    else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                    else zt ? F && e.texSubImage3D(i.TEXTURE_2D_ARRAY, Z, 0, 0, 0, bt.width, bt.height, ct.depth, yt, It, bt.data) : e.texImage3D(i.TEXTURE_2D_ARRAY, Z, Ut, bt.width, bt.height, ct.depth, 0, yt, It, bt.data);
                } else {
                    zt && he && e.texStorage2D(i.TEXTURE_2D, pt, Ut, jt[0].width, jt[0].height);
                    for(let Z = 0, tt = jt.length; Z < tt; Z++)bt = jt[Z], M.format !== fn ? yt !== null ? zt ? F && e.compressedTexSubImage2D(i.TEXTURE_2D, Z, 0, 0, bt.width, bt.height, yt, bt.data) : e.compressedTexImage2D(i.TEXTURE_2D, Z, Ut, bt.width, bt.height, 0, bt.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : zt ? F && e.texSubImage2D(i.TEXTURE_2D, Z, 0, 0, bt.width, bt.height, yt, It, bt.data) : e.texImage2D(i.TEXTURE_2D, Z, Ut, bt.width, bt.height, 0, yt, It, bt.data);
                }
                else if (M.isDataArrayTexture) if (zt) {
                    if (he && e.texStorage3D(i.TEXTURE_2D_ARRAY, pt, Ut, ct.width, ct.height, ct.depth), F) if (M.layerUpdates.size > 0) {
                        const Z = Pu(ct.width, ct.height, M.format, M.type);
                        for (const tt of M.layerUpdates){
                            const _t = ct.data.subarray(tt * Z / ct.data.BYTES_PER_ELEMENT, (tt + 1) * Z / ct.data.BYTES_PER_ELEMENT);
                            e.texSubImage3D(i.TEXTURE_2D_ARRAY, 0, 0, 0, tt, ct.width, ct.height, 1, yt, It, _t);
                        }
                        M.clearLayerUpdates();
                    } else e.texSubImage3D(i.TEXTURE_2D_ARRAY, 0, 0, 0, 0, ct.width, ct.height, ct.depth, yt, It, ct.data);
                } else e.texImage3D(i.TEXTURE_2D_ARRAY, 0, Ut, ct.width, ct.height, ct.depth, 0, yt, It, ct.data);
                else if (M.isData3DTexture) zt ? (he && e.texStorage3D(i.TEXTURE_3D, pt, Ut, ct.width, ct.height, ct.depth), F && e.texSubImage3D(i.TEXTURE_3D, 0, 0, 0, 0, ct.width, ct.height, ct.depth, yt, It, ct.data)) : e.texImage3D(i.TEXTURE_3D, 0, Ut, ct.width, ct.height, ct.depth, 0, yt, It, ct.data);
                else if (M.isFramebufferTexture) {
                    if (he) if (zt) e.texStorage2D(i.TEXTURE_2D, pt, Ut, ct.width, ct.height);
                    else {
                        let Z = ct.width, tt = ct.height;
                        for(let _t = 0; _t < pt; _t++)e.texImage2D(i.TEXTURE_2D, _t, Ut, Z, tt, 0, yt, It, null), Z >>= 1, tt >>= 1;
                    }
                } else if (jt.length > 0) {
                    if (zt && he) {
                        const Z = At(jt[0]);
                        e.texStorage2D(i.TEXTURE_2D, pt, Ut, Z.width, Z.height);
                    }
                    for(let Z = 0, tt = jt.length; Z < tt; Z++)bt = jt[Z], zt ? F && e.texSubImage2D(i.TEXTURE_2D, Z, 0, 0, yt, It, bt) : e.texImage2D(i.TEXTURE_2D, Z, Ut, yt, It, bt);
                    M.generateMipmaps = !1;
                } else if (zt) {
                    if (he) {
                        const Z = At(ct);
                        e.texStorage2D(i.TEXTURE_2D, pt, Ut, Z.width, Z.height);
                    }
                    F && e.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, yt, It, ct);
                } else e.texImage2D(i.TEXTURE_2D, 0, Ut, yt, It, ct);
                p(M) && m(Q), Tt.__version = J.version, M.onUpdate && M.onUpdate(M);
            }
            P.__version = M.version;
        }
        function $(P, M, W) {
            if (M.image.length !== 6) return;
            const Q = et(P, M), rt = M.source;
            e.bindTexture(i.TEXTURE_CUBE_MAP, P.__webglTexture, i.TEXTURE0 + W);
            const J = n.get(rt);
            if (rt.version !== J.__version || Q === !0) {
                e.activeTexture(i.TEXTURE0 + W);
                const Tt = $t.getPrimaries($t.workingColorSpace), ft = M.colorSpace === di ? null : $t.getPrimaries(M.colorSpace), vt = M.colorSpace === di || Tt === ft ? i.NONE : i.BROWSER_DEFAULT_WEBGL;
                i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, M.flipY), i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, M.premultiplyAlpha), i.pixelStorei(i.UNPACK_ALIGNMENT, M.unpackAlignment), i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL, vt);
                const Zt = M.isCompressedTexture || M.image[0].isCompressedTexture, ct = M.image[0] && M.image[0].isDataTexture, yt = [];
                for(let tt = 0; tt < 6; tt++)!Zt && !ct ? yt[tt] = g(M.image[tt], !0, s.maxCubemapSize) : yt[tt] = ct ? M.image[tt].image : M.image[tt], yt[tt] = le(M, yt[tt]);
                const It = yt[0], Ut = r.convert(M.format, M.colorSpace), bt = r.convert(M.type), jt = y(M.internalFormat, Ut, bt, M.colorSpace), zt = M.isVideoTexture !== !0, he = J.__version === void 0 || Q === !0, F = rt.dataReady;
                let pt = I(M, It);
                q(i.TEXTURE_CUBE_MAP, M);
                let Z;
                if (Zt) {
                    zt && he && e.texStorage2D(i.TEXTURE_CUBE_MAP, pt, jt, It.width, It.height);
                    for(let tt = 0; tt < 6; tt++){
                        Z = yt[tt].mipmaps;
                        for(let _t = 0; _t < Z.length; _t++){
                            const mt = Z[_t];
                            M.format !== fn ? Ut !== null ? zt ? F && e.compressedTexSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + tt, _t, 0, 0, mt.width, mt.height, Ut, mt.data) : e.compressedTexImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + tt, _t, jt, mt.width, mt.height, 0, mt.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : zt ? F && e.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + tt, _t, 0, 0, mt.width, mt.height, Ut, bt, mt.data) : e.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + tt, _t, jt, mt.width, mt.height, 0, Ut, bt, mt.data);
                        }
                    }
                } else {
                    if (Z = M.mipmaps, zt && he) {
                        Z.length > 0 && pt++;
                        const tt = At(yt[0]);
                        e.texStorage2D(i.TEXTURE_CUBE_MAP, pt, jt, tt.width, tt.height);
                    }
                    for(let tt = 0; tt < 6; tt++)if (ct) {
                        zt ? F && e.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + tt, 0, 0, 0, yt[tt].width, yt[tt].height, Ut, bt, yt[tt].data) : e.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + tt, 0, jt, yt[tt].width, yt[tt].height, 0, Ut, bt, yt[tt].data);
                        for(let _t = 0; _t < Z.length; _t++){
                            const kt = Z[_t].image[tt].image;
                            zt ? F && e.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + tt, _t + 1, 0, 0, kt.width, kt.height, Ut, bt, kt.data) : e.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + tt, _t + 1, jt, kt.width, kt.height, 0, Ut, bt, kt.data);
                        }
                    } else {
                        zt ? F && e.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + tt, 0, 0, 0, Ut, bt, yt[tt]) : e.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + tt, 0, jt, Ut, bt, yt[tt]);
                        for(let _t = 0; _t < Z.length; _t++){
                            const mt = Z[_t];
                            zt ? F && e.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + tt, _t + 1, 0, 0, Ut, bt, mt.image[tt]) : e.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + tt, _t + 1, jt, Ut, bt, mt.image[tt]);
                        }
                    }
                }
                p(M) && m(i.TEXTURE_CUBE_MAP), J.__version = rt.version, M.onUpdate && M.onUpdate(M);
            }
            P.__version = M.version;
        }
        function ot(P, M, W, Q, rt, J) {
            const Tt = r.convert(W.format, W.colorSpace), ft = r.convert(W.type), vt = y(W.internalFormat, Tt, ft, W.colorSpace), Zt = n.get(M), ct = n.get(W);
            if (ct.__renderTarget = M, !Zt.__hasExternalTextures) {
                const yt = Math.max(1, M.width >> J), It = Math.max(1, M.height >> J);
                rt === i.TEXTURE_3D || rt === i.TEXTURE_2D_ARRAY ? e.texImage3D(rt, J, vt, yt, It, M.depth, 0, Tt, ft, null) : e.texImage2D(rt, J, vt, yt, It, 0, Tt, ft, null);
            }
            e.bindFramebuffer(i.FRAMEBUFFER, P), Xt(M) ? o.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER, Q, rt, ct.__webglTexture, 0, gt(M)) : (rt === i.TEXTURE_2D || rt >= i.TEXTURE_CUBE_MAP_POSITIVE_X && rt <= i.TEXTURE_CUBE_MAP_NEGATIVE_Z) && i.framebufferTexture2D(i.FRAMEBUFFER, Q, rt, ct.__webglTexture, J), e.bindFramebuffer(i.FRAMEBUFFER, null);
        }
        function it(P, M, W) {
            if (i.bindRenderbuffer(i.RENDERBUFFER, P), M.depthBuffer) {
                const Q = M.depthTexture, rt = Q && Q.isDepthTexture ? Q.type : null, J = v(M.stencilBuffer, rt), Tt = M.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT, ft = gt(M);
                Xt(M) ? o.renderbufferStorageMultisampleEXT(i.RENDERBUFFER, ft, J, M.width, M.height) : W ? i.renderbufferStorageMultisample(i.RENDERBUFFER, ft, J, M.width, M.height) : i.renderbufferStorage(i.RENDERBUFFER, J, M.width, M.height), i.framebufferRenderbuffer(i.FRAMEBUFFER, Tt, i.RENDERBUFFER, P);
            } else {
                const Q = M.textures;
                for(let rt = 0; rt < Q.length; rt++){
                    const J = Q[rt], Tt = r.convert(J.format, J.colorSpace), ft = r.convert(J.type), vt = y(J.internalFormat, Tt, ft, J.colorSpace), Zt = gt(M);
                    W && Xt(M) === !1 ? i.renderbufferStorageMultisample(i.RENDERBUFFER, Zt, vt, M.width, M.height) : Xt(M) ? o.renderbufferStorageMultisampleEXT(i.RENDERBUFFER, Zt, vt, M.width, M.height) : i.renderbufferStorage(i.RENDERBUFFER, vt, M.width, M.height);
                }
            }
            i.bindRenderbuffer(i.RENDERBUFFER, null);
        }
        function lt(P, M) {
            if (M && M.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
            if (e.bindFramebuffer(i.FRAMEBUFFER, P), !(M.depthTexture && M.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
            const Q = n.get(M.depthTexture);
            Q.__renderTarget = M, (!Q.__webglTexture || M.depthTexture.image.width !== M.width || M.depthTexture.image.height !== M.height) && (M.depthTexture.image.width = M.width, M.depthTexture.image.height = M.height, M.depthTexture.needsUpdate = !0), nt(M.depthTexture, 0);
            const rt = Q.__webglTexture, J = gt(M);
            if (M.depthTexture.format === Ar) Xt(M) ? o.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.TEXTURE_2D, rt, 0, J) : i.framebufferTexture2D(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.TEXTURE_2D, rt, 0);
            else if (M.depthTexture.format === wr) Xt(M) ? o.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.TEXTURE_2D, rt, 0, J) : i.framebufferTexture2D(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.TEXTURE_2D, rt, 0);
            else throw new Error("Unknown depthTexture format");
        }
        function wt(P) {
            const M = n.get(P), W = P.isWebGLCubeRenderTarget === !0;
            if (M.__boundDepthTexture !== P.depthTexture) {
                const Q = P.depthTexture;
                if (M.__depthDisposeCallback && M.__depthDisposeCallback(), Q) {
                    const rt = ()=>{
                        delete M.__boundDepthTexture, delete M.__depthDisposeCallback, Q.removeEventListener("dispose", rt);
                    };
                    Q.addEventListener("dispose", rt), M.__depthDisposeCallback = rt;
                }
                M.__boundDepthTexture = Q;
            }
            if (P.depthTexture && !M.__autoAllocateDepthBuffer) {
                if (W) throw new Error("target.depthTexture not supported in Cube render targets");
                lt(M.__webglFramebuffer, P);
            } else if (W) {
                M.__webglDepthbuffer = [];
                for(let Q = 0; Q < 6; Q++)if (e.bindFramebuffer(i.FRAMEBUFFER, M.__webglFramebuffer[Q]), M.__webglDepthbuffer[Q] === void 0) M.__webglDepthbuffer[Q] = i.createRenderbuffer(), it(M.__webglDepthbuffer[Q], P, !1);
                else {
                    const rt = P.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT, J = M.__webglDepthbuffer[Q];
                    i.bindRenderbuffer(i.RENDERBUFFER, J), i.framebufferRenderbuffer(i.FRAMEBUFFER, rt, i.RENDERBUFFER, J);
                }
            } else if (e.bindFramebuffer(i.FRAMEBUFFER, M.__webglFramebuffer), M.__webglDepthbuffer === void 0) M.__webglDepthbuffer = i.createRenderbuffer(), it(M.__webglDepthbuffer, P, !1);
            else {
                const Q = P.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT, rt = M.__webglDepthbuffer;
                i.bindRenderbuffer(i.RENDERBUFFER, rt), i.framebufferRenderbuffer(i.FRAMEBUFFER, Q, i.RENDERBUFFER, rt);
            }
            e.bindFramebuffer(i.FRAMEBUFFER, null);
        }
        function ht(P, M, W) {
            const Q = n.get(P);
            M !== void 0 && ot(Q.__webglFramebuffer, P, P.texture, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, 0), W !== void 0 && wt(P);
        }
        function ee(P) {
            const M = P.texture, W = n.get(P), Q = n.get(M);
            P.addEventListener("dispose", R);
            const rt = P.textures, J = P.isWebGLCubeRenderTarget === !0, Tt = rt.length > 1;
            if (Tt || (Q.__webglTexture === void 0 && (Q.__webglTexture = i.createTexture()), Q.__version = M.version, a.memory.textures++), J) {
                W.__webglFramebuffer = [];
                for(let ft = 0; ft < 6; ft++)if (M.mipmaps && M.mipmaps.length > 0) {
                    W.__webglFramebuffer[ft] = [];
                    for(let vt = 0; vt < M.mipmaps.length; vt++)W.__webglFramebuffer[ft][vt] = i.createFramebuffer();
                } else W.__webglFramebuffer[ft] = i.createFramebuffer();
            } else {
                if (M.mipmaps && M.mipmaps.length > 0) {
                    W.__webglFramebuffer = [];
                    for(let ft = 0; ft < M.mipmaps.length; ft++)W.__webglFramebuffer[ft] = i.createFramebuffer();
                } else W.__webglFramebuffer = i.createFramebuffer();
                if (Tt) for(let ft = 0, vt = rt.length; ft < vt; ft++){
                    const Zt = n.get(rt[ft]);
                    Zt.__webglTexture === void 0 && (Zt.__webglTexture = i.createTexture(), a.memory.textures++);
                }
                if (P.samples > 0 && Xt(P) === !1) {
                    W.__webglMultisampledFramebuffer = i.createFramebuffer(), W.__webglColorRenderbuffer = [], e.bindFramebuffer(i.FRAMEBUFFER, W.__webglMultisampledFramebuffer);
                    for(let ft = 0; ft < rt.length; ft++){
                        const vt = rt[ft];
                        W.__webglColorRenderbuffer[ft] = i.createRenderbuffer(), i.bindRenderbuffer(i.RENDERBUFFER, W.__webglColorRenderbuffer[ft]);
                        const Zt = r.convert(vt.format, vt.colorSpace), ct = r.convert(vt.type), yt = y(vt.internalFormat, Zt, ct, vt.colorSpace, P.isXRRenderTarget === !0), It = gt(P);
                        i.renderbufferStorageMultisample(i.RENDERBUFFER, It, yt, P.width, P.height), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + ft, i.RENDERBUFFER, W.__webglColorRenderbuffer[ft]);
                    }
                    i.bindRenderbuffer(i.RENDERBUFFER, null), P.depthBuffer && (W.__webglDepthRenderbuffer = i.createRenderbuffer(), it(W.__webglDepthRenderbuffer, P, !0)), e.bindFramebuffer(i.FRAMEBUFFER, null);
                }
            }
            if (J) {
                e.bindTexture(i.TEXTURE_CUBE_MAP, Q.__webglTexture), q(i.TEXTURE_CUBE_MAP, M);
                for(let ft = 0; ft < 6; ft++)if (M.mipmaps && M.mipmaps.length > 0) for(let vt = 0; vt < M.mipmaps.length; vt++)ot(W.__webglFramebuffer[ft][vt], P, M, i.COLOR_ATTACHMENT0, i.TEXTURE_CUBE_MAP_POSITIVE_X + ft, vt);
                else ot(W.__webglFramebuffer[ft], P, M, i.COLOR_ATTACHMENT0, i.TEXTURE_CUBE_MAP_POSITIVE_X + ft, 0);
                p(M) && m(i.TEXTURE_CUBE_MAP), e.unbindTexture();
            } else if (Tt) {
                for(let ft = 0, vt = rt.length; ft < vt; ft++){
                    const Zt = rt[ft], ct = n.get(Zt);
                    e.bindTexture(i.TEXTURE_2D, ct.__webglTexture), q(i.TEXTURE_2D, Zt), ot(W.__webglFramebuffer, P, Zt, i.COLOR_ATTACHMENT0 + ft, i.TEXTURE_2D, 0), p(Zt) && m(i.TEXTURE_2D);
                }
                e.unbindTexture();
            } else {
                let ft = i.TEXTURE_2D;
                if ((P.isWebGL3DRenderTarget || P.isWebGLArrayRenderTarget) && (ft = P.isWebGL3DRenderTarget ? i.TEXTURE_3D : i.TEXTURE_2D_ARRAY), e.bindTexture(ft, Q.__webglTexture), q(ft, M), M.mipmaps && M.mipmaps.length > 0) for(let vt = 0; vt < M.mipmaps.length; vt++)ot(W.__webglFramebuffer[vt], P, M, i.COLOR_ATTACHMENT0, ft, vt);
                else ot(W.__webglFramebuffer, P, M, i.COLOR_ATTACHMENT0, ft, 0);
                p(M) && m(ft), e.unbindTexture();
            }
            P.depthBuffer && wt(P);
        }
        function Wt(P) {
            const M = P.textures;
            for(let W = 0, Q = M.length; W < Q; W++){
                const rt = M[W];
                if (p(rt)) {
                    const J = x(P), Tt = n.get(rt).__webglTexture;
                    e.bindTexture(J, Tt), m(J), e.unbindTexture();
                }
            }
        }
        const Lt = [], L = [];
        function Ct(P) {
            if (P.samples > 0) {
                if (Xt(P) === !1) {
                    const M = P.textures, W = P.width, Q = P.height;
                    let rt = i.COLOR_BUFFER_BIT;
                    const J = P.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT, Tt = n.get(P), ft = M.length > 1;
                    if (ft) for(let vt = 0; vt < M.length; vt++)e.bindFramebuffer(i.FRAMEBUFFER, Tt.__webglMultisampledFramebuffer), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + vt, i.RENDERBUFFER, null), e.bindFramebuffer(i.FRAMEBUFFER, Tt.__webglFramebuffer), i.framebufferTexture2D(i.DRAW_FRAMEBUFFER, i.COLOR_ATTACHMENT0 + vt, i.TEXTURE_2D, null, 0);
                    e.bindFramebuffer(i.READ_FRAMEBUFFER, Tt.__webglMultisampledFramebuffer), e.bindFramebuffer(i.DRAW_FRAMEBUFFER, Tt.__webglFramebuffer);
                    for(let vt = 0; vt < M.length; vt++){
                        if (P.resolveDepthBuffer && (P.depthBuffer && (rt |= i.DEPTH_BUFFER_BIT), P.stencilBuffer && P.resolveStencilBuffer && (rt |= i.STENCIL_BUFFER_BIT)), ft) {
                            i.framebufferRenderbuffer(i.READ_FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.RENDERBUFFER, Tt.__webglColorRenderbuffer[vt]);
                            const Zt = n.get(M[vt]).__webglTexture;
                            i.framebufferTexture2D(i.DRAW_FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, Zt, 0);
                        }
                        i.blitFramebuffer(0, 0, W, Q, 0, 0, W, Q, rt, i.NEAREST), c === !0 && (Lt.length = 0, L.length = 0, Lt.push(i.COLOR_ATTACHMENT0 + vt), P.depthBuffer && P.resolveDepthBuffer === !1 && (Lt.push(J), L.push(J), i.invalidateFramebuffer(i.DRAW_FRAMEBUFFER, L)), i.invalidateFramebuffer(i.READ_FRAMEBUFFER, Lt));
                    }
                    if (e.bindFramebuffer(i.READ_FRAMEBUFFER, null), e.bindFramebuffer(i.DRAW_FRAMEBUFFER, null), ft) for(let vt = 0; vt < M.length; vt++){
                        e.bindFramebuffer(i.FRAMEBUFFER, Tt.__webglMultisampledFramebuffer), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + vt, i.RENDERBUFFER, Tt.__webglColorRenderbuffer[vt]);
                        const Zt = n.get(M[vt]).__webglTexture;
                        e.bindFramebuffer(i.FRAMEBUFFER, Tt.__webglFramebuffer), i.framebufferTexture2D(i.DRAW_FRAMEBUFFER, i.COLOR_ATTACHMENT0 + vt, i.TEXTURE_2D, Zt, 0);
                    }
                    e.bindFramebuffer(i.DRAW_FRAMEBUFFER, Tt.__webglMultisampledFramebuffer);
                } else if (P.depthBuffer && P.resolveDepthBuffer === !1 && c) {
                    const M = P.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT;
                    i.invalidateFramebuffer(i.DRAW_FRAMEBUFFER, [
                        M
                    ]);
                }
            }
        }
        function gt(P) {
            return Math.min(s.maxSamples, P.samples);
        }
        function Xt(P) {
            const M = n.get(P);
            return P.samples > 0 && t.has("WEBGL_multisampled_render_to_texture") === !0 && M.__useRenderToTexture !== !1;
        }
        function Et(P) {
            const M = a.render.frame;
            h.get(P) !== M && (h.set(P, M), P.update());
        }
        function le(P, M) {
            const W = P.colorSpace, Q = P.format, rt = P.type;
            return P.isCompressedTexture === !0 || P.isVideoTexture === !0 || W !== Ke && W !== di && ($t.getTransfer(W) === ce ? (Q !== fn || rt !== si) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", W)), M;
        }
        function At(P) {
            return typeof HTMLImageElement < "u" && P instanceof HTMLImageElement ? (l.width = P.naturalWidth || P.width, l.height = P.naturalHeight || P.height) : typeof VideoFrame < "u" && P instanceof VideoFrame ? (l.width = P.displayWidth, l.height = P.displayHeight) : (l.width = P.width, l.height = P.height), l;
        }
        this.allocateTextureUnit = z, this.resetTextureUnits = j, this.setTexture2D = nt, this.setTexture2DArray = b, this.setTexture3D = C, this.setTextureCube = A, this.rebindTextures = ht, this.setupRenderTarget = ee, this.updateRenderTargetMipmap = Wt, this.updateMultisampleRenderTarget = Ct, this.setupDepthRenderbuffer = wt, this.setupFrameBufferTexture = ot, this.useMultisampledRTT = Xt;
    }
    function ES(i, t) {
        function e(n, s = di) {
            let r;
            const a = $t.getTransfer(s);
            if (n === si) return i.UNSIGNED_BYTE;
            if (n === Ol) return i.UNSIGNED_SHORT_4_4_4_4;
            if (n === kl) return i.UNSIGNED_SHORT_5_5_5_1;
            if (n === Ef) return i.UNSIGNED_INT_5_9_9_9_REV;
            if (n === Mf) return i.BYTE;
            if (n === Tf) return i.SHORT;
            if (n === Tr) return i.UNSIGNED_SHORT;
            if (n === Fl) return i.INT;
            if (n === Vi) return i.UNSIGNED_INT;
            if (n === An) return i.FLOAT;
            if (n === Ur) return i.HALF_FLOAT;
            if (n === Af) return i.ALPHA;
            if (n === wf) return i.RGB;
            if (n === fn) return i.RGBA;
            if (n === Rf) return i.LUMINANCE;
            if (n === Cf) return i.LUMINANCE_ALPHA;
            if (n === Ar) return i.DEPTH_COMPONENT;
            if (n === wr) return i.DEPTH_STENCIL;
            if (n === Gl) return i.RED;
            if (n === Hl) return i.RED_INTEGER;
            if (n === Pf) return i.RG;
            if (n === zl) return i.RG_INTEGER;
            if (n === Vl) return i.RGBA_INTEGER;
            if (n === Ea || n === Aa || n === wa || n === Ra) if (a === ce) if (r = t.get("WEBGL_compressed_texture_s3tc_srgb"), r !== null) {
                if (n === Ea) return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                if (n === Aa) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                if (n === wa) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                if (n === Ra) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
            } else return null;
            else if (r = t.get("WEBGL_compressed_texture_s3tc"), r !== null) {
                if (n === Ea) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (n === Aa) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (n === wa) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (n === Ra) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            } else return null;
            if (n === Ic || n === Dc || n === Lc || n === Uc) if (r = t.get("WEBGL_compressed_texture_pvrtc"), r !== null) {
                if (n === Ic) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (n === Dc) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (n === Lc) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (n === Uc) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            } else return null;
            if (n === Nc || n === Bc || n === Fc) if (r = t.get("WEBGL_compressed_texture_etc"), r !== null) {
                if (n === Nc || n === Bc) return a === ce ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
                if (n === Fc) return a === ce ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC;
            } else return null;
            if (n === Oc || n === kc || n === Gc || n === Hc || n === zc || n === Vc || n === Wc || n === Xc || n === Yc || n === qc || n === jc || n === $c || n === Kc || n === Zc) if (r = t.get("WEBGL_compressed_texture_astc"), r !== null) {
                if (n === Oc) return a === ce ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (n === kc) return a === ce ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (n === Gc) return a === ce ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (n === Hc) return a === ce ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (n === zc) return a === ce ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (n === Vc) return a === ce ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (n === Wc) return a === ce ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (n === Xc) return a === ce ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (n === Yc) return a === ce ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (n === qc) return a === ce ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (n === jc) return a === ce ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (n === $c) return a === ce ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (n === Kc) return a === ce ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (n === Zc) return a === ce ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR;
            } else return null;
            if (n === Ca || n === Jc || n === Qc) if (r = t.get("EXT_texture_compression_bptc"), r !== null) {
                if (n === Ca) return a === ce ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                if (n === Jc) return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                if (n === Qc) return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
            } else return null;
            if (n === If || n === tl || n === el || n === nl) if (r = t.get("EXT_texture_compression_rgtc"), r !== null) {
                if (n === Ca) return r.COMPRESSED_RED_RGTC1_EXT;
                if (n === tl) return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                if (n === el) return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
                if (n === nl) return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
            } else return null;
            return n === Er ? i.UNSIGNED_INT_24_8 : i[n] !== void 0 ? i[n] : null;
        }
        return {
            convert: e
        };
    }
    const AS = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, wS = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
    class RS {
        constructor(){
            this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
        }
        init(t, e, n) {
            if (this.texture === null) {
                const s = new tn, r = t.properties.get(s);
                r.__webglTexture = e.texture, (e.depthNear !== n.depthNear || e.depthFar !== n.depthFar) && (this.depthNear = e.depthNear, this.depthFar = e.depthFar), this.texture = s;
            }
        }
        getMesh(t) {
            if (this.texture !== null && this.mesh === null) {
                const e = t.cameras[0].viewport, n = new yi({
                    vertexShader: AS,
                    fragmentShader: wS,
                    uniforms: {
                        depthColor: {
                            value: this.texture
                        },
                        depthWidth: {
                            value: e.z
                        },
                        depthHeight: {
                            value: e.w
                        }
                    }
                });
                this.mesh = new Le(new zs(20, 20), n);
            }
            return this.mesh;
        }
        reset() {
            this.texture = null, this.mesh = null;
        }
        getDepthTexture() {
            return this.texture;
        }
    }
    class CS extends $i {
        constructor(t, e){
            super();
            const n = this;
            let s = null, r = 1, a = null, o = "local-floor", c = 1, l = null, h = null, u = null, d = null, f = null, _ = null;
            const g = new RS, p = e.getContextAttributes();
            let m = null, x = null;
            const y = [], v = [], I = new Kt;
            let w = null;
            const R = new We;
            R.viewport = new ne;
            const N = new We;
            N.viewport = new ne;
            const E = [
                R,
                N
            ], S = new Bx;
            let D = null, j = null;
            this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(H) {
                let $ = y[H];
                return $ === void 0 && ($ = new Mo, y[H] = $), $.getTargetRaySpace();
            }, this.getControllerGrip = function(H) {
                let $ = y[H];
                return $ === void 0 && ($ = new Mo, y[H] = $), $.getGripSpace();
            }, this.getHand = function(H) {
                let $ = y[H];
                return $ === void 0 && ($ = new Mo, y[H] = $), $.getHandSpace();
            };
            function z(H) {
                const $ = v.indexOf(H.inputSource);
                if ($ === -1) return;
                const ot = y[$];
                ot !== void 0 && (ot.update(H.inputSource, H.frame, l || a), ot.dispatchEvent({
                    type: H.type,
                    data: H.inputSource
                }));
            }
            function K() {
                s.removeEventListener("select", z), s.removeEventListener("selectstart", z), s.removeEventListener("selectend", z), s.removeEventListener("squeeze", z), s.removeEventListener("squeezestart", z), s.removeEventListener("squeezeend", z), s.removeEventListener("end", K), s.removeEventListener("inputsourceschange", nt);
                for(let H = 0; H < y.length; H++){
                    const $ = v[H];
                    $ !== null && (v[H] = null, y[H].disconnect($));
                }
                D = null, j = null, g.reset(), t.setRenderTarget(m), f = null, d = null, u = null, s = null, x = null, et.stop(), n.isPresenting = !1, t.setPixelRatio(w), t.setSize(I.width, I.height, !1), n.dispatchEvent({
                    type: "sessionend"
                });
            }
            this.setFramebufferScaleFactor = function(H) {
                r = H, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
            }, this.setReferenceSpaceType = function(H) {
                o = H, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
            }, this.getReferenceSpace = function() {
                return l || a;
            }, this.setReferenceSpace = function(H) {
                l = H;
            }, this.getBaseLayer = function() {
                return d !== null ? d : f;
            }, this.getBinding = function() {
                return u;
            }, this.getFrame = function() {
                return _;
            }, this.getSession = function() {
                return s;
            }, this.setSession = async function(H) {
                if (s = H, s !== null) {
                    if (m = t.getRenderTarget(), s.addEventListener("select", z), s.addEventListener("selectstart", z), s.addEventListener("selectend", z), s.addEventListener("squeeze", z), s.addEventListener("squeezestart", z), s.addEventListener("squeezeend", z), s.addEventListener("end", K), s.addEventListener("inputsourceschange", nt), p.xrCompatible !== !0 && await e.makeXRCompatible(), w = t.getPixelRatio(), t.getSize(I), typeof XRWebGLBinding < "u" && "createProjectionLayer" in XRWebGLBinding.prototype) {
                        let ot = null, it = null, lt = null;
                        p.depth && (lt = p.stencil ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT24, ot = p.stencil ? wr : Ar, it = p.stencil ? Er : Vi);
                        const wt = {
                            colorFormat: e.RGBA8,
                            depthFormat: lt,
                            scaleFactor: r
                        };
                        u = new XRWebGLBinding(s, e), d = u.createProjectionLayer(wt), s.updateRenderState({
                            layers: [
                                d
                            ]
                        }), t.setPixelRatio(1), t.setSize(d.textureWidth, d.textureHeight, !1), x = new Wi(d.textureWidth, d.textureHeight, {
                            format: fn,
                            type: si,
                            depthTexture: new jf(d.textureWidth, d.textureHeight, it, void 0, void 0, void 0, void 0, void 0, void 0, ot),
                            stencilBuffer: p.stencil,
                            colorSpace: t.outputColorSpace,
                            samples: p.antialias ? 4 : 0,
                            resolveDepthBuffer: d.ignoreDepthValues === !1,
                            resolveStencilBuffer: d.ignoreDepthValues === !1
                        });
                    } else {
                        const ot = {
                            antialias: p.antialias,
                            alpha: !0,
                            depth: p.depth,
                            stencil: p.stencil,
                            framebufferScaleFactor: r
                        };
                        f = new XRWebGLLayer(s, e, ot), s.updateRenderState({
                            baseLayer: f
                        }), t.setPixelRatio(1), t.setSize(f.framebufferWidth, f.framebufferHeight, !1), x = new Wi(f.framebufferWidth, f.framebufferHeight, {
                            format: fn,
                            type: si,
                            colorSpace: t.outputColorSpace,
                            stencilBuffer: p.stencil,
                            resolveDepthBuffer: f.ignoreDepthValues === !1,
                            resolveStencilBuffer: f.ignoreDepthValues === !1
                        });
                    }
                    x.isXRRenderTarget = !0, this.setFoveation(c), l = null, a = await s.requestReferenceSpace(o), et.setContext(s), et.start(), n.isPresenting = !0, n.dispatchEvent({
                        type: "sessionstart"
                    });
                }
            }, this.getEnvironmentBlendMode = function() {
                if (s !== null) return s.environmentBlendMode;
            }, this.getDepthTexture = function() {
                return g.getDepthTexture();
            };
            function nt(H) {
                for(let $ = 0; $ < H.removed.length; $++){
                    const ot = H.removed[$], it = v.indexOf(ot);
                    it >= 0 && (v[it] = null, y[it].disconnect(ot));
                }
                for(let $ = 0; $ < H.added.length; $++){
                    const ot = H.added[$];
                    let it = v.indexOf(ot);
                    if (it === -1) {
                        for(let wt = 0; wt < y.length; wt++)if (wt >= v.length) {
                            v.push(ot), it = wt;
                            break;
                        } else if (v[wt] === null) {
                            v[wt] = ot, it = wt;
                            break;
                        }
                        if (it === -1) break;
                    }
                    const lt = y[it];
                    lt && lt.connect(ot);
                }
            }
            const b = new k, C = new k;
            function A(H, $, ot) {
                b.setFromMatrixPosition($.matrixWorld), C.setFromMatrixPosition(ot.matrixWorld);
                const it = b.distanceTo(C), lt = $.projectionMatrix.elements, wt = ot.projectionMatrix.elements, ht = lt[14] / (lt[10] - 1), ee = lt[14] / (lt[10] + 1), Wt = (lt[9] + 1) / lt[5], Lt = (lt[9] - 1) / lt[5], L = (lt[8] - 1) / lt[0], Ct = (wt[8] + 1) / wt[0], gt = ht * L, Xt = ht * Ct, Et = it / (-L + Ct), le = Et * -L;
                if ($.matrixWorld.decompose(H.position, H.quaternion, H.scale), H.translateX(le), H.translateZ(Et), H.matrixWorld.compose(H.position, H.quaternion, H.scale), H.matrixWorldInverse.copy(H.matrixWorld).invert(), lt[10] === -1) H.projectionMatrix.copy($.projectionMatrix), H.projectionMatrixInverse.copy($.projectionMatrixInverse);
                else {
                    const At = ht + Et, P = ee + Et, M = gt - le, W = Xt + (it - le), Q = Wt * ee / P * At, rt = Lt * ee / P * At;
                    H.projectionMatrix.makePerspective(M, W, Q, rt, At, P), H.projectionMatrixInverse.copy(H.projectionMatrix).invert();
                }
            }
            function U(H, $) {
                $ === null ? H.matrixWorld.copy(H.matrix) : H.matrixWorld.multiplyMatrices($.matrixWorld, H.matrix), H.matrixWorldInverse.copy(H.matrixWorld).invert();
            }
            this.updateCamera = function(H) {
                if (s === null) return;
                let $ = H.near, ot = H.far;
                g.texture !== null && (g.depthNear > 0 && ($ = g.depthNear), g.depthFar > 0 && (ot = g.depthFar)), S.near = N.near = R.near = $, S.far = N.far = R.far = ot, (D !== S.near || j !== S.far) && (s.updateRenderState({
                    depthNear: S.near,
                    depthFar: S.far
                }), D = S.near, j = S.far), R.layers.mask = H.layers.mask | 2, N.layers.mask = H.layers.mask | 4, S.layers.mask = R.layers.mask | N.layers.mask;
                const it = H.parent, lt = S.cameras;
                U(S, it);
                for(let wt = 0; wt < lt.length; wt++)U(lt[wt], it);
                lt.length === 2 ? A(S, R, N) : S.projectionMatrix.copy(R.projectionMatrix), B(H, S, it);
            };
            function B(H, $, ot) {
                ot === null ? H.matrix.copy($.matrixWorld) : (H.matrix.copy(ot.matrixWorld), H.matrix.invert(), H.matrix.multiply($.matrixWorld)), H.matrix.decompose(H.position, H.quaternion, H.scale), H.updateMatrixWorld(!0), H.projectionMatrix.copy($.projectionMatrix), H.projectionMatrixInverse.copy($.projectionMatrixInverse), H.isPerspectiveCamera && (H.fov = Ds * 2 * Math.atan(1 / H.projectionMatrix.elements[5]), H.zoom = 1);
            }
            this.getCamera = function() {
                return S;
            }, this.getFoveation = function() {
                if (!(d === null && f === null)) return c;
            }, this.setFoveation = function(H) {
                c = H, d !== null && (d.fixedFoveation = H), f !== null && f.fixedFoveation !== void 0 && (f.fixedFoveation = H);
            }, this.hasDepthSensing = function() {
                return g.texture !== null;
            }, this.getDepthSensingMesh = function() {
                return g.getMesh(S);
            };
            let V = null;
            function q(H, $) {
                if (h = $.getViewerPose(l || a), _ = $, h !== null) {
                    const ot = h.views;
                    f !== null && (t.setRenderTargetFramebuffer(x, f.framebuffer), t.setRenderTarget(x));
                    let it = !1;
                    ot.length !== S.cameras.length && (S.cameras.length = 0, it = !0);
                    for(let ht = 0; ht < ot.length; ht++){
                        const ee = ot[ht];
                        let Wt = null;
                        if (f !== null) Wt = f.getViewport(ee);
                        else {
                            const L = u.getViewSubImage(d, ee);
                            Wt = L.viewport, ht === 0 && (t.setRenderTargetTextures(x, L.colorTexture, L.depthStencilTexture), t.setRenderTarget(x));
                        }
                        let Lt = E[ht];
                        Lt === void 0 && (Lt = new We, Lt.layers.enable(ht), Lt.viewport = new ne, E[ht] = Lt), Lt.matrix.fromArray(ee.transform.matrix), Lt.matrix.decompose(Lt.position, Lt.quaternion, Lt.scale), Lt.projectionMatrix.fromArray(ee.projectionMatrix), Lt.projectionMatrixInverse.copy(Lt.projectionMatrix).invert(), Lt.viewport.set(Wt.x, Wt.y, Wt.width, Wt.height), ht === 0 && (S.matrix.copy(Lt.matrix), S.matrix.decompose(S.position, S.quaternion, S.scale)), it === !0 && S.cameras.push(Lt);
                    }
                    const lt = s.enabledFeatures;
                    if (lt && lt.includes("depth-sensing") && s.depthUsage == "gpu-optimized" && u) {
                        const ht = u.getDepthInformation(ot[0]);
                        ht && ht.isValid && ht.texture && g.init(t, ht, s.renderState);
                    }
                }
                for(let ot = 0; ot < y.length; ot++){
                    const it = v[ot], lt = y[ot];
                    it !== null && lt !== void 0 && lt.update(it, $, l || a);
                }
                V && V(H, $), $.detectedPlanes && n.dispatchEvent({
                    type: "planesdetected",
                    data: $
                }), _ = null;
            }
            const et = new tp;
            et.setAnimationLoop(q), this.setAnimationLoop = function(H) {
                V = H;
            }, this.dispose = function() {};
        }
    }
    const Ri = new Fn, PS = new Ht;
    function IS(i, t) {
        function e(p, m) {
            p.matrixAutoUpdate === !0 && p.updateMatrix(), m.value.copy(p.matrix);
        }
        function n(p, m) {
            m.color.getRGB(p.fogColor.value, Hf(i)), m.isFog ? (p.fogNear.value = m.near, p.fogFar.value = m.far) : m.isFogExp2 && (p.fogDensity.value = m.density);
        }
        function s(p, m, x, y, v) {
            m.isMeshBasicMaterial || m.isMeshLambertMaterial ? r(p, m) : m.isMeshToonMaterial ? (r(p, m), u(p, m)) : m.isMeshPhongMaterial ? (r(p, m), h(p, m)) : m.isMeshStandardMaterial ? (r(p, m), d(p, m), m.isMeshPhysicalMaterial && f(p, m, v)) : m.isMeshMatcapMaterial ? (r(p, m), _(p, m)) : m.isMeshDepthMaterial ? r(p, m) : m.isMeshDistanceMaterial ? (r(p, m), g(p, m)) : m.isMeshNormalMaterial ? r(p, m) : m.isLineBasicMaterial ? (a(p, m), m.isLineDashedMaterial && o(p, m)) : m.isPointsMaterial ? c(p, m, x, y) : m.isSpriteMaterial ? l(p, m) : m.isShadowMaterial ? (p.color.value.copy(m.color), p.opacity.value = m.opacity) : m.isShaderMaterial && (m.uniformsNeedUpdate = !1);
        }
        function r(p, m) {
            p.opacity.value = m.opacity, m.color && p.diffuse.value.copy(m.color), m.emissive && p.emissive.value.copy(m.emissive).multiplyScalar(m.emissiveIntensity), m.map && (p.map.value = m.map, e(m.map, p.mapTransform)), m.alphaMap && (p.alphaMap.value = m.alphaMap, e(m.alphaMap, p.alphaMapTransform)), m.bumpMap && (p.bumpMap.value = m.bumpMap, e(m.bumpMap, p.bumpMapTransform), p.bumpScale.value = m.bumpScale, m.side === Qe && (p.bumpScale.value *= -1)), m.normalMap && (p.normalMap.value = m.normalMap, e(m.normalMap, p.normalMapTransform), p.normalScale.value.copy(m.normalScale), m.side === Qe && p.normalScale.value.negate()), m.displacementMap && (p.displacementMap.value = m.displacementMap, e(m.displacementMap, p.displacementMapTransform), p.displacementScale.value = m.displacementScale, p.displacementBias.value = m.displacementBias), m.emissiveMap && (p.emissiveMap.value = m.emissiveMap, e(m.emissiveMap, p.emissiveMapTransform)), m.specularMap && (p.specularMap.value = m.specularMap, e(m.specularMap, p.specularMapTransform)), m.alphaTest > 0 && (p.alphaTest.value = m.alphaTest);
            const x = t.get(m), y = x.envMap, v = x.envMapRotation;
            y && (p.envMap.value = y, Ri.copy(v), Ri.x *= -1, Ri.y *= -1, Ri.z *= -1, y.isCubeTexture && y.isRenderTargetTexture === !1 && (Ri.y *= -1, Ri.z *= -1), p.envMapRotation.value.setFromMatrix4(PS.makeRotationFromEuler(Ri)), p.flipEnvMap.value = y.isCubeTexture && y.isRenderTargetTexture === !1 ? -1 : 1, p.reflectivity.value = m.reflectivity, p.ior.value = m.ior, p.refractionRatio.value = m.refractionRatio), m.lightMap && (p.lightMap.value = m.lightMap, p.lightMapIntensity.value = m.lightMapIntensity, e(m.lightMap, p.lightMapTransform)), m.aoMap && (p.aoMap.value = m.aoMap, p.aoMapIntensity.value = m.aoMapIntensity, e(m.aoMap, p.aoMapTransform));
        }
        function a(p, m) {
            p.diffuse.value.copy(m.color), p.opacity.value = m.opacity, m.map && (p.map.value = m.map, e(m.map, p.mapTransform));
        }
        function o(p, m) {
            p.dashSize.value = m.dashSize, p.totalSize.value = m.dashSize + m.gapSize, p.scale.value = m.scale;
        }
        function c(p, m, x, y) {
            p.diffuse.value.copy(m.color), p.opacity.value = m.opacity, p.size.value = m.size * x, p.scale.value = y * .5, m.map && (p.map.value = m.map, e(m.map, p.uvTransform)), m.alphaMap && (p.alphaMap.value = m.alphaMap, e(m.alphaMap, p.alphaMapTransform)), m.alphaTest > 0 && (p.alphaTest.value = m.alphaTest);
        }
        function l(p, m) {
            p.diffuse.value.copy(m.color), p.opacity.value = m.opacity, p.rotation.value = m.rotation, m.map && (p.map.value = m.map, e(m.map, p.mapTransform)), m.alphaMap && (p.alphaMap.value = m.alphaMap, e(m.alphaMap, p.alphaMapTransform)), m.alphaTest > 0 && (p.alphaTest.value = m.alphaTest);
        }
        function h(p, m) {
            p.specular.value.copy(m.specular), p.shininess.value = Math.max(m.shininess, 1e-4);
        }
        function u(p, m) {
            m.gradientMap && (p.gradientMap.value = m.gradientMap);
        }
        function d(p, m) {
            p.metalness.value = m.metalness, m.metalnessMap && (p.metalnessMap.value = m.metalnessMap, e(m.metalnessMap, p.metalnessMapTransform)), p.roughness.value = m.roughness, m.roughnessMap && (p.roughnessMap.value = m.roughnessMap, e(m.roughnessMap, p.roughnessMapTransform)), m.envMap && (p.envMapIntensity.value = m.envMapIntensity);
        }
        function f(p, m, x) {
            p.ior.value = m.ior, m.sheen > 0 && (p.sheenColor.value.copy(m.sheenColor).multiplyScalar(m.sheen), p.sheenRoughness.value = m.sheenRoughness, m.sheenColorMap && (p.sheenColorMap.value = m.sheenColorMap, e(m.sheenColorMap, p.sheenColorMapTransform)), m.sheenRoughnessMap && (p.sheenRoughnessMap.value = m.sheenRoughnessMap, e(m.sheenRoughnessMap, p.sheenRoughnessMapTransform))), m.clearcoat > 0 && (p.clearcoat.value = m.clearcoat, p.clearcoatRoughness.value = m.clearcoatRoughness, m.clearcoatMap && (p.clearcoatMap.value = m.clearcoatMap, e(m.clearcoatMap, p.clearcoatMapTransform)), m.clearcoatRoughnessMap && (p.clearcoatRoughnessMap.value = m.clearcoatRoughnessMap, e(m.clearcoatRoughnessMap, p.clearcoatRoughnessMapTransform)), m.clearcoatNormalMap && (p.clearcoatNormalMap.value = m.clearcoatNormalMap, e(m.clearcoatNormalMap, p.clearcoatNormalMapTransform), p.clearcoatNormalScale.value.copy(m.clearcoatNormalScale), m.side === Qe && p.clearcoatNormalScale.value.negate())), m.dispersion > 0 && (p.dispersion.value = m.dispersion), m.iridescence > 0 && (p.iridescence.value = m.iridescence, p.iridescenceIOR.value = m.iridescenceIOR, p.iridescenceThicknessMinimum.value = m.iridescenceThicknessRange[0], p.iridescenceThicknessMaximum.value = m.iridescenceThicknessRange[1], m.iridescenceMap && (p.iridescenceMap.value = m.iridescenceMap, e(m.iridescenceMap, p.iridescenceMapTransform)), m.iridescenceThicknessMap && (p.iridescenceThicknessMap.value = m.iridescenceThicknessMap, e(m.iridescenceThicknessMap, p.iridescenceThicknessMapTransform))), m.transmission > 0 && (p.transmission.value = m.transmission, p.transmissionSamplerMap.value = x.texture, p.transmissionSamplerSize.value.set(x.width, x.height), m.transmissionMap && (p.transmissionMap.value = m.transmissionMap, e(m.transmissionMap, p.transmissionMapTransform)), p.thickness.value = m.thickness, m.thicknessMap && (p.thicknessMap.value = m.thicknessMap, e(m.thicknessMap, p.thicknessMapTransform)), p.attenuationDistance.value = m.attenuationDistance, p.attenuationColor.value.copy(m.attenuationColor)), m.anisotropy > 0 && (p.anisotropyVector.value.set(m.anisotropy * Math.cos(m.anisotropyRotation), m.anisotropy * Math.sin(m.anisotropyRotation)), m.anisotropyMap && (p.anisotropyMap.value = m.anisotropyMap, e(m.anisotropyMap, p.anisotropyMapTransform))), p.specularIntensity.value = m.specularIntensity, p.specularColor.value.copy(m.specularColor), m.specularColorMap && (p.specularColorMap.value = m.specularColorMap, e(m.specularColorMap, p.specularColorMapTransform)), m.specularIntensityMap && (p.specularIntensityMap.value = m.specularIntensityMap, e(m.specularIntensityMap, p.specularIntensityMapTransform));
        }
        function _(p, m) {
            m.matcap && (p.matcap.value = m.matcap);
        }
        function g(p, m) {
            const x = t.get(m).light;
            p.referencePosition.value.setFromMatrixPosition(x.matrixWorld), p.nearDistance.value = x.shadow.camera.near, p.farDistance.value = x.shadow.camera.far;
        }
        return {
            refreshFogUniforms: n,
            refreshMaterialUniforms: s
        };
    }
    function DS(i, t, e, n) {
        let s = {}, r = {}, a = [];
        const o = i.getParameter(i.MAX_UNIFORM_BUFFER_BINDINGS);
        function c(x, y) {
            const v = y.program;
            n.uniformBlockBinding(x, v);
        }
        function l(x, y) {
            let v = s[x.id];
            v === void 0 && (_(x), v = h(x), s[x.id] = v, x.addEventListener("dispose", p));
            const I = y.program;
            n.updateUBOMapping(x, I);
            const w = t.render.frame;
            r[x.id] !== w && (d(x), r[x.id] = w);
        }
        function h(x) {
            const y = u();
            x.__bindingPointIndex = y;
            const v = i.createBuffer(), I = x.__size, w = x.usage;
            return i.bindBuffer(i.UNIFORM_BUFFER, v), i.bufferData(i.UNIFORM_BUFFER, I, w), i.bindBuffer(i.UNIFORM_BUFFER, null), i.bindBufferBase(i.UNIFORM_BUFFER, y, v), v;
        }
        function u() {
            for(let x = 0; x < o; x++)if (a.indexOf(x) === -1) return a.push(x), x;
            return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
        }
        function d(x) {
            const y = s[x.id], v = x.uniforms, I = x.__cache;
            i.bindBuffer(i.UNIFORM_BUFFER, y);
            for(let w = 0, R = v.length; w < R; w++){
                const N = Array.isArray(v[w]) ? v[w] : [
                    v[w]
                ];
                for(let E = 0, S = N.length; E < S; E++){
                    const D = N[E];
                    if (f(D, w, E, I) === !0) {
                        const j = D.__offset, z = Array.isArray(D.value) ? D.value : [
                            D.value
                        ];
                        let K = 0;
                        for(let nt = 0; nt < z.length; nt++){
                            const b = z[nt], C = g(b);
                            typeof b == "number" || typeof b == "boolean" ? (D.__data[0] = b, i.bufferSubData(i.UNIFORM_BUFFER, j + K, D.__data)) : b.isMatrix3 ? (D.__data[0] = b.elements[0], D.__data[1] = b.elements[1], D.__data[2] = b.elements[2], D.__data[3] = 0, D.__data[4] = b.elements[3], D.__data[5] = b.elements[4], D.__data[6] = b.elements[5], D.__data[7] = 0, D.__data[8] = b.elements[6], D.__data[9] = b.elements[7], D.__data[10] = b.elements[8], D.__data[11] = 0) : (b.toArray(D.__data, K), K += C.storage / Float32Array.BYTES_PER_ELEMENT);
                        }
                        i.bufferSubData(i.UNIFORM_BUFFER, j, D.__data);
                    }
                }
            }
            i.bindBuffer(i.UNIFORM_BUFFER, null);
        }
        function f(x, y, v, I) {
            const w = x.value, R = y + "_" + v;
            if (I[R] === void 0) return typeof w == "number" || typeof w == "boolean" ? I[R] = w : I[R] = w.clone(), !0;
            {
                const N = I[R];
                if (typeof w == "number" || typeof w == "boolean") {
                    if (N !== w) return I[R] = w, !0;
                } else if (N.equals(w) === !1) return N.copy(w), !0;
            }
            return !1;
        }
        function _(x) {
            const y = x.uniforms;
            let v = 0;
            const I = 16;
            for(let R = 0, N = y.length; R < N; R++){
                const E = Array.isArray(y[R]) ? y[R] : [
                    y[R]
                ];
                for(let S = 0, D = E.length; S < D; S++){
                    const j = E[S], z = Array.isArray(j.value) ? j.value : [
                        j.value
                    ];
                    for(let K = 0, nt = z.length; K < nt; K++){
                        const b = z[K], C = g(b), A = v % I, U = A % C.boundary, B = A + U;
                        v += U, B !== 0 && I - B < C.storage && (v += I - B), j.__data = new Float32Array(C.storage / Float32Array.BYTES_PER_ELEMENT), j.__offset = v, v += C.storage;
                    }
                }
            }
            const w = v % I;
            return w > 0 && (v += I - w), x.__size = v, x.__cache = {}, this;
        }
        function g(x) {
            const y = {
                boundary: 0,
                storage: 0
            };
            return typeof x == "number" || typeof x == "boolean" ? (y.boundary = 4, y.storage = 4) : x.isVector2 ? (y.boundary = 8, y.storage = 8) : x.isVector3 || x.isColor ? (y.boundary = 16, y.storage = 12) : x.isVector4 ? (y.boundary = 16, y.storage = 16) : x.isMatrix3 ? (y.boundary = 48, y.storage = 48) : x.isMatrix4 ? (y.boundary = 64, y.storage = 64) : x.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", x), y;
        }
        function p(x) {
            const y = x.target;
            y.removeEventListener("dispose", p);
            const v = a.indexOf(y.__bindingPointIndex);
            a.splice(v, 1), i.deleteBuffer(s[y.id]), delete s[y.id], delete r[y.id];
        }
        function m() {
            for(const x in s)i.deleteBuffer(s[x]);
            a = [], s = {}, r = {};
        }
        return {
            bind: c,
            update: l,
            dispose: m
        };
    }
    let LS = class {
        constructor(t = {}){
            const { canvas: e = Ig(), context: n = null, depth: s = !0, stencil: r = !1, alpha: a = !1, antialias: o = !1, premultipliedAlpha: c = !0, preserveDrawingBuffer: l = !1, powerPreference: h = "default", failIfMajorPerformanceCaveat: u = !1, reverseDepthBuffer: d = !1 } = t;
            this.isWebGLRenderer = !0;
            let f;
            if (n !== null) {
                if (typeof WebGLRenderingContext < "u" && n instanceof WebGLRenderingContext) throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
                f = n.getContextAttributes().alpha;
            } else f = a;
            const _ = new Uint32Array(4), g = new Int32Array(4);
            let p = null, m = null;
            const x = [], y = [];
            this.domElement = e, this.debug = {
                checkShaderErrors: !0,
                onShaderError: null
            }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.toneMapping = gi, this.toneMappingExposure = 1, this.transmissionResolutionScale = 1;
            const v = this;
            let I = !1;
            this._outputColorSpace = De;
            let w = 0, R = 0, N = null, E = -1, S = null;
            const D = new ne, j = new ne;
            let z = null;
            const K = new Bt(0);
            let nt = 0, b = e.width, C = e.height, A = 1, U = null, B = null;
            const V = new ne(0, 0, b, C), q = new ne(0, 0, b, C);
            let et = !1;
            const H = new $l;
            let $ = !1, ot = !1;
            const it = new Ht, lt = new Ht, wt = new k, ht = new ne, ee = {
                background: null,
                fog: null,
                environment: null,
                overrideMaterial: null,
                isScene: !0
            };
            let Wt = !1;
            function Lt() {
                return N === null ? A : 1;
            }
            let L = n;
            function Ct(T, O) {
                return e.getContext(T, O);
            }
            try {
                const T = {
                    alpha: !0,
                    depth: s,
                    stencil: r,
                    antialias: o,
                    premultipliedAlpha: c,
                    preserveDrawingBuffer: l,
                    powerPreference: h,
                    failIfMajorPerformanceCaveat: u
                };
                if ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${Bl}`), e.addEventListener("webglcontextlost", tt, !1), e.addEventListener("webglcontextrestored", _t, !1), e.addEventListener("webglcontextcreationerror", mt, !1), L === null) {
                    const O = "webgl2";
                    if (L = Ct(O, T), L === null) throw Ct(O) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
                }
            } catch (T) {
                throw console.error("THREE.WebGLRenderer: " + T.message), T;
            }
            let gt, Xt, Et, le, At, P, M, W, Q, rt, J, Tt, ft, vt, Zt, ct, yt, It, Ut, bt, jt, zt, he, F;
            function pt() {
                gt = new Vy(L), gt.init(), zt = new ES(L, gt), Xt = new By(L, gt, t, zt), Et = new MS(L, gt), Xt.reverseDepthBuffer && d && Et.buffers.depth.setReversed(!0), le = new Yy(L), At = new hS, P = new TS(L, gt, Et, At, Xt, zt, le), M = new Oy(v), W = new zy(v), Q = new Jx(L), he = new Uy(L, Q), rt = new Wy(L, Q, le, he), J = new jy(L, rt, Q, le), Ut = new qy(L, Xt, P), ct = new Fy(At), Tt = new lS(v, M, W, gt, Xt, he, ct), ft = new IS(v, At), vt = new dS, Zt = new xS(gt), It = new Ly(v, M, W, Et, J, f, c), yt = new bS(v, J, Xt), F = new DS(L, le, Xt, Et), bt = new Ny(L, gt, le), jt = new Xy(L, gt, le), le.programs = Tt.programs, v.capabilities = Xt, v.extensions = gt, v.properties = At, v.renderLists = vt, v.shadowMap = yt, v.state = Et, v.info = le;
            }
            pt();
            const Z = new CS(v, L);
            this.xr = Z, this.getContext = function() {
                return L;
            }, this.getContextAttributes = function() {
                return L.getContextAttributes();
            }, this.forceContextLoss = function() {
                const T = gt.get("WEBGL_lose_context");
                T && T.loseContext();
            }, this.forceContextRestore = function() {
                const T = gt.get("WEBGL_lose_context");
                T && T.restoreContext();
            }, this.getPixelRatio = function() {
                return A;
            }, this.setPixelRatio = function(T) {
                T !== void 0 && (A = T, this.setSize(b, C, !1));
            }, this.getSize = function(T) {
                return T.set(b, C);
            }, this.setSize = function(T, O, X = !0) {
                if (Z.isPresenting) {
                    console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                    return;
                }
                b = T, C = O, e.width = Math.floor(T * A), e.height = Math.floor(O * A), X === !0 && (e.style.width = T + "px", e.style.height = O + "px"), this.setViewport(0, 0, T, O);
            }, this.getDrawingBufferSize = function(T) {
                return T.set(b * A, C * A).floor();
            }, this.setDrawingBufferSize = function(T, O, X) {
                b = T, C = O, A = X, e.width = Math.floor(T * X), e.height = Math.floor(O * X), this.setViewport(0, 0, T, O);
            }, this.getCurrentViewport = function(T) {
                return T.copy(D);
            }, this.getViewport = function(T) {
                return T.copy(V);
            }, this.setViewport = function(T, O, X, Y) {
                T.isVector4 ? V.set(T.x, T.y, T.z, T.w) : V.set(T, O, X, Y), Et.viewport(D.copy(V).multiplyScalar(A).round());
            }, this.getScissor = function(T) {
                return T.copy(q);
            }, this.setScissor = function(T, O, X, Y) {
                T.isVector4 ? q.set(T.x, T.y, T.z, T.w) : q.set(T, O, X, Y), Et.scissor(j.copy(q).multiplyScalar(A).round());
            }, this.getScissorTest = function() {
                return et;
            }, this.setScissorTest = function(T) {
                Et.setScissorTest(et = T);
            }, this.setOpaqueSort = function(T) {
                U = T;
            }, this.setTransparentSort = function(T) {
                B = T;
            }, this.getClearColor = function(T) {
                return T.copy(It.getClearColor());
            }, this.setClearColor = function() {
                It.setClearColor(...arguments);
            }, this.getClearAlpha = function() {
                return It.getClearAlpha();
            }, this.setClearAlpha = function() {
                It.setClearAlpha(...arguments);
            }, this.clear = function(T = !0, O = !0, X = !0) {
                let Y = 0;
                if (T) {
                    let G = !1;
                    if (N !== null) {
                        const at = N.texture.format;
                        G = at === Vl || at === zl || at === Hl;
                    }
                    if (G) {
                        const at = N.texture.type, dt = at === si || at === Vi || at === Tr || at === Er || at === Ol || at === kl, xt = It.getClearColor(), St = It.getClearAlpha(), Nt = xt.r, Dt = xt.g, Rt = xt.b;
                        dt ? (_[0] = Nt, _[1] = Dt, _[2] = Rt, _[3] = St, L.clearBufferuiv(L.COLOR, 0, _)) : (g[0] = Nt, g[1] = Dt, g[2] = Rt, g[3] = St, L.clearBufferiv(L.COLOR, 0, g));
                    } else Y |= L.COLOR_BUFFER_BIT;
                }
                O && (Y |= L.DEPTH_BUFFER_BIT), X && (Y |= L.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), L.clear(Y);
            }, this.clearColor = function() {
                this.clear(!0, !1, !1);
            }, this.clearDepth = function() {
                this.clear(!1, !0, !1);
            }, this.clearStencil = function() {
                this.clear(!1, !1, !0);
            }, this.dispose = function() {
                e.removeEventListener("webglcontextlost", tt, !1), e.removeEventListener("webglcontextrestored", _t, !1), e.removeEventListener("webglcontextcreationerror", mt, !1), It.dispose(), vt.dispose(), Zt.dispose(), At.dispose(), M.dispose(), W.dispose(), J.dispose(), he.dispose(), F.dispose(), Tt.dispose(), Z.dispose(), Z.removeEventListener("sessionstart", Lh), Z.removeEventListener("sessionend", Uh), bi.stop();
            };
            function tt(T) {
                T.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), I = !0;
            }
            function _t() {
                console.log("THREE.WebGLRenderer: Context Restored."), I = !1;
                const T = le.autoReset, O = yt.enabled, X = yt.autoUpdate, Y = yt.needsUpdate, G = yt.type;
                pt(), le.autoReset = T, yt.enabled = O, yt.autoUpdate = X, yt.needsUpdate = Y, yt.type = G;
            }
            function mt(T) {
                console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", T.statusMessage);
            }
            function kt(T) {
                const O = T.target;
                O.removeEventListener("dispose", kt), xe(O);
            }
            function xe(T) {
                Fe(T), At.remove(T);
            }
            function Fe(T) {
                const O = At.get(T).programs;
                O !== void 0 && (O.forEach(function(X) {
                    Tt.releaseProgram(X);
                }), T.isShaderMaterial && Tt.releaseShaderCache(T));
            }
            this.renderBufferDirect = function(T, O, X, Y, G, at) {
                O === null && (O = ee);
                const dt = G.isMesh && G.matrixWorld.determinant() < 0, xt = g_(T, O, X, Y, G);
                Et.setMaterial(Y, dt);
                let St = X.index, Nt = 1;
                if (Y.wireframe === !0) {
                    if (St = rt.getWireframeAttribute(X), St === void 0) return;
                    Nt = 2;
                }
                const Dt = X.drawRange, Rt = X.attributes.position;
                let Jt = Dt.start * Nt, ie = (Dt.start + Dt.count) * Nt;
                at !== null && (Jt = Math.max(Jt, at.start * Nt), ie = Math.min(ie, (at.start + at.count) * Nt)), St !== null ? (Jt = Math.max(Jt, 0), ie = Math.min(ie, St.count)) : Rt != null && (Jt = Math.max(Jt, 0), ie = Math.min(ie, Rt.count));
                const Me = ie - Jt;
                if (Me < 0 || Me === 1 / 0) return;
                he.setup(G, Y, xt, X, St);
                let ve, Qt = bt;
                if (St !== null && (ve = Q.get(St), Qt = jt, Qt.setIndex(ve)), G.isMesh) Y.wireframe === !0 ? (Et.setLineWidth(Y.wireframeLinewidth * Lt()), Qt.setMode(L.LINES)) : Qt.setMode(L.TRIANGLES);
                else if (G.isLine) {
                    let Pt = Y.linewidth;
                    Pt === void 0 && (Pt = 1), Et.setLineWidth(Pt * Lt()), G.isLineSegments ? Qt.setMode(L.LINES) : G.isLineLoop ? Qt.setMode(L.LINE_LOOP) : Qt.setMode(L.LINE_STRIP);
                } else G.isPoints ? Qt.setMode(L.POINTS) : G.isSprite && Qt.setMode(L.TRIANGLES);
                if (G.isBatchedMesh) if (G._multiDrawInstances !== null) Pa("THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."), Qt.renderMultiDrawInstances(G._multiDrawStarts, G._multiDrawCounts, G._multiDrawCount, G._multiDrawInstances);
                else if (gt.get("WEBGL_multi_draw")) Qt.renderMultiDraw(G._multiDrawStarts, G._multiDrawCounts, G._multiDrawCount);
                else {
                    const Pt = G._multiDrawStarts, Ie = G._multiDrawCounts, se = G._multiDrawCount, gn = St ? Q.get(St).bytesPerElement : 1, Qi = At.get(Y).currentProgram.getUniforms();
                    for(let nn = 0; nn < se; nn++)Qi.setValue(L, "_gl_DrawID", nn), Qt.render(Pt[nn] / gn, Ie[nn]);
                }
                else if (G.isInstancedMesh) Qt.renderInstances(Jt, Me, G.count);
                else if (X.isInstancedBufferGeometry) {
                    const Pt = X._maxInstanceCount !== void 0 ? X._maxInstanceCount : 1 / 0, Ie = Math.min(X.instanceCount, Pt);
                    Qt.renderInstances(Jt, Me, Ie);
                } else Qt.render(Jt, Me);
            };
            function ae(T, O, X) {
                T.transparent === !0 && T.side === dn && T.forceSinglePass === !1 ? (T.side = Qe, T.needsUpdate = !0, kr(T, O, X), T.side = ii, T.needsUpdate = !0, kr(T, O, X), T.side = dn) : kr(T, O, X);
            }
            this.compile = function(T, O, X = null) {
                X === null && (X = T), m = Zt.get(X), m.init(O), y.push(m), X.traverseVisible(function(G) {
                    G.isLight && G.layers.test(O.layers) && (m.pushLight(G), G.castShadow && m.pushShadow(G));
                }), T !== X && T.traverseVisible(function(G) {
                    G.isLight && G.layers.test(O.layers) && (m.pushLight(G), G.castShadow && m.pushShadow(G));
                }), m.setupLights();
                const Y = new Set;
                return T.traverse(function(G) {
                    if (!(G.isMesh || G.isPoints || G.isLine || G.isSprite)) return;
                    const at = G.material;
                    if (at) if (Array.isArray(at)) for(let dt = 0; dt < at.length; dt++){
                        const xt = at[dt];
                        ae(xt, X, G), Y.add(xt);
                    }
                    else ae(at, X, G), Y.add(at);
                }), m = y.pop(), Y;
            }, this.compileAsync = function(T, O, X = null) {
                const Y = this.compile(T, O, X);
                return new Promise((G)=>{
                    function at() {
                        if (Y.forEach(function(dt) {
                            At.get(dt).currentProgram.isReady() && Y.delete(dt);
                        }), Y.size === 0) {
                            G(T);
                            return;
                        }
                        setTimeout(at, 10);
                    }
                    gt.get("KHR_parallel_shader_compile") !== null ? at() : setTimeout(at, 10);
                });
            };
            let _n = null;
            function Hn(T) {
                _n && _n(T);
            }
            function Lh() {
                bi.stop();
            }
            function Uh() {
                bi.start();
            }
            const bi = new tp;
            bi.setAnimationLoop(Hn), typeof self < "u" && bi.setContext(self), this.setAnimationLoop = function(T) {
                _n = T, Z.setAnimationLoop(T), T === null ? bi.stop() : bi.start();
            }, Z.addEventListener("sessionstart", Lh), Z.addEventListener("sessionend", Uh), this.render = function(T, O) {
                if (O !== void 0 && O.isCamera !== !0) {
                    console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                    return;
                }
                if (I === !0) return;
                if (T.matrixWorldAutoUpdate === !0 && T.updateMatrixWorld(), O.parent === null && O.matrixWorldAutoUpdate === !0 && O.updateMatrixWorld(), Z.enabled === !0 && Z.isPresenting === !0 && (Z.cameraAutoUpdate === !0 && Z.updateCamera(O), O = Z.getCamera()), T.isScene === !0 && T.onBeforeRender(v, T, O, N), m = Zt.get(T, y.length), m.init(O), y.push(m), lt.multiplyMatrices(O.projectionMatrix, O.matrixWorldInverse), H.setFromProjectionMatrix(lt), ot = this.localClippingEnabled, $ = ct.init(this.clippingPlanes, ot), p = vt.get(T, x.length), p.init(), x.push(p), Z.enabled === !0 && Z.isPresenting === !0) {
                    const at = v.xr.getDepthSensingMesh();
                    at !== null && to(at, O, -1 / 0, v.sortObjects);
                }
                to(T, O, 0, v.sortObjects), p.finish(), v.sortObjects === !0 && p.sort(U, B), Wt = Z.enabled === !1 || Z.isPresenting === !1 || Z.hasDepthSensing() === !1, Wt && It.addToRenderList(p, T), this.info.render.frame++, $ === !0 && ct.beginShadows();
                const X = m.state.shadowsArray;
                yt.render(X, T, O), $ === !0 && ct.endShadows(), this.info.autoReset === !0 && this.info.reset();
                const Y = p.opaque, G = p.transmissive;
                if (m.setupLights(), O.isArrayCamera) {
                    const at = O.cameras;
                    if (G.length > 0) for(let dt = 0, xt = at.length; dt < xt; dt++){
                        const St = at[dt];
                        Bh(Y, G, T, St);
                    }
                    Wt && It.render(T);
                    for(let dt = 0, xt = at.length; dt < xt; dt++){
                        const St = at[dt];
                        Nh(p, T, St, St.viewport);
                    }
                } else G.length > 0 && Bh(Y, G, T, O), Wt && It.render(T), Nh(p, T, O);
                N !== null && R === 0 && (P.updateMultisampleRenderTarget(N), P.updateRenderTargetMipmap(N)), T.isScene === !0 && T.onAfterRender(v, T, O), he.resetDefaultState(), E = -1, S = null, y.pop(), y.length > 0 ? (m = y[y.length - 1], $ === !0 && ct.setGlobalState(v.clippingPlanes, m.state.camera)) : m = null, x.pop(), x.length > 0 ? p = x[x.length - 1] : p = null;
            };
            function to(T, O, X, Y) {
                if (T.visible === !1) return;
                if (T.layers.test(O.layers)) {
                    if (T.isGroup) X = T.renderOrder;
                    else if (T.isLOD) T.autoUpdate === !0 && T.update(O);
                    else if (T.isLight) m.pushLight(T), T.castShadow && m.pushShadow(T);
                    else if (T.isSprite) {
                        if (!T.frustumCulled || H.intersectsSprite(T)) {
                            Y && ht.setFromMatrixPosition(T.matrixWorld).applyMatrix4(lt);
                            const dt = J.update(T), xt = T.material;
                            xt.visible && p.push(T, dt, xt, X, ht.z, null);
                        }
                    } else if ((T.isMesh || T.isLine || T.isPoints) && (!T.frustumCulled || H.intersectsObject(T))) {
                        const dt = J.update(T), xt = T.material;
                        if (Y && (T.boundingSphere !== void 0 ? (T.boundingSphere === null && T.computeBoundingSphere(), ht.copy(T.boundingSphere.center)) : (dt.boundingSphere === null && dt.computeBoundingSphere(), ht.copy(dt.boundingSphere.center)), ht.applyMatrix4(T.matrixWorld).applyMatrix4(lt)), Array.isArray(xt)) {
                            const St = dt.groups;
                            for(let Nt = 0, Dt = St.length; Nt < Dt; Nt++){
                                const Rt = St[Nt], Jt = xt[Rt.materialIndex];
                                Jt && Jt.visible && p.push(T, dt, Jt, X, ht.z, Rt);
                            }
                        } else xt.visible && p.push(T, dt, xt, X, ht.z, null);
                    }
                }
                const at = T.children;
                for(let dt = 0, xt = at.length; dt < xt; dt++)to(at[dt], O, X, Y);
            }
            function Nh(T, O, X, Y) {
                const G = T.opaque, at = T.transmissive, dt = T.transparent;
                m.setupLightsView(X), $ === !0 && ct.setGlobalState(v.clippingPlanes, X), Y && Et.viewport(D.copy(Y)), G.length > 0 && Or(G, O, X), at.length > 0 && Or(at, O, X), dt.length > 0 && Or(dt, O, X), Et.buffers.depth.setTest(!0), Et.buffers.depth.setMask(!0), Et.buffers.color.setMask(!0), Et.setPolygonOffset(!1);
            }
            function Bh(T, O, X, Y) {
                if ((X.isScene === !0 ? X.overrideMaterial : null) !== null) return;
                m.state.transmissionRenderTarget[Y.id] === void 0 && (m.state.transmissionRenderTarget[Y.id] = new Wi(1, 1, {
                    generateMipmaps: !0,
                    type: gt.has("EXT_color_buffer_half_float") || gt.has("EXT_color_buffer_float") ? Ur : si,
                    minFilter: Zn,
                    samples: 4,
                    stencilBuffer: r,
                    resolveDepthBuffer: !1,
                    resolveStencilBuffer: !1,
                    colorSpace: $t.workingColorSpace
                }));
                const at = m.state.transmissionRenderTarget[Y.id], dt = Y.viewport || D;
                at.setSize(dt.z * v.transmissionResolutionScale, dt.w * v.transmissionResolutionScale);
                const xt = v.getRenderTarget();
                v.setRenderTarget(at), v.getClearColor(K), nt = v.getClearAlpha(), nt < 1 && v.setClearColor(16777215, .5), v.clear(), Wt && It.render(X);
                const St = v.toneMapping;
                v.toneMapping = gi;
                const Nt = Y.viewport;
                if (Y.viewport !== void 0 && (Y.viewport = void 0), m.setupLightsView(Y), $ === !0 && ct.setGlobalState(v.clippingPlanes, Y), Or(T, X, Y), P.updateMultisampleRenderTarget(at), P.updateRenderTargetMipmap(at), gt.has("WEBGL_multisampled_render_to_texture") === !1) {
                    let Dt = !1;
                    for(let Rt = 0, Jt = O.length; Rt < Jt; Rt++){
                        const ie = O[Rt], Me = ie.object, ve = ie.geometry, Qt = ie.material, Pt = ie.group;
                        if (Qt.side === dn && Me.layers.test(Y.layers)) {
                            const Ie = Qt.side;
                            Qt.side = Qe, Qt.needsUpdate = !0, Fh(Me, X, Y, ve, Qt, Pt), Qt.side = Ie, Qt.needsUpdate = !0, Dt = !0;
                        }
                    }
                    Dt === !0 && (P.updateMultisampleRenderTarget(at), P.updateRenderTargetMipmap(at));
                }
                v.setRenderTarget(xt), v.setClearColor(K, nt), Nt !== void 0 && (Y.viewport = Nt), v.toneMapping = St;
            }
            function Or(T, O, X) {
                const Y = O.isScene === !0 ? O.overrideMaterial : null;
                for(let G = 0, at = T.length; G < at; G++){
                    const dt = T[G], xt = dt.object, St = dt.geometry, Nt = dt.group;
                    let Dt = dt.material;
                    Dt.allowOverride === !0 && Y !== null && (Dt = Y), xt.layers.test(X.layers) && Fh(xt, O, X, St, Dt, Nt);
                }
            }
            function Fh(T, O, X, Y, G, at) {
                T.onBeforeRender(v, O, X, Y, G, at), T.modelViewMatrix.multiplyMatrices(X.matrixWorldInverse, T.matrixWorld), T.normalMatrix.getNormalMatrix(T.modelViewMatrix), G.onBeforeRender(v, O, X, Y, T, at), G.transparent === !0 && G.side === dn && G.forceSinglePass === !1 ? (G.side = Qe, G.needsUpdate = !0, v.renderBufferDirect(X, O, Y, G, T, at), G.side = ii, G.needsUpdate = !0, v.renderBufferDirect(X, O, Y, G, T, at), G.side = dn) : v.renderBufferDirect(X, O, Y, G, T, at), T.onAfterRender(v, O, X, Y, G, at);
            }
            function kr(T, O, X) {
                O.isScene !== !0 && (O = ee);
                const Y = At.get(T), G = m.state.lights, at = m.state.shadowsArray, dt = G.state.version, xt = Tt.getParameters(T, G.state, at, O, X), St = Tt.getProgramCacheKey(xt);
                let Nt = Y.programs;
                Y.environment = T.isMeshStandardMaterial ? O.environment : null, Y.fog = O.fog, Y.envMap = (T.isMeshStandardMaterial ? W : M).get(T.envMap || Y.environment), Y.envMapRotation = Y.environment !== null && T.envMap === null ? O.environmentRotation : T.envMapRotation, Nt === void 0 && (T.addEventListener("dispose", kt), Nt = new Map, Y.programs = Nt);
                let Dt = Nt.get(St);
                if (Dt !== void 0) {
                    if (Y.currentProgram === Dt && Y.lightsStateVersion === dt) return kh(T, xt), Dt;
                } else xt.uniforms = Tt.getUniforms(T), T.onBeforeCompile(xt, v), Dt = Tt.acquireProgram(xt, St), Nt.set(St, Dt), Y.uniforms = xt.uniforms;
                const Rt = Y.uniforms;
                return (!T.isShaderMaterial && !T.isRawShaderMaterial || T.clipping === !0) && (Rt.clippingPlanes = ct.uniform), kh(T, xt), Y.needsLights = v_(T), Y.lightsStateVersion = dt, Y.needsLights && (Rt.ambientLightColor.value = G.state.ambient, Rt.lightProbe.value = G.state.probe, Rt.directionalLights.value = G.state.directional, Rt.directionalLightShadows.value = G.state.directionalShadow, Rt.spotLights.value = G.state.spot, Rt.spotLightShadows.value = G.state.spotShadow, Rt.rectAreaLights.value = G.state.rectArea, Rt.ltc_1.value = G.state.rectAreaLTC1, Rt.ltc_2.value = G.state.rectAreaLTC2, Rt.pointLights.value = G.state.point, Rt.pointLightShadows.value = G.state.pointShadow, Rt.hemisphereLights.value = G.state.hemi, Rt.directionalShadowMap.value = G.state.directionalShadowMap, Rt.directionalShadowMatrix.value = G.state.directionalShadowMatrix, Rt.spotShadowMap.value = G.state.spotShadowMap, Rt.spotLightMatrix.value = G.state.spotLightMatrix, Rt.spotLightMap.value = G.state.spotLightMap, Rt.pointShadowMap.value = G.state.pointShadowMap, Rt.pointShadowMatrix.value = G.state.pointShadowMatrix), Y.currentProgram = Dt, Y.uniformsList = null, Dt;
            }
            function Oh(T) {
                if (T.uniformsList === null) {
                    const O = T.currentProgram.getUniforms();
                    T.uniformsList = Da.seqWithValue(O.seq, T.uniforms);
                }
                return T.uniformsList;
            }
            function kh(T, O) {
                const X = At.get(T);
                X.outputColorSpace = O.outputColorSpace, X.batching = O.batching, X.batchingColor = O.batchingColor, X.instancing = O.instancing, X.instancingColor = O.instancingColor, X.instancingMorph = O.instancingMorph, X.skinning = O.skinning, X.morphTargets = O.morphTargets, X.morphNormals = O.morphNormals, X.morphColors = O.morphColors, X.morphTargetsCount = O.morphTargetsCount, X.numClippingPlanes = O.numClippingPlanes, X.numIntersection = O.numClipIntersection, X.vertexAlphas = O.vertexAlphas, X.vertexTangents = O.vertexTangents, X.toneMapping = O.toneMapping;
            }
            function g_(T, O, X, Y, G) {
                O.isScene !== !0 && (O = ee), P.resetTextureUnits();
                const at = O.fog, dt = Y.isMeshStandardMaterial ? O.environment : null, xt = N === null ? v.outputColorSpace : N.isXRRenderTarget === !0 ? N.texture.colorSpace : Ke, St = (Y.isMeshStandardMaterial ? W : M).get(Y.envMap || dt), Nt = Y.vertexColors === !0 && !!X.attributes.color && X.attributes.color.itemSize === 4, Dt = !!X.attributes.tangent && (!!Y.normalMap || Y.anisotropy > 0), Rt = !!X.morphAttributes.position, Jt = !!X.morphAttributes.normal, ie = !!X.morphAttributes.color;
                let Me = gi;
                Y.toneMapped && (N === null || N.isXRRenderTarget === !0) && (Me = v.toneMapping);
                const ve = X.morphAttributes.position || X.morphAttributes.normal || X.morphAttributes.color, Qt = ve !== void 0 ? ve.length : 0, Pt = At.get(Y), Ie = m.state.lights;
                if ($ === !0 && (ot === !0 || T !== S)) {
                    const He = T === S && Y.id === E;
                    ct.setState(Y, T, He);
                }
                let se = !1;
                Y.version === Pt.__version ? (Pt.needsLights && Pt.lightsStateVersion !== Ie.state.version || Pt.outputColorSpace !== xt || G.isBatchedMesh && Pt.batching === !1 || !G.isBatchedMesh && Pt.batching === !0 || G.isBatchedMesh && Pt.batchingColor === !0 && G.colorTexture === null || G.isBatchedMesh && Pt.batchingColor === !1 && G.colorTexture !== null || G.isInstancedMesh && Pt.instancing === !1 || !G.isInstancedMesh && Pt.instancing === !0 || G.isSkinnedMesh && Pt.skinning === !1 || !G.isSkinnedMesh && Pt.skinning === !0 || G.isInstancedMesh && Pt.instancingColor === !0 && G.instanceColor === null || G.isInstancedMesh && Pt.instancingColor === !1 && G.instanceColor !== null || G.isInstancedMesh && Pt.instancingMorph === !0 && G.morphTexture === null || G.isInstancedMesh && Pt.instancingMorph === !1 && G.morphTexture !== null || Pt.envMap !== St || Y.fog === !0 && Pt.fog !== at || Pt.numClippingPlanes !== void 0 && (Pt.numClippingPlanes !== ct.numPlanes || Pt.numIntersection !== ct.numIntersection) || Pt.vertexAlphas !== Nt || Pt.vertexTangents !== Dt || Pt.morphTargets !== Rt || Pt.morphNormals !== Jt || Pt.morphColors !== ie || Pt.toneMapping !== Me || Pt.morphTargetsCount !== Qt) && (se = !0) : (se = !0, Pt.__version = Y.version);
                let gn = Pt.currentProgram;
                se === !0 && (gn = kr(Y, O, G));
                let Qi = !1, nn = !1, js = !1;
                const de = gn.getUniforms(), cn = Pt.uniforms;
                if (Et.useProgram(gn.program) && (Qi = !0, nn = !0, js = !0), Y.id !== E && (E = Y.id, nn = !0), Qi || S !== T) {
                    Et.buffers.depth.getReversed() ? (it.copy(T.projectionMatrix), Lg(it), Ug(it), de.setValue(L, "projectionMatrix", it)) : de.setValue(L, "projectionMatrix", T.projectionMatrix), de.setValue(L, "viewMatrix", T.matrixWorldInverse);
                    const Ze = de.map.cameraPosition;
                    Ze !== void 0 && Ze.setValue(L, wt.setFromMatrixPosition(T.matrixWorld)), Xt.logarithmicDepthBuffer && de.setValue(L, "logDepthBufFC", 2 / (Math.log(T.far + 1) / Math.LN2)), (Y.isMeshPhongMaterial || Y.isMeshToonMaterial || Y.isMeshLambertMaterial || Y.isMeshBasicMaterial || Y.isMeshStandardMaterial || Y.isShaderMaterial) && de.setValue(L, "isOrthographic", T.isOrthographicCamera === !0), S !== T && (S = T, nn = !0, js = !0);
                }
                if (G.isSkinnedMesh) {
                    de.setOptional(L, G, "bindMatrix"), de.setOptional(L, G, "bindMatrixInverse");
                    const He = G.skeleton;
                    He && (He.boneTexture === null && He.computeBoneTexture(), de.setValue(L, "boneTexture", He.boneTexture, P));
                }
                G.isBatchedMesh && (de.setOptional(L, G, "batchingTexture"), de.setValue(L, "batchingTexture", G._matricesTexture, P), de.setOptional(L, G, "batchingIdTexture"), de.setValue(L, "batchingIdTexture", G._indirectTexture, P), de.setOptional(L, G, "batchingColorTexture"), G._colorsTexture !== null && de.setValue(L, "batchingColorTexture", G._colorsTexture, P));
                const ln = X.morphAttributes;
                if ((ln.position !== void 0 || ln.normal !== void 0 || ln.color !== void 0) && Ut.update(G, X, gn), (nn || Pt.receiveShadow !== G.receiveShadow) && (Pt.receiveShadow = G.receiveShadow, de.setValue(L, "receiveShadow", G.receiveShadow)), Y.isMeshGouraudMaterial && Y.envMap !== null && (cn.envMap.value = St, cn.flipEnvMap.value = St.isCubeTexture && St.isRenderTargetTexture === !1 ? -1 : 1), Y.isMeshStandardMaterial && Y.envMap === null && O.environment !== null && (cn.envMapIntensity.value = O.environmentIntensity), nn && (de.setValue(L, "toneMappingExposure", v.toneMappingExposure), Pt.needsLights && x_(cn, js), at && Y.fog === !0 && ft.refreshFogUniforms(cn, at), ft.refreshMaterialUniforms(cn, Y, A, C, m.state.transmissionRenderTarget[T.id]), Da.upload(L, Oh(Pt), cn, P)), Y.isShaderMaterial && Y.uniformsNeedUpdate === !0 && (Da.upload(L, Oh(Pt), cn, P), Y.uniformsNeedUpdate = !1), Y.isSpriteMaterial && de.setValue(L, "center", G.center), de.setValue(L, "modelViewMatrix", G.modelViewMatrix), de.setValue(L, "normalMatrix", G.normalMatrix), de.setValue(L, "modelMatrix", G.matrixWorld), Y.isShaderMaterial || Y.isRawShaderMaterial) {
                    const He = Y.uniformsGroups;
                    for(let Ze = 0, eo = He.length; Ze < eo; Ze++){
                        const Si = He[Ze];
                        F.update(Si, gn), F.bind(Si, gn);
                    }
                }
                return gn;
            }
            function x_(T, O) {
                T.ambientLightColor.needsUpdate = O, T.lightProbe.needsUpdate = O, T.directionalLights.needsUpdate = O, T.directionalLightShadows.needsUpdate = O, T.pointLights.needsUpdate = O, T.pointLightShadows.needsUpdate = O, T.spotLights.needsUpdate = O, T.spotLightShadows.needsUpdate = O, T.rectAreaLights.needsUpdate = O, T.hemisphereLights.needsUpdate = O;
            }
            function v_(T) {
                return T.isMeshLambertMaterial || T.isMeshToonMaterial || T.isMeshPhongMaterial || T.isMeshStandardMaterial || T.isShadowMaterial || T.isShaderMaterial && T.lights === !0;
            }
            this.getActiveCubeFace = function() {
                return w;
            }, this.getActiveMipmapLevel = function() {
                return R;
            }, this.getRenderTarget = function() {
                return N;
            }, this.setRenderTargetTextures = function(T, O, X) {
                const Y = At.get(T);
                Y.__autoAllocateDepthBuffer = T.resolveDepthBuffer === !1, Y.__autoAllocateDepthBuffer === !1 && (Y.__useRenderToTexture = !1), At.get(T.texture).__webglTexture = O, At.get(T.depthTexture).__webglTexture = Y.__autoAllocateDepthBuffer ? void 0 : X, Y.__hasExternalTextures = !0;
            }, this.setRenderTargetFramebuffer = function(T, O) {
                const X = At.get(T);
                X.__webglFramebuffer = O, X.__useDefaultFramebuffer = O === void 0;
            };
            const y_ = L.createFramebuffer();
            this.setRenderTarget = function(T, O = 0, X = 0) {
                N = T, w = O, R = X;
                let Y = !0, G = null, at = !1, dt = !1;
                if (T) {
                    const St = At.get(T);
                    if (St.__useDefaultFramebuffer !== void 0) Et.bindFramebuffer(L.FRAMEBUFFER, null), Y = !1;
                    else if (St.__webglFramebuffer === void 0) P.setupRenderTarget(T);
                    else if (St.__hasExternalTextures) P.rebindTextures(T, At.get(T.texture).__webglTexture, At.get(T.depthTexture).__webglTexture);
                    else if (T.depthBuffer) {
                        const Rt = T.depthTexture;
                        if (St.__boundDepthTexture !== Rt) {
                            if (Rt !== null && At.has(Rt) && (T.width !== Rt.image.width || T.height !== Rt.image.height)) throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
                            P.setupDepthRenderbuffer(T);
                        }
                    }
                    const Nt = T.texture;
                    (Nt.isData3DTexture || Nt.isDataArrayTexture || Nt.isCompressedArrayTexture) && (dt = !0);
                    const Dt = At.get(T).__webglFramebuffer;
                    T.isWebGLCubeRenderTarget ? (Array.isArray(Dt[O]) ? G = Dt[O][X] : G = Dt[O], at = !0) : T.samples > 0 && P.useMultisampledRTT(T) === !1 ? G = At.get(T).__webglMultisampledFramebuffer : Array.isArray(Dt) ? G = Dt[X] : G = Dt, D.copy(T.viewport), j.copy(T.scissor), z = T.scissorTest;
                } else D.copy(V).multiplyScalar(A).floor(), j.copy(q).multiplyScalar(A).floor(), z = et;
                if (X !== 0 && (G = y_), Et.bindFramebuffer(L.FRAMEBUFFER, G) && Y && Et.drawBuffers(T, G), Et.viewport(D), Et.scissor(j), Et.setScissorTest(z), at) {
                    const St = At.get(T.texture);
                    L.framebufferTexture2D(L.FRAMEBUFFER, L.COLOR_ATTACHMENT0, L.TEXTURE_CUBE_MAP_POSITIVE_X + O, St.__webglTexture, X);
                } else if (dt) {
                    const St = At.get(T.texture), Nt = O;
                    L.framebufferTextureLayer(L.FRAMEBUFFER, L.COLOR_ATTACHMENT0, St.__webglTexture, X, Nt);
                } else if (T !== null && X !== 0) {
                    const St = At.get(T.texture);
                    L.framebufferTexture2D(L.FRAMEBUFFER, L.COLOR_ATTACHMENT0, L.TEXTURE_2D, St.__webglTexture, X);
                }
                E = -1;
            }, this.readRenderTargetPixels = function(T, O, X, Y, G, at, dt) {
                if (!(T && T.isWebGLRenderTarget)) {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                    return;
                }
                let xt = At.get(T).__webglFramebuffer;
                if (T.isWebGLCubeRenderTarget && dt !== void 0 && (xt = xt[dt]), xt) {
                    Et.bindFramebuffer(L.FRAMEBUFFER, xt);
                    try {
                        const St = T.texture, Nt = St.format, Dt = St.type;
                        if (!Xt.textureFormatReadable(Nt)) {
                            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                            return;
                        }
                        if (!Xt.textureTypeReadable(Dt)) {
                            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                            return;
                        }
                        O >= 0 && O <= T.width - Y && X >= 0 && X <= T.height - G && L.readPixels(O, X, Y, G, zt.convert(Nt), zt.convert(Dt), at);
                    } finally{
                        const St = N !== null ? At.get(N).__webglFramebuffer : null;
                        Et.bindFramebuffer(L.FRAMEBUFFER, St);
                    }
                }
            }, this.readRenderTargetPixelsAsync = async function(T, O, X, Y, G, at, dt) {
                if (!(T && T.isWebGLRenderTarget)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                let xt = At.get(T).__webglFramebuffer;
                if (T.isWebGLCubeRenderTarget && dt !== void 0 && (xt = xt[dt]), xt) if (O >= 0 && O <= T.width - Y && X >= 0 && X <= T.height - G) {
                    Et.bindFramebuffer(L.FRAMEBUFFER, xt);
                    const St = T.texture, Nt = St.format, Dt = St.type;
                    if (!Xt.textureFormatReadable(Nt)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
                    if (!Xt.textureTypeReadable(Dt)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
                    const Rt = L.createBuffer();
                    L.bindBuffer(L.PIXEL_PACK_BUFFER, Rt), L.bufferData(L.PIXEL_PACK_BUFFER, at.byteLength, L.STREAM_READ), L.readPixels(O, X, Y, G, zt.convert(Nt), zt.convert(Dt), 0);
                    const Jt = N !== null ? At.get(N).__webglFramebuffer : null;
                    Et.bindFramebuffer(L.FRAMEBUFFER, Jt);
                    const ie = L.fenceSync(L.SYNC_GPU_COMMANDS_COMPLETE, 0);
                    return L.flush(), await Dg(L, ie, 4), L.bindBuffer(L.PIXEL_PACK_BUFFER, Rt), L.getBufferSubData(L.PIXEL_PACK_BUFFER, 0, at), L.deleteBuffer(Rt), L.deleteSync(ie), at;
                } else throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.");
            }, this.copyFramebufferToTexture = function(T, O = null, X = 0) {
                const Y = Math.pow(2, -X), G = Math.floor(T.image.width * Y), at = Math.floor(T.image.height * Y), dt = O !== null ? O.x : 0, xt = O !== null ? O.y : 0;
                P.setTexture2D(T, 0), L.copyTexSubImage2D(L.TEXTURE_2D, X, 0, 0, dt, xt, G, at), Et.unbindTexture();
            };
            const b_ = L.createFramebuffer(), S_ = L.createFramebuffer();
            this.copyTextureToTexture = function(T, O, X = null, Y = null, G = 0, at = null) {
                at === null && (G !== 0 ? (Pa("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."), at = G, G = 0) : at = 0);
                let dt, xt, St, Nt, Dt, Rt, Jt, ie, Me;
                const ve = T.isCompressedTexture ? T.mipmaps[at] : T.image;
                if (X !== null) dt = X.max.x - X.min.x, xt = X.max.y - X.min.y, St = X.isBox3 ? X.max.z - X.min.z : 1, Nt = X.min.x, Dt = X.min.y, Rt = X.isBox3 ? X.min.z : 0;
                else {
                    const ln = Math.pow(2, -G);
                    dt = Math.floor(ve.width * ln), xt = Math.floor(ve.height * ln), T.isDataArrayTexture ? St = ve.depth : T.isData3DTexture ? St = Math.floor(ve.depth * ln) : St = 1, Nt = 0, Dt = 0, Rt = 0;
                }
                Y !== null ? (Jt = Y.x, ie = Y.y, Me = Y.z) : (Jt = 0, ie = 0, Me = 0);
                const Qt = zt.convert(O.format), Pt = zt.convert(O.type);
                let Ie;
                O.isData3DTexture ? (P.setTexture3D(O, 0), Ie = L.TEXTURE_3D) : O.isDataArrayTexture || O.isCompressedArrayTexture ? (P.setTexture2DArray(O, 0), Ie = L.TEXTURE_2D_ARRAY) : (P.setTexture2D(O, 0), Ie = L.TEXTURE_2D), L.pixelStorei(L.UNPACK_FLIP_Y_WEBGL, O.flipY), L.pixelStorei(L.UNPACK_PREMULTIPLY_ALPHA_WEBGL, O.premultiplyAlpha), L.pixelStorei(L.UNPACK_ALIGNMENT, O.unpackAlignment);
                const se = L.getParameter(L.UNPACK_ROW_LENGTH), gn = L.getParameter(L.UNPACK_IMAGE_HEIGHT), Qi = L.getParameter(L.UNPACK_SKIP_PIXELS), nn = L.getParameter(L.UNPACK_SKIP_ROWS), js = L.getParameter(L.UNPACK_SKIP_IMAGES);
                L.pixelStorei(L.UNPACK_ROW_LENGTH, ve.width), L.pixelStorei(L.UNPACK_IMAGE_HEIGHT, ve.height), L.pixelStorei(L.UNPACK_SKIP_PIXELS, Nt), L.pixelStorei(L.UNPACK_SKIP_ROWS, Dt), L.pixelStorei(L.UNPACK_SKIP_IMAGES, Rt);
                const de = T.isDataArrayTexture || T.isData3DTexture, cn = O.isDataArrayTexture || O.isData3DTexture;
                if (T.isDepthTexture) {
                    const ln = At.get(T), He = At.get(O), Ze = At.get(ln.__renderTarget), eo = At.get(He.__renderTarget);
                    Et.bindFramebuffer(L.READ_FRAMEBUFFER, Ze.__webglFramebuffer), Et.bindFramebuffer(L.DRAW_FRAMEBUFFER, eo.__webglFramebuffer);
                    for(let Si = 0; Si < St; Si++)de && (L.framebufferTextureLayer(L.READ_FRAMEBUFFER, L.COLOR_ATTACHMENT0, At.get(T).__webglTexture, G, Rt + Si), L.framebufferTextureLayer(L.DRAW_FRAMEBUFFER, L.COLOR_ATTACHMENT0, At.get(O).__webglTexture, at, Me + Si)), L.blitFramebuffer(Nt, Dt, dt, xt, Jt, ie, dt, xt, L.DEPTH_BUFFER_BIT, L.NEAREST);
                    Et.bindFramebuffer(L.READ_FRAMEBUFFER, null), Et.bindFramebuffer(L.DRAW_FRAMEBUFFER, null);
                } else if (G !== 0 || T.isRenderTargetTexture || At.has(T)) {
                    const ln = At.get(T), He = At.get(O);
                    Et.bindFramebuffer(L.READ_FRAMEBUFFER, b_), Et.bindFramebuffer(L.DRAW_FRAMEBUFFER, S_);
                    for(let Ze = 0; Ze < St; Ze++)de ? L.framebufferTextureLayer(L.READ_FRAMEBUFFER, L.COLOR_ATTACHMENT0, ln.__webglTexture, G, Rt + Ze) : L.framebufferTexture2D(L.READ_FRAMEBUFFER, L.COLOR_ATTACHMENT0, L.TEXTURE_2D, ln.__webglTexture, G), cn ? L.framebufferTextureLayer(L.DRAW_FRAMEBUFFER, L.COLOR_ATTACHMENT0, He.__webglTexture, at, Me + Ze) : L.framebufferTexture2D(L.DRAW_FRAMEBUFFER, L.COLOR_ATTACHMENT0, L.TEXTURE_2D, He.__webglTexture, at), G !== 0 ? L.blitFramebuffer(Nt, Dt, dt, xt, Jt, ie, dt, xt, L.COLOR_BUFFER_BIT, L.NEAREST) : cn ? L.copyTexSubImage3D(Ie, at, Jt, ie, Me + Ze, Nt, Dt, dt, xt) : L.copyTexSubImage2D(Ie, at, Jt, ie, Nt, Dt, dt, xt);
                    Et.bindFramebuffer(L.READ_FRAMEBUFFER, null), Et.bindFramebuffer(L.DRAW_FRAMEBUFFER, null);
                } else cn ? T.isDataTexture || T.isData3DTexture ? L.texSubImage3D(Ie, at, Jt, ie, Me, dt, xt, St, Qt, Pt, ve.data) : O.isCompressedArrayTexture ? L.compressedTexSubImage3D(Ie, at, Jt, ie, Me, dt, xt, St, Qt, ve.data) : L.texSubImage3D(Ie, at, Jt, ie, Me, dt, xt, St, Qt, Pt, ve) : T.isDataTexture ? L.texSubImage2D(L.TEXTURE_2D, at, Jt, ie, dt, xt, Qt, Pt, ve.data) : T.isCompressedTexture ? L.compressedTexSubImage2D(L.TEXTURE_2D, at, Jt, ie, ve.width, ve.height, Qt, ve.data) : L.texSubImage2D(L.TEXTURE_2D, at, Jt, ie, dt, xt, Qt, Pt, ve);
                L.pixelStorei(L.UNPACK_ROW_LENGTH, se), L.pixelStorei(L.UNPACK_IMAGE_HEIGHT, gn), L.pixelStorei(L.UNPACK_SKIP_PIXELS, Qi), L.pixelStorei(L.UNPACK_SKIP_ROWS, nn), L.pixelStorei(L.UNPACK_SKIP_IMAGES, js), at === 0 && O.generateMipmaps && L.generateMipmap(Ie), Et.unbindTexture();
            }, this.copyTextureToTexture3D = function(T, O, X = null, Y = null, G = 0) {
                return Pa('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'), this.copyTextureToTexture(T, O, X, Y, G);
            }, this.initRenderTarget = function(T) {
                At.get(T).__webglFramebuffer === void 0 && P.setupRenderTarget(T);
            }, this.initTexture = function(T) {
                T.isCubeTexture ? P.setTextureCube(T, 0) : T.isData3DTexture ? P.setTexture3D(T, 0) : T.isDataArrayTexture || T.isCompressedArrayTexture ? P.setTexture2DArray(T, 0) : P.setTexture2D(T, 0), Et.unbindTexture();
            }, this.resetState = function() {
                w = 0, R = 0, N = null, Et.reset(), he.reset();
            }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                detail: this
            }));
        }
        get coordinateSystem() {
            return Jn;
        }
        get outputColorSpace() {
            return this._outputColorSpace;
        }
        set outputColorSpace(t) {
            this._outputColorSpace = t;
            const e = this.getContext();
            e.drawingBufferColorSpace = $t._getDrawingBufferColorSpace(t), e.unpackColorSpace = $t._getUnpackColorSpace();
        }
    };
    function ed(i, t) {
        if (t === ig) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), i;
        if (t === sl || t === Df) {
            let e = i.getIndex();
            if (e === null) {
                const a = [], o = i.getAttribute("position");
                if (o !== void 0) {
                    for(let c = 0; c < o.count; c++)a.push(c);
                    i.setIndex(a), e = i.getIndex();
                } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), i;
            }
            const n = e.count - 2, s = [];
            if (t === sl) for(let a = 1; a <= n; a++)s.push(e.getX(0)), s.push(e.getX(a)), s.push(e.getX(a + 1));
            else for(let a = 0; a < n; a++)a % 2 === 0 ? (s.push(e.getX(a)), s.push(e.getX(a + 1)), s.push(e.getX(a + 2))) : (s.push(e.getX(a + 2)), s.push(e.getX(a + 1)), s.push(e.getX(a)));
            s.length / 3 !== n && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
            const r = i.clone();
            return r.setIndex(s), r.clearGroups(), r;
        } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", t), i;
    }
    class nd extends Xs {
        constructor(t){
            super(t), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(e) {
                return new OS(e);
            }), this.register(function(e) {
                return new kS(e);
            }), this.register(function(e) {
                return new jS(e);
            }), this.register(function(e) {
                return new $S(e);
            }), this.register(function(e) {
                return new KS(e);
            }), this.register(function(e) {
                return new HS(e);
            }), this.register(function(e) {
                return new zS(e);
            }), this.register(function(e) {
                return new VS(e);
            }), this.register(function(e) {
                return new WS(e);
            }), this.register(function(e) {
                return new FS(e);
            }), this.register(function(e) {
                return new XS(e);
            }), this.register(function(e) {
                return new GS(e);
            }), this.register(function(e) {
                return new qS(e);
            }), this.register(function(e) {
                return new YS(e);
            }), this.register(function(e) {
                return new NS(e);
            }), this.register(function(e) {
                return new ZS(e);
            }), this.register(function(e) {
                return new JS(e);
            });
        }
        load(t, e, n, s) {
            const r = this;
            let a;
            if (this.resourcePath !== "") a = this.resourcePath;
            else if (this.path !== "") {
                const l = _r.extractUrlBase(t);
                a = _r.resolveURL(l, this.path);
            } else a = _r.extractUrlBase(t);
            this.manager.itemStart(t);
            const o = function(l) {
                s ? s(l) : console.error(l), r.manager.itemError(t), r.manager.itemEnd(t);
            }, c = new Jf(this.manager);
            c.setPath(this.path), c.setResponseType("arraybuffer"), c.setRequestHeader(this.requestHeader), c.setWithCredentials(this.withCredentials), c.load(t, function(l) {
                try {
                    r.parse(l, a, function(h) {
                        e(h), r.manager.itemEnd(t);
                    }, o);
                } catch (h) {
                    o(h);
                }
            }, n, o);
        }
        setDRACOLoader(t) {
            return this.dracoLoader = t, this;
        }
        setKTX2Loader(t) {
            return this.ktx2Loader = t, this;
        }
        setMeshoptDecoder(t) {
            return this.meshoptDecoder = t, this;
        }
        register(t) {
            return this.pluginCallbacks.indexOf(t) === -1 && this.pluginCallbacks.push(t), this;
        }
        unregister(t) {
            return this.pluginCallbacks.indexOf(t) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1), this;
        }
        parse(t, e, n, s) {
            let r;
            const a = {}, o = {}, c = new TextDecoder;
            if (typeof t == "string") r = JSON.parse(t);
            else if (t instanceof ArrayBuffer) if (c.decode(new Uint8Array(t, 0, 4)) === rp) {
                try {
                    a[qt.KHR_BINARY_GLTF] = new QS(t);
                } catch (u) {
                    s && s(u);
                    return;
                }
                r = JSON.parse(a[qt.KHR_BINARY_GLTF].content);
            } else r = JSON.parse(c.decode(t));
            else r = t;
            if (r.asset === void 0 || r.asset.version[0] < 2) {
                s && s(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
                return;
            }
            const l = new dM(r, {
                path: e || this.resourcePath || "",
                crossOrigin: this.crossOrigin,
                requestHeader: this.requestHeader,
                manager: this.manager,
                ktx2Loader: this.ktx2Loader,
                meshoptDecoder: this.meshoptDecoder
            });
            l.fileLoader.setRequestHeader(this.requestHeader);
            for(let h = 0; h < this.pluginCallbacks.length; h++){
                const u = this.pluginCallbacks[h](l);
                u.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), o[u.name] = u, a[u.name] = !0;
            }
            if (r.extensionsUsed) for(let h = 0; h < r.extensionsUsed.length; ++h){
                const u = r.extensionsUsed[h], d = r.extensionsRequired || [];
                switch(u){
                    case qt.KHR_MATERIALS_UNLIT:
                        a[u] = new BS;
                        break;
                    case qt.KHR_DRACO_MESH_COMPRESSION:
                        a[u] = new tM(r, this.dracoLoader);
                        break;
                    case qt.KHR_TEXTURE_TRANSFORM:
                        a[u] = new eM;
                        break;
                    case qt.KHR_MESH_QUANTIZATION:
                        a[u] = new nM;
                        break;
                    default:
                        d.indexOf(u) >= 0 && o[u] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + u + '".');
                }
            }
            l.setExtensions(a), l.setPlugins(o), l.parse(n, s);
        }
        parseAsync(t, e) {
            const n = this;
            return new Promise(function(s, r) {
                n.parse(t, e, s, r);
            });
        }
    }
    function US() {
        let i = {};
        return {
            get: function(t) {
                return i[t];
            },
            add: function(t, e) {
                i[t] = e;
            },
            remove: function(t) {
                delete i[t];
            },
            removeAll: function() {
                i = {};
            }
        };
    }
    const qt = {
        KHR_BINARY_GLTF: "KHR_binary_glTF",
        KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
        KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
        KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
        KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
        KHR_MATERIALS_IOR: "KHR_materials_ior",
        KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
        KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
        KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
        KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
        KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
        KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
        KHR_MATERIALS_VOLUME: "KHR_materials_volume",
        KHR_TEXTURE_BASISU: "KHR_texture_basisu",
        KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
        KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
        KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
        EXT_MATERIALS_BUMP: "EXT_materials_bump",
        EXT_TEXTURE_WEBP: "EXT_texture_webp",
        EXT_TEXTURE_AVIF: "EXT_texture_avif",
        EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
        EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
    };
    class NS {
        constructor(t){
            this.parser = t, this.name = qt.KHR_LIGHTS_PUNCTUAL, this.cache = {
                refs: {},
                uses: {}
            };
        }
        _markDefs() {
            const t = this.parser, e = this.parser.json.nodes || [];
            for(let n = 0, s = e.length; n < s; n++){
                const r = e[n];
                r.extensions && r.extensions[this.name] && r.extensions[this.name].light !== void 0 && t._addNodeRef(this.cache, r.extensions[this.name].light);
            }
        }
        _loadLight(t) {
            const e = this.parser, n = "light:" + t;
            let s = e.cache.get(n);
            if (s) return s;
            const r = e.json, c = ((r.extensions && r.extensions[this.name] || {}).lights || [])[t];
            let l;
            const h = new Bt(16777215);
            c.color !== void 0 && h.setRGB(c.color[0], c.color[1], c.color[2], Ke);
            const u = c.range !== void 0 ? c.range : 0;
            switch(c.type){
                case "directional":
                    l = new Ql(h), l.target.position.set(0, 0, -1), l.add(l.target);
                    break;
                case "point":
                    l = new Lx(h), l.distance = u;
                    break;
                case "spot":
                    l = new Ix(h), l.distance = u, c.spot = c.spot || {}, c.spot.innerConeAngle = c.spot.innerConeAngle !== void 0 ? c.spot.innerConeAngle : 0, c.spot.outerConeAngle = c.spot.outerConeAngle !== void 0 ? c.spot.outerConeAngle : Math.PI / 4, l.angle = c.spot.outerConeAngle, l.penumbra = 1 - c.spot.innerConeAngle / c.spot.outerConeAngle, l.target.position.set(0, 0, -1), l.add(l.target);
                    break;
                default:
                    throw new Error("THREE.GLTFLoader: Unexpected light type: " + c.type);
            }
            return l.position.set(0, 0, 0), Kn(l, c), c.intensity !== void 0 && (l.intensity = c.intensity), l.name = e.createUniqueName(c.name || "light_" + t), s = Promise.resolve(l), e.cache.add(n, s), s;
        }
        getDependency(t, e) {
            if (t === "light") return this._loadLight(e);
        }
        createNodeAttachment(t) {
            const e = this, n = this.parser, r = n.json.nodes[t], o = (r.extensions && r.extensions[this.name] || {}).light;
            return o === void 0 ? null : this._loadLight(o).then(function(c) {
                return n._getNodeRef(e.cache, o, c);
            });
        }
    }
    class BS {
        constructor(){
            this.name = qt.KHR_MATERIALS_UNLIT;
        }
        getMaterialType() {
            return ki;
        }
        extendParams(t, e, n) {
            const s = [];
            t.color = new Bt(1, 1, 1), t.opacity = 1;
            const r = e.pbrMetallicRoughness;
            if (r) {
                if (Array.isArray(r.baseColorFactor)) {
                    const a = r.baseColorFactor;
                    t.color.setRGB(a[0], a[1], a[2], Ke), t.opacity = a[3];
                }
                r.baseColorTexture !== void 0 && s.push(n.assignTexture(t, "map", r.baseColorTexture, De));
            }
            return Promise.all(s);
        }
    }
    class FS {
        constructor(t){
            this.parser = t, this.name = qt.KHR_MATERIALS_EMISSIVE_STRENGTH;
        }
        extendMaterialParams(t, e) {
            const s = this.parser.json.materials[t];
            if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
            const r = s.extensions[this.name].emissiveStrength;
            return r !== void 0 && (e.emissiveIntensity = r), Promise.resolve();
        }
    }
    class OS {
        constructor(t){
            this.parser = t, this.name = qt.KHR_MATERIALS_CLEARCOAT;
        }
        getMaterialType(t) {
            const n = this.parser.json.materials[t];
            return !n.extensions || !n.extensions[this.name] ? null : Gn;
        }
        extendMaterialParams(t, e) {
            const n = this.parser, s = n.json.materials[t];
            if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
            const r = [], a = s.extensions[this.name];
            if (a.clearcoatFactor !== void 0 && (e.clearcoat = a.clearcoatFactor), a.clearcoatTexture !== void 0 && r.push(n.assignTexture(e, "clearcoatMap", a.clearcoatTexture)), a.clearcoatRoughnessFactor !== void 0 && (e.clearcoatRoughness = a.clearcoatRoughnessFactor), a.clearcoatRoughnessTexture !== void 0 && r.push(n.assignTexture(e, "clearcoatRoughnessMap", a.clearcoatRoughnessTexture)), a.clearcoatNormalTexture !== void 0 && (r.push(n.assignTexture(e, "clearcoatNormalMap", a.clearcoatNormalTexture)), a.clearcoatNormalTexture.scale !== void 0)) {
                const o = a.clearcoatNormalTexture.scale;
                e.clearcoatNormalScale = new Kt(o, o);
            }
            return Promise.all(r);
        }
    }
    class kS {
        constructor(t){
            this.parser = t, this.name = qt.KHR_MATERIALS_DISPERSION;
        }
        getMaterialType(t) {
            const n = this.parser.json.materials[t];
            return !n.extensions || !n.extensions[this.name] ? null : Gn;
        }
        extendMaterialParams(t, e) {
            const s = this.parser.json.materials[t];
            if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
            const r = s.extensions[this.name];
            return e.dispersion = r.dispersion !== void 0 ? r.dispersion : 0, Promise.resolve();
        }
    }
    class GS {
        constructor(t){
            this.parser = t, this.name = qt.KHR_MATERIALS_IRIDESCENCE;
        }
        getMaterialType(t) {
            const n = this.parser.json.materials[t];
            return !n.extensions || !n.extensions[this.name] ? null : Gn;
        }
        extendMaterialParams(t, e) {
            const n = this.parser, s = n.json.materials[t];
            if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
            const r = [], a = s.extensions[this.name];
            return a.iridescenceFactor !== void 0 && (e.iridescence = a.iridescenceFactor), a.iridescenceTexture !== void 0 && r.push(n.assignTexture(e, "iridescenceMap", a.iridescenceTexture)), a.iridescenceIor !== void 0 && (e.iridescenceIOR = a.iridescenceIor), e.iridescenceThicknessRange === void 0 && (e.iridescenceThicknessRange = [
                100,
                400
            ]), a.iridescenceThicknessMinimum !== void 0 && (e.iridescenceThicknessRange[0] = a.iridescenceThicknessMinimum), a.iridescenceThicknessMaximum !== void 0 && (e.iridescenceThicknessRange[1] = a.iridescenceThicknessMaximum), a.iridescenceThicknessTexture !== void 0 && r.push(n.assignTexture(e, "iridescenceThicknessMap", a.iridescenceThicknessTexture)), Promise.all(r);
        }
    }
    class HS {
        constructor(t){
            this.parser = t, this.name = qt.KHR_MATERIALS_SHEEN;
        }
        getMaterialType(t) {
            const n = this.parser.json.materials[t];
            return !n.extensions || !n.extensions[this.name] ? null : Gn;
        }
        extendMaterialParams(t, e) {
            const n = this.parser, s = n.json.materials[t];
            if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
            const r = [];
            e.sheenColor = new Bt(0, 0, 0), e.sheenRoughness = 0, e.sheen = 1;
            const a = s.extensions[this.name];
            if (a.sheenColorFactor !== void 0) {
                const o = a.sheenColorFactor;
                e.sheenColor.setRGB(o[0], o[1], o[2], Ke);
            }
            return a.sheenRoughnessFactor !== void 0 && (e.sheenRoughness = a.sheenRoughnessFactor), a.sheenColorTexture !== void 0 && r.push(n.assignTexture(e, "sheenColorMap", a.sheenColorTexture, De)), a.sheenRoughnessTexture !== void 0 && r.push(n.assignTexture(e, "sheenRoughnessMap", a.sheenRoughnessTexture)), Promise.all(r);
        }
    }
    class zS {
        constructor(t){
            this.parser = t, this.name = qt.KHR_MATERIALS_TRANSMISSION;
        }
        getMaterialType(t) {
            const n = this.parser.json.materials[t];
            return !n.extensions || !n.extensions[this.name] ? null : Gn;
        }
        extendMaterialParams(t, e) {
            const n = this.parser, s = n.json.materials[t];
            if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
            const r = [], a = s.extensions[this.name];
            return a.transmissionFactor !== void 0 && (e.transmission = a.transmissionFactor), a.transmissionTexture !== void 0 && r.push(n.assignTexture(e, "transmissionMap", a.transmissionTexture)), Promise.all(r);
        }
    }
    class VS {
        constructor(t){
            this.parser = t, this.name = qt.KHR_MATERIALS_VOLUME;
        }
        getMaterialType(t) {
            const n = this.parser.json.materials[t];
            return !n.extensions || !n.extensions[this.name] ? null : Gn;
        }
        extendMaterialParams(t, e) {
            const n = this.parser, s = n.json.materials[t];
            if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
            const r = [], a = s.extensions[this.name];
            e.thickness = a.thicknessFactor !== void 0 ? a.thicknessFactor : 0, a.thicknessTexture !== void 0 && r.push(n.assignTexture(e, "thicknessMap", a.thicknessTexture)), e.attenuationDistance = a.attenuationDistance || 1 / 0;
            const o = a.attenuationColor || [
                1,
                1,
                1
            ];
            return e.attenuationColor = new Bt().setRGB(o[0], o[1], o[2], Ke), Promise.all(r);
        }
    }
    class WS {
        constructor(t){
            this.parser = t, this.name = qt.KHR_MATERIALS_IOR;
        }
        getMaterialType(t) {
            const n = this.parser.json.materials[t];
            return !n.extensions || !n.extensions[this.name] ? null : Gn;
        }
        extendMaterialParams(t, e) {
            const s = this.parser.json.materials[t];
            if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
            const r = s.extensions[this.name];
            return e.ior = r.ior !== void 0 ? r.ior : 1.5, Promise.resolve();
        }
    }
    class XS {
        constructor(t){
            this.parser = t, this.name = qt.KHR_MATERIALS_SPECULAR;
        }
        getMaterialType(t) {
            const n = this.parser.json.materials[t];
            return !n.extensions || !n.extensions[this.name] ? null : Gn;
        }
        extendMaterialParams(t, e) {
            const n = this.parser, s = n.json.materials[t];
            if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
            const r = [], a = s.extensions[this.name];
            e.specularIntensity = a.specularFactor !== void 0 ? a.specularFactor : 1, a.specularTexture !== void 0 && r.push(n.assignTexture(e, "specularIntensityMap", a.specularTexture));
            const o = a.specularColorFactor || [
                1,
                1,
                1
            ];
            return e.specularColor = new Bt().setRGB(o[0], o[1], o[2], Ke), a.specularColorTexture !== void 0 && r.push(n.assignTexture(e, "specularColorMap", a.specularColorTexture, De)), Promise.all(r);
        }
    }
    class YS {
        constructor(t){
            this.parser = t, this.name = qt.EXT_MATERIALS_BUMP;
        }
        getMaterialType(t) {
            const n = this.parser.json.materials[t];
            return !n.extensions || !n.extensions[this.name] ? null : Gn;
        }
        extendMaterialParams(t, e) {
            const n = this.parser, s = n.json.materials[t];
            if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
            const r = [], a = s.extensions[this.name];
            return e.bumpScale = a.bumpFactor !== void 0 ? a.bumpFactor : 1, a.bumpTexture !== void 0 && r.push(n.assignTexture(e, "bumpMap", a.bumpTexture)), Promise.all(r);
        }
    }
    class qS {
        constructor(t){
            this.parser = t, this.name = qt.KHR_MATERIALS_ANISOTROPY;
        }
        getMaterialType(t) {
            const n = this.parser.json.materials[t];
            return !n.extensions || !n.extensions[this.name] ? null : Gn;
        }
        extendMaterialParams(t, e) {
            const n = this.parser, s = n.json.materials[t];
            if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
            const r = [], a = s.extensions[this.name];
            return a.anisotropyStrength !== void 0 && (e.anisotropy = a.anisotropyStrength), a.anisotropyRotation !== void 0 && (e.anisotropyRotation = a.anisotropyRotation), a.anisotropyTexture !== void 0 && r.push(n.assignTexture(e, "anisotropyMap", a.anisotropyTexture)), Promise.all(r);
        }
    }
    class jS {
        constructor(t){
            this.parser = t, this.name = qt.KHR_TEXTURE_BASISU;
        }
        loadTexture(t) {
            const e = this.parser, n = e.json, s = n.textures[t];
            if (!s.extensions || !s.extensions[this.name]) return null;
            const r = s.extensions[this.name], a = e.options.ktx2Loader;
            if (!a) {
                if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                return null;
            }
            return e.loadTextureImage(t, r.source, a);
        }
    }
    class $S {
        constructor(t){
            this.parser = t, this.name = qt.EXT_TEXTURE_WEBP, this.isSupported = null;
        }
        loadTexture(t) {
            const e = this.name, n = this.parser, s = n.json, r = s.textures[t];
            if (!r.extensions || !r.extensions[e]) return null;
            const a = r.extensions[e], o = s.images[a.source];
            let c = n.textureLoader;
            if (o.uri) {
                const l = n.options.manager.getHandler(o.uri);
                l !== null && (c = l);
            }
            return this.detectSupport().then(function(l) {
                if (l) return n.loadTextureImage(t, a.source, c);
                if (s.extensionsRequired && s.extensionsRequired.indexOf(e) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                return n.loadTexture(t);
            });
        }
        detectSupport() {
            return this.isSupported || (this.isSupported = new Promise(function(t) {
                const e = new Image;
                e.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", e.onload = e.onerror = function() {
                    t(e.height === 1);
                };
            })), this.isSupported;
        }
    }
    class KS {
        constructor(t){
            this.parser = t, this.name = qt.EXT_TEXTURE_AVIF, this.isSupported = null;
        }
        loadTexture(t) {
            const e = this.name, n = this.parser, s = n.json, r = s.textures[t];
            if (!r.extensions || !r.extensions[e]) return null;
            const a = r.extensions[e], o = s.images[a.source];
            let c = n.textureLoader;
            if (o.uri) {
                const l = n.options.manager.getHandler(o.uri);
                l !== null && (c = l);
            }
            return this.detectSupport().then(function(l) {
                if (l) return n.loadTextureImage(t, a.source, c);
                if (s.extensionsRequired && s.extensionsRequired.indexOf(e) >= 0) throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
                return n.loadTexture(t);
            });
        }
        detectSupport() {
            return this.isSupported || (this.isSupported = new Promise(function(t) {
                const e = new Image;
                e.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", e.onload = e.onerror = function() {
                    t(e.height === 1);
                };
            })), this.isSupported;
        }
    }
    class ZS {
        constructor(t){
            this.name = qt.EXT_MESHOPT_COMPRESSION, this.parser = t;
        }
        loadBufferView(t) {
            const e = this.parser.json, n = e.bufferViews[t];
            if (n.extensions && n.extensions[this.name]) {
                const s = n.extensions[this.name], r = this.parser.getDependency("buffer", s.buffer), a = this.parser.options.meshoptDecoder;
                if (!a || !a.supported) {
                    if (e.extensionsRequired && e.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                    return null;
                }
                return r.then(function(o) {
                    const c = s.byteOffset || 0, l = s.byteLength || 0, h = s.count, u = s.byteStride, d = new Uint8Array(o, c, l);
                    return a.decodeGltfBufferAsync ? a.decodeGltfBufferAsync(h, u, d, s.mode, s.filter).then(function(f) {
                        return f.buffer;
                    }) : a.ready.then(function() {
                        const f = new ArrayBuffer(h * u);
                        return a.decodeGltfBuffer(new Uint8Array(f), h, u, d, s.mode, s.filter), f;
                    });
                });
            } else return null;
        }
    }
    class JS {
        constructor(t){
            this.name = qt.EXT_MESH_GPU_INSTANCING, this.parser = t;
        }
        createNodeMesh(t) {
            const e = this.parser.json, n = e.nodes[t];
            if (!n.extensions || !n.extensions[this.name] || n.mesh === void 0) return null;
            const s = e.meshes[n.mesh];
            for (const l of s.primitives)if (l.mode !== un.TRIANGLES && l.mode !== un.TRIANGLE_STRIP && l.mode !== un.TRIANGLE_FAN && l.mode !== void 0) return null;
            const a = n.extensions[this.name].attributes, o = [], c = {};
            for(const l in a)o.push(this.parser.getDependency("accessor", a[l]).then((h)=>(c[l] = h, c[l])));
            return o.length < 1 ? null : (o.push(this.parser.createNodeMesh(t)), Promise.all(o).then((l)=>{
                const h = l.pop(), u = h.isGroup ? h.children : [
                    h
                ], d = l[0].count, f = [];
                for (const _ of u){
                    const g = new Ht, p = new k, m = new Rn, x = new k(1, 1, 1), y = new ux(_.geometry, _.material, d);
                    for(let v = 0; v < d; v++)c.TRANSLATION && p.fromBufferAttribute(c.TRANSLATION, v), c.ROTATION && m.fromBufferAttribute(c.ROTATION, v), c.SCALE && x.fromBufferAttribute(c.SCALE, v), y.setMatrixAt(v, g.compose(p, m, x));
                    for(const v in c)if (v === "_COLOR_0") {
                        const I = c[v];
                        y.instanceColor = new al(I.array, I.itemSize, I.normalized);
                    } else v !== "TRANSLATION" && v !== "ROTATION" && v !== "SCALE" && _.geometry.setAttribute(v, c[v]);
                    ge.prototype.copy.call(y, _), this.parser.assignFinalMaterial(y), f.push(y);
                }
                return h.isGroup ? (h.clear(), h.add(...f), h) : f[0];
            }));
        }
    }
    const rp = "glTF", ir = 12, id = {
        JSON: 1313821514,
        BIN: 5130562
    };
    class QS {
        constructor(t){
            this.name = qt.KHR_BINARY_GLTF, this.content = null, this.body = null;
            const e = new DataView(t, 0, ir), n = new TextDecoder;
            if (this.header = {
                magic: n.decode(new Uint8Array(t.slice(0, 4))),
                version: e.getUint32(4, !0),
                length: e.getUint32(8, !0)
            }, this.header.magic !== rp) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
            if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
            const s = this.header.length - ir, r = new DataView(t, ir);
            let a = 0;
            for(; a < s;){
                const o = r.getUint32(a, !0);
                a += 4;
                const c = r.getUint32(a, !0);
                if (a += 4, c === id.JSON) {
                    const l = new Uint8Array(t, ir + a, o);
                    this.content = n.decode(l);
                } else if (c === id.BIN) {
                    const l = ir + a;
                    this.body = t.slice(l, l + o);
                }
                a += o;
            }
            if (this.content === null) throw new Error("THREE.GLTFLoader: JSON content not found.");
        }
    }
    class tM {
        constructor(t, e){
            if (!e) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
            this.name = qt.KHR_DRACO_MESH_COMPRESSION, this.json = t, this.dracoLoader = e, this.dracoLoader.preload();
        }
        decodePrimitive(t, e) {
            const n = this.json, s = this.dracoLoader, r = t.extensions[this.name].bufferView, a = t.extensions[this.name].attributes, o = {}, c = {}, l = {};
            for(const h in a){
                const u = ul[h] || h.toLowerCase();
                o[u] = a[h];
            }
            for(const h in t.attributes){
                const u = ul[h] || h.toLowerCase();
                if (a[h] !== void 0) {
                    const d = n.accessors[t.attributes[h]], f = As[d.componentType];
                    l[u] = f.name, c[u] = d.normalized === !0;
                }
            }
            return e.getDependency("bufferView", r).then(function(h) {
                return new Promise(function(u, d) {
                    s.decodeDracoFile(h, function(f) {
                        for(const _ in f.attributes){
                            const g = f.attributes[_], p = c[_];
                            p !== void 0 && (g.normalized = p);
                        }
                        u(f);
                    }, o, l, Ke, d);
                });
            });
        }
    }
    class eM {
        constructor(){
            this.name = qt.KHR_TEXTURE_TRANSFORM;
        }
        extendTexture(t, e) {
            return (e.texCoord === void 0 || e.texCoord === t.channel) && e.offset === void 0 && e.rotation === void 0 && e.scale === void 0 || (t = t.clone(), e.texCoord !== void 0 && (t.channel = e.texCoord), e.offset !== void 0 && t.offset.fromArray(e.offset), e.rotation !== void 0 && (t.rotation = e.rotation), e.scale !== void 0 && t.repeat.fromArray(e.scale), t.needsUpdate = !0), t;
        }
    }
    class nM {
        constructor(){
            this.name = qt.KHR_MESH_QUANTIZATION;
        }
    }
    class ap extends Nr {
        constructor(t, e, n, s){
            super(t, e, n, s);
        }
        copySampleValue_(t) {
            const e = this.resultBuffer, n = this.sampleValues, s = this.valueSize, r = t * s * 3 + s;
            for(let a = 0; a !== s; a++)e[a] = n[r + a];
            return e;
        }
        interpolate_(t, e, n, s) {
            const r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, c = o * 2, l = o * 3, h = s - e, u = (n - e) / h, d = u * u, f = d * u, _ = t * l, g = _ - l, p = -2 * f + 3 * d, m = f - d, x = 1 - p, y = m - d + u;
            for(let v = 0; v !== o; v++){
                const I = a[g + v + o], w = a[g + v + c] * h, R = a[_ + v + o], N = a[_ + v] * h;
                r[v] = x * I + y * w + p * R + m * N;
            }
            return r;
        }
    }
    const iM = new Rn;
    class sM extends ap {
        interpolate_(t, e, n, s) {
            const r = super.interpolate_(t, e, n, s);
            return iM.fromArray(r).normalize().toArray(r), r;
        }
    }
    const un = {
        POINTS: 0,
        LINES: 1,
        LINE_LOOP: 2,
        LINE_STRIP: 3,
        TRIANGLES: 4,
        TRIANGLE_STRIP: 5,
        TRIANGLE_FAN: 6
    }, As = {
        5120: Int8Array,
        5121: Uint8Array,
        5122: Int16Array,
        5123: Uint16Array,
        5125: Uint32Array,
        5126: Float32Array
    }, sd = {
        9728: qe,
        9729: on,
        9984: Sf,
        9985: Ta,
        9986: lr,
        9987: Zn
    }, rd = {
        33071: fi,
        33648: Ba,
        10497: Is
    }, Bo = {
        SCALAR: 1,
        VEC2: 2,
        VEC3: 3,
        VEC4: 4,
        MAT2: 4,
        MAT3: 9,
        MAT4: 16
    }, ul = {
        POSITION: "position",
        NORMAL: "normal",
        TANGENT: "tangent",
        TEXCOORD_0: "uv",
        TEXCOORD_1: "uv1",
        TEXCOORD_2: "uv2",
        TEXCOORD_3: "uv3",
        COLOR_0: "color",
        WEIGHTS_0: "skinWeight",
        JOINTS_0: "skinIndex"
    }, ui = {
        scale: "scale",
        translation: "position",
        rotation: "quaternion",
        weights: "morphTargetInfluences"
    }, rM = {
        CUBICSPLINE: void 0,
        LINEAR: Cr,
        STEP: Rr
    }, Fo = {
        OPAQUE: "OPAQUE",
        MASK: "MASK",
        BLEND: "BLEND"
    };
    function aM(i) {
        return i.DefaultMaterial === void 0 && (i.DefaultMaterial = new Us({
            color: 16777215,
            emissive: 0,
            metalness: 1,
            roughness: 1,
            transparent: !1,
            depthTest: !0,
            side: ii
        })), i.DefaultMaterial;
    }
    function Ci(i, t, e) {
        for(const n in e.extensions)i[n] === void 0 && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[n] = e.extensions[n]);
    }
    function Kn(i, t) {
        t.extras !== void 0 && (typeof t.extras == "object" ? Object.assign(i.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras));
    }
    function oM(i, t, e) {
        let n = !1, s = !1, r = !1;
        for(let l = 0, h = t.length; l < h; l++){
            const u = t[l];
            if (u.POSITION !== void 0 && (n = !0), u.NORMAL !== void 0 && (s = !0), u.COLOR_0 !== void 0 && (r = !0), n && s && r) break;
        }
        if (!n && !s && !r) return Promise.resolve(i);
        const a = [], o = [], c = [];
        for(let l = 0, h = t.length; l < h; l++){
            const u = t[l];
            if (n) {
                const d = u.POSITION !== void 0 ? e.getDependency("accessor", u.POSITION) : i.attributes.position;
                a.push(d);
            }
            if (s) {
                const d = u.NORMAL !== void 0 ? e.getDependency("accessor", u.NORMAL) : i.attributes.normal;
                o.push(d);
            }
            if (r) {
                const d = u.COLOR_0 !== void 0 ? e.getDependency("accessor", u.COLOR_0) : i.attributes.color;
                c.push(d);
            }
        }
        return Promise.all([
            Promise.all(a),
            Promise.all(o),
            Promise.all(c)
        ]).then(function(l) {
            const h = l[0], u = l[1], d = l[2];
            return n && (i.morphAttributes.position = h), s && (i.morphAttributes.normal = u), r && (i.morphAttributes.color = d), i.morphTargetsRelative = !0, i;
        });
    }
    function cM(i, t) {
        if (i.updateMorphTargets(), t.weights !== void 0) for(let e = 0, n = t.weights.length; e < n; e++)i.morphTargetInfluences[e] = t.weights[e];
        if (t.extras && Array.isArray(t.extras.targetNames)) {
            const e = t.extras.targetNames;
            if (i.morphTargetInfluences.length === e.length) {
                i.morphTargetDictionary = {};
                for(let n = 0, s = e.length; n < s; n++)i.morphTargetDictionary[e[n]] = n;
            } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
        }
    }
    function lM(i) {
        let t;
        const e = i.extensions && i.extensions[qt.KHR_DRACO_MESH_COMPRESSION];
        if (e ? t = "draco:" + e.bufferView + ":" + e.indices + ":" + Oo(e.attributes) : t = i.indices + ":" + Oo(i.attributes) + ":" + i.mode, i.targets !== void 0) for(let n = 0, s = i.targets.length; n < s; n++)t += ":" + Oo(i.targets[n]);
        return t;
    }
    function Oo(i) {
        let t = "";
        const e = Object.keys(i).sort();
        for(let n = 0, s = e.length; n < s; n++)t += e[n] + ":" + i[e[n]] + ";";
        return t;
    }
    function dl(i) {
        switch(i){
            case Int8Array:
                return 1 / 127;
            case Uint8Array:
                return 1 / 255;
            case Int16Array:
                return 1 / 32767;
            case Uint16Array:
                return 1 / 65535;
            default:
                throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
        }
    }
    function hM(i) {
        return i.search(/\.jpe?g($|\?)/i) > 0 || i.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : i.search(/\.webp($|\?)/i) > 0 || i.search(/^data\:image\/webp/) === 0 ? "image/webp" : i.search(/\.ktx2($|\?)/i) > 0 || i.search(/^data\:image\/ktx2/) === 0 ? "image/ktx2" : "image/png";
    }
    const uM = new Ht;
    class dM {
        constructor(t = {}, e = {}){
            this.json = t, this.extensions = {}, this.plugins = {}, this.options = e, this.cache = new US, this.associations = new Map, this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = {
                refs: {},
                uses: {}
            }, this.cameraCache = {
                refs: {},
                uses: {}
            }, this.lightCache = {
                refs: {},
                uses: {}
            }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
            let n = !1, s = -1, r = !1, a = -1;
            if (typeof navigator < "u") {
                const o = navigator.userAgent;
                n = /^((?!chrome|android).)*safari/i.test(o) === !0;
                const c = o.match(/Version\/(\d+)/);
                s = n && c ? parseInt(c[1], 10) : -1, r = o.indexOf("Firefox") > -1, a = r ? o.match(/Firefox\/([0-9]+)\./)[1] : -1;
            }
            typeof createImageBitmap > "u" || n && s < 17 || r && a < 98 ? this.textureLoader = new ll(this.options.manager) : this.textureLoader = new Nx(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new Jf(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0);
        }
        setExtensions(t) {
            this.extensions = t;
        }
        setPlugins(t) {
            this.plugins = t;
        }
        parse(t, e) {
            const n = this, s = this.json, r = this.extensions;
            this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(a) {
                return a._markDefs && a._markDefs();
            }), Promise.all(this._invokeAll(function(a) {
                return a.beforeRoot && a.beforeRoot();
            })).then(function() {
                return Promise.all([
                    n.getDependencies("scene"),
                    n.getDependencies("animation"),
                    n.getDependencies("camera")
                ]);
            }).then(function(a) {
                const o = {
                    scene: a[0][s.scene || 0],
                    scenes: a[0],
                    animations: a[1],
                    cameras: a[2],
                    asset: s.asset,
                    parser: n,
                    userData: {}
                };
                return Ci(r, o, s), Kn(o, s), Promise.all(n._invokeAll(function(c) {
                    return c.afterRoot && c.afterRoot(o);
                })).then(function() {
                    for (const c of o.scenes)c.updateMatrixWorld();
                    t(o);
                });
            }).catch(e);
        }
        _markDefs() {
            const t = this.json.nodes || [], e = this.json.skins || [], n = this.json.meshes || [];
            for(let s = 0, r = e.length; s < r; s++){
                const a = e[s].joints;
                for(let o = 0, c = a.length; o < c; o++)t[a[o]].isBone = !0;
            }
            for(let s = 0, r = t.length; s < r; s++){
                const a = t[s];
                a.mesh !== void 0 && (this._addNodeRef(this.meshCache, a.mesh), a.skin !== void 0 && (n[a.mesh].isSkinnedMesh = !0)), a.camera !== void 0 && this._addNodeRef(this.cameraCache, a.camera);
            }
        }
        _addNodeRef(t, e) {
            e !== void 0 && (t.refs[e] === void 0 && (t.refs[e] = t.uses[e] = 0), t.refs[e]++);
        }
        _getNodeRef(t, e, n) {
            if (t.refs[e] <= 1) return n;
            const s = n.clone(), r = (a, o)=>{
                const c = this.associations.get(a);
                c != null && this.associations.set(o, c);
                for (const [l, h] of a.children.entries())r(h, o.children[l]);
            };
            return r(n, s), s.name += "_instance_" + t.uses[e]++, s;
        }
        _invokeOne(t) {
            const e = Object.values(this.plugins);
            e.push(this);
            for(let n = 0; n < e.length; n++){
                const s = t(e[n]);
                if (s) return s;
            }
            return null;
        }
        _invokeAll(t) {
            const e = Object.values(this.plugins);
            e.unshift(this);
            const n = [];
            for(let s = 0; s < e.length; s++){
                const r = t(e[s]);
                r && n.push(r);
            }
            return n;
        }
        getDependency(t, e) {
            const n = t + ":" + e;
            let s = this.cache.get(n);
            if (!s) {
                switch(t){
                    case "scene":
                        s = this.loadScene(e);
                        break;
                    case "node":
                        s = this._invokeOne(function(r) {
                            return r.loadNode && r.loadNode(e);
                        });
                        break;
                    case "mesh":
                        s = this._invokeOne(function(r) {
                            return r.loadMesh && r.loadMesh(e);
                        });
                        break;
                    case "accessor":
                        s = this.loadAccessor(e);
                        break;
                    case "bufferView":
                        s = this._invokeOne(function(r) {
                            return r.loadBufferView && r.loadBufferView(e);
                        });
                        break;
                    case "buffer":
                        s = this.loadBuffer(e);
                        break;
                    case "material":
                        s = this._invokeOne(function(r) {
                            return r.loadMaterial && r.loadMaterial(e);
                        });
                        break;
                    case "texture":
                        s = this._invokeOne(function(r) {
                            return r.loadTexture && r.loadTexture(e);
                        });
                        break;
                    case "skin":
                        s = this.loadSkin(e);
                        break;
                    case "animation":
                        s = this._invokeOne(function(r) {
                            return r.loadAnimation && r.loadAnimation(e);
                        });
                        break;
                    case "camera":
                        s = this.loadCamera(e);
                        break;
                    default:
                        if (s = this._invokeOne(function(r) {
                            return r != this && r.getDependency && r.getDependency(t, e);
                        }), !s) throw new Error("Unknown type: " + t);
                        break;
                }
                this.cache.add(n, s);
            }
            return s;
        }
        getDependencies(t) {
            let e = this.cache.get(t);
            if (!e) {
                const n = this, s = this.json[t + (t === "mesh" ? "es" : "s")] || [];
                e = Promise.all(s.map(function(r, a) {
                    return n.getDependency(t, a);
                })), this.cache.add(t, e);
            }
            return e;
        }
        loadBuffer(t) {
            const e = this.json.buffers[t], n = this.fileLoader;
            if (e.type && e.type !== "arraybuffer") throw new Error("THREE.GLTFLoader: " + e.type + " buffer type is not supported.");
            if (e.uri === void 0 && t === 0) return Promise.resolve(this.extensions[qt.KHR_BINARY_GLTF].body);
            const s = this.options;
            return new Promise(function(r, a) {
                n.load(_r.resolveURL(e.uri, s.path), r, void 0, function() {
                    a(new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'));
                });
            });
        }
        loadBufferView(t) {
            const e = this.json.bufferViews[t];
            return this.getDependency("buffer", e.buffer).then(function(n) {
                const s = e.byteLength || 0, r = e.byteOffset || 0;
                return n.slice(r, r + s);
            });
        }
        loadAccessor(t) {
            const e = this, n = this.json, s = this.json.accessors[t];
            if (s.bufferView === void 0 && s.sparse === void 0) {
                const a = Bo[s.type], o = As[s.componentType], c = s.normalized === !0, l = new o(s.count * a);
                return Promise.resolve(new je(l, a, c));
            }
            const r = [];
            return s.bufferView !== void 0 ? r.push(this.getDependency("bufferView", s.bufferView)) : r.push(null), s.sparse !== void 0 && (r.push(this.getDependency("bufferView", s.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", s.sparse.values.bufferView))), Promise.all(r).then(function(a) {
                const o = a[0], c = Bo[s.type], l = As[s.componentType], h = l.BYTES_PER_ELEMENT, u = h * c, d = s.byteOffset || 0, f = s.bufferView !== void 0 ? n.bufferViews[s.bufferView].byteStride : void 0, _ = s.normalized === !0;
                let g, p;
                if (f && f !== u) {
                    const m = Math.floor(d / f), x = "InterleavedBuffer:" + s.bufferView + ":" + s.componentType + ":" + m + ":" + s.count;
                    let y = e.cache.get(x);
                    y || (g = new l(o, m * f, s.count * f / h), y = new ax(g, f / h), e.cache.add(x, y)), p = new ql(y, c, d % f / h, _);
                } else o === null ? g = new l(s.count * c) : g = new l(o, d, s.count * c), p = new je(g, c, _);
                if (s.sparse !== void 0) {
                    const m = Bo.SCALAR, x = As[s.sparse.indices.componentType], y = s.sparse.indices.byteOffset || 0, v = s.sparse.values.byteOffset || 0, I = new x(a[1], y, s.sparse.count * m), w = new l(a[2], v, s.sparse.count * c);
                    o !== null && (p = new je(p.array.slice(), p.itemSize, p.normalized)), p.normalized = !1;
                    for(let R = 0, N = I.length; R < N; R++){
                        const E = I[R];
                        if (p.setX(E, w[R * c]), c >= 2 && p.setY(E, w[R * c + 1]), c >= 3 && p.setZ(E, w[R * c + 2]), c >= 4 && p.setW(E, w[R * c + 3]), c >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
                    }
                    p.normalized = _;
                }
                return p;
            });
        }
        loadTexture(t) {
            const e = this.json, n = this.options, r = e.textures[t].source, a = e.images[r];
            let o = this.textureLoader;
            if (a.uri) {
                const c = n.manager.getHandler(a.uri);
                c !== null && (o = c);
            }
            return this.loadTextureImage(t, r, o);
        }
        loadTextureImage(t, e, n) {
            const s = this, r = this.json, a = r.textures[t], o = r.images[e], c = (o.uri || o.bufferView) + ":" + a.sampler;
            if (this.textureCache[c]) return this.textureCache[c];
            const l = this.loadImageSource(e, n).then(function(h) {
                h.flipY = !1, h.name = a.name || o.name || "", h.name === "" && typeof o.uri == "string" && o.uri.startsWith("data:image/") === !1 && (h.name = o.uri);
                const d = (r.samplers || {})[a.sampler] || {};
                return h.magFilter = sd[d.magFilter] || on, h.minFilter = sd[d.minFilter] || Zn, h.wrapS = rd[d.wrapS] || Is, h.wrapT = rd[d.wrapT] || Is, h.generateMipmaps = !h.isCompressedTexture && h.minFilter !== qe && h.minFilter !== on, s.associations.set(h, {
                    textures: t
                }), h;
            }).catch(function() {
                return null;
            });
            return this.textureCache[c] = l, l;
        }
        loadImageSource(t, e) {
            const n = this, s = this.json, r = this.options;
            if (this.sourceCache[t] !== void 0) return this.sourceCache[t].then((u)=>u.clone());
            const a = s.images[t], o = self.URL || self.webkitURL;
            let c = a.uri || "", l = !1;
            if (a.bufferView !== void 0) c = n.getDependency("bufferView", a.bufferView).then(function(u) {
                l = !0;
                const d = new Blob([
                    u
                ], {
                    type: a.mimeType
                });
                return c = o.createObjectURL(d), c;
            });
            else if (a.uri === void 0) throw new Error("THREE.GLTFLoader: Image " + t + " is missing URI and bufferView");
            const h = Promise.resolve(c).then(function(u) {
                return new Promise(function(d, f) {
                    let _ = d;
                    e.isImageBitmapLoader === !0 && (_ = function(g) {
                        const p = new tn(g);
                        p.needsUpdate = !0, d(p);
                    }), e.load(_r.resolveURL(u, r.path), _, void 0, f);
                });
            }).then(function(u) {
                return l === !0 && o.revokeObjectURL(c), Kn(u, a), u.userData.mimeType = a.mimeType || hM(a.uri), u;
            }).catch(function(u) {
                throw console.error("THREE.GLTFLoader: Couldn't load texture", c), u;
            });
            return this.sourceCache[t] = h, h;
        }
        assignTexture(t, e, n, s) {
            const r = this;
            return this.getDependency("texture", n.index).then(function(a) {
                if (!a) return null;
                if (n.texCoord !== void 0 && n.texCoord > 0 && (a = a.clone(), a.channel = n.texCoord), r.extensions[qt.KHR_TEXTURE_TRANSFORM]) {
                    const o = n.extensions !== void 0 ? n.extensions[qt.KHR_TEXTURE_TRANSFORM] : void 0;
                    if (o) {
                        const c = r.associations.get(a);
                        a = r.extensions[qt.KHR_TEXTURE_TRANSFORM].extendTexture(a, o), r.associations.set(a, c);
                    }
                }
                return s !== void 0 && (a.colorSpace = s), t[e] = a, a;
            });
        }
        assignFinalMaterial(t) {
            const e = t.geometry;
            let n = t.material;
            const s = e.attributes.tangent === void 0, r = e.attributes.color !== void 0, a = e.attributes.normal === void 0;
            if (t.isPoints) {
                const o = "PointsMaterial:" + n.uuid;
                let c = this.cache.get(o);
                c || (c = new qf, Bn.prototype.copy.call(c, n), c.color.copy(n.color), c.map = n.map, c.sizeAttenuation = !1, this.cache.add(o, c)), n = c;
            } else if (t.isLine) {
                const o = "LineBasicMaterial:" + n.uuid;
                let c = this.cache.get(o);
                c || (c = new Yf, Bn.prototype.copy.call(c, n), c.color.copy(n.color), c.map = n.map, this.cache.add(o, c)), n = c;
            }
            if (s || r || a) {
                let o = "ClonedMaterial:" + n.uuid + ":";
                s && (o += "derivative-tangents:"), r && (o += "vertex-colors:"), a && (o += "flat-shading:");
                let c = this.cache.get(o);
                c || (c = n.clone(), r && (c.vertexColors = !0), a && (c.flatShading = !0), s && (c.normalScale && (c.normalScale.y *= -1), c.clearcoatNormalScale && (c.clearcoatNormalScale.y *= -1)), this.cache.add(o, c), this.associations.set(c, this.associations.get(n))), n = c;
            }
            t.material = n;
        }
        getMaterialType() {
            return Us;
        }
        loadMaterial(t) {
            const e = this, n = this.json, s = this.extensions, r = n.materials[t];
            let a;
            const o = {}, c = r.extensions || {}, l = [];
            if (c[qt.KHR_MATERIALS_UNLIT]) {
                const u = s[qt.KHR_MATERIALS_UNLIT];
                a = u.getMaterialType(), l.push(u.extendParams(o, r, e));
            } else {
                const u = r.pbrMetallicRoughness || {};
                if (o.color = new Bt(1, 1, 1), o.opacity = 1, Array.isArray(u.baseColorFactor)) {
                    const d = u.baseColorFactor;
                    o.color.setRGB(d[0], d[1], d[2], Ke), o.opacity = d[3];
                }
                u.baseColorTexture !== void 0 && l.push(e.assignTexture(o, "map", u.baseColorTexture, De)), o.metalness = u.metallicFactor !== void 0 ? u.metallicFactor : 1, o.roughness = u.roughnessFactor !== void 0 ? u.roughnessFactor : 1, u.metallicRoughnessTexture !== void 0 && (l.push(e.assignTexture(o, "metalnessMap", u.metallicRoughnessTexture)), l.push(e.assignTexture(o, "roughnessMap", u.metallicRoughnessTexture))), a = this._invokeOne(function(d) {
                    return d.getMaterialType && d.getMaterialType(t);
                }), l.push(Promise.all(this._invokeAll(function(d) {
                    return d.extendMaterialParams && d.extendMaterialParams(t, o);
                })));
            }
            r.doubleSided === !0 && (o.side = dn);
            const h = r.alphaMode || Fo.OPAQUE;
            if (h === Fo.BLEND ? (o.transparent = !0, o.depthWrite = !1) : (o.transparent = !1, h === Fo.MASK && (o.alphaTest = r.alphaCutoff !== void 0 ? r.alphaCutoff : .5)), r.normalTexture !== void 0 && a !== ki && (l.push(e.assignTexture(o, "normalMap", r.normalTexture)), o.normalScale = new Kt(1, 1), r.normalTexture.scale !== void 0)) {
                const u = r.normalTexture.scale;
                o.normalScale.set(u, u);
            }
            if (r.occlusionTexture !== void 0 && a !== ki && (l.push(e.assignTexture(o, "aoMap", r.occlusionTexture)), r.occlusionTexture.strength !== void 0 && (o.aoMapIntensity = r.occlusionTexture.strength)), r.emissiveFactor !== void 0 && a !== ki) {
                const u = r.emissiveFactor;
                o.emissive = new Bt().setRGB(u[0], u[1], u[2], Ke);
            }
            return r.emissiveTexture !== void 0 && a !== ki && l.push(e.assignTexture(o, "emissiveMap", r.emissiveTexture, De)), Promise.all(l).then(function() {
                const u = new a(o);
                return r.name && (u.name = r.name), Kn(u, r), e.associations.set(u, {
                    materials: t
                }), r.extensions && Ci(s, u, r), u;
            });
        }
        createUniqueName(t) {
            const e = re.sanitizeNodeName(t || "");
            return e in this.nodeNamesUsed ? e + "_" + ++this.nodeNamesUsed[e] : (this.nodeNamesUsed[e] = 0, e);
        }
        loadGeometries(t) {
            const e = this, n = this.extensions, s = this.primitiveCache;
            function r(o) {
                return n[qt.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(o, e).then(function(c) {
                    return ad(c, o, e);
                });
            }
            const a = [];
            for(let o = 0, c = t.length; o < c; o++){
                const l = t[o], h = lM(l), u = s[h];
                if (u) a.push(u.promise);
                else {
                    let d;
                    l.extensions && l.extensions[qt.KHR_DRACO_MESH_COMPRESSION] ? d = r(l) : d = ad(new kn, l, e), s[h] = {
                        primitive: l,
                        promise: d
                    }, a.push(d);
                }
            }
            return Promise.all(a);
        }
        loadMesh(t) {
            const e = this, n = this.json, s = this.extensions, r = n.meshes[t], a = r.primitives, o = [];
            for(let c = 0, l = a.length; c < l; c++){
                const h = a[c].material === void 0 ? aM(this.cache) : this.getDependency("material", a[c].material);
                o.push(h);
            }
            return o.push(e.loadGeometries(a)), Promise.all(o).then(function(c) {
                const l = c.slice(0, c.length - 1), h = c[c.length - 1], u = [];
                for(let f = 0, _ = h.length; f < _; f++){
                    const g = h[f], p = a[f];
                    let m;
                    const x = l[f];
                    if (p.mode === un.TRIANGLES || p.mode === un.TRIANGLE_STRIP || p.mode === un.TRIANGLE_FAN || p.mode === void 0) m = r.isSkinnedMesh === !0 ? new cx(g, x) : new Le(g, x), m.isSkinnedMesh === !0 && m.normalizeSkinWeights(), p.mode === un.TRIANGLE_STRIP ? m.geometry = ed(m.geometry, Df) : p.mode === un.TRIANGLE_FAN && (m.geometry = ed(m.geometry, sl));
                    else if (p.mode === un.LINES) m = new px(g, x);
                    else if (p.mode === un.LINE_STRIP) m = new Kl(g, x);
                    else if (p.mode === un.LINE_LOOP) m = new mx(g, x);
                    else if (p.mode === un.POINTS) m = new _x(g, x);
                    else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + p.mode);
                    Object.keys(m.geometry.morphAttributes).length > 0 && cM(m, r), m.name = e.createUniqueName(r.name || "mesh_" + t), Kn(m, r), p.extensions && Ci(s, m, p), e.assignFinalMaterial(m), u.push(m);
                }
                for(let f = 0, _ = u.length; f < _; f++)e.associations.set(u[f], {
                    meshes: t,
                    primitives: f
                });
                if (u.length === 1) return r.extensions && Ci(s, u[0], r), u[0];
                const d = new Gi;
                r.extensions && Ci(s, d, r), e.associations.set(d, {
                    meshes: t
                });
                for(let f = 0, _ = u.length; f < _; f++)d.add(u[f]);
                return d;
            });
        }
        loadCamera(t) {
            let e;
            const n = this.json.cameras[t], s = n[n.type];
            if (!s) {
                console.warn("THREE.GLTFLoader: Missing camera parameters.");
                return;
            }
            return n.type === "perspective" ? e = new We(Pg.radToDeg(s.yfov), s.aspectRatio || 1, s.znear || 1, s.zfar || 2e6) : n.type === "orthographic" && (e = new Jl(-s.xmag, s.xmag, s.ymag, -s.ymag, s.znear, s.zfar)), n.name && (e.name = this.createUniqueName(n.name)), Kn(e, n), Promise.resolve(e);
        }
        loadSkin(t) {
            const e = this.json.skins[t], n = [];
            for(let s = 0, r = e.joints.length; s < r; s++)n.push(this._loadNodeShallow(e.joints[s]));
            return e.inverseBindMatrices !== void 0 ? n.push(this.getDependency("accessor", e.inverseBindMatrices)) : n.push(null), Promise.all(n).then(function(s) {
                const r = s.pop(), a = s, o = [], c = [];
                for(let l = 0, h = a.length; l < h; l++){
                    const u = a[l];
                    if (u) {
                        o.push(u);
                        const d = new Ht;
                        r !== null && d.fromArray(r.array, l * 16), c.push(d);
                    } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', e.joints[l]);
                }
                return new jl(o, c);
            });
        }
        loadAnimation(t) {
            const e = this.json, n = this, s = e.animations[t], r = s.name ? s.name : "animation_" + t, a = [], o = [], c = [], l = [], h = [];
            for(let u = 0, d = s.channels.length; u < d; u++){
                const f = s.channels[u], _ = s.samplers[f.sampler], g = f.target, p = g.node, m = s.parameters !== void 0 ? s.parameters[_.input] : _.input, x = s.parameters !== void 0 ? s.parameters[_.output] : _.output;
                g.node !== void 0 && (a.push(this.getDependency("node", p)), o.push(this.getDependency("accessor", m)), c.push(this.getDependency("accessor", x)), l.push(_), h.push(g));
            }
            return Promise.all([
                Promise.all(a),
                Promise.all(o),
                Promise.all(c),
                Promise.all(l),
                Promise.all(h)
            ]).then(function(u) {
                const d = u[0], f = u[1], _ = u[2], g = u[3], p = u[4], m = [];
                for(let x = 0, y = d.length; x < y; x++){
                    const v = d[x], I = f[x], w = _[x], R = g[x], N = p[x];
                    if (v === void 0) continue;
                    v.updateMatrix && v.updateMatrix();
                    const E = n._createAnimationTracks(v, I, w, R, N);
                    if (E) for(let S = 0; S < E.length; S++)m.push(E[S]);
                }
                return new cl(r, void 0, m);
            });
        }
        createNodeMesh(t) {
            const e = this.json, n = this, s = e.nodes[t];
            return s.mesh === void 0 ? null : n.getDependency("mesh", s.mesh).then(function(r) {
                const a = n._getNodeRef(n.meshCache, s.mesh, r);
                return s.weights !== void 0 && a.traverse(function(o) {
                    if (o.isMesh) for(let c = 0, l = s.weights.length; c < l; c++)o.morphTargetInfluences[c] = s.weights[c];
                }), a;
            });
        }
        loadNode(t) {
            const e = this.json, n = this, s = e.nodes[t], r = n._loadNodeShallow(t), a = [], o = s.children || [];
            for(let l = 0, h = o.length; l < h; l++)a.push(n.getDependency("node", o[l]));
            const c = s.skin === void 0 ? Promise.resolve(null) : n.getDependency("skin", s.skin);
            return Promise.all([
                r,
                Promise.all(a),
                c
            ]).then(function(l) {
                const h = l[0], u = l[1], d = l[2];
                d !== null && h.traverse(function(f) {
                    f.isSkinnedMesh && f.bind(d, uM);
                });
                for(let f = 0, _ = u.length; f < _; f++)h.add(u[f]);
                return h;
            });
        }
        _loadNodeShallow(t) {
            const e = this.json, n = this.extensions, s = this;
            if (this.nodeCache[t] !== void 0) return this.nodeCache[t];
            const r = e.nodes[t], a = r.name ? s.createUniqueName(r.name) : "", o = [], c = s._invokeOne(function(l) {
                return l.createNodeMesh && l.createNodeMesh(t);
            });
            return c && o.push(c), r.camera !== void 0 && o.push(s.getDependency("camera", r.camera).then(function(l) {
                return s._getNodeRef(s.cameraCache, r.camera, l);
            })), s._invokeAll(function(l) {
                return l.createNodeAttachment && l.createNodeAttachment(t);
            }).forEach(function(l) {
                o.push(l);
            }), this.nodeCache[t] = Promise.all(o).then(function(l) {
                let h;
                if (r.isBone === !0 ? h = new Wf : l.length > 1 ? h = new Gi : l.length === 1 ? h = l[0] : h = new ge, h !== l[0]) for(let u = 0, d = l.length; u < d; u++)h.add(l[u]);
                if (r.name && (h.userData.name = r.name, h.name = a), Kn(h, r), r.extensions && Ci(n, h, r), r.matrix !== void 0) {
                    const u = new Ht;
                    u.fromArray(r.matrix), h.applyMatrix4(u);
                } else r.translation !== void 0 && h.position.fromArray(r.translation), r.rotation !== void 0 && h.quaternion.fromArray(r.rotation), r.scale !== void 0 && h.scale.fromArray(r.scale);
                return s.associations.has(h) || s.associations.set(h, {}), s.associations.get(h).nodes = t, h;
            }), this.nodeCache[t];
        }
        loadScene(t) {
            const e = this.extensions, n = this.json.scenes[t], s = this, r = new Gi;
            n.name && (r.name = s.createUniqueName(n.name)), Kn(r, n), n.extensions && Ci(e, r, n);
            const a = n.nodes || [], o = [];
            for(let c = 0, l = a.length; c < l; c++)o.push(s.getDependency("node", a[c]));
            return Promise.all(o).then(function(c) {
                for(let h = 0, u = c.length; h < u; h++)r.add(c[h]);
                const l = (h)=>{
                    const u = new Map;
                    for (const [d, f] of s.associations)(d instanceof Bn || d instanceof tn) && u.set(d, f);
                    return h.traverse((d)=>{
                        const f = s.associations.get(d);
                        f != null && u.set(d, f);
                    }), u;
                };
                return s.associations = l(r), r;
            });
        }
        _createAnimationTracks(t, e, n, s, r) {
            const a = [], o = t.name ? t.name : t.uuid, c = [];
            ui[r.path] === ui.weights ? t.traverse(function(d) {
                d.morphTargetInfluences && c.push(d.name ? d.name : d.uuid);
            }) : c.push(o);
            let l;
            switch(ui[r.path]){
                case ui.weights:
                    l = Ns;
                    break;
                case ui.rotation:
                    l = Bs;
                    break;
                case ui.translation:
                case ui.scale:
                    l = Fs;
                    break;
                default:
                    switch(n.itemSize){
                        case 1:
                            l = Ns;
                            break;
                        case 2:
                        case 3:
                        default:
                            l = Fs;
                            break;
                    }
                    break;
            }
            const h = s.interpolation !== void 0 ? rM[s.interpolation] : Cr, u = this._getArrayFromAccessor(n);
            for(let d = 0, f = c.length; d < f; d++){
                const _ = new l(c[d] + "." + ui[r.path], e.array, u, h);
                s.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(_), a.push(_);
            }
            return a;
        }
        _getArrayFromAccessor(t) {
            let e = t.array;
            if (t.normalized) {
                const n = dl(e.constructor), s = new Float32Array(e.length);
                for(let r = 0, a = e.length; r < a; r++)s[r] = e[r] * n;
                e = s;
            }
            return e;
        }
        _createCubicSplineTrackInterpolant(t) {
            t.createInterpolant = function(n) {
                const s = this instanceof Bs ? sM : ap;
                return new s(this.times, this.values, this.getValueSize() / 3, n);
            }, t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0;
        }
    }
    function fM(i, t, e) {
        const n = t.attributes, s = new Cn;
        if (n.POSITION !== void 0) {
            const o = e.json.accessors[n.POSITION], c = o.min, l = o.max;
            if (c !== void 0 && l !== void 0) {
                if (s.set(new k(c[0], c[1], c[2]), new k(l[0], l[1], l[2])), o.normalized) {
                    const h = dl(As[o.componentType]);
                    s.min.multiplyScalar(h), s.max.multiplyScalar(h);
                }
            } else {
                console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                return;
            }
        } else return;
        const r = t.targets;
        if (r !== void 0) {
            const o = new k, c = new k;
            for(let l = 0, h = r.length; l < h; l++){
                const u = r[l];
                if (u.POSITION !== void 0) {
                    const d = e.json.accessors[u.POSITION], f = d.min, _ = d.max;
                    if (f !== void 0 && _ !== void 0) {
                        if (c.setX(Math.max(Math.abs(f[0]), Math.abs(_[0]))), c.setY(Math.max(Math.abs(f[1]), Math.abs(_[1]))), c.setZ(Math.max(Math.abs(f[2]), Math.abs(_[2]))), d.normalized) {
                            const g = dl(As[d.componentType]);
                            c.multiplyScalar(g);
                        }
                        o.max(c);
                    } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                }
            }
            s.expandByVector(o);
        }
        i.boundingBox = s;
        const a = new On;
        s.getCenter(a.center), a.radius = s.min.distanceTo(s.max) / 2, i.boundingSphere = a;
    }
    function ad(i, t, e) {
        const n = t.attributes, s = [];
        function r(a, o) {
            return e.getDependency("accessor", a).then(function(c) {
                i.setAttribute(o, c);
            });
        }
        for(const a in n){
            const o = ul[a] || a.toLowerCase();
            o in i.attributes || s.push(r(n[a], o));
        }
        if (t.indices !== void 0 && !i.index) {
            const a = e.getDependency("accessor", t.indices).then(function(o) {
                i.setIndex(o);
            });
            s.push(a);
        }
        return $t.workingColorSpace !== Ke && "COLOR_0" in n && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${$t.workingColorSpace}" not supported.`), Kn(i, t), fM(i, t, e), Promise.all(s).then(function() {
            return t.targets !== void 0 ? oM(i, t.targets, e) : i;
        });
    }
    class Xi {
        static _instance = new Xi;
        static get instance() {
            return this._instance;
        }
        constructor(){}
        _models = new Map;
        _textures = new Map;
        getModel(t) {
            const e = this._models.get(t);
            if (!e) throw new Error(`Model ${t} not found`);
            return e;
        }
        getTexture(t) {
            const e = this._textures.get(t);
            if (!e) throw new Error(`Texture ${t} not found`);
            return e;
        }
        async load() {
            new nd().load("assets/models/cibus_ninja.glb", (n)=>{
                this._models.set("ninja", n);
            }, (n)=>{
                console.log(n.loaded / n.total * 100 + "% loaded");
            }, (n)=>{
                console.error("Error loading GLB:", n);
            });
            const t = new ll, e = (n, s)=>{
                const r = t.load(n);
                this._textures.set(s, r);
            };
            e("assets/textures/ninja.png", "ninja"), e("assets/textures/sand.jpg", "ground"), e("assets/textures/brick.png", "wall");
        }
        async loadAsync() {
            await this.loadModels(), await this.loadTextures();
        }
        async loadModels() {
            const t = new nd;
            (async (n, s)=>{
                const r = await t.loadAsync(n);
                this._models.set(s, r);
            })("assets/models/cibus_ninja.glb", "ninja");
        }
        async loadTextures() {
            const t = new ll, e = async (n, s)=>{
                const r = await t.loadAsync(n);
                this._textures.set(s, r);
            };
            await e("assets/textures/ninja.png", "ninja"), await e("assets/textures/sand.jpg", "ground"), await e("assets/textures/brick.png", "wall");
        }
    }
    const pM = "modulepreload", mM = function(i) {
        return "/" + i;
    }, od = {}, op = function(t, e, n) {
        let s = Promise.resolve();
        if (e && e.length > 0) {
            let a = function(l) {
                return Promise.all(l.map((h)=>Promise.resolve(h).then((u)=>({
                            status: "fulfilled",
                            value: u
                        }), (u)=>({
                            status: "rejected",
                            reason: u
                        }))));
            };
            document.getElementsByTagName("link");
            const o = document.querySelector("meta[property=csp-nonce]"), c = o?.nonce || o?.getAttribute("nonce");
            s = a(e.map((l)=>{
                if (l = mM(l), l in od) return;
                od[l] = !0;
                const h = l.endsWith(".css"), u = h ? '[rel="stylesheet"]' : "";
                if (document.querySelector(`link[href="${l}"]${u}`)) return;
                const d = document.createElement("link");
                if (d.rel = h ? "stylesheet" : pM, h || (d.as = "script"), d.crossOrigin = "", d.href = l, c && d.setAttribute("nonce", c), document.head.appendChild(d), h) return new Promise((f, _)=>{
                    d.addEventListener("load", f), d.addEventListener("error", ()=>_(new Error(`Unable to preload CSS for ${l}`)));
                });
            }));
        }
        function r(a) {
            const o = new Event("vite:preloadError", {
                cancelable: !0
            });
            if (o.payload = a, window.dispatchEvent(o), !o.defaultPrevented) throw a;
        }
        return s.then((a)=>{
            for (const o of a || [])o.status === "rejected" && r(o.reason);
            return t().catch(r);
        });
    };
    st = ((i)=>(i.Application = "application", i.WebGLPipes = "webgl-pipes", i.WebGLPipesAdaptor = "webgl-pipes-adaptor", i.WebGLSystem = "webgl-system", i.WebGPUPipes = "webgpu-pipes", i.WebGPUPipesAdaptor = "webgpu-pipes-adaptor", i.WebGPUSystem = "webgpu-system", i.CanvasSystem = "canvas-system", i.CanvasPipesAdaptor = "canvas-pipes-adaptor", i.CanvasPipes = "canvas-pipes", i.Asset = "asset", i.LoadParser = "load-parser", i.ResolveParser = "resolve-parser", i.CacheParser = "cache-parser", i.DetectionParser = "detection-parser", i.MaskEffect = "mask-effect", i.BlendMode = "blend-mode", i.TextureSource = "texture-source", i.Environment = "environment", i.ShapeBuilder = "shape-builder", i.Batcher = "batcher", i))(st || {});
    let fl, fa, _M, gM;
    fl = (i)=>{
        if (typeof i == "function" || typeof i == "object" && i.extension) {
            if (!i.extension) throw new Error("Extension class must have an extension object");
            i = {
                ...typeof i.extension != "object" ? {
                    type: i.extension
                } : i.extension,
                ref: i
            };
        }
        if (typeof i == "object") i = {
            ...i
        };
        else throw new Error("Invalid extension type");
        return typeof i.type == "string" && (i.type = [
            i.type
        ]), i;
    };
    fa = (i, t)=>fl(i).priority ?? t;
    Be = {
        _addHandlers: {},
        _removeHandlers: {},
        _queue: {},
        remove (...i) {
            return i.map(fl).forEach((t)=>{
                t.type.forEach((e)=>this._removeHandlers[e]?.(t));
            }), this;
        },
        add (...i) {
            return i.map(fl).forEach((t)=>{
                t.type.forEach((e)=>{
                    const n = this._addHandlers, s = this._queue;
                    n[e] ? n[e]?.(t) : (s[e] = s[e] || [], s[e]?.push(t));
                });
            }), this;
        },
        handle (i, t, e) {
            const n = this._addHandlers, s = this._removeHandlers;
            if (n[i] || s[i]) throw new Error(`Extension type ${i} already has a handler`);
            n[i] = t, s[i] = e;
            const r = this._queue;
            return r[i] && (r[i]?.forEach((a)=>t(a)), delete r[i]), this;
        },
        handleByMap (i, t) {
            return this.handle(i, (e)=>{
                e.name && (t[e.name] = e.ref);
            }, (e)=>{
                e.name && delete t[e.name];
            });
        },
        handleByNamedList (i, t, e = -1) {
            return this.handle(i, (n)=>{
                t.findIndex((r)=>r.name === n.name) >= 0 || (t.push({
                    name: n.name,
                    value: n.ref
                }), t.sort((r, a)=>fa(a.value, e) - fa(r.value, e)));
            }, (n)=>{
                const s = t.findIndex((r)=>r.name === n.name);
                s !== -1 && t.splice(s, 1);
            });
        },
        handleByList (i, t, e = -1) {
            return this.handle(i, (n)=>{
                t.includes(n.ref) || (t.push(n.ref), t.sort((s, r)=>fa(r, e) - fa(s, e)));
            }, (n)=>{
                const s = t.indexOf(n.ref);
                s !== -1 && t.splice(s, 1);
            });
        },
        mixin (i, ...t) {
            for (const e of t)Object.defineProperties(i.prototype, Object.getOwnPropertyDescriptors(e));
        }
    };
    _M = {
        extension: {
            type: st.Environment,
            name: "browser",
            priority: -1
        },
        test: ()=>!0,
        load: async ()=>{
            await op(()=>import("./browserAll-BG0lP3r1.js"), __vite__mapDeps([0,1]));
        }
    };
    gM = {
        extension: {
            type: st.Environment,
            name: "webworker",
            priority: 0
        },
        test: ()=>typeof self < "u" && self.WorkerGlobalScope !== void 0,
        load: async ()=>{
            await op(()=>import("./webworkerAll-DcBE8OqC.js"), []);
        }
    };
    class Je {
        constructor(t, e, n){
            this._x = e || 0, this._y = n || 0, this._observer = t;
        }
        clone(t) {
            return new Je(t ?? this._observer, this._x, this._y);
        }
        set(t = 0, e = t) {
            return (this._x !== t || this._y !== e) && (this._x = t, this._y = e, this._observer._onUpdate(this)), this;
        }
        copyFrom(t) {
            return (this._x !== t.x || this._y !== t.y) && (this._x = t.x, this._y = t.y, this._observer._onUpdate(this)), this;
        }
        copyTo(t) {
            return t.set(this._x, this._y), t;
        }
        equals(t) {
            return t.x === this._x && t.y === this._y;
        }
        toString() {
            return `[pixi.js/math:ObservablePoint x=0 y=0 scope=${this._observer}]`;
        }
        get x() {
            return this._x;
        }
        set x(t) {
            this._x !== t && (this._x = t, this._observer._onUpdate(this));
        }
        get y() {
            return this._y;
        }
        set y(t) {
            this._y !== t && (this._y = t, this._observer._onUpdate(this));
        }
    }
    function ih(i) {
        return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
    }
    var ko = {
        exports: {}
    }, cd;
    function xM() {
        return cd || (cd = 1, function(i) {
            var t = Object.prototype.hasOwnProperty, e = "~";
            function n() {}
            Object.create && (n.prototype = Object.create(null), new n().__proto__ || (e = !1));
            function s(c, l, h) {
                this.fn = c, this.context = l, this.once = h || !1;
            }
            function r(c, l, h, u, d) {
                if (typeof h != "function") throw new TypeError("The listener must be a function");
                var f = new s(h, u || c, d), _ = e ? e + l : l;
                return c._events[_] ? c._events[_].fn ? c._events[_] = [
                    c._events[_],
                    f
                ] : c._events[_].push(f) : (c._events[_] = f, c._eventsCount++), c;
            }
            function a(c, l) {
                --c._eventsCount === 0 ? c._events = new n : delete c._events[l];
            }
            function o() {
                this._events = new n, this._eventsCount = 0;
            }
            o.prototype.eventNames = function() {
                var l = [], h, u;
                if (this._eventsCount === 0) return l;
                for(u in h = this._events)t.call(h, u) && l.push(e ? u.slice(1) : u);
                return Object.getOwnPropertySymbols ? l.concat(Object.getOwnPropertySymbols(h)) : l;
            }, o.prototype.listeners = function(l) {
                var h = e ? e + l : l, u = this._events[h];
                if (!u) return [];
                if (u.fn) return [
                    u.fn
                ];
                for(var d = 0, f = u.length, _ = new Array(f); d < f; d++)_[d] = u[d].fn;
                return _;
            }, o.prototype.listenerCount = function(l) {
                var h = e ? e + l : l, u = this._events[h];
                return u ? u.fn ? 1 : u.length : 0;
            }, o.prototype.emit = function(l, h, u, d, f, _) {
                var g = e ? e + l : l;
                if (!this._events[g]) return !1;
                var p = this._events[g], m = arguments.length, x, y;
                if (p.fn) {
                    switch(p.once && this.removeListener(l, p.fn, void 0, !0), m){
                        case 1:
                            return p.fn.call(p.context), !0;
                        case 2:
                            return p.fn.call(p.context, h), !0;
                        case 3:
                            return p.fn.call(p.context, h, u), !0;
                        case 4:
                            return p.fn.call(p.context, h, u, d), !0;
                        case 5:
                            return p.fn.call(p.context, h, u, d, f), !0;
                        case 6:
                            return p.fn.call(p.context, h, u, d, f, _), !0;
                    }
                    for(y = 1, x = new Array(m - 1); y < m; y++)x[y - 1] = arguments[y];
                    p.fn.apply(p.context, x);
                } else {
                    var v = p.length, I;
                    for(y = 0; y < v; y++)switch(p[y].once && this.removeListener(l, p[y].fn, void 0, !0), m){
                        case 1:
                            p[y].fn.call(p[y].context);
                            break;
                        case 2:
                            p[y].fn.call(p[y].context, h);
                            break;
                        case 3:
                            p[y].fn.call(p[y].context, h, u);
                            break;
                        case 4:
                            p[y].fn.call(p[y].context, h, u, d);
                            break;
                        default:
                            if (!x) for(I = 1, x = new Array(m - 1); I < m; I++)x[I - 1] = arguments[I];
                            p[y].fn.apply(p[y].context, x);
                    }
                }
                return !0;
            }, o.prototype.on = function(l, h, u) {
                return r(this, l, h, u, !1);
            }, o.prototype.once = function(l, h, u) {
                return r(this, l, h, u, !0);
            }, o.prototype.removeListener = function(l, h, u, d) {
                var f = e ? e + l : l;
                if (!this._events[f]) return this;
                if (!h) return a(this, f), this;
                var _ = this._events[f];
                if (_.fn) _.fn === h && (!d || _.once) && (!u || _.context === u) && a(this, f);
                else {
                    for(var g = 0, p = [], m = _.length; g < m; g++)(_[g].fn !== h || d && !_[g].once || u && _[g].context !== u) && p.push(_[g]);
                    p.length ? this._events[f] = p.length === 1 ? p[0] : p : a(this, f);
                }
                return this;
            }, o.prototype.removeAllListeners = function(l) {
                var h;
                return l ? (h = e ? e + l : l, this._events[h] && a(this, h)) : (this._events = new n, this._eventsCount = 0), this;
            }, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prefixed = e, o.EventEmitter = o, i.exports = o;
        }(ko)), ko.exports;
    }
    var vM = xM();
    let yM, bM, SM;
    In = ih(vM);
    yM = Math.PI * 2;
    bM = 180 / Math.PI;
    SM = Math.PI / 180;
    Ue = class {
        constructor(t = 0, e = 0){
            this.x = 0, this.y = 0, this.x = t, this.y = e;
        }
        clone() {
            return new Ue(this.x, this.y);
        }
        copyFrom(t) {
            return this.set(t.x, t.y), this;
        }
        copyTo(t) {
            return t.set(this.x, this.y), t;
        }
        equals(t) {
            return t.x === this.x && t.y === this.y;
        }
        set(t = 0, e = t) {
            return this.x = t, this.y = e, this;
        }
        toString() {
            return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;
        }
        static get shared() {
            return Go.x = 0, Go.y = 0, Go;
        }
    };
    const Go = new Ue;
    Ft = class {
        constructor(t = 1, e = 0, n = 0, s = 1, r = 0, a = 0){
            this.array = null, this.a = t, this.b = e, this.c = n, this.d = s, this.tx = r, this.ty = a;
        }
        fromArray(t) {
            this.a = t[0], this.b = t[1], this.c = t[3], this.d = t[4], this.tx = t[2], this.ty = t[5];
        }
        set(t, e, n, s, r, a) {
            return this.a = t, this.b = e, this.c = n, this.d = s, this.tx = r, this.ty = a, this;
        }
        toArray(t, e) {
            this.array || (this.array = new Float32Array(9));
            const n = e || this.array;
            return t ? (n[0] = this.a, n[1] = this.b, n[2] = 0, n[3] = this.c, n[4] = this.d, n[5] = 0, n[6] = this.tx, n[7] = this.ty, n[8] = 1) : (n[0] = this.a, n[1] = this.c, n[2] = this.tx, n[3] = this.b, n[4] = this.d, n[5] = this.ty, n[6] = 0, n[7] = 0, n[8] = 1), n;
        }
        apply(t, e) {
            e = e || new Ue;
            const n = t.x, s = t.y;
            return e.x = this.a * n + this.c * s + this.tx, e.y = this.b * n + this.d * s + this.ty, e;
        }
        applyInverse(t, e) {
            e = e || new Ue;
            const n = this.a, s = this.b, r = this.c, a = this.d, o = this.tx, c = this.ty, l = 1 / (n * a + r * -s), h = t.x, u = t.y;
            return e.x = a * l * h + -r * l * u + (c * r - o * a) * l, e.y = n * l * u + -s * l * h + (-c * n + o * s) * l, e;
        }
        translate(t, e) {
            return this.tx += t, this.ty += e, this;
        }
        scale(t, e) {
            return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this;
        }
        rotate(t) {
            const e = Math.cos(t), n = Math.sin(t), s = this.a, r = this.c, a = this.tx;
            return this.a = s * e - this.b * n, this.b = s * n + this.b * e, this.c = r * e - this.d * n, this.d = r * n + this.d * e, this.tx = a * e - this.ty * n, this.ty = a * n + this.ty * e, this;
        }
        append(t) {
            const e = this.a, n = this.b, s = this.c, r = this.d;
            return this.a = t.a * e + t.b * s, this.b = t.a * n + t.b * r, this.c = t.c * e + t.d * s, this.d = t.c * n + t.d * r, this.tx = t.tx * e + t.ty * s + this.tx, this.ty = t.tx * n + t.ty * r + this.ty, this;
        }
        appendFrom(t, e) {
            const n = t.a, s = t.b, r = t.c, a = t.d, o = t.tx, c = t.ty, l = e.a, h = e.b, u = e.c, d = e.d;
            return this.a = n * l + s * u, this.b = n * h + s * d, this.c = r * l + a * u, this.d = r * h + a * d, this.tx = o * l + c * u + e.tx, this.ty = o * h + c * d + e.ty, this;
        }
        setTransform(t, e, n, s, r, a, o, c, l) {
            return this.a = Math.cos(o + l) * r, this.b = Math.sin(o + l) * r, this.c = -Math.sin(o - c) * a, this.d = Math.cos(o - c) * a, this.tx = t - (n * this.a + s * this.c), this.ty = e - (n * this.b + s * this.d), this;
        }
        prepend(t) {
            const e = this.tx;
            if (t.a !== 1 || t.b !== 0 || t.c !== 0 || t.d !== 1) {
                const n = this.a, s = this.c;
                this.a = n * t.a + this.b * t.c, this.b = n * t.b + this.b * t.d, this.c = s * t.a + this.d * t.c, this.d = s * t.b + this.d * t.d;
            }
            return this.tx = e * t.a + this.ty * t.c + t.tx, this.ty = e * t.b + this.ty * t.d + t.ty, this;
        }
        decompose(t) {
            const e = this.a, n = this.b, s = this.c, r = this.d, a = t.pivot, o = -Math.atan2(-s, r), c = Math.atan2(n, e), l = Math.abs(o + c);
            return l < 1e-5 || Math.abs(yM - l) < 1e-5 ? (t.rotation = c, t.skew.x = t.skew.y = 0) : (t.rotation = 0, t.skew.x = o, t.skew.y = c), t.scale.x = Math.sqrt(e * e + n * n), t.scale.y = Math.sqrt(s * s + r * r), t.position.x = this.tx + (a.x * e + a.y * s), t.position.y = this.ty + (a.x * n + a.y * r), t;
        }
        invert() {
            const t = this.a, e = this.b, n = this.c, s = this.d, r = this.tx, a = t * s - e * n;
            return this.a = s / a, this.b = -e / a, this.c = -n / a, this.d = t / a, this.tx = (n * this.ty - s * r) / a, this.ty = -(t * this.ty - e * r) / a, this;
        }
        isIdentity() {
            return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;
        }
        identity() {
            return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;
        }
        clone() {
            const t = new Ft;
            return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;
        }
        copyTo(t) {
            return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;
        }
        copyFrom(t) {
            return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this;
        }
        equals(t) {
            return t.a === this.a && t.b === this.b && t.c === this.c && t.d === this.d && t.tx === this.tx && t.ty === this.ty;
        }
        toString() {
            return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
        }
        static get IDENTITY() {
            return TM.identity();
        }
        static get shared() {
            return MM.identity();
        }
    };
    const MM = new Ft, TM = new Ft, Li = [
        1,
        1,
        0,
        -1,
        -1,
        -1,
        0,
        1,
        1,
        1,
        0,
        -1,
        -1,
        -1,
        0,
        1
    ], Ui = [
        0,
        1,
        1,
        1,
        0,
        -1,
        -1,
        -1,
        0,
        1,
        1,
        1,
        0,
        -1,
        -1,
        -1
    ], Ni = [
        0,
        -1,
        -1,
        -1,
        0,
        1,
        1,
        1,
        0,
        1,
        1,
        1,
        0,
        -1,
        -1,
        -1
    ], Bi = [
        1,
        1,
        0,
        -1,
        -1,
        -1,
        0,
        1,
        -1,
        -1,
        0,
        1,
        1,
        1,
        0,
        -1
    ], pl = [], cp = [], pa = Math.sign;
    function EM() {
        for(let i = 0; i < 16; i++){
            const t = [];
            pl.push(t);
            for(let e = 0; e < 16; e++){
                const n = pa(Li[i] * Li[e] + Ni[i] * Ui[e]), s = pa(Ui[i] * Li[e] + Bi[i] * Ui[e]), r = pa(Li[i] * Ni[e] + Ni[i] * Bi[e]), a = pa(Ui[i] * Ni[e] + Bi[i] * Bi[e]);
                for(let o = 0; o < 16; o++)if (Li[o] === n && Ui[o] === s && Ni[o] === r && Bi[o] === a) {
                    t.push(o);
                    break;
                }
            }
        }
        for(let i = 0; i < 16; i++){
            const t = new Ft;
            t.set(Li[i], Ui[i], Ni[i], Bi[i], 0, 0), cp.push(t);
        }
    }
    EM();
    const me = {
        E: 0,
        SE: 1,
        S: 2,
        SW: 3,
        W: 4,
        NW: 5,
        N: 6,
        NE: 7,
        MIRROR_VERTICAL: 8,
        MAIN_DIAGONAL: 10,
        MIRROR_HORIZONTAL: 12,
        REVERSE_DIAGONAL: 14,
        uX: (i)=>Li[i],
        uY: (i)=>Ui[i],
        vX: (i)=>Ni[i],
        vY: (i)=>Bi[i],
        inv: (i)=>i & 8 ? i & 15 : -i & 7,
        add: (i, t)=>pl[i][t],
        sub: (i, t)=>pl[i][me.inv(t)],
        rotate180: (i)=>i ^ 4,
        isVertical: (i)=>(i & 3) === 2,
        byDirection: (i, t)=>Math.abs(i) * 2 <= Math.abs(t) ? t >= 0 ? me.S : me.N : Math.abs(t) * 2 <= Math.abs(i) ? i > 0 ? me.E : me.W : t > 0 ? i > 0 ? me.SE : me.SW : i > 0 ? me.NE : me.NW,
        matrixAppendRotationInv: (i, t, e = 0, n = 0)=>{
            const s = cp[me.inv(t)];
            s.tx = e, s.ty = n, i.append(s);
        }
    }, ma = [
        new Ue,
        new Ue,
        new Ue,
        new Ue
    ];
    fe = class {
        constructor(t = 0, e = 0, n = 0, s = 0){
            this.type = "rectangle", this.x = Number(t), this.y = Number(e), this.width = Number(n), this.height = Number(s);
        }
        get left() {
            return this.x;
        }
        get right() {
            return this.x + this.width;
        }
        get top() {
            return this.y;
        }
        get bottom() {
            return this.y + this.height;
        }
        isEmpty() {
            return this.left === this.right || this.top === this.bottom;
        }
        static get EMPTY() {
            return new fe(0, 0, 0, 0);
        }
        clone() {
            return new fe(this.x, this.y, this.width, this.height);
        }
        copyFromBounds(t) {
            return this.x = t.minX, this.y = t.minY, this.width = t.maxX - t.minX, this.height = t.maxY - t.minY, this;
        }
        copyFrom(t) {
            return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this;
        }
        copyTo(t) {
            return t.copyFrom(this), t;
        }
        contains(t, e) {
            return this.width <= 0 || this.height <= 0 ? !1 : t >= this.x && t < this.x + this.width && e >= this.y && e < this.y + this.height;
        }
        strokeContains(t, e, n, s = .5) {
            const { width: r, height: a } = this;
            if (r <= 0 || a <= 0) return !1;
            const o = this.x, c = this.y, l = n * (1 - s), h = n - l, u = o - l, d = o + r + l, f = c - l, _ = c + a + l, g = o + h, p = o + r - h, m = c + h, x = c + a - h;
            return t >= u && t <= d && e >= f && e <= _ && !(t > g && t < p && e > m && e < x);
        }
        intersects(t, e) {
            if (!e) {
                const N = this.x < t.x ? t.x : this.x;
                if ((this.right > t.right ? t.right : this.right) <= N) return !1;
                const S = this.y < t.y ? t.y : this.y;
                return (this.bottom > t.bottom ? t.bottom : this.bottom) > S;
            }
            const n = this.left, s = this.right, r = this.top, a = this.bottom;
            if (s <= n || a <= r) return !1;
            const o = ma[0].set(t.left, t.top), c = ma[1].set(t.left, t.bottom), l = ma[2].set(t.right, t.top), h = ma[3].set(t.right, t.bottom);
            if (l.x <= o.x || c.y <= o.y) return !1;
            const u = Math.sign(e.a * e.d - e.b * e.c);
            if (u === 0 || (e.apply(o, o), e.apply(c, c), e.apply(l, l), e.apply(h, h), Math.max(o.x, c.x, l.x, h.x) <= n || Math.min(o.x, c.x, l.x, h.x) >= s || Math.max(o.y, c.y, l.y, h.y) <= r || Math.min(o.y, c.y, l.y, h.y) >= a)) return !1;
            const d = u * (c.y - o.y), f = u * (o.x - c.x), _ = d * n + f * r, g = d * s + f * r, p = d * n + f * a, m = d * s + f * a;
            if (Math.max(_, g, p, m) <= d * o.x + f * o.y || Math.min(_, g, p, m) >= d * h.x + f * h.y) return !1;
            const x = u * (o.y - l.y), y = u * (l.x - o.x), v = x * n + y * r, I = x * s + y * r, w = x * n + y * a, R = x * s + y * a;
            return !(Math.max(v, I, w, R) <= x * o.x + y * o.y || Math.min(v, I, w, R) >= x * h.x + y * h.y);
        }
        pad(t = 0, e = t) {
            return this.x -= t, this.y -= e, this.width += t * 2, this.height += e * 2, this;
        }
        fit(t) {
            const e = Math.max(this.x, t.x), n = Math.min(this.x + this.width, t.x + t.width), s = Math.max(this.y, t.y), r = Math.min(this.y + this.height, t.y + t.height);
            return this.x = e, this.width = Math.max(n - e, 0), this.y = s, this.height = Math.max(r - s, 0), this;
        }
        ceil(t = 1, e = .001) {
            const n = Math.ceil((this.x + this.width - e) * t) / t, s = Math.ceil((this.y + this.height - e) * t) / t;
            return this.x = Math.floor((this.x + e) * t) / t, this.y = Math.floor((this.y + e) * t) / t, this.width = n - this.x, this.height = s - this.y, this;
        }
        enlarge(t) {
            const e = Math.min(this.x, t.x), n = Math.max(this.x + this.width, t.x + t.width), s = Math.min(this.y, t.y), r = Math.max(this.y + this.height, t.y + t.height);
            return this.x = e, this.width = n - e, this.y = s, this.height = r - s, this;
        }
        getBounds(t) {
            return t || (t = new fe), t.copyFrom(this), t;
        }
        containsRect(t) {
            if (this.width <= 0 || this.height <= 0) return !1;
            const e = t.x, n = t.y, s = t.x + t.width, r = t.y + t.height;
            return e >= this.x && e < this.x + this.width && n >= this.y && n < this.y + this.height && s >= this.x && s < this.x + this.width && r >= this.y && r < this.y + this.height;
        }
        toString() {
            return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
        }
    };
    const Ho = {
        default: -1
    };
    function pe(i = "default") {
        return Ho[i] === void 0 && (Ho[i] = -1), ++Ho[i];
    }
    let ld, AM;
    ld = {};
    be = "8.0.0";
    AM = "8.3.4";
    ue = function(i, t, e = 3) {
        if (ld[t]) return;
        let n = new Error().stack;
        typeof n > "u" ? console.warn("PixiJS Deprecation Warning: ", `${t}
Deprecated since v${i}`) : (n = n.split(`
`).splice(e).join(`
`), console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", `${t}
Deprecated since v${i}`), console.warn(n), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", `${t}
Deprecated since v${i}`), console.warn(n))), ld[t] = !0;
    };
    const lp = ()=>{};
    hd = function(i) {
        return i += i === 0 ? 1 : 0, --i, i |= i >>> 1, i |= i >>> 2, i |= i >>> 4, i |= i >>> 8, i |= i >>> 16, i + 1;
    };
    function ud(i) {
        return !(i & i - 1) && !!i;
    }
    function hp(i) {
        const t = {};
        for(const e in i)i[e] !== void 0 && (t[e] = i[e]);
        return t;
    }
    const dd = Object.create(null);
    function wM(i) {
        const t = dd[i];
        return t === void 0 && (dd[i] = pe("resource")), t;
    }
    const up = class dp extends In {
        constructor(t = {}){
            super(), this._resourceType = "textureSampler", this._touched = 0, this._maxAnisotropy = 1, this.destroyed = !1, t = {
                ...dp.defaultOptions,
                ...t
            }, this.addressMode = t.addressMode, this.addressModeU = t.addressModeU ?? this.addressModeU, this.addressModeV = t.addressModeV ?? this.addressModeV, this.addressModeW = t.addressModeW ?? this.addressModeW, this.scaleMode = t.scaleMode, this.magFilter = t.magFilter ?? this.magFilter, this.minFilter = t.minFilter ?? this.minFilter, this.mipmapFilter = t.mipmapFilter ?? this.mipmapFilter, this.lodMinClamp = t.lodMinClamp, this.lodMaxClamp = t.lodMaxClamp, this.compare = t.compare, this.maxAnisotropy = t.maxAnisotropy ?? 1;
        }
        set addressMode(t) {
            this.addressModeU = t, this.addressModeV = t, this.addressModeW = t;
        }
        get addressMode() {
            return this.addressModeU;
        }
        set wrapMode(t) {
            ue(be, "TextureStyle.wrapMode is now TextureStyle.addressMode"), this.addressMode = t;
        }
        get wrapMode() {
            return this.addressMode;
        }
        set scaleMode(t) {
            this.magFilter = t, this.minFilter = t, this.mipmapFilter = t;
        }
        get scaleMode() {
            return this.magFilter;
        }
        set maxAnisotropy(t) {
            this._maxAnisotropy = Math.min(t, 16), this._maxAnisotropy > 1 && (this.scaleMode = "linear");
        }
        get maxAnisotropy() {
            return this._maxAnisotropy;
        }
        get _resourceId() {
            return this._sharedResourceId || this._generateResourceId();
        }
        update() {
            this.emit("change", this), this._sharedResourceId = null;
        }
        _generateResourceId() {
            const t = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
            return this._sharedResourceId = wM(t), this._resourceId;
        }
        destroy() {
            this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this.removeAllListeners();
        }
    };
    up.defaultOptions = {
        addressMode: "clamp-to-edge",
        scaleMode: "linear"
    };
    RM = up;
    const fp = class pp extends In {
        constructor(t = {}){
            super(), this.options = t, this.uid = pe("textureSource"), this._resourceType = "textureSource", this._resourceId = pe("resource"), this.uploadMethodId = "unknown", this._resolution = 1, this.pixelWidth = 1, this.pixelHeight = 1, this.width = 1, this.height = 1, this.sampleCount = 1, this.mipLevelCount = 1, this.autoGenerateMipmaps = !1, this.format = "rgba8unorm", this.dimension = "2d", this.antialias = !1, this._touched = 0, this._batchTick = -1, this._textureBindLocation = -1, t = {
                ...pp.defaultOptions,
                ...t
            }, this.label = t.label ?? "", this.resource = t.resource, this.autoGarbageCollect = t.autoGarbageCollect, this._resolution = t.resolution, t.width ? this.pixelWidth = t.width * this._resolution : this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1, t.height ? this.pixelHeight = t.height * this._resolution : this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1, this.width = this.pixelWidth / this._resolution, this.height = this.pixelHeight / this._resolution, this.format = t.format, this.dimension = t.dimensions, this.mipLevelCount = t.mipLevelCount, this.autoGenerateMipmaps = t.autoGenerateMipmaps, this.sampleCount = t.sampleCount, this.antialias = t.antialias, this.alphaMode = t.alphaMode, this.style = new RM(hp(t)), this.destroyed = !1, this._refreshPOT();
        }
        get source() {
            return this;
        }
        get style() {
            return this._style;
        }
        set style(t) {
            this.style !== t && (this._style?.off("change", this._onStyleChange, this), this._style = t, this._style?.on("change", this._onStyleChange, this), this._onStyleChange());
        }
        get addressMode() {
            return this._style.addressMode;
        }
        set addressMode(t) {
            this._style.addressMode = t;
        }
        get repeatMode() {
            return this._style.addressMode;
        }
        set repeatMode(t) {
            this._style.addressMode = t;
        }
        get magFilter() {
            return this._style.magFilter;
        }
        set magFilter(t) {
            this._style.magFilter = t;
        }
        get minFilter() {
            return this._style.minFilter;
        }
        set minFilter(t) {
            this._style.minFilter = t;
        }
        get mipmapFilter() {
            return this._style.mipmapFilter;
        }
        set mipmapFilter(t) {
            this._style.mipmapFilter = t;
        }
        get lodMinClamp() {
            return this._style.lodMinClamp;
        }
        set lodMinClamp(t) {
            this._style.lodMinClamp = t;
        }
        get lodMaxClamp() {
            return this._style.lodMaxClamp;
        }
        set lodMaxClamp(t) {
            this._style.lodMaxClamp = t;
        }
        _onStyleChange() {
            this.emit("styleChange", this);
        }
        update() {
            if (this.resource) {
                const t = this._resolution;
                if (this.resize(this.resourceWidth / t, this.resourceHeight / t)) return;
            }
            this.emit("update", this);
        }
        destroy() {
            this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this._style && (this._style.destroy(), this._style = null), this.uploadMethodId = null, this.resource = null, this.removeAllListeners();
        }
        unload() {
            this._resourceId = pe("resource"), this.emit("change", this), this.emit("unload", this);
        }
        get resourceWidth() {
            const { resource: t } = this;
            return t.naturalWidth || t.videoWidth || t.displayWidth || t.width;
        }
        get resourceHeight() {
            const { resource: t } = this;
            return t.naturalHeight || t.videoHeight || t.displayHeight || t.height;
        }
        get resolution() {
            return this._resolution;
        }
        set resolution(t) {
            this._resolution !== t && (this._resolution = t, this.width = this.pixelWidth / t, this.height = this.pixelHeight / t);
        }
        resize(t, e, n) {
            n || (n = this._resolution), t || (t = this.width), e || (e = this.height);
            const s = Math.round(t * n), r = Math.round(e * n);
            return this.width = s / n, this.height = r / n, this._resolution = n, this.pixelWidth === s && this.pixelHeight === r ? !1 : (this._refreshPOT(), this.pixelWidth = s, this.pixelHeight = r, this.emit("resize", this), this._resourceId = pe("resource"), this.emit("change", this), !0);
        }
        updateMipmaps() {
            this.autoGenerateMipmaps && this.mipLevelCount > 1 && this.emit("updateMipmaps", this);
        }
        set wrapMode(t) {
            this._style.wrapMode = t;
        }
        get wrapMode() {
            return this._style.wrapMode;
        }
        set scaleMode(t) {
            this._style.scaleMode = t;
        }
        get scaleMode() {
            return this._style.scaleMode;
        }
        _refreshPOT() {
            this.isPowerOfTwo = ud(this.pixelWidth) && ud(this.pixelHeight);
        }
        static test(t) {
            throw new Error("Unimplemented");
        }
    };
    fp.defaultOptions = {
        resolution: 1,
        format: "bgra8unorm",
        alphaMode: "premultiply-alpha-on-upload",
        dimensions: "2d",
        mipLevelCount: 1,
        autoGenerateMipmaps: !1,
        sampleCount: 1,
        antialias: !1,
        autoGarbageCollect: !1
    };
    let Ne = fp;
    class sh extends Ne {
        constructor(t){
            const e = t.resource || new Float32Array(t.width * t.height * 4);
            let n = t.format;
            n || (e instanceof Float32Array ? n = "rgba32float" : e instanceof Int32Array || e instanceof Uint32Array ? n = "rgba32uint" : e instanceof Int16Array || e instanceof Uint16Array ? n = "rgba16uint" : (e instanceof Int8Array, n = "bgra8unorm")), super({
                ...t,
                resource: e,
                format: n
            }), this.uploadMethodId = "buffer";
        }
        static test(t) {
            return t instanceof Int8Array || t instanceof Uint8Array || t instanceof Uint8ClampedArray || t instanceof Int16Array || t instanceof Uint16Array || t instanceof Int32Array || t instanceof Uint32Array || t instanceof Float32Array;
        }
    }
    sh.extension = st.TextureSource;
    const fd = new Ft;
    class mp {
        constructor(t, e){
            this.mapCoord = new Ft, this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, typeof e > "u" ? this.clampMargin = t.width < 10 ? 0 : .5 : this.clampMargin = e, this.isSimple = !1, this.texture = t;
        }
        get texture() {
            return this._texture;
        }
        set texture(t) {
            this.texture !== t && (this._texture?.removeListener("update", this.update, this), this._texture = t, this._texture.addListener("update", this.update, this), this.update());
        }
        multiplyUvs(t, e) {
            e === void 0 && (e = t);
            const n = this.mapCoord;
            for(let s = 0; s < t.length; s += 2){
                const r = t[s], a = t[s + 1];
                e[s] = r * n.a + a * n.c + n.tx, e[s + 1] = r * n.b + a * n.d + n.ty;
            }
            return e;
        }
        update() {
            const t = this._texture;
            this._updateID++;
            const e = t.uvs;
            this.mapCoord.set(e.x1 - e.x0, e.y1 - e.y0, e.x3 - e.x0, e.y3 - e.y0, e.x0, e.y0);
            const n = t.orig, s = t.trim;
            s && (fd.set(n.width / s.width, 0, 0, n.height / s.height, -s.x / s.width, -s.y / s.height), this.mapCoord.append(fd));
            const r = t.source, a = this.uClampFrame, o = this.clampMargin / r._resolution, c = this.clampOffset / r._resolution;
            return a[0] = (t.frame.x + o + c) / r.width, a[1] = (t.frame.y + o + c) / r.height, a[2] = (t.frame.x + t.frame.width - o + c) / r.width, a[3] = (t.frame.y + t.frame.height - o + c) / r.height, this.uClampOffset[0] = this.clampOffset / r.pixelWidth, this.uClampOffset[1] = this.clampOffset / r.pixelHeight, this.isSimple = t.frame.width === r.width && t.frame.height === r.height && t.rotate === 0, !0;
        }
    }
    Ot = class extends In {
        constructor({ source: t, label: e, frame: n, orig: s, trim: r, defaultAnchor: a, defaultBorders: o, rotate: c, dynamic: l } = {}){
            if (super(), this.uid = pe("texture"), this.uvs = {
                x0: 0,
                y0: 0,
                x1: 0,
                y1: 0,
                x2: 0,
                y2: 0,
                x3: 0,
                y3: 0
            }, this.frame = new fe, this.noFrame = !1, this.dynamic = !1, this.isTexture = !0, this.label = e, this.source = t?.source ?? new Ne, this.noFrame = !n, n) this.frame.copyFrom(n);
            else {
                const { width: h, height: u } = this._source;
                this.frame.width = h, this.frame.height = u;
            }
            this.orig = s || this.frame, this.trim = r, this.rotate = c ?? 0, this.defaultAnchor = a, this.defaultBorders = o, this.destroyed = !1, this.dynamic = l || !1, this.updateUvs();
        }
        set source(t) {
            this._source && this._source.off("resize", this.update, this), this._source = t, t.on("resize", this.update, this), this.emit("update", this);
        }
        get source() {
            return this._source;
        }
        get textureMatrix() {
            return this._textureMatrix || (this._textureMatrix = new mp(this)), this._textureMatrix;
        }
        get width() {
            return this.orig.width;
        }
        get height() {
            return this.orig.height;
        }
        updateUvs() {
            const { uvs: t, frame: e } = this, { width: n, height: s } = this._source, r = e.x / n, a = e.y / s, o = e.width / n, c = e.height / s;
            let l = this.rotate;
            if (l) {
                const h = o / 2, u = c / 2, d = r + h, f = a + u;
                l = me.add(l, me.NW), t.x0 = d + h * me.uX(l), t.y0 = f + u * me.uY(l), l = me.add(l, 2), t.x1 = d + h * me.uX(l), t.y1 = f + u * me.uY(l), l = me.add(l, 2), t.x2 = d + h * me.uX(l), t.y2 = f + u * me.uY(l), l = me.add(l, 2), t.x3 = d + h * me.uX(l), t.y3 = f + u * me.uY(l);
            } else t.x0 = r, t.y0 = a, t.x1 = r + o, t.y1 = a, t.x2 = r + o, t.y2 = a + c, t.x3 = r, t.y3 = a + c;
        }
        destroy(t = !1) {
            this._source && t && (this._source.destroy(), this._source = null), this._textureMatrix = null, this.destroyed = !0, this.emit("destroy", this), this.removeAllListeners();
        }
        update() {
            this.noFrame && (this.frame.width = this._source.width, this.frame.height = this._source.height), this.updateUvs(), this.emit("update", this);
        }
        get baseTexture() {
            return ue(be, "Texture.baseTexture is now Texture.source"), this._source;
        }
    };
    Ot.EMPTY = new Ot({
        label: "EMPTY",
        source: new Ne({
            label: "EMPTY"
        })
    });
    Ot.EMPTY.destroy = lp;
    Ot.WHITE = new Ot({
        source: new sh({
            resource: new Uint8Array([
                255,
                255,
                255,
                255
            ]),
            width: 1,
            height: 1,
            alphaMode: "premultiply-alpha-on-upload",
            label: "WHITE"
        }),
        label: "WHITE"
    });
    Ot.WHITE.destroy = lp;
    CM = function(i, t, e) {
        const { width: n, height: s } = e.orig, r = e.trim;
        if (r) {
            const a = r.width, o = r.height;
            i.minX = r.x - t._x * n, i.maxX = i.minX + a, i.minY = r.y - t._y * s, i.maxY = i.minY + o;
        } else i.minX = -t._x * n, i.maxX = i.minX + n, i.minY = -t._y * s, i.maxY = i.minY + s;
    };
    const pd = new Ft;
    en = class {
        constructor(t = 1 / 0, e = 1 / 0, n = -1 / 0, s = -1 / 0){
            this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = pd, this.minX = t, this.minY = e, this.maxX = n, this.maxY = s;
        }
        isEmpty() {
            return this.minX > this.maxX || this.minY > this.maxY;
        }
        get rectangle() {
            this._rectangle || (this._rectangle = new fe);
            const t = this._rectangle;
            return this.minX > this.maxX || this.minY > this.maxY ? (t.x = 0, t.y = 0, t.width = 0, t.height = 0) : t.copyFromBounds(this), t;
        }
        clear() {
            return this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = pd, this;
        }
        set(t, e, n, s) {
            this.minX = t, this.minY = e, this.maxX = n, this.maxY = s;
        }
        addFrame(t, e, n, s, r) {
            r || (r = this.matrix);
            const a = r.a, o = r.b, c = r.c, l = r.d, h = r.tx, u = r.ty;
            let d = this.minX, f = this.minY, _ = this.maxX, g = this.maxY, p = a * t + c * e + h, m = o * t + l * e + u;
            p < d && (d = p), m < f && (f = m), p > _ && (_ = p), m > g && (g = m), p = a * n + c * e + h, m = o * n + l * e + u, p < d && (d = p), m < f && (f = m), p > _ && (_ = p), m > g && (g = m), p = a * t + c * s + h, m = o * t + l * s + u, p < d && (d = p), m < f && (f = m), p > _ && (_ = p), m > g && (g = m), p = a * n + c * s + h, m = o * n + l * s + u, p < d && (d = p), m < f && (f = m), p > _ && (_ = p), m > g && (g = m), this.minX = d, this.minY = f, this.maxX = _, this.maxY = g;
        }
        addRect(t, e) {
            this.addFrame(t.x, t.y, t.x + t.width, t.y + t.height, e);
        }
        addBounds(t, e) {
            this.addFrame(t.minX, t.minY, t.maxX, t.maxY, e);
        }
        addBoundsMask(t) {
            this.minX = this.minX > t.minX ? this.minX : t.minX, this.minY = this.minY > t.minY ? this.minY : t.minY, this.maxX = this.maxX < t.maxX ? this.maxX : t.maxX, this.maxY = this.maxY < t.maxY ? this.maxY : t.maxY;
        }
        applyMatrix(t) {
            const e = this.minX, n = this.minY, s = this.maxX, r = this.maxY, { a, b: o, c, d: l, tx: h, ty: u } = t;
            let d = a * e + c * n + h, f = o * e + l * n + u;
            this.minX = d, this.minY = f, this.maxX = d, this.maxY = f, d = a * s + c * n + h, f = o * s + l * n + u, this.minX = d < this.minX ? d : this.minX, this.minY = f < this.minY ? f : this.minY, this.maxX = d > this.maxX ? d : this.maxX, this.maxY = f > this.maxY ? f : this.maxY, d = a * e + c * r + h, f = o * e + l * r + u, this.minX = d < this.minX ? d : this.minX, this.minY = f < this.minY ? f : this.minY, this.maxX = d > this.maxX ? d : this.maxX, this.maxY = f > this.maxY ? f : this.maxY, d = a * s + c * r + h, f = o * s + l * r + u, this.minX = d < this.minX ? d : this.minX, this.minY = f < this.minY ? f : this.minY, this.maxX = d > this.maxX ? d : this.maxX, this.maxY = f > this.maxY ? f : this.maxY;
        }
        fit(t) {
            return this.minX < t.left && (this.minX = t.left), this.maxX > t.right && (this.maxX = t.right), this.minY < t.top && (this.minY = t.top), this.maxY > t.bottom && (this.maxY = t.bottom), this;
        }
        fitBounds(t, e, n, s) {
            return this.minX < t && (this.minX = t), this.maxX > e && (this.maxX = e), this.minY < n && (this.minY = n), this.maxY > s && (this.maxY = s), this;
        }
        pad(t, e = t) {
            return this.minX -= t, this.maxX += t, this.minY -= e, this.maxY += e, this;
        }
        ceil() {
            return this.minX = Math.floor(this.minX), this.minY = Math.floor(this.minY), this.maxX = Math.ceil(this.maxX), this.maxY = Math.ceil(this.maxY), this;
        }
        clone() {
            return new en(this.minX, this.minY, this.maxX, this.maxY);
        }
        scale(t, e = t) {
            return this.minX *= t, this.minY *= e, this.maxX *= t, this.maxY *= e, this;
        }
        get x() {
            return this.minX;
        }
        set x(t) {
            const e = this.maxX - this.minX;
            this.minX = t, this.maxX = t + e;
        }
        get y() {
            return this.minY;
        }
        set y(t) {
            const e = this.maxY - this.minY;
            this.minY = t, this.maxY = t + e;
        }
        get width() {
            return this.maxX - this.minX;
        }
        set width(t) {
            this.maxX = this.minX + t;
        }
        get height() {
            return this.maxY - this.minY;
        }
        set height(t) {
            this.maxY = this.minY + t;
        }
        get left() {
            return this.minX;
        }
        get right() {
            return this.maxX;
        }
        get top() {
            return this.minY;
        }
        get bottom() {
            return this.maxY;
        }
        get isPositive() {
            return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;
        }
        get isValid() {
            return this.minX + this.minY !== 1 / 0;
        }
        addVertexData(t, e, n, s) {
            let r = this.minX, a = this.minY, o = this.maxX, c = this.maxY;
            s || (s = this.matrix);
            const l = s.a, h = s.b, u = s.c, d = s.d, f = s.tx, _ = s.ty;
            for(let g = e; g < n; g += 2){
                const p = t[g], m = t[g + 1], x = l * p + u * m + f, y = h * p + d * m + _;
                r = x < r ? x : r, a = y < a ? y : a, o = x > o ? x : o, c = y > c ? y : c;
            }
            this.minX = r, this.minY = a, this.maxX = o, this.maxY = c;
        }
        containsPoint(t, e) {
            return this.minX <= t && this.minY <= e && this.maxX >= t && this.maxY >= e;
        }
        toString() {
            return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;
        }
        copyFrom(t) {
            return this.minX = t.minX, this.minY = t.minY, this.maxX = t.maxX, this.maxY = t.maxY, this;
        }
    };
    var PM = {
        grad: .9,
        turn: 360,
        rad: 360 / (2 * Math.PI)
    }, jn = function(i) {
        return typeof i == "string" ? i.length > 0 : typeof i == "number";
    }, Re = function(i, t, e) {
        return t === void 0 && (t = 0), e === void 0 && (e = Math.pow(10, t)), Math.round(e * i) / e + 0;
    }, pn = function(i, t, e) {
        return t === void 0 && (t = 0), e === void 0 && (e = 1), i > e ? e : i > t ? i : t;
    }, _p = function(i) {
        return (i = isFinite(i) ? i % 360 : 0) > 0 ? i : i + 360;
    }, md = function(i) {
        return {
            r: pn(i.r, 0, 255),
            g: pn(i.g, 0, 255),
            b: pn(i.b, 0, 255),
            a: pn(i.a)
        };
    }, zo = function(i) {
        return {
            r: Re(i.r),
            g: Re(i.g),
            b: Re(i.b),
            a: Re(i.a, 3)
        };
    }, IM = /^#([0-9a-f]{3,8})$/i, _a = function(i) {
        var t = i.toString(16);
        return t.length < 2 ? "0" + t : t;
    }, gp = function(i) {
        var t = i.r, e = i.g, n = i.b, s = i.a, r = Math.max(t, e, n), a = r - Math.min(t, e, n), o = a ? r === t ? (e - n) / a : r === e ? 2 + (n - t) / a : 4 + (t - e) / a : 0;
        return {
            h: 60 * (o < 0 ? o + 6 : o),
            s: r ? a / r * 100 : 0,
            v: r / 255 * 100,
            a: s
        };
    }, xp = function(i) {
        var t = i.h, e = i.s, n = i.v, s = i.a;
        t = t / 360 * 6, e /= 100, n /= 100;
        var r = Math.floor(t), a = n * (1 - e), o = n * (1 - (t - r) * e), c = n * (1 - (1 - t + r) * e), l = r % 6;
        return {
            r: 255 * [
                n,
                o,
                a,
                a,
                c,
                n
            ][l],
            g: 255 * [
                c,
                n,
                n,
                o,
                a,
                a
            ][l],
            b: 255 * [
                a,
                a,
                c,
                n,
                n,
                o
            ][l],
            a: s
        };
    }, _d = function(i) {
        return {
            h: _p(i.h),
            s: pn(i.s, 0, 100),
            l: pn(i.l, 0, 100),
            a: pn(i.a)
        };
    }, gd = function(i) {
        return {
            h: Re(i.h),
            s: Re(i.s),
            l: Re(i.l),
            a: Re(i.a, 3)
        };
    }, xd = function(i) {
        return xp((e = (t = i).s, {
            h: t.h,
            s: (e *= ((n = t.l) < 50 ? n : 100 - n) / 100) > 0 ? 2 * e / (n + e) * 100 : 0,
            v: n + e,
            a: t.a
        }));
        var t, e, n;
    }, gr = function(i) {
        return {
            h: (t = gp(i)).h,
            s: (s = (200 - (e = t.s)) * (n = t.v) / 100) > 0 && s < 200 ? e * n / 100 / (s <= 100 ? s : 200 - s) * 100 : 0,
            l: s / 2,
            a: t.a
        };
        var t, e, n, s;
    }, DM = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, LM = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, UM = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, NM = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, ml = {
        string: [
            [
                function(i) {
                    var t = IM.exec(i);
                    return t ? (i = t[1]).length <= 4 ? {
                        r: parseInt(i[0] + i[0], 16),
                        g: parseInt(i[1] + i[1], 16),
                        b: parseInt(i[2] + i[2], 16),
                        a: i.length === 4 ? Re(parseInt(i[3] + i[3], 16) / 255, 2) : 1
                    } : i.length === 6 || i.length === 8 ? {
                        r: parseInt(i.substr(0, 2), 16),
                        g: parseInt(i.substr(2, 2), 16),
                        b: parseInt(i.substr(4, 2), 16),
                        a: i.length === 8 ? Re(parseInt(i.substr(6, 2), 16) / 255, 2) : 1
                    } : null : null;
                },
                "hex"
            ],
            [
                function(i) {
                    var t = UM.exec(i) || NM.exec(i);
                    return t ? t[2] !== t[4] || t[4] !== t[6] ? null : md({
                        r: Number(t[1]) / (t[2] ? 100 / 255 : 1),
                        g: Number(t[3]) / (t[4] ? 100 / 255 : 1),
                        b: Number(t[5]) / (t[6] ? 100 / 255 : 1),
                        a: t[7] === void 0 ? 1 : Number(t[7]) / (t[8] ? 100 : 1)
                    }) : null;
                },
                "rgb"
            ],
            [
                function(i) {
                    var t = DM.exec(i) || LM.exec(i);
                    if (!t) return null;
                    var e, n, s = _d({
                        h: (e = t[1], n = t[2], n === void 0 && (n = "deg"), Number(e) * (PM[n] || 1)),
                        s: Number(t[3]),
                        l: Number(t[4]),
                        a: t[5] === void 0 ? 1 : Number(t[5]) / (t[6] ? 100 : 1)
                    });
                    return xd(s);
                },
                "hsl"
            ]
        ],
        object: [
            [
                function(i) {
                    var t = i.r, e = i.g, n = i.b, s = i.a, r = s === void 0 ? 1 : s;
                    return jn(t) && jn(e) && jn(n) ? md({
                        r: Number(t),
                        g: Number(e),
                        b: Number(n),
                        a: Number(r)
                    }) : null;
                },
                "rgb"
            ],
            [
                function(i) {
                    var t = i.h, e = i.s, n = i.l, s = i.a, r = s === void 0 ? 1 : s;
                    if (!jn(t) || !jn(e) || !jn(n)) return null;
                    var a = _d({
                        h: Number(t),
                        s: Number(e),
                        l: Number(n),
                        a: Number(r)
                    });
                    return xd(a);
                },
                "hsl"
            ],
            [
                function(i) {
                    var t = i.h, e = i.s, n = i.v, s = i.a, r = s === void 0 ? 1 : s;
                    if (!jn(t) || !jn(e) || !jn(n)) return null;
                    var a = function(o) {
                        return {
                            h: _p(o.h),
                            s: pn(o.s, 0, 100),
                            v: pn(o.v, 0, 100),
                            a: pn(o.a)
                        };
                    }({
                        h: Number(t),
                        s: Number(e),
                        v: Number(n),
                        a: Number(r)
                    });
                    return xp(a);
                },
                "hsv"
            ]
        ]
    }, vd = function(i, t) {
        for(var e = 0; e < t.length; e++){
            var n = t[e][0](i);
            if (n) return [
                n,
                t[e][1]
            ];
        }
        return [
            null,
            void 0
        ];
    }, BM = function(i) {
        return typeof i == "string" ? vd(i.trim(), ml.string) : typeof i == "object" && i !== null ? vd(i, ml.object) : [
            null,
            void 0
        ];
    }, Vo = function(i, t) {
        var e = gr(i);
        return {
            h: e.h,
            s: pn(e.s + 100 * t, 0, 100),
            l: e.l,
            a: e.a
        };
    }, Wo = function(i) {
        return (299 * i.r + 587 * i.g + 114 * i.b) / 1e3 / 255;
    }, yd = function(i, t) {
        var e = gr(i);
        return {
            h: e.h,
            s: e.s,
            l: pn(e.l + 100 * t, 0, 100),
            a: e.a
        };
    }, _l = function() {
        function i(t) {
            this.parsed = BM(t)[0], this.rgba = this.parsed || {
                r: 0,
                g: 0,
                b: 0,
                a: 1
            };
        }
        return i.prototype.isValid = function() {
            return this.parsed !== null;
        }, i.prototype.brightness = function() {
            return Re(Wo(this.rgba), 2);
        }, i.prototype.isDark = function() {
            return Wo(this.rgba) < .5;
        }, i.prototype.isLight = function() {
            return Wo(this.rgba) >= .5;
        }, i.prototype.toHex = function() {
            return t = zo(this.rgba), e = t.r, n = t.g, s = t.b, a = (r = t.a) < 1 ? _a(Re(255 * r)) : "", "#" + _a(e) + _a(n) + _a(s) + a;
            var t, e, n, s, r, a;
        }, i.prototype.toRgb = function() {
            return zo(this.rgba);
        }, i.prototype.toRgbString = function() {
            return t = zo(this.rgba), e = t.r, n = t.g, s = t.b, (r = t.a) < 1 ? "rgba(" + e + ", " + n + ", " + s + ", " + r + ")" : "rgb(" + e + ", " + n + ", " + s + ")";
            var t, e, n, s, r;
        }, i.prototype.toHsl = function() {
            return gd(gr(this.rgba));
        }, i.prototype.toHslString = function() {
            return t = gd(gr(this.rgba)), e = t.h, n = t.s, s = t.l, (r = t.a) < 1 ? "hsla(" + e + ", " + n + "%, " + s + "%, " + r + ")" : "hsl(" + e + ", " + n + "%, " + s + "%)";
            var t, e, n, s, r;
        }, i.prototype.toHsv = function() {
            return t = gp(this.rgba), {
                h: Re(t.h),
                s: Re(t.s),
                v: Re(t.v),
                a: Re(t.a, 3)
            };
            var t;
        }, i.prototype.invert = function() {
            return Ln({
                r: 255 - (t = this.rgba).r,
                g: 255 - t.g,
                b: 255 - t.b,
                a: t.a
            });
            var t;
        }, i.prototype.saturate = function(t) {
            return t === void 0 && (t = .1), Ln(Vo(this.rgba, t));
        }, i.prototype.desaturate = function(t) {
            return t === void 0 && (t = .1), Ln(Vo(this.rgba, -t));
        }, i.prototype.grayscale = function() {
            return Ln(Vo(this.rgba, -1));
        }, i.prototype.lighten = function(t) {
            return t === void 0 && (t = .1), Ln(yd(this.rgba, t));
        }, i.prototype.darken = function(t) {
            return t === void 0 && (t = .1), Ln(yd(this.rgba, -t));
        }, i.prototype.rotate = function(t) {
            return t === void 0 && (t = 15), this.hue(this.hue() + t);
        }, i.prototype.alpha = function(t) {
            return typeof t == "number" ? Ln({
                r: (e = this.rgba).r,
                g: e.g,
                b: e.b,
                a: t
            }) : Re(this.rgba.a, 3);
            var e;
        }, i.prototype.hue = function(t) {
            var e = gr(this.rgba);
            return typeof t == "number" ? Ln({
                h: t,
                s: e.s,
                l: e.l,
                a: e.a
            }) : Re(e.h);
        }, i.prototype.isEqual = function(t) {
            return this.toHex() === Ln(t).toHex();
        }, i;
    }(), Ln = function(i) {
        return i instanceof _l ? i : new _l(i);
    }, bd = [], FM = function(i) {
        i.forEach(function(t) {
            bd.indexOf(t) < 0 && (t(_l, ml), bd.push(t));
        });
    };
    function OM(i, t) {
        var e = {
            white: "#ffffff",
            bisque: "#ffe4c4",
            blue: "#0000ff",
            cadetblue: "#5f9ea0",
            chartreuse: "#7fff00",
            chocolate: "#d2691e",
            coral: "#ff7f50",
            antiquewhite: "#faebd7",
            aqua: "#00ffff",
            azure: "#f0ffff",
            whitesmoke: "#f5f5f5",
            papayawhip: "#ffefd5",
            plum: "#dda0dd",
            blanchedalmond: "#ffebcd",
            black: "#000000",
            gold: "#ffd700",
            goldenrod: "#daa520",
            gainsboro: "#dcdcdc",
            cornsilk: "#fff8dc",
            cornflowerblue: "#6495ed",
            burlywood: "#deb887",
            aquamarine: "#7fffd4",
            beige: "#f5f5dc",
            crimson: "#dc143c",
            cyan: "#00ffff",
            darkblue: "#00008b",
            darkcyan: "#008b8b",
            darkgoldenrod: "#b8860b",
            darkkhaki: "#bdb76b",
            darkgray: "#a9a9a9",
            darkgreen: "#006400",
            darkgrey: "#a9a9a9",
            peachpuff: "#ffdab9",
            darkmagenta: "#8b008b",
            darkred: "#8b0000",
            darkorchid: "#9932cc",
            darkorange: "#ff8c00",
            darkslateblue: "#483d8b",
            gray: "#808080",
            darkslategray: "#2f4f4f",
            darkslategrey: "#2f4f4f",
            deeppink: "#ff1493",
            deepskyblue: "#00bfff",
            wheat: "#f5deb3",
            firebrick: "#b22222",
            floralwhite: "#fffaf0",
            ghostwhite: "#f8f8ff",
            darkviolet: "#9400d3",
            magenta: "#ff00ff",
            green: "#008000",
            dodgerblue: "#1e90ff",
            grey: "#808080",
            honeydew: "#f0fff0",
            hotpink: "#ff69b4",
            blueviolet: "#8a2be2",
            forestgreen: "#228b22",
            lawngreen: "#7cfc00",
            indianred: "#cd5c5c",
            indigo: "#4b0082",
            fuchsia: "#ff00ff",
            brown: "#a52a2a",
            maroon: "#800000",
            mediumblue: "#0000cd",
            lightcoral: "#f08080",
            darkturquoise: "#00ced1",
            lightcyan: "#e0ffff",
            ivory: "#fffff0",
            lightyellow: "#ffffe0",
            lightsalmon: "#ffa07a",
            lightseagreen: "#20b2aa",
            linen: "#faf0e6",
            mediumaquamarine: "#66cdaa",
            lemonchiffon: "#fffacd",
            lime: "#00ff00",
            khaki: "#f0e68c",
            mediumseagreen: "#3cb371",
            limegreen: "#32cd32",
            mediumspringgreen: "#00fa9a",
            lightskyblue: "#87cefa",
            lightblue: "#add8e6",
            midnightblue: "#191970",
            lightpink: "#ffb6c1",
            mistyrose: "#ffe4e1",
            moccasin: "#ffe4b5",
            mintcream: "#f5fffa",
            lightslategray: "#778899",
            lightslategrey: "#778899",
            navajowhite: "#ffdead",
            navy: "#000080",
            mediumvioletred: "#c71585",
            powderblue: "#b0e0e6",
            palegoldenrod: "#eee8aa",
            oldlace: "#fdf5e6",
            paleturquoise: "#afeeee",
            mediumturquoise: "#48d1cc",
            mediumorchid: "#ba55d3",
            rebeccapurple: "#663399",
            lightsteelblue: "#b0c4de",
            mediumslateblue: "#7b68ee",
            thistle: "#d8bfd8",
            tan: "#d2b48c",
            orchid: "#da70d6",
            mediumpurple: "#9370db",
            purple: "#800080",
            pink: "#ffc0cb",
            skyblue: "#87ceeb",
            springgreen: "#00ff7f",
            palegreen: "#98fb98",
            red: "#ff0000",
            yellow: "#ffff00",
            slateblue: "#6a5acd",
            lavenderblush: "#fff0f5",
            peru: "#cd853f",
            palevioletred: "#db7093",
            violet: "#ee82ee",
            teal: "#008080",
            slategray: "#708090",
            slategrey: "#708090",
            aliceblue: "#f0f8ff",
            darkseagreen: "#8fbc8f",
            darkolivegreen: "#556b2f",
            greenyellow: "#adff2f",
            seagreen: "#2e8b57",
            seashell: "#fff5ee",
            tomato: "#ff6347",
            silver: "#c0c0c0",
            sienna: "#a0522d",
            lavender: "#e6e6fa",
            lightgreen: "#90ee90",
            orange: "#ffa500",
            orangered: "#ff4500",
            steelblue: "#4682b4",
            royalblue: "#4169e1",
            turquoise: "#40e0d0",
            yellowgreen: "#9acd32",
            salmon: "#fa8072",
            saddlebrown: "#8b4513",
            sandybrown: "#f4a460",
            rosybrown: "#bc8f8f",
            darksalmon: "#e9967a",
            lightgoldenrodyellow: "#fafad2",
            snow: "#fffafa",
            lightgrey: "#d3d3d3",
            lightgray: "#d3d3d3",
            dimgray: "#696969",
            dimgrey: "#696969",
            olivedrab: "#6b8e23",
            olive: "#808000"
        }, n = {};
        for(var s in e)n[e[s]] = s;
        var r = {};
        i.prototype.toName = function(a) {
            if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent";
            var o, c, l = n[this.toHex()];
            if (l) return l;
            if (a?.closest) {
                var h = this.toRgb(), u = 1 / 0, d = "black";
                if (!r.length) for(var f in e)r[f] = new i(e[f]).toRgb();
                for(var _ in e){
                    var g = (o = h, c = r[_], Math.pow(o.r - c.r, 2) + Math.pow(o.g - c.g, 2) + Math.pow(o.b - c.b, 2));
                    g < u && (u = g, d = _);
                }
                return d;
            }
        }, t.string.push([
            function(a) {
                var o = a.toLowerCase(), c = o === "transparent" ? "#0000" : e[o];
                return c ? new i(c).toRgb() : null;
            },
            "name"
        ]);
    }
    FM([
        OM
    ]);
    const Os = class ur {
        constructor(t = 16777215){
            this._value = null, this._components = new Float32Array(4), this._components.fill(1), this._int = 16777215, this.value = t;
        }
        get red() {
            return this._components[0];
        }
        get green() {
            return this._components[1];
        }
        get blue() {
            return this._components[2];
        }
        get alpha() {
            return this._components[3];
        }
        setValue(t) {
            return this.value = t, this;
        }
        set value(t) {
            if (t instanceof ur) this._value = this._cloneSource(t._value), this._int = t._int, this._components.set(t._components);
            else {
                if (t === null) throw new Error("Cannot set Color#value to null");
                (this._value === null || !this._isSourceEqual(this._value, t)) && (this._value = this._cloneSource(t), this._normalize(this._value));
            }
        }
        get value() {
            return this._value;
        }
        _cloneSource(t) {
            return typeof t == "string" || typeof t == "number" || t instanceof Number || t === null ? t : Array.isArray(t) || ArrayBuffer.isView(t) ? t.slice(0) : typeof t == "object" && t !== null ? {
                ...t
            } : t;
        }
        _isSourceEqual(t, e) {
            const n = typeof t;
            if (n !== typeof e) return !1;
            if (n === "number" || n === "string" || t instanceof Number) return t === e;
            if (Array.isArray(t) && Array.isArray(e) || ArrayBuffer.isView(t) && ArrayBuffer.isView(e)) return t.length !== e.length ? !1 : t.every((r, a)=>r === e[a]);
            if (t !== null && e !== null) {
                const r = Object.keys(t), a = Object.keys(e);
                return r.length !== a.length ? !1 : r.every((o)=>t[o] === e[o]);
            }
            return t === e;
        }
        toRgba() {
            const [t, e, n, s] = this._components;
            return {
                r: t,
                g: e,
                b: n,
                a: s
            };
        }
        toRgb() {
            const [t, e, n] = this._components;
            return {
                r: t,
                g: e,
                b: n
            };
        }
        toRgbaString() {
            const [t, e, n] = this.toUint8RgbArray();
            return `rgba(${t},${e},${n},${this.alpha})`;
        }
        toUint8RgbArray(t) {
            const [e, n, s] = this._components;
            return this._arrayRgb || (this._arrayRgb = []), t || (t = this._arrayRgb), t[0] = Math.round(e * 255), t[1] = Math.round(n * 255), t[2] = Math.round(s * 255), t;
        }
        toArray(t) {
            this._arrayRgba || (this._arrayRgba = []), t || (t = this._arrayRgba);
            const [e, n, s, r] = this._components;
            return t[0] = e, t[1] = n, t[2] = s, t[3] = r, t;
        }
        toRgbArray(t) {
            this._arrayRgb || (this._arrayRgb = []), t || (t = this._arrayRgb);
            const [e, n, s] = this._components;
            return t[0] = e, t[1] = n, t[2] = s, t;
        }
        toNumber() {
            return this._int;
        }
        toBgrNumber() {
            const [t, e, n] = this.toUint8RgbArray();
            return (n << 16) + (e << 8) + t;
        }
        toLittleEndianNumber() {
            const t = this._int;
            return (t >> 16) + (t & 65280) + ((t & 255) << 16);
        }
        multiply(t) {
            const [e, n, s, r] = ur._temp.setValue(t)._components;
            return this._components[0] *= e, this._components[1] *= n, this._components[2] *= s, this._components[3] *= r, this._refreshInt(), this._value = null, this;
        }
        premultiply(t, e = !0) {
            return e && (this._components[0] *= t, this._components[1] *= t, this._components[2] *= t), this._components[3] = t, this._refreshInt(), this._value = null, this;
        }
        toPremultiplied(t, e = !0) {
            if (t === 1) return (255 << 24) + this._int;
            if (t === 0) return e ? 0 : this._int;
            let n = this._int >> 16 & 255, s = this._int >> 8 & 255, r = this._int & 255;
            return e && (n = n * t + .5 | 0, s = s * t + .5 | 0, r = r * t + .5 | 0), (t * 255 << 24) + (n << 16) + (s << 8) + r;
        }
        toHex() {
            const t = this._int.toString(16);
            return `#${"000000".substring(0, 6 - t.length) + t}`;
        }
        toHexa() {
            const e = Math.round(this._components[3] * 255).toString(16);
            return this.toHex() + "00".substring(0, 2 - e.length) + e;
        }
        setAlpha(t) {
            return this._components[3] = this._clamp(t), this;
        }
        _normalize(t) {
            let e, n, s, r;
            if ((typeof t == "number" || t instanceof Number) && t >= 0 && t <= 16777215) {
                const a = t;
                e = (a >> 16 & 255) / 255, n = (a >> 8 & 255) / 255, s = (a & 255) / 255, r = 1;
            } else if ((Array.isArray(t) || t instanceof Float32Array) && t.length >= 3 && t.length <= 4) t = this._clamp(t), [e, n, s, r = 1] = t;
            else if ((t instanceof Uint8Array || t instanceof Uint8ClampedArray) && t.length >= 3 && t.length <= 4) t = this._clamp(t, 0, 255), [e, n, s, r = 255] = t, e /= 255, n /= 255, s /= 255, r /= 255;
            else if (typeof t == "string" || typeof t == "object") {
                if (typeof t == "string") {
                    const o = ur.HEX_PATTERN.exec(t);
                    o && (t = `#${o[2]}`);
                }
                const a = Ln(t);
                a.isValid() && ({ r: e, g: n, b: s, a: r } = a.rgba, e /= 255, n /= 255, s /= 255);
            }
            if (e !== void 0) this._components[0] = e, this._components[1] = n, this._components[2] = s, this._components[3] = r, this._refreshInt();
            else throw new Error(`Unable to convert color ${t}`);
        }
        _refreshInt() {
            this._clamp(this._components);
            const [t, e, n] = this._components;
            this._int = (t * 255 << 16) + (e * 255 << 8) + (n * 255 | 0);
        }
        _clamp(t, e = 0, n = 1) {
            return typeof t == "number" ? Math.min(Math.max(t, e), n) : (t.forEach((s, r)=>{
                t[r] = Math.min(Math.max(s, e), n);
            }), t);
        }
        static isColorLike(t) {
            return typeof t == "number" || typeof t == "string" || t instanceof Number || t instanceof ur || Array.isArray(t) || t instanceof Uint8Array || t instanceof Uint8ClampedArray || t instanceof Float32Array || t.r !== void 0 && t.g !== void 0 && t.b !== void 0 || t.r !== void 0 && t.g !== void 0 && t.b !== void 0 && t.a !== void 0 || t.h !== void 0 && t.s !== void 0 && t.l !== void 0 || t.h !== void 0 && t.s !== void 0 && t.l !== void 0 && t.a !== void 0 || t.h !== void 0 && t.s !== void 0 && t.v !== void 0 || t.h !== void 0 && t.s !== void 0 && t.v !== void 0 && t.a !== void 0;
        }
    };
    Os.shared = new Os;
    Os._temp = new Os;
    Os.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
    Pe = Os;
    const kM = {
        cullArea: null,
        cullable: !1,
        cullableChildren: !0
    };
    class rh {
        constructor(t, e){
            this._pool = [], this._count = 0, this._index = 0, this._classType = t, e && this.prepopulate(e);
        }
        prepopulate(t) {
            for(let e = 0; e < t; e++)this._pool[this._index++] = new this._classType;
            this._count += t;
        }
        get(t) {
            let e;
            return this._index > 0 ? e = this._pool[--this._index] : e = new this._classType, e.init?.(t), e;
        }
        return(t) {
            t.reset?.(), this._pool[this._index++] = t;
        }
        get totalSize() {
            return this._count;
        }
        get totalFree() {
            return this._index;
        }
        get totalUsed() {
            return this._count - this._index;
        }
        clear() {
            this._pool.length = 0, this._index = 0;
        }
    }
    class GM {
        constructor(){
            this._poolsByClass = new Map;
        }
        prepopulate(t, e) {
            this.getPool(t).prepopulate(e);
        }
        get(t, e) {
            return this.getPool(t).get(e);
        }
        return(t) {
            this.getPool(t.constructor).return(t);
        }
        getPool(t) {
            return this._poolsByClass.has(t) || this._poolsByClass.set(t, new rh(t)), this._poolsByClass.get(t);
        }
        stats() {
            const t = {};
            return this._poolsByClass.forEach((e)=>{
                const n = t[e._classType.name] ? e._classType.name + e._classType.ID : e._classType.name;
                t[n] = {
                    free: e.totalFree,
                    used: e.totalUsed,
                    size: e.totalSize
                };
            }), t;
        }
    }
    let HM;
    Ge = new GM;
    HM = {
        get isCachedAsTexture () {
            return !!this.renderGroup?.isCachedAsTexture;
        },
        cacheAsTexture (i) {
            typeof i == "boolean" && i === !1 ? this.disableRenderGroup() : (this.enableRenderGroup(), this.renderGroup.enableCacheAsTexture(i === !0 ? {} : i));
        },
        updateCacheTexture () {
            this.renderGroup?.updateCacheTexture();
        },
        get cacheAsBitmap () {
            return this.isCachedAsTexture;
        },
        set cacheAsBitmap (i){
            ue("v8.6.0", "cacheAsBitmap is deprecated, use cacheAsTexture instead."), this.cacheAsTexture(i);
        }
    };
    zM = function(i, t, e) {
        const n = i.length;
        let s;
        if (t >= n || e === 0) return;
        e = t + e > n ? n - t : e;
        const r = n - e;
        for(s = t; s < r; ++s)i[s] = i[s + e];
        i.length = r;
    };
    const VM = {
        allowChildren: !0,
        removeChildren (i = 0, t) {
            const e = t ?? this.children.length, n = e - i, s = [];
            if (n > 0 && n <= e) {
                for(let a = e - 1; a >= i; a--){
                    const o = this.children[a];
                    o && (s.push(o), o.parent = null);
                }
                zM(this.children, i, e);
                const r = this.renderGroup || this.parentRenderGroup;
                r && r.removeChildren(s);
                for(let a = 0; a < s.length; ++a)this.emit("childRemoved", s[a], this, a), s[a].emit("removed", this);
                return s.length > 0 && this._didViewChangeTick++, s;
            } else if (n === 0 && this.children.length === 0) return s;
            throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
        },
        removeChildAt (i) {
            const t = this.getChildAt(i);
            return this.removeChild(t);
        },
        getChildAt (i) {
            if (i < 0 || i >= this.children.length) throw new Error(`getChildAt: Index (${i}) does not exist.`);
            return this.children[i];
        },
        setChildIndex (i, t) {
            if (t < 0 || t >= this.children.length) throw new Error(`The index ${t} supplied is out of bounds ${this.children.length}`);
            this.getChildIndex(i), this.addChildAt(i, t);
        },
        getChildIndex (i) {
            const t = this.children.indexOf(i);
            if (t === -1) throw new Error("The supplied Container must be a child of the caller");
            return t;
        },
        addChildAt (i, t) {
            this.allowChildren || ue(be, "addChildAt: Only Containers will be allowed to add children in v8.0.0");
            const { children: e } = this;
            if (t < 0 || t > e.length) throw new Error(`${i}addChildAt: The index ${t} supplied is out of bounds ${e.length}`);
            if (i.parent) {
                const s = i.parent.children.indexOf(i);
                if (i.parent === this && s === t) return i;
                s !== -1 && i.parent.children.splice(s, 1);
            }
            t === e.length ? e.push(i) : e.splice(t, 0, i), i.parent = this, i.didChange = !0, i._updateFlags = 15;
            const n = this.renderGroup || this.parentRenderGroup;
            return n && n.addChild(i), this.sortableChildren && (this.sortDirty = !0), this.emit("childAdded", i, this, t), i.emit("added", this), i;
        },
        swapChildren (i, t) {
            if (i === t) return;
            const e = this.getChildIndex(i), n = this.getChildIndex(t);
            this.children[e] = t, this.children[n] = i;
            const s = this.renderGroup || this.parentRenderGroup;
            s && (s.structureDidChange = !0), this._didContainerChangeTick++;
        },
        removeFromParent () {
            this.parent?.removeChild(this);
        },
        reparentChild (...i) {
            return i.length === 1 ? this.reparentChildAt(i[0], this.children.length) : (i.forEach((t)=>this.reparentChildAt(t, this.children.length)), i[0]);
        },
        reparentChildAt (i, t) {
            if (i.parent === this) return this.setChildIndex(i, t), i;
            const e = i.worldTransform.clone();
            i.removeFromParent(), this.addChildAt(i, t);
            const n = this.worldTransform.clone();
            return n.invert(), e.prepend(n), i.setFromMatrix(e), i;
        }
    }, WM = {
        collectRenderables (i, t, e) {
            this.parentRenderLayer && this.parentRenderLayer !== e || this.globalDisplayStatus < 7 || !this.includeInBuild || (this.sortableChildren && this.sortChildren(), this.isSimple ? this.collectRenderablesSimple(i, t, e) : this.renderGroup ? t.renderPipes.renderGroup.addRenderGroup(this.renderGroup, i) : this.collectRenderablesWithEffects(i, t, e));
        },
        collectRenderablesSimple (i, t, e) {
            const n = this.children, s = n.length;
            for(let r = 0; r < s; r++)n[r].collectRenderables(i, t, e);
        },
        collectRenderablesWithEffects (i, t, e) {
            const { renderPipes: n } = t;
            for(let s = 0; s < this.effects.length; s++){
                const r = this.effects[s];
                n[r.pipe].push(r, this, i);
            }
            this.collectRenderablesSimple(i, t, e);
            for(let s = this.effects.length - 1; s >= 0; s--){
                const r = this.effects[s];
                n[r.pipe].pop(r, this, i);
            }
        }
    };
    class za {
        constructor(){
            this.pipe = "filter", this.priority = 1;
        }
        destroy() {
            for(let t = 0; t < this.filters.length; t++)this.filters[t].destroy();
            this.filters = null, this.filterArea = null;
        }
    }
    class XM {
        constructor(){
            this._effectClasses = [], this._tests = [], this._initialized = !1;
        }
        init() {
            this._initialized || (this._initialized = !0, this._effectClasses.forEach((t)=>{
                this.add({
                    test: t.test,
                    maskClass: t
                });
            }));
        }
        add(t) {
            this._tests.push(t);
        }
        getMaskEffect(t) {
            this._initialized || this.init();
            for(let e = 0; e < this._tests.length; e++){
                const n = this._tests[e];
                if (n.test(t)) return Ge.get(n.maskClass, t);
            }
            return t;
        }
        returnMaskEffect(t) {
            Ge.return(t);
        }
    }
    const gl = new XM;
    Be.handleByList(st.MaskEffect, gl._effectClasses);
    const YM = {
        _maskEffect: null,
        _maskOptions: {
            inverse: !1
        },
        _filterEffect: null,
        effects: [],
        _markStructureAsChanged () {
            const i = this.renderGroup || this.parentRenderGroup;
            i && (i.structureDidChange = !0);
        },
        addEffect (i) {
            this.effects.indexOf(i) === -1 && (this.effects.push(i), this.effects.sort((e, n)=>e.priority - n.priority), this._markStructureAsChanged(), this._updateIsSimple());
        },
        removeEffect (i) {
            const t = this.effects.indexOf(i);
            t !== -1 && (this.effects.splice(t, 1), this._markStructureAsChanged(), this._updateIsSimple());
        },
        set mask (i){
            const t = this._maskEffect;
            t?.mask !== i && (t && (this.removeEffect(t), gl.returnMaskEffect(t), this._maskEffect = null), i != null && (this._maskEffect = gl.getMaskEffect(i), this.addEffect(this._maskEffect)));
        },
        setMask (i) {
            this._maskOptions = {
                ...this._maskOptions,
                ...i
            }, i.mask && (this.mask = i.mask), this._markStructureAsChanged();
        },
        get mask () {
            return this._maskEffect?.mask;
        },
        set filters (i){
            !Array.isArray(i) && i && (i = [
                i
            ]);
            const t = this._filterEffect || (this._filterEffect = new za);
            i = i;
            const e = i?.length > 0, n = t.filters?.length > 0, s = e !== n;
            i = Array.isArray(i) ? i.slice(0) : i, t.filters = Object.freeze(i), s && (e ? this.addEffect(t) : (this.removeEffect(t), t.filters = i ?? null));
        },
        get filters () {
            return this._filterEffect?.filters;
        },
        set filterArea (i){
            this._filterEffect || (this._filterEffect = new za), this._filterEffect.filterArea = i;
        },
        get filterArea () {
            return this._filterEffect?.filterArea;
        }
    }, qM = {
        label: null,
        get name () {
            return ue(be, "Container.name property has been removed, use Container.label instead"), this.label;
        },
        set name (i){
            ue(be, "Container.name property has been removed, use Container.label instead"), this.label = i;
        },
        getChildByName (i, t = !1) {
            return this.getChildByLabel(i, t);
        },
        getChildByLabel (i, t = !1) {
            const e = this.children;
            for(let n = 0; n < e.length; n++){
                const s = e[n];
                if (s.label === i || i instanceof RegExp && i.test(s.label)) return s;
            }
            if (t) for(let n = 0; n < e.length; n++){
                const r = e[n].getChildByLabel(i, !0);
                if (r) return r;
            }
            return null;
        },
        getChildrenByLabel (i, t = !1, e = []) {
            const n = this.children;
            for(let s = 0; s < n.length; s++){
                const r = n[s];
                (r.label === i || i instanceof RegExp && i.test(r.label)) && e.push(r);
            }
            if (t) for(let s = 0; s < n.length; s++)n[s].getChildrenByLabel(i, !0, e);
            return e;
        }
    }, Ye = new rh(Ft), ei = new rh(en), jM = new Ft, $M = {
        getFastGlobalBounds (i, t) {
            t || (t = new en), t.clear(), this._getGlobalBoundsRecursive(!!i, t, this.parentRenderLayer), t.isValid || t.set(0, 0, 0, 0);
            const e = this.renderGroup || this.parentRenderGroup;
            return t.applyMatrix(e.worldTransform), t;
        },
        _getGlobalBoundsRecursive (i, t, e) {
            let n = t;
            if (i && this.parentRenderLayer && this.parentRenderLayer !== e || this.localDisplayStatus !== 7 || !this.measurable) return;
            const s = !!this.effects.length;
            if ((this.renderGroup || s) && (n = ei.get().clear()), this.boundsArea) t.addRect(this.boundsArea, this.worldTransform);
            else {
                if (this.renderPipeId) {
                    const a = this.bounds;
                    n.addFrame(a.minX, a.minY, a.maxX, a.maxY, this.groupTransform);
                }
                const r = this.children;
                for(let a = 0; a < r.length; a++)r[a]._getGlobalBoundsRecursive(i, n, e);
            }
            if (s) {
                let r = !1;
                const a = this.renderGroup || this.parentRenderGroup;
                for(let o = 0; o < this.effects.length; o++)this.effects[o].addBounds && (r || (r = !0, n.applyMatrix(a.worldTransform)), this.effects[o].addBounds(n, !0));
                r && (n.applyMatrix(a.worldTransform.copyTo(jM).invert()), t.addBounds(n, this.relativeGroupTransform)), t.addBounds(n), ei.return(n);
            } else this.renderGroup && (t.addBounds(n, this.relativeGroupTransform), ei.return(n));
        }
    };
    function ah(i, t, e) {
        e.clear();
        let n, s;
        return i.parent ? t ? n = i.parent.worldTransform : (s = Ye.get().identity(), n = oh(i, s)) : n = Ft.IDENTITY, vp(i, e, n, t), s && Ye.return(s), e.isValid || e.set(0, 0, 0, 0), e;
    }
    function vp(i, t, e, n) {
        if (!i.visible || !i.measurable) return;
        let s;
        n ? s = i.worldTransform : (i.updateLocalTransform(), s = Ye.get(), s.appendFrom(i.localTransform, e));
        const r = t, a = !!i.effects.length;
        if (a && (t = ei.get().clear()), i.boundsArea) t.addRect(i.boundsArea, s);
        else {
            i.bounds && (t.matrix = s, t.addBounds(i.bounds));
            for(let o = 0; o < i.children.length; o++)vp(i.children[o], t, s, n);
        }
        if (a) {
            for(let o = 0; o < i.effects.length; o++)i.effects[o].addBounds?.(t);
            r.addBounds(t, Ft.IDENTITY), ei.return(t);
        }
        n || Ye.return(s);
    }
    function oh(i, t) {
        const e = i.parent;
        return e && (oh(e, t), e.updateLocalTransform(), t.append(e.localTransform)), t;
    }
    function yp(i, t) {
        if (i === 16777215 || !t) return t;
        if (t === 16777215 || !i) return i;
        const e = i >> 16 & 255, n = i >> 8 & 255, s = i & 255, r = t >> 16 & 255, a = t >> 8 & 255, o = t & 255, c = e * r / 255 | 0, l = n * a / 255 | 0, h = s * o / 255 | 0;
        return (c << 16) + (l << 8) + h;
    }
    const Sd = 16777215;
    function Va(i, t) {
        return i === Sd ? t : t === Sd ? i : yp(i, t);
    }
    function La(i) {
        return ((i & 255) << 16) + (i & 65280) + (i >> 16 & 255);
    }
    const KM = {
        getGlobalAlpha (i) {
            if (i) return this.renderGroup ? this.renderGroup.worldAlpha : this.parentRenderGroup ? this.parentRenderGroup.worldAlpha * this.alpha : this.alpha;
            let t = this.alpha, e = this.parent;
            for(; e;)t *= e.alpha, e = e.parent;
            return t;
        },
        getGlobalTransform (i, t) {
            if (t) return i.copyFrom(this.worldTransform);
            this.updateLocalTransform();
            const e = oh(this, Ye.get().identity());
            return i.appendFrom(this.localTransform, e), Ye.return(e), i;
        },
        getGlobalTint (i) {
            if (i) return this.renderGroup ? La(this.renderGroup.worldColor) : this.parentRenderGroup ? La(Va(this.localColor, this.parentRenderGroup.worldColor)) : this.tint;
            let t = this.localColor, e = this.parent;
            for(; e;)t = Va(t, e.localColor), e = e.parent;
            return La(t);
        }
    };
    let Xo = 0;
    const Md = 500;
    _e = function(...i) {
        Xo !== Md && (Xo++, Xo === Md ? console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.") : console.warn("PixiJS Warning: ", ...i));
    };
    function ch(i, t, e) {
        return t.clear(), e || (e = Ft.IDENTITY), bp(i, t, e, i, !0), t.isValid || t.set(0, 0, 0, 0), t;
    }
    function bp(i, t, e, n, s) {
        let r;
        if (s) r = Ye.get(), r = e.copyTo(r);
        else {
            if (!i.visible || !i.measurable) return;
            i.updateLocalTransform();
            const c = i.localTransform;
            r = Ye.get(), r.appendFrom(c, e);
        }
        const a = t, o = !!i.effects.length;
        if (o && (t = ei.get().clear()), i.boundsArea) t.addRect(i.boundsArea, r);
        else {
            i.renderPipeId && (t.matrix = r, t.addBounds(i.bounds));
            const c = i.children;
            for(let l = 0; l < c.length; l++)bp(c[l], t, r, n, !1);
        }
        if (o) {
            for(let c = 0; c < i.effects.length; c++)i.effects[c].addLocalBounds?.(t, n);
            a.addBounds(t, Ft.IDENTITY), ei.return(t);
        }
        Ye.return(r);
    }
    function Sp(i, t) {
        const e = i.children;
        for(let n = 0; n < e.length; n++){
            const s = e[n], r = s.uid, a = (s._didViewChangeTick & 65535) << 16 | s._didContainerChangeTick & 65535, o = t.index;
            (t.data[o] !== r || t.data[o + 1] !== a) && (t.data[t.index] = r, t.data[t.index + 1] = a, t.didChange = !0), t.index = o + 2, s.children.length && Sp(s, t);
        }
        return t.didChange;
    }
    const ZM = new Ft, JM = {
        _localBoundsCacheId: -1,
        _localBoundsCacheData: null,
        _setWidth (i, t) {
            const e = Math.sign(this.scale.x) || 1;
            t !== 0 ? this.scale.x = i / t * e : this.scale.x = e;
        },
        _setHeight (i, t) {
            const e = Math.sign(this.scale.y) || 1;
            t !== 0 ? this.scale.y = i / t * e : this.scale.y = e;
        },
        getLocalBounds () {
            this._localBoundsCacheData || (this._localBoundsCacheData = {
                data: [],
                index: 1,
                didChange: !1,
                localBounds: new en
            });
            const i = this._localBoundsCacheData;
            return i.index = 1, i.didChange = !1, i.data[0] !== this._didViewChangeTick && (i.didChange = !0, i.data[0] = this._didViewChangeTick), Sp(this, i), i.didChange && ch(this, i.localBounds, ZM), i.localBounds;
        },
        getBounds (i, t) {
            return ah(this, i, t || new en);
        }
    }, QM = {
        _onRender: null,
        set onRender (i){
            const t = this.renderGroup || this.parentRenderGroup;
            if (!i) {
                this._onRender && t?.removeOnRender(this), this._onRender = null;
                return;
            }
            this._onRender || t?.addOnRender(this), this._onRender = i;
        },
        get onRender () {
            return this._onRender;
        }
    }, tT = {
        _zIndex: 0,
        sortDirty: !1,
        sortableChildren: !1,
        get zIndex () {
            return this._zIndex;
        },
        set zIndex (i){
            this._zIndex !== i && (this._zIndex = i, this.depthOfChildModified());
        },
        depthOfChildModified () {
            this.parent && (this.parent.sortableChildren = !0, this.parent.sortDirty = !0), this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0);
        },
        sortChildren () {
            this.sortDirty && (this.sortDirty = !1, this.children.sort(eT));
        }
    };
    function eT(i, t) {
        return i._zIndex - t._zIndex;
    }
    const nT = {
        getGlobalPosition (i = new Ue, t = !1) {
            return this.parent ? this.parent.toGlobal(this._position, i, t) : (i.x = this._position.x, i.y = this._position.y), i;
        },
        toGlobal (i, t, e = !1) {
            const n = this.getGlobalTransform(Ye.get(), e);
            return t = n.apply(i, t), Ye.return(n), t;
        },
        toLocal (i, t, e, n) {
            t && (i = t.toGlobal(i, e, n));
            const s = this.getGlobalTransform(Ye.get(), n);
            return e = s.applyInverse(i, e), Ye.return(s), e;
        }
    };
    class Mp {
        constructor(){
            this.uid = pe("instructionSet"), this.instructions = [], this.instructionSize = 0, this.renderables = [], this.gcTick = 0;
        }
        reset() {
            this.instructionSize = 0;
        }
        add(t) {
            this.instructions[this.instructionSize++] = t;
        }
        log() {
            this.instructions.length = this.instructionSize, console.table(this.instructions, [
                "type",
                "action"
            ]);
        }
    }
    let iT = 0;
    class sT {
        constructor(t){
            this._poolKeyHash = Object.create(null), this._texturePool = {}, this.textureOptions = t || {}, this.enableFullScreen = !1;
        }
        createTexture(t, e, n) {
            const s = new Ne({
                ...this.textureOptions,
                width: t,
                height: e,
                resolution: 1,
                antialias: n,
                autoGarbageCollect: !1
            });
            return new Ot({
                source: s,
                label: `texturePool_${iT++}`
            });
        }
        getOptimalTexture(t, e, n = 1, s) {
            let r = Math.ceil(t * n - 1e-6), a = Math.ceil(e * n - 1e-6);
            r = hd(r), a = hd(a);
            const o = (r << 17) + (a << 1) + (s ? 1 : 0);
            this._texturePool[o] || (this._texturePool[o] = []);
            let c = this._texturePool[o].pop();
            return c || (c = this.createTexture(r, a, s)), c.source._resolution = n, c.source.width = r / n, c.source.height = a / n, c.source.pixelWidth = r, c.source.pixelHeight = a, c.frame.x = 0, c.frame.y = 0, c.frame.width = t, c.frame.height = e, c.updateUvs(), this._poolKeyHash[c.uid] = o, c;
        }
        getSameSizeTexture(t, e = !1) {
            const n = t.source;
            return this.getOptimalTexture(t.width, t.height, n._resolution, e);
        }
        returnTexture(t) {
            const e = this._poolKeyHash[t.uid];
            this._texturePool[e].push(t);
        }
        clear(t) {
            if (t = t !== !1, t) for(const e in this._texturePool){
                const n = this._texturePool[e];
                if (n) for(let s = 0; s < n.length; s++)n[s].destroy(!0);
            }
            this._texturePool = {};
        }
    }
    ws = new sT;
    class rT {
        constructor(){
            this.renderPipeId = "renderGroup", this.root = null, this.canBundle = !1, this.renderGroupParent = null, this.renderGroupChildren = [], this.worldTransform = new Ft, this.worldColorAlpha = 4294967295, this.worldColor = 16777215, this.worldAlpha = 1, this.childrenToUpdate = Object.create(null), this.updateTick = 0, this.gcTick = 0, this.childrenRenderablesToUpdate = {
                list: [],
                index: 0
            }, this.structureDidChange = !0, this.instructionSet = new Mp, this._onRenderContainers = [], this.textureNeedsUpdate = !0, this.isCachedAsTexture = !1, this._matrixDirty = 7;
        }
        init(t) {
            this.root = t, t._onRender && this.addOnRender(t), t.didChange = !0;
            const e = t.children;
            for(let n = 0; n < e.length; n++){
                const s = e[n];
                s._updateFlags = 15, this.addChild(s);
            }
        }
        enableCacheAsTexture(t = {}) {
            this.textureOptions = t, this.isCachedAsTexture = !0, this.textureNeedsUpdate = !0;
        }
        disableCacheAsTexture() {
            this.isCachedAsTexture = !1, this.texture && (ws.returnTexture(this.texture), this.texture = null);
        }
        updateCacheTexture() {
            this.textureNeedsUpdate = !0;
        }
        reset() {
            this.renderGroupChildren.length = 0;
            for(const t in this.childrenToUpdate){
                const e = this.childrenToUpdate[t];
                e.list.fill(null), e.index = 0;
            }
            this.childrenRenderablesToUpdate.index = 0, this.childrenRenderablesToUpdate.list.fill(null), this.root = null, this.updateTick = 0, this.structureDidChange = !0, this._onRenderContainers.length = 0, this.renderGroupParent = null, this.disableCacheAsTexture();
        }
        get localTransform() {
            return this.root.localTransform;
        }
        addRenderGroupChild(t) {
            t.renderGroupParent && t.renderGroupParent._removeRenderGroupChild(t), t.renderGroupParent = this, this.renderGroupChildren.push(t);
        }
        _removeRenderGroupChild(t) {
            const e = this.renderGroupChildren.indexOf(t);
            e > -1 && this.renderGroupChildren.splice(e, 1), t.renderGroupParent = null;
        }
        addChild(t) {
            if (this.structureDidChange = !0, t.parentRenderGroup = this, t.updateTick = -1, t.parent === this.root ? t.relativeRenderGroupDepth = 1 : t.relativeRenderGroupDepth = t.parent.relativeRenderGroupDepth + 1, t.didChange = !0, this.onChildUpdate(t), t.renderGroup) {
                this.addRenderGroupChild(t.renderGroup);
                return;
            }
            t._onRender && this.addOnRender(t);
            const e = t.children;
            for(let n = 0; n < e.length; n++)this.addChild(e[n]);
        }
        removeChild(t) {
            if (this.structureDidChange = !0, t._onRender && (t.renderGroup || this.removeOnRender(t)), t.parentRenderGroup = null, t.renderGroup) {
                this._removeRenderGroupChild(t.renderGroup);
                return;
            }
            const e = t.children;
            for(let n = 0; n < e.length; n++)this.removeChild(e[n]);
        }
        removeChildren(t) {
            for(let e = 0; e < t.length; e++)this.removeChild(t[e]);
        }
        onChildUpdate(t) {
            let e = this.childrenToUpdate[t.relativeRenderGroupDepth];
            e || (e = this.childrenToUpdate[t.relativeRenderGroupDepth] = {
                index: 0,
                list: []
            }), e.list[e.index++] = t;
        }
        updateRenderable(t) {
            t.globalDisplayStatus < 7 || (this.instructionSet.renderPipes[t.renderPipeId].updateRenderable(t), t.didViewUpdate = !1);
        }
        onChildViewUpdate(t) {
            this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = t;
        }
        get isRenderable() {
            return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;
        }
        addOnRender(t) {
            this._onRenderContainers.push(t);
        }
        removeOnRender(t) {
            this._onRenderContainers.splice(this._onRenderContainers.indexOf(t), 1);
        }
        runOnRender(t) {
            for(let e = 0; e < this._onRenderContainers.length; e++)this._onRenderContainers[e]._onRender(t);
        }
        destroy() {
            this.disableCacheAsTexture(), this.renderGroupParent = null, this.root = null, this.childrenRenderablesToUpdate = null, this.childrenToUpdate = null, this.renderGroupChildren = null, this._onRenderContainers = null, this.instructionSet = null;
        }
        getChildren(t = []) {
            const e = this.root.children;
            for(let n = 0; n < e.length; n++)this._getChildren(e[n], t);
            return t;
        }
        _getChildren(t, e = []) {
            if (e.push(t), t.renderGroup) return e;
            const n = t.children;
            for(let s = 0; s < n.length; s++)this._getChildren(n[s], e);
            return e;
        }
        invalidateMatrices() {
            this._matrixDirty = 7;
        }
        get inverseWorldTransform() {
            return (this._matrixDirty & 1) === 0 ? this._inverseWorldTransform : (this._matrixDirty &= -2, this._inverseWorldTransform || (this._inverseWorldTransform = new Ft), this._inverseWorldTransform.copyFrom(this.worldTransform).invert());
        }
        get textureOffsetInverseTransform() {
            return (this._matrixDirty & 2) === 0 ? this._textureOffsetInverseTransform : (this._matrixDirty &= -3, this._textureOffsetInverseTransform || (this._textureOffsetInverseTransform = new Ft), this._textureOffsetInverseTransform.copyFrom(this.inverseWorldTransform).translate(-this._textureBounds.x, -this._textureBounds.y));
        }
        get inverseParentTextureTransform() {
            if ((this._matrixDirty & 4) === 0) return this._inverseParentTextureTransform;
            this._matrixDirty &= -5;
            const t = this._parentCacheAsTextureRenderGroup;
            return t ? (this._inverseParentTextureTransform || (this._inverseParentTextureTransform = new Ft), this._inverseParentTextureTransform.copyFrom(this.worldTransform).prepend(t.inverseWorldTransform).translate(-t._textureBounds.x, -t._textureBounds.y)) : this.worldTransform;
        }
        get cacheToLocalTransform() {
            return this._parentCacheAsTextureRenderGroup ? this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform : null;
        }
    }
    function aT(i, t, e = {}) {
        for(const n in t)!e[n] && t[n] !== void 0 && (i[n] = t[n]);
    }
    const Yo = new Je(null), qo = new Je(null), jo = new Je(null, 1, 1), Wa = 1, lh = 2, xr = 4;
    mn = class extends In {
        constructor(t = {}){
            super(), this.uid = pe("renderable"), this._updateFlags = 15, this.renderGroup = null, this.parentRenderGroup = null, this.parentRenderGroupIndex = 0, this.didChange = !1, this.didViewUpdate = !1, this.relativeRenderGroupDepth = 0, this.children = [], this.parent = null, this.includeInBuild = !0, this.measurable = !0, this.isSimple = !0, this.updateTick = -1, this.localTransform = new Ft, this.relativeGroupTransform = new Ft, this.groupTransform = this.relativeGroupTransform, this.destroyed = !1, this._position = new Je(this, 0, 0), this._scale = jo, this._pivot = qo, this._skew = Yo, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._rotation = 0, this.localColor = 16777215, this.localAlpha = 1, this.groupAlpha = 1, this.groupColor = 16777215, this.groupColorAlpha = 4294967295, this.localBlendMode = "inherit", this.groupBlendMode = "normal", this.localDisplayStatus = 7, this.globalDisplayStatus = 7, this._didContainerChangeTick = 0, this._didViewChangeTick = 0, this._didLocalTransformChangeId = -1, this.effects = [], aT(this, t, {
                children: !0,
                parent: !0,
                effects: !0
            }), t.children?.forEach((e)=>this.addChild(e)), t.parent?.addChild(this);
        }
        static mixin(t) {
            ue("8.8.0", "Container.mixin is deprecated, please use extensions.mixin instead."), Be.mixin(mn, t);
        }
        set _didChangeId(t) {
            this._didViewChangeTick = t >> 12 & 4095, this._didContainerChangeTick = t & 4095;
        }
        get _didChangeId() {
            return this._didContainerChangeTick & 4095 | (this._didViewChangeTick & 4095) << 12;
        }
        addChild(...t) {
            if (this.allowChildren || ue(be, "addChild: Only Containers will be allowed to add children in v8.0.0"), t.length > 1) {
                for(let s = 0; s < t.length; s++)this.addChild(t[s]);
                return t[0];
            }
            const e = t[0], n = this.renderGroup || this.parentRenderGroup;
            return e.parent === this ? (this.children.splice(this.children.indexOf(e), 1), this.children.push(e), n && (n.structureDidChange = !0), e) : (e.parent && e.parent.removeChild(e), this.children.push(e), this.sortableChildren && (this.sortDirty = !0), e.parent = this, e.didChange = !0, e._updateFlags = 15, n && n.addChild(e), this.emit("childAdded", e, this, this.children.length - 1), e.emit("added", this), this._didViewChangeTick++, e._zIndex !== 0 && e.depthOfChildModified(), e);
        }
        removeChild(...t) {
            if (t.length > 1) {
                for(let s = 0; s < t.length; s++)this.removeChild(t[s]);
                return t[0];
            }
            const e = t[0], n = this.children.indexOf(e);
            return n > -1 && (this._didViewChangeTick++, this.children.splice(n, 1), this.renderGroup ? this.renderGroup.removeChild(e) : this.parentRenderGroup && this.parentRenderGroup.removeChild(e), e.parentRenderLayer && e.parentRenderLayer.detach(e), e.parent = null, this.emit("childRemoved", e, this, n), e.emit("removed", this)), e;
        }
        _onUpdate(t) {
            t && t === this._skew && this._updateSkew(), this._didContainerChangeTick++, !this.didChange && (this.didChange = !0, this.parentRenderGroup && this.parentRenderGroup.onChildUpdate(this));
        }
        set isRenderGroup(t) {
            !!this.renderGroup !== t && (t ? this.enableRenderGroup() : this.disableRenderGroup());
        }
        get isRenderGroup() {
            return !!this.renderGroup;
        }
        enableRenderGroup() {
            if (this.renderGroup) return;
            const t = this.parentRenderGroup;
            t?.removeChild(this), this.renderGroup = Ge.get(rT, this), this.groupTransform = Ft.IDENTITY, t?.addChild(this), this._updateIsSimple();
        }
        disableRenderGroup() {
            if (!this.renderGroup) return;
            const t = this.parentRenderGroup;
            t?.removeChild(this), Ge.return(this.renderGroup), this.renderGroup = null, this.groupTransform = this.relativeGroupTransform, t?.addChild(this), this._updateIsSimple();
        }
        _updateIsSimple() {
            this.isSimple = !this.renderGroup && this.effects.length === 0;
        }
        get worldTransform() {
            return this._worldTransform || (this._worldTransform = new Ft), this.renderGroup ? this._worldTransform.copyFrom(this.renderGroup.worldTransform) : this.parentRenderGroup && this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform), this._worldTransform;
        }
        get x() {
            return this._position.x;
        }
        set x(t) {
            this._position.x = t;
        }
        get y() {
            return this._position.y;
        }
        set y(t) {
            this._position.y = t;
        }
        get position() {
            return this._position;
        }
        set position(t) {
            this._position.copyFrom(t);
        }
        get rotation() {
            return this._rotation;
        }
        set rotation(t) {
            this._rotation !== t && (this._rotation = t, this._onUpdate(this._skew));
        }
        get angle() {
            return this.rotation * bM;
        }
        set angle(t) {
            this.rotation = t * SM;
        }
        get pivot() {
            return this._pivot === qo && (this._pivot = new Je(this, 0, 0)), this._pivot;
        }
        set pivot(t) {
            this._pivot === qo && (this._pivot = new Je(this, 0, 0)), typeof t == "number" ? this._pivot.set(t) : this._pivot.copyFrom(t);
        }
        get skew() {
            return this._skew === Yo && (this._skew = new Je(this, 0, 0)), this._skew;
        }
        set skew(t) {
            this._skew === Yo && (this._skew = new Je(this, 0, 0)), this._skew.copyFrom(t);
        }
        get scale() {
            return this._scale === jo && (this._scale = new Je(this, 1, 1)), this._scale;
        }
        set scale(t) {
            this._scale === jo && (this._scale = new Je(this, 0, 0)), typeof t == "number" ? this._scale.set(t) : this._scale.copyFrom(t);
        }
        get width() {
            return Math.abs(this.scale.x * this.getLocalBounds().width);
        }
        set width(t) {
            const e = this.getLocalBounds().width;
            this._setWidth(t, e);
        }
        get height() {
            return Math.abs(this.scale.y * this.getLocalBounds().height);
        }
        set height(t) {
            const e = this.getLocalBounds().height;
            this._setHeight(t, e);
        }
        getSize(t) {
            t || (t = {});
            const e = this.getLocalBounds();
            return t.width = Math.abs(this.scale.x * e.width), t.height = Math.abs(this.scale.y * e.height), t;
        }
        setSize(t, e) {
            const n = this.getLocalBounds();
            typeof t == "object" ? (e = t.height ?? t.width, t = t.width) : e ?? (e = t), t !== void 0 && this._setWidth(t, n.width), e !== void 0 && this._setHeight(e, n.height);
        }
        _updateSkew() {
            const t = this._rotation, e = this._skew;
            this._cx = Math.cos(t + e._y), this._sx = Math.sin(t + e._y), this._cy = -Math.sin(t - e._x), this._sy = Math.cos(t - e._x);
        }
        updateTransform(t) {
            return this.position.set(typeof t.x == "number" ? t.x : this.position.x, typeof t.y == "number" ? t.y : this.position.y), this.scale.set(typeof t.scaleX == "number" ? t.scaleX || 1 : this.scale.x, typeof t.scaleY == "number" ? t.scaleY || 1 : this.scale.y), this.rotation = typeof t.rotation == "number" ? t.rotation : this.rotation, this.skew.set(typeof t.skewX == "number" ? t.skewX : this.skew.x, typeof t.skewY == "number" ? t.skewY : this.skew.y), this.pivot.set(typeof t.pivotX == "number" ? t.pivotX : this.pivot.x, typeof t.pivotY == "number" ? t.pivotY : this.pivot.y), this;
        }
        setFromMatrix(t) {
            t.decompose(this);
        }
        updateLocalTransform() {
            const t = this._didContainerChangeTick;
            if (this._didLocalTransformChangeId === t) return;
            this._didLocalTransformChangeId = t;
            const e = this.localTransform, n = this._scale, s = this._pivot, r = this._position, a = n._x, o = n._y, c = s._x, l = s._y;
            e.a = this._cx * a, e.b = this._sx * a, e.c = this._cy * o, e.d = this._sy * o, e.tx = r._x - (c * e.a + l * e.c), e.ty = r._y - (c * e.b + l * e.d);
        }
        set alpha(t) {
            t !== this.localAlpha && (this.localAlpha = t, this._updateFlags |= Wa, this._onUpdate());
        }
        get alpha() {
            return this.localAlpha;
        }
        set tint(t) {
            const n = Pe.shared.setValue(t ?? 16777215).toBgrNumber();
            n !== this.localColor && (this.localColor = n, this._updateFlags |= Wa, this._onUpdate());
        }
        get tint() {
            return La(this.localColor);
        }
        set blendMode(t) {
            this.localBlendMode !== t && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._updateFlags |= lh, this.localBlendMode = t, this._onUpdate());
        }
        get blendMode() {
            return this.localBlendMode;
        }
        get visible() {
            return !!(this.localDisplayStatus & 2);
        }
        set visible(t) {
            const e = t ? 2 : 0;
            (this.localDisplayStatus & 2) !== e && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._updateFlags |= xr, this.localDisplayStatus ^= 2, this._onUpdate());
        }
        get culled() {
            return !(this.localDisplayStatus & 4);
        }
        set culled(t) {
            const e = t ? 0 : 4;
            (this.localDisplayStatus & 4) !== e && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._updateFlags |= xr, this.localDisplayStatus ^= 4, this._onUpdate());
        }
        get renderable() {
            return !!(this.localDisplayStatus & 1);
        }
        set renderable(t) {
            const e = t ? 1 : 0;
            (this.localDisplayStatus & 1) !== e && (this._updateFlags |= xr, this.localDisplayStatus ^= 1, this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._onUpdate());
        }
        get isRenderable() {
            return this.localDisplayStatus === 7 && this.groupAlpha > 0;
        }
        destroy(t = !1) {
            if (this.destroyed) return;
            this.destroyed = !0;
            let e;
            if (this.children.length && (e = this.removeChildren(0, this.children.length)), this.removeFromParent(), this.parent = null, this._maskEffect = null, this._filterEffect = null, this.effects = null, this._position = null, this._scale = null, this._pivot = null, this._skew = null, this.emit("destroyed", this), this.removeAllListeners(), (typeof t == "boolean" ? t : t?.children) && e) for(let s = 0; s < e.length; ++s)e[s].destroy(t);
            this.renderGroup?.destroy(), this.renderGroup = null;
        }
    };
    Be.mixin(mn, VM, $M, nT, QM, JM, YM, qM, tT, kM, HM, KM, WM);
    class hh extends mn {
        constructor(t){
            super(t), this.canBundle = !0, this.allowChildren = !1, this._roundPixels = 0, this._lastUsed = -1, this._bounds = new en(0, 1, 0, 0), this._boundsDirty = !0;
        }
        get bounds() {
            return this._boundsDirty ? (this.updateBounds(), this._boundsDirty = !1, this._bounds) : this._bounds;
        }
        get roundPixels() {
            return !!this._roundPixels;
        }
        set roundPixels(t) {
            this._roundPixels = t ? 1 : 0;
        }
        containsPoint(t) {
            const e = this.bounds, { x: n, y: s } = t;
            return n >= e.minX && n <= e.maxX && s >= e.minY && s <= e.maxY;
        }
        onViewUpdate() {
            if (this._didViewChangeTick++, this._boundsDirty = !0, this.didViewUpdate) return;
            this.didViewUpdate = !0;
            const t = this.renderGroup || this.parentRenderGroup;
            t && t.onChildViewUpdate(this);
        }
        destroy(t) {
            super.destroy(t), this._bounds = null;
        }
        collectRenderablesSimple(t, e, n) {
            const { renderPipes: s, renderableGC: r } = e;
            s.blendMode.setBlendMode(this, this.groupBlendMode, t), s[this.renderPipeId].addRenderable(this, t), r.addRenderable(this), this.didViewUpdate = !1;
            const o = this.children, c = o.length;
            for(let l = 0; l < c; l++)o[l].collectRenderables(t, e, n);
        }
    }
    class ks extends hh {
        constructor(t = Ot.EMPTY){
            t instanceof Ot && (t = {
                texture: t
            });
            const { texture: e = Ot.EMPTY, anchor: n, roundPixels: s, width: r, height: a, ...o } = t;
            super({
                label: "Sprite",
                ...o
            }), this.renderPipeId = "sprite", this.batched = !0, this._visualBounds = {
                minX: 0,
                maxX: 1,
                minY: 0,
                maxY: 0
            }, this._anchor = new Je({
                _onUpdate: ()=>{
                    this.onViewUpdate();
                }
            }), n ? this.anchor = n : e.defaultAnchor && (this.anchor = e.defaultAnchor), this.texture = e, this.allowChildren = !1, this.roundPixels = s ?? !1, r !== void 0 && (this.width = r), a !== void 0 && (this.height = a);
        }
        static from(t, e = !1) {
            return t instanceof Ot ? new ks(t) : new ks(Ot.from(t, e));
        }
        set texture(t) {
            t || (t = Ot.EMPTY);
            const e = this._texture;
            e !== t && (e && e.dynamic && e.off("update", this.onViewUpdate, this), t.dynamic && t.on("update", this.onViewUpdate, this), this._texture = t, this._width && this._setWidth(this._width, this._texture.orig.width), this._height && this._setHeight(this._height, this._texture.orig.height), this.onViewUpdate());
        }
        get texture() {
            return this._texture;
        }
        get visualBounds() {
            return CM(this._visualBounds, this._anchor, this._texture), this._visualBounds;
        }
        get sourceBounds() {
            return ue("8.6.1", "Sprite.sourceBounds is deprecated, use visualBounds instead."), this.visualBounds;
        }
        updateBounds() {
            const t = this._anchor, e = this._texture, n = this._bounds, { width: s, height: r } = e.orig;
            n.minX = -t._x * s, n.maxX = n.minX + s, n.minY = -t._y * r, n.maxY = n.minY + r;
        }
        destroy(t = !1) {
            if (super.destroy(t), typeof t == "boolean" ? t : t?.texture) {
                const n = typeof t == "boolean" ? t : t?.textureSource;
                this._texture.destroy(n);
            }
            this._texture = null, this._visualBounds = null, this._bounds = null, this._anchor = null;
        }
        get anchor() {
            return this._anchor;
        }
        set anchor(t) {
            typeof t == "number" ? this._anchor.set(t) : this._anchor.copyFrom(t);
        }
        get width() {
            return Math.abs(this.scale.x) * this._texture.orig.width;
        }
        set width(t) {
            this._setWidth(t, this._texture.orig.width), this._width = t;
        }
        get height() {
            return Math.abs(this.scale.y) * this._texture.orig.height;
        }
        set height(t) {
            this._setHeight(t, this._texture.orig.height), this._height = t;
        }
        getSize(t) {
            return t || (t = {}), t.width = Math.abs(this.scale.x) * this._texture.orig.width, t.height = Math.abs(this.scale.y) * this._texture.orig.height, t;
        }
        setSize(t, e) {
            typeof t == "object" ? (e = t.height ?? t.width, t = t.width) : e ?? (e = t), t !== void 0 && this._setWidth(t, this._texture.orig.width), e !== void 0 && this._setHeight(e, this._texture.orig.height);
        }
    }
    const oT = new en;
    function Tp(i, t, e) {
        const n = oT;
        i.measurable = !0, ah(i, e, n), t.addBoundsMask(n), i.measurable = !1;
    }
    function Ep(i, t, e) {
        const n = ei.get();
        i.measurable = !0;
        const s = Ye.get().identity(), r = Ap(i, e, s);
        ch(i, n, r), i.measurable = !1, t.addBoundsMask(n), Ye.return(s), ei.return(n);
    }
    function Ap(i, t, e) {
        return i ? (i !== t && (Ap(i.parent, t, e), i.updateLocalTransform(), e.append(i.localTransform)), e) : (_e("Mask bounds, renderable is not inside the root container"), e);
    }
    class wp {
        constructor(t){
            this.priority = 0, this.inverse = !1, this.pipe = "alphaMask", t?.mask && this.init(t.mask);
        }
        init(t) {
            this.mask = t, this.renderMaskToTexture = !(t instanceof ks), this.mask.renderable = this.renderMaskToTexture, this.mask.includeInBuild = !this.renderMaskToTexture, this.mask.measurable = !1;
        }
        reset() {
            this.mask.measurable = !0, this.mask = null;
        }
        addBounds(t, e) {
            this.inverse || Tp(this.mask, t, e);
        }
        addLocalBounds(t, e) {
            Ep(this.mask, t, e);
        }
        containsPoint(t, e) {
            const n = this.mask;
            return e(n, t);
        }
        destroy() {
            this.reset();
        }
        static test(t) {
            return t instanceof ks;
        }
    }
    wp.extension = st.MaskEffect;
    class Rp {
        constructor(t){
            this.priority = 0, this.pipe = "colorMask", t?.mask && this.init(t.mask);
        }
        init(t) {
            this.mask = t;
        }
        destroy() {}
        static test(t) {
            return typeof t == "number";
        }
    }
    Rp.extension = st.MaskEffect;
    class Cp {
        constructor(t){
            this.priority = 0, this.pipe = "stencilMask", t?.mask && this.init(t.mask);
        }
        init(t) {
            this.mask = t, this.mask.includeInBuild = !1, this.mask.measurable = !1;
        }
        reset() {
            this.mask.measurable = !0, this.mask.includeInBuild = !0, this.mask = null;
        }
        addBounds(t, e) {
            Tp(this.mask, t, e);
        }
        addLocalBounds(t, e) {
            Ep(this.mask, t, e);
        }
        containsPoint(t, e) {
            const n = this.mask;
            return e(n, t);
        }
        destroy() {
            this.reset();
        }
        static test(t) {
            return t instanceof mn;
        }
    }
    Cp.extension = st.MaskEffect;
    const cT = {
        createCanvas: (i, t)=>{
            const e = document.createElement("canvas");
            return e.width = i, e.height = t, e;
        },
        getCanvasRenderingContext2D: ()=>CanvasRenderingContext2D,
        getWebGLRenderingContext: ()=>WebGLRenderingContext,
        getNavigator: ()=>navigator,
        getBaseUrl: ()=>document.baseURI ?? window.location.href,
        getFontFaceSet: ()=>document.fonts,
        fetch: (i, t)=>fetch(i, t),
        parseXML: (i)=>new DOMParser().parseFromString(i, "text/xml")
    };
    let Td = cT;
    $e = {
        get () {
            return Td;
        },
        set (i) {
            Td = i;
        }
    };
    class xi extends Ne {
        constructor(t){
            t.resource || (t.resource = $e.get().createCanvas()), t.width || (t.width = t.resource.width, t.autoDensity || (t.width /= t.resolution)), t.height || (t.height = t.resource.height, t.autoDensity || (t.height /= t.resolution)), super(t), this.uploadMethodId = "image", this.autoDensity = t.autoDensity, this.resizeCanvas(), this.transparent = !!t.transparent;
        }
        resizeCanvas() {
            this.autoDensity && "style" in this.resource && (this.resource.style.width = `${this.width}px`, this.resource.style.height = `${this.height}px`), (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) && (this.resource.width = this.pixelWidth, this.resource.height = this.pixelHeight);
        }
        resize(t = this.width, e = this.height, n = this._resolution) {
            const s = super.resize(t, e, n);
            return s && this.resizeCanvas(), s;
        }
        static test(t) {
            return globalThis.HTMLCanvasElement && t instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && t instanceof OffscreenCanvas;
        }
        get context2D() {
            return this._context2D || (this._context2D = this.resource.getContext("2d"));
        }
    }
    xi.extension = st.TextureSource;
    Xa = class extends Ne {
        constructor(t){
            if (t.resource && globalThis.HTMLImageElement && t.resource instanceof HTMLImageElement) {
                const e = $e.get().createCanvas(t.resource.width, t.resource.height);
                e.getContext("2d").drawImage(t.resource, 0, 0, t.resource.width, t.resource.height), t.resource = e, _e("ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.");
            }
            super(t), this.uploadMethodId = "image", this.autoGarbageCollect = !0;
        }
        static test(t) {
            return globalThis.HTMLImageElement && t instanceof HTMLImageElement || typeof ImageBitmap < "u" && t instanceof ImageBitmap || globalThis.VideoFrame && t instanceof VideoFrame;
        }
    };
    Xa.extension = st.TextureSource;
    xl = ((i)=>(i[i.INTERACTION = 50] = "INTERACTION", i[i.HIGH = 25] = "HIGH", i[i.NORMAL = 0] = "NORMAL", i[i.LOW = -25] = "LOW", i[i.UTILITY = -50] = "UTILITY", i))(xl || {});
    class $o {
        constructor(t, e = null, n = 0, s = !1){
            this.next = null, this.previous = null, this._destroyed = !1, this._fn = t, this._context = e, this.priority = n, this._once = s;
        }
        match(t, e = null) {
            return this._fn === t && this._context === e;
        }
        emit(t) {
            this._fn && (this._context ? this._fn.call(this._context, t) : this._fn(t));
            const e = this.next;
            return this._once && this.destroy(!0), this._destroyed && (this.next = null), e;
        }
        connect(t) {
            this.previous = t, t.next && (t.next.previous = this), this.next = t.next, t.next = this;
        }
        destroy(t = !1) {
            this._destroyed = !0, this._fn = null, this._context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
            const e = this.next;
            return this.next = t ? null : e, this.previous = null, e;
        }
    }
    const Pp = class an {
        constructor(){
            this.autoStart = !1, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = !1, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = !1, this._lastFrame = -1, this._head = new $o(null, null, 1 / 0), this.deltaMS = 1 / an.targetFPMS, this.elapsedMS = 1 / an.targetFPMS, this._tick = (t)=>{
                this._requestId = null, this.started && (this.update(t), this.started && this._requestId === null && this._head.next && (this._requestId = requestAnimationFrame(this._tick)));
            };
        }
        _requestIfNeeded() {
            this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));
        }
        _cancelIfNeeded() {
            this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null);
        }
        _startIfPossible() {
            this.started ? this._requestIfNeeded() : this.autoStart && this.start();
        }
        add(t, e, n = xl.NORMAL) {
            return this._addListener(new $o(t, e, n));
        }
        addOnce(t, e, n = xl.NORMAL) {
            return this._addListener(new $o(t, e, n, !0));
        }
        _addListener(t) {
            let e = this._head.next, n = this._head;
            if (!e) t.connect(n);
            else {
                for(; e;){
                    if (t.priority > e.priority) {
                        t.connect(n);
                        break;
                    }
                    n = e, e = e.next;
                }
                t.previous || t.connect(n);
            }
            return this._startIfPossible(), this;
        }
        remove(t, e) {
            let n = this._head.next;
            for(; n;)n.match(t, e) ? n = n.destroy() : n = n.next;
            return this._head.next || this._cancelIfNeeded(), this;
        }
        get count() {
            if (!this._head) return 0;
            let t = 0, e = this._head;
            for(; e = e.next;)t++;
            return t;
        }
        start() {
            this.started || (this.started = !0, this._requestIfNeeded());
        }
        stop() {
            this.started && (this.started = !1, this._cancelIfNeeded());
        }
        destroy() {
            if (!this._protected) {
                this.stop();
                let t = this._head.next;
                for(; t;)t = t.destroy(!0);
                this._head.destroy(), this._head = null;
            }
        }
        update(t = performance.now()) {
            let e;
            if (t > this.lastTime) {
                if (e = this.elapsedMS = t - this.lastTime, e > this._maxElapsedMS && (e = this._maxElapsedMS), e *= this.speed, this._minElapsedMS) {
                    const r = t - this._lastFrame | 0;
                    if (r < this._minElapsedMS) return;
                    this._lastFrame = t - r % this._minElapsedMS;
                }
                this.deltaMS = e, this.deltaTime = this.deltaMS * an.targetFPMS;
                const n = this._head;
                let s = n.next;
                for(; s;)s = s.emit(this);
                n.next || this._cancelIfNeeded();
            } else this.deltaTime = this.deltaMS = this.elapsedMS = 0;
            this.lastTime = t;
        }
        get FPS() {
            return 1e3 / this.elapsedMS;
        }
        get minFPS() {
            return 1e3 / this._maxElapsedMS;
        }
        set minFPS(t) {
            const e = Math.min(this.maxFPS, t), n = Math.min(Math.max(0, e) / 1e3, an.targetFPMS);
            this._maxElapsedMS = 1 / n;
        }
        get maxFPS() {
            return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;
        }
        set maxFPS(t) {
            if (t === 0) this._minElapsedMS = 0;
            else {
                const e = Math.max(this.minFPS, t);
                this._minElapsedMS = 1 / (e / 1e3);
            }
        }
        static get shared() {
            if (!an._shared) {
                const t = an._shared = new an;
                t.autoStart = !0, t._protected = !0;
            }
            return an._shared;
        }
        static get system() {
            if (!an._system) {
                const t = an._system = new an;
                t.autoStart = !0, t._protected = !0;
            }
            return an._system;
        }
    };
    Pp.targetFPMS = .06;
    let Ko;
    Ms = Pp;
    async function lT() {
        return Ko ?? (Ko = (async ()=>{
            const t = document.createElement("canvas").getContext("webgl");
            if (!t) return "premultiply-alpha-on-upload";
            const e = await new Promise((a)=>{
                const o = document.createElement("video");
                o.onloadeddata = ()=>a(o), o.onerror = ()=>a(null), o.autoplay = !1, o.crossOrigin = "anonymous", o.preload = "auto", o.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=", o.load();
            });
            if (!e) return "premultiply-alpha-on-upload";
            const n = t.createTexture();
            t.bindTexture(t.TEXTURE_2D, n);
            const s = t.createFramebuffer();
            t.bindFramebuffer(t.FRAMEBUFFER, s), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, n, 0), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, t.NONE), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, e);
            const r = new Uint8Array(4);
            return t.readPixels(0, 0, 1, 1, t.RGBA, t.UNSIGNED_BYTE, r), t.deleteFramebuffer(s), t.deleteTexture(n), t.getExtension("WEBGL_lose_context")?.loseContext(), r[0] <= r[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload";
        })()), Ko;
    }
    const Za = class Ip extends Ne {
        constructor(t){
            super(t), this.isReady = !1, this.uploadMethodId = "video", t = {
                ...Ip.defaultOptions,
                ...t
            }, this._autoUpdate = !0, this._isConnectedToTicker = !1, this._updateFPS = t.updateFPS || 0, this._msToNextUpdate = 0, this.autoPlay = t.autoPlay !== !1, this.alphaMode = t.alphaMode ?? "premultiply-alpha-on-upload", this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this), this._videoFrameRequestCallbackHandle = null, this._load = null, this._resolve = null, this._reject = null, this._onCanPlay = this._onCanPlay.bind(this), this._onCanPlayThrough = this._onCanPlayThrough.bind(this), this._onError = this._onError.bind(this), this._onPlayStart = this._onPlayStart.bind(this), this._onPlayStop = this._onPlayStop.bind(this), this._onSeeked = this._onSeeked.bind(this), t.autoLoad !== !1 && this.load();
        }
        updateFrame() {
            if (!this.destroyed) {
                if (this._updateFPS) {
                    const t = Ms.shared.elapsedMS * this.resource.playbackRate;
                    this._msToNextUpdate = Math.floor(this._msToNextUpdate - t);
                }
                (!this._updateFPS || this._msToNextUpdate <= 0) && (this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0), this.isValid && this.update();
            }
        }
        _videoFrameRequestCallback() {
            this.updateFrame(), this.destroyed ? this._videoFrameRequestCallbackHandle = null : this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback);
        }
        get isValid() {
            return !!this.resource.videoWidth && !!this.resource.videoHeight;
        }
        async load() {
            if (this._load) return this._load;
            const t = this.resource, e = this.options;
            return (t.readyState === t.HAVE_ENOUGH_DATA || t.readyState === t.HAVE_FUTURE_DATA) && t.width && t.height && (t.complete = !0), t.addEventListener("play", this._onPlayStart), t.addEventListener("pause", this._onPlayStop), t.addEventListener("seeked", this._onSeeked), this._isSourceReady() ? this._mediaReady() : (e.preload || t.addEventListener("canplay", this._onCanPlay), t.addEventListener("canplaythrough", this._onCanPlayThrough), t.addEventListener("error", this._onError, !0)), this.alphaMode = await lT(), this._load = new Promise((n, s)=>{
                this.isValid ? n(this) : (this._resolve = n, this._reject = s, e.preloadTimeoutMs !== void 0 && (this._preloadTimeout = setTimeout(()=>{
                    this._onError(new ErrorEvent(`Preload exceeded timeout of ${e.preloadTimeoutMs}ms`));
                })), t.load());
            }), this._load;
        }
        _onError(t) {
            this.resource.removeEventListener("error", this._onError, !0), this.emit("error", t), this._reject && (this._reject(t), this._reject = null, this._resolve = null);
        }
        _isSourcePlaying() {
            const t = this.resource;
            return !t.paused && !t.ended;
        }
        _isSourceReady() {
            return this.resource.readyState > 2;
        }
        _onPlayStart() {
            this.isValid || this._mediaReady(), this._configureAutoUpdate();
        }
        _onPlayStop() {
            this._configureAutoUpdate();
        }
        _onSeeked() {
            this._autoUpdate && !this._isSourcePlaying() && (this._msToNextUpdate = 0, this.updateFrame(), this._msToNextUpdate = 0);
        }
        _onCanPlay() {
            this.resource.removeEventListener("canplay", this._onCanPlay), this._mediaReady();
        }
        _onCanPlayThrough() {
            this.resource.removeEventListener("canplaythrough", this._onCanPlay), this._preloadTimeout && (clearTimeout(this._preloadTimeout), this._preloadTimeout = void 0), this._mediaReady();
        }
        _mediaReady() {
            const t = this.resource;
            this.isValid && (this.isReady = !0, this.resize(t.videoWidth, t.videoHeight)), this._msToNextUpdate = 0, this.updateFrame(), this._msToNextUpdate = 0, this._resolve && (this._resolve(this), this._resolve = null, this._reject = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && this.resource.play();
        }
        destroy() {
            this._configureAutoUpdate();
            const t = this.resource;
            t && (t.removeEventListener("play", this._onPlayStart), t.removeEventListener("pause", this._onPlayStop), t.removeEventListener("seeked", this._onSeeked), t.removeEventListener("canplay", this._onCanPlay), t.removeEventListener("canplaythrough", this._onCanPlayThrough), t.removeEventListener("error", this._onError, !0), t.pause(), t.src = "", t.load()), super.destroy();
        }
        get autoUpdate() {
            return this._autoUpdate;
        }
        set autoUpdate(t) {
            t !== this._autoUpdate && (this._autoUpdate = t, this._configureAutoUpdate());
        }
        get updateFPS() {
            return this._updateFPS;
        }
        set updateFPS(t) {
            t !== this._updateFPS && (this._updateFPS = t, this._configureAutoUpdate());
        }
        _configureAutoUpdate() {
            this._autoUpdate && this._isSourcePlaying() ? !this._updateFPS && this.resource.requestVideoFrameCallback ? (this._isConnectedToTicker && (Ms.shared.remove(this.updateFrame, this), this._isConnectedToTicker = !1, this._msToNextUpdate = 0), this._videoFrameRequestCallbackHandle === null && (this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback))) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker || (Ms.shared.add(this.updateFrame, this), this._isConnectedToTicker = !0, this._msToNextUpdate = 0)) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker && (Ms.shared.remove(this.updateFrame, this), this._isConnectedToTicker = !1, this._msToNextUpdate = 0));
        }
        static test(t) {
            return globalThis.HTMLVideoElement && t instanceof HTMLVideoElement;
        }
    };
    Za.extension = st.TextureSource;
    Za.defaultOptions = {
        ...Ne.defaultOptions,
        autoLoad: !0,
        autoPlay: !0,
        updateFPS: 0,
        crossorigin: !0,
        loop: !1,
        muted: !0,
        playsinline: !0,
        preload: !1
    };
    Za.MIME_TYPES = {
        ogv: "video/ogg",
        mov: "video/quicktime",
        m4v: "video/mp4"
    };
    let hT = Za;
    const gs = (i, t, e = !1)=>(Array.isArray(i) || (i = [
            i
        ]), t ? i.map((n)=>typeof n == "string" || e ? t(n) : n) : i);
    class uT {
        constructor(){
            this._parsers = [], this._cache = new Map, this._cacheMap = new Map;
        }
        reset() {
            this._cacheMap.clear(), this._cache.clear();
        }
        has(t) {
            return this._cache.has(t);
        }
        get(t) {
            const e = this._cache.get(t);
            return e || _e(`[Assets] Asset id ${t} was not found in the Cache`), e;
        }
        set(t, e) {
            const n = gs(t);
            let s;
            for(let c = 0; c < this.parsers.length; c++){
                const l = this.parsers[c];
                if (l.test(e)) {
                    s = l.getCacheableAssets(n, e);
                    break;
                }
            }
            const r = new Map(Object.entries(s || {}));
            s || n.forEach((c)=>{
                r.set(c, e);
            });
            const a = [
                ...r.keys()
            ], o = {
                cacheKeys: a,
                keys: n
            };
            n.forEach((c)=>{
                this._cacheMap.set(c, o);
            }), a.forEach((c)=>{
                const l = s ? s[c] : e;
                this._cache.has(c) && this._cache.get(c) !== l && _e("[Cache] already has key:", c), this._cache.set(c, r.get(c));
            });
        }
        remove(t) {
            if (!this._cacheMap.has(t)) {
                _e(`[Assets] Asset id ${t} was not found in the Cache`);
                return;
            }
            const e = this._cacheMap.get(t);
            e.cacheKeys.forEach((s)=>{
                this._cache.delete(s);
            }), e.keys.forEach((s)=>{
                this._cacheMap.delete(s);
            });
        }
        get parsers() {
            return this._parsers;
        }
    }
    let vl;
    xs = new uT;
    vl = [];
    Be.handleByList(st.TextureSource, vl);
    function Dp(i = {}) {
        const t = i && i.resource, e = t ? i.resource : i, n = t ? i : {
            resource: i
        };
        for(let s = 0; s < vl.length; s++){
            const r = vl[s];
            if (r.test(e)) return new r(n);
        }
        throw new Error(`Could not find a source type for resource: ${n.resource}`);
    }
    function dT(i = {}, t = !1) {
        const e = i && i.resource, n = e ? i.resource : i, s = e ? i : {
            resource: i
        };
        if (!t && xs.has(n)) return xs.get(n);
        const r = new Ot({
            source: Dp(s)
        });
        return r.on("destroy", ()=>{
            xs.has(n) && xs.remove(n);
        }), t || xs.set(n, r), r;
    }
    function fT(i, t = !1) {
        return typeof i == "string" ? xs.get(i) : i instanceof Ne ? new Ot({
            source: i
        }) : dT(i, t);
    }
    Ot.from = fT;
    Ne.from = Dp;
    Be.add(wp, Rp, Cp, hT, Xa, xi, sh);
    var Lp = ((i)=>(i[i.Low = 0] = "Low", i[i.Normal = 1] = "Normal", i[i.High = 2] = "High", i))(Lp || {});
    function bn(i) {
        if (typeof i != "string") throw new TypeError(`Path must be a string. Received ${JSON.stringify(i)}`);
    }
    function sr(i) {
        return i.split("?")[0].split("#")[0];
    }
    function pT(i) {
        return i.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function mT(i, t, e) {
        return i.replace(new RegExp(pT(t), "g"), e);
    }
    function _T(i, t) {
        let e = "", n = 0, s = -1, r = 0, a = -1;
        for(let o = 0; o <= i.length; ++o){
            if (o < i.length) a = i.charCodeAt(o);
            else {
                if (a === 47) break;
                a = 47;
            }
            if (a === 47) {
                if (!(s === o - 1 || r === 1)) if (s !== o - 1 && r === 2) {
                    if (e.length < 2 || n !== 2 || e.charCodeAt(e.length - 1) !== 46 || e.charCodeAt(e.length - 2) !== 46) {
                        if (e.length > 2) {
                            const c = e.lastIndexOf("/");
                            if (c !== e.length - 1) {
                                c === -1 ? (e = "", n = 0) : (e = e.slice(0, c), n = e.length - 1 - e.lastIndexOf("/")), s = o, r = 0;
                                continue;
                            }
                        } else if (e.length === 2 || e.length === 1) {
                            e = "", n = 0, s = o, r = 0;
                            continue;
                        }
                    }
                } else e.length > 0 ? e += `/${i.slice(s + 1, o)}` : e = i.slice(s + 1, o), n = o - s - 1;
                s = o, r = 0;
            } else a === 46 && r !== -1 ? ++r : r = -1;
        }
        return e;
    }
    const Ir = {
        toPosix (i) {
            return mT(i, "\\", "/");
        },
        isUrl (i) {
            return /^https?:/.test(this.toPosix(i));
        },
        isDataUrl (i) {
            return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(i);
        },
        isBlobUrl (i) {
            return i.startsWith("blob:");
        },
        hasProtocol (i) {
            return /^[^/:]+:/.test(this.toPosix(i));
        },
        getProtocol (i) {
            bn(i), i = this.toPosix(i);
            const t = /^file:\/\/\//.exec(i);
            if (t) return t[0];
            const e = /^[^/:]+:\/{0,2}/.exec(i);
            return e ? e[0] : "";
        },
        toAbsolute (i, t, e) {
            if (bn(i), this.isDataUrl(i) || this.isBlobUrl(i)) return i;
            const n = sr(this.toPosix(t ?? $e.get().getBaseUrl())), s = sr(this.toPosix(e ?? this.rootname(n)));
            return i = this.toPosix(i), i.startsWith("/") ? Ir.join(s, i.slice(1)) : this.isAbsolute(i) ? i : this.join(n, i);
        },
        normalize (i) {
            if (bn(i), i.length === 0) return ".";
            if (this.isDataUrl(i) || this.isBlobUrl(i)) return i;
            i = this.toPosix(i);
            let t = "";
            const e = i.startsWith("/");
            this.hasProtocol(i) && (t = this.rootname(i), i = i.slice(t.length));
            const n = i.endsWith("/");
            return i = _T(i), i.length > 0 && n && (i += "/"), e ? `/${i}` : t + i;
        },
        isAbsolute (i) {
            return bn(i), i = this.toPosix(i), this.hasProtocol(i) ? !0 : i.startsWith("/");
        },
        join (...i) {
            if (i.length === 0) return ".";
            let t;
            for(let e = 0; e < i.length; ++e){
                const n = i[e];
                if (bn(n), n.length > 0) if (t === void 0) t = n;
                else {
                    const s = i[e - 1] ?? "";
                    this.joinExtensions.includes(this.extname(s).toLowerCase()) ? t += `/../${n}` : t += `/${n}`;
                }
            }
            return t === void 0 ? "." : this.normalize(t);
        },
        dirname (i) {
            if (bn(i), i.length === 0) return ".";
            i = this.toPosix(i);
            let t = i.charCodeAt(0);
            const e = t === 47;
            let n = -1, s = !0;
            const r = this.getProtocol(i), a = i;
            i = i.slice(r.length);
            for(let o = i.length - 1; o >= 1; --o)if (t = i.charCodeAt(o), t === 47) {
                if (!s) {
                    n = o;
                    break;
                }
            } else s = !1;
            return n === -1 ? e ? "/" : this.isUrl(a) ? r + i : r : e && n === 1 ? "//" : r + i.slice(0, n);
        },
        rootname (i) {
            bn(i), i = this.toPosix(i);
            let t = "";
            if (i.startsWith("/") ? t = "/" : t = this.getProtocol(i), this.isUrl(i)) {
                const e = i.indexOf("/", t.length);
                e !== -1 ? t = i.slice(0, e) : t = i, t.endsWith("/") || (t += "/");
            }
            return t;
        },
        basename (i, t) {
            bn(i), t && bn(t), i = sr(this.toPosix(i));
            let e = 0, n = -1, s = !0, r;
            if (t !== void 0 && t.length > 0 && t.length <= i.length) {
                if (t.length === i.length && t === i) return "";
                let a = t.length - 1, o = -1;
                for(r = i.length - 1; r >= 0; --r){
                    const c = i.charCodeAt(r);
                    if (c === 47) {
                        if (!s) {
                            e = r + 1;
                            break;
                        }
                    } else o === -1 && (s = !1, o = r + 1), a >= 0 && (c === t.charCodeAt(a) ? --a === -1 && (n = r) : (a = -1, n = o));
                }
                return e === n ? n = o : n === -1 && (n = i.length), i.slice(e, n);
            }
            for(r = i.length - 1; r >= 0; --r)if (i.charCodeAt(r) === 47) {
                if (!s) {
                    e = r + 1;
                    break;
                }
            } else n === -1 && (s = !1, n = r + 1);
            return n === -1 ? "" : i.slice(e, n);
        },
        extname (i) {
            bn(i), i = sr(this.toPosix(i));
            let t = -1, e = 0, n = -1, s = !0, r = 0;
            for(let a = i.length - 1; a >= 0; --a){
                const o = i.charCodeAt(a);
                if (o === 47) {
                    if (!s) {
                        e = a + 1;
                        break;
                    }
                    continue;
                }
                n === -1 && (s = !1, n = a + 1), o === 46 ? t === -1 ? t = a : r !== 1 && (r = 1) : t !== -1 && (r = -1);
            }
            return t === -1 || n === -1 || r === 0 || r === 1 && t === n - 1 && t === e + 1 ? "" : i.slice(t, n);
        },
        parse (i) {
            bn(i);
            const t = {
                root: "",
                dir: "",
                base: "",
                ext: "",
                name: ""
            };
            if (i.length === 0) return t;
            i = sr(this.toPosix(i));
            let e = i.charCodeAt(0);
            const n = this.isAbsolute(i);
            let s;
            t.root = this.rootname(i), n || this.hasProtocol(i) ? s = 1 : s = 0;
            let r = -1, a = 0, o = -1, c = !0, l = i.length - 1, h = 0;
            for(; l >= s; --l){
                if (e = i.charCodeAt(l), e === 47) {
                    if (!c) {
                        a = l + 1;
                        break;
                    }
                    continue;
                }
                o === -1 && (c = !1, o = l + 1), e === 46 ? r === -1 ? r = l : h !== 1 && (h = 1) : r !== -1 && (h = -1);
            }
            return r === -1 || o === -1 || h === 0 || h === 1 && r === o - 1 && r === a + 1 ? o !== -1 && (a === 0 && n ? t.base = t.name = i.slice(1, o) : t.base = t.name = i.slice(a, o)) : (a === 0 && n ? (t.name = i.slice(1, r), t.base = i.slice(1, o)) : (t.name = i.slice(a, r), t.base = i.slice(a, o)), t.ext = i.slice(r, o)), t.dir = this.dirname(i), t;
        },
        sep: "/",
        delimiter: ":",
        joinExtensions: [
            ".html"
        ]
    };
    function Up(i, t, e, n, s) {
        const r = t[e];
        for(let a = 0; a < r.length; a++){
            const o = r[a];
            e < t.length - 1 ? Up(i.replace(n[e], o), t, e + 1, n, s) : s.push(i.replace(n[e], o));
        }
    }
    function gT(i) {
        const t = /\{(.*?)\}/g, e = i.match(t), n = [];
        if (e) {
            const s = [];
            e.forEach((r)=>{
                const a = r.substring(1, r.length - 1).split(",");
                s.push(a);
            }), Up(i, s, 0, e, n);
        } else n.push(i);
        return n;
    }
    const Ed = (i)=>!Array.isArray(i);
    class Np {
        constructor(){
            this._defaultBundleIdentifierOptions = {
                connector: "-",
                createBundleAssetId: (t, e)=>`${t}${this._bundleIdConnector}${e}`,
                extractAssetIdFromBundle: (t, e)=>e.replace(`${t}${this._bundleIdConnector}`, "")
            }, this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector, this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId, this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle, this._assetMap = {}, this._preferredOrder = [], this._parsers = [], this._resolverHash = {}, this._bundles = {};
        }
        setBundleIdentifier(t) {
            if (this._bundleIdConnector = t.connector ?? this._bundleIdConnector, this._createBundleAssetId = t.createBundleAssetId ?? this._createBundleAssetId, this._extractAssetIdFromBundle = t.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle, this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
        }
        prefer(...t) {
            t.forEach((e)=>{
                this._preferredOrder.push(e), e.priority || (e.priority = Object.keys(e.params));
            }), this._resolverHash = {};
        }
        set basePath(t) {
            this._basePath = t;
        }
        get basePath() {
            return this._basePath;
        }
        set rootPath(t) {
            this._rootPath = t;
        }
        get rootPath() {
            return this._rootPath;
        }
        get parsers() {
            return this._parsers;
        }
        reset() {
            this.setBundleIdentifier(this._defaultBundleIdentifierOptions), this._assetMap = {}, this._preferredOrder = [], this._resolverHash = {}, this._rootPath = null, this._basePath = null, this._manifest = null, this._bundles = {}, this._defaultSearchParams = null;
        }
        setDefaultSearchParams(t) {
            if (typeof t == "string") this._defaultSearchParams = t;
            else {
                const e = t;
                this._defaultSearchParams = Object.keys(e).map((n)=>`${encodeURIComponent(n)}=${encodeURIComponent(e[n])}`).join("&");
            }
        }
        getAlias(t) {
            const { alias: e, src: n } = t;
            return gs(e || n, (r)=>typeof r == "string" ? r : Array.isArray(r) ? r.map((a)=>a?.src ?? a) : r?.src ? r.src : r, !0);
        }
        addManifest(t) {
            this._manifest && _e("[Resolver] Manifest already exists, this will be overwritten"), this._manifest = t, t.bundles.forEach((e)=>{
                this.addBundle(e.name, e.assets);
            });
        }
        addBundle(t, e) {
            const n = [];
            let s = e;
            Array.isArray(e) || (s = Object.entries(e).map(([r, a])=>typeof a == "string" || Array.isArray(a) ? {
                    alias: r,
                    src: a
                } : {
                    alias: r,
                    ...a
                })), s.forEach((r)=>{
                const a = r.src, o = r.alias;
                let c;
                if (typeof o == "string") {
                    const l = this._createBundleAssetId(t, o);
                    n.push(l), c = [
                        o,
                        l
                    ];
                } else {
                    const l = o.map((h)=>this._createBundleAssetId(t, h));
                    n.push(...l), c = [
                        ...o,
                        ...l
                    ];
                }
                this.add({
                    ...r,
                    alias: c,
                    src: a
                });
            }), this._bundles[t] = n;
        }
        add(t) {
            const e = [];
            Array.isArray(t) ? e.push(...t) : e.push(t);
            let n;
            n = (r)=>{
                this.hasKey(r) && _e(`[Resolver] already has key: ${r} overwriting`);
            }, gs(e).forEach((r)=>{
                const { src: a } = r;
                let { data: o, format: c, loadParser: l } = r;
                const h = gs(a).map((f)=>typeof f == "string" ? gT(f) : Array.isArray(f) ? f : [
                        f
                    ]), u = this.getAlias(r);
                Array.isArray(u) ? u.forEach(n) : n(u);
                const d = [];
                h.forEach((f)=>{
                    f.forEach((_)=>{
                        let g = {};
                        if (typeof _ != "object") {
                            g.src = _;
                            for(let p = 0; p < this._parsers.length; p++){
                                const m = this._parsers[p];
                                if (m.test(_)) {
                                    g = m.parse(_);
                                    break;
                                }
                            }
                        } else o = _.data ?? o, c = _.format ?? c, l = _.loadParser ?? l, g = {
                            ...g,
                            ..._
                        };
                        if (!u) throw new Error(`[Resolver] alias is undefined for this asset: ${g.src}`);
                        g = this._buildResolvedAsset(g, {
                            aliases: u,
                            data: o,
                            format: c,
                            loadParser: l
                        }), d.push(g);
                    });
                }), u.forEach((f)=>{
                    this._assetMap[f] = d;
                });
            });
        }
        resolveBundle(t) {
            const e = Ed(t);
            t = gs(t);
            const n = {};
            return t.forEach((s)=>{
                const r = this._bundles[s];
                if (r) {
                    const a = this.resolve(r), o = {};
                    for(const c in a){
                        const l = a[c];
                        o[this._extractAssetIdFromBundle(s, c)] = l;
                    }
                    n[s] = o;
                }
            }), e ? n[t[0]] : n;
        }
        resolveUrl(t) {
            const e = this.resolve(t);
            if (typeof t != "string") {
                const n = {};
                for(const s in e)n[s] = e[s].src;
                return n;
            }
            return e.src;
        }
        resolve(t) {
            const e = Ed(t);
            t = gs(t);
            const n = {};
            return t.forEach((s)=>{
                if (!this._resolverHash[s]) if (this._assetMap[s]) {
                    let r = this._assetMap[s];
                    const a = this._getPreferredOrder(r);
                    a?.priority.forEach((o)=>{
                        a.params[o].forEach((c)=>{
                            const l = r.filter((h)=>h[o] ? h[o] === c : !1);
                            l.length && (r = l);
                        });
                    }), this._resolverHash[s] = r[0];
                } else this._resolverHash[s] = this._buildResolvedAsset({
                    alias: [
                        s
                    ],
                    src: s
                }, {});
                n[s] = this._resolverHash[s];
            }), e ? n[t[0]] : n;
        }
        hasKey(t) {
            return !!this._assetMap[t];
        }
        hasBundle(t) {
            return !!this._bundles[t];
        }
        _getPreferredOrder(t) {
            for(let e = 0; e < t.length; e++){
                const n = t[e], s = this._preferredOrder.find((r)=>r.params.format.includes(n.format));
                if (s) return s;
            }
            return this._preferredOrder[0];
        }
        _appendDefaultSearchParams(t) {
            if (!this._defaultSearchParams) return t;
            const e = /\?/.test(t) ? "&" : "?";
            return `${t}${e}${this._defaultSearchParams}`;
        }
        _buildResolvedAsset(t, e) {
            const { aliases: n, data: s, loadParser: r, format: a } = e;
            return (this._basePath || this._rootPath) && (t.src = Ir.toAbsolute(t.src, this._basePath, this._rootPath)), t.alias = n ?? t.alias ?? [
                t.src
            ], t.src = this._appendDefaultSearchParams(t.src), t.data = {
                ...s || {},
                ...t.data
            }, t.loadParser = r ?? t.loadParser, t.format = a ?? t.format ?? xT(t.src), t;
        }
    }
    Np.RETINA_PREFIX = /@([0-9\.]+)x/;
    function xT(i) {
        return i.split(".").pop().split("?").shift().split("#").shift();
    }
    const Ad = (i, t)=>{
        const e = t.split("?")[1];
        return e && (i += `?${e}`), i;
    }, Bp = class dr {
        constructor(t, e){
            this.linkedSheets = [], this._texture = t instanceof Ot ? t : null, this.textureSource = t.source, this.textures = {}, this.animations = {}, this.data = e;
            const n = parseFloat(e.meta.scale);
            n ? (this.resolution = n, t.source.resolution = this.resolution) : this.resolution = t.source._resolution, this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null;
        }
        parse() {
            return new Promise((t)=>{
                this._callback = t, this._batchIndex = 0, this._frameKeys.length <= dr.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch();
            });
        }
        _processFrames(t) {
            let e = t;
            const n = dr.BATCH_SIZE;
            for(; e - t < n && e < this._frameKeys.length;){
                const s = this._frameKeys[e], r = this._frames[s], a = r.frame;
                if (a) {
                    let o = null, c = null;
                    const l = r.trimmed !== !1 && r.sourceSize ? r.sourceSize : r.frame, h = new fe(0, 0, Math.floor(l.w) / this.resolution, Math.floor(l.h) / this.resolution);
                    r.rotated ? o = new fe(Math.floor(a.x) / this.resolution, Math.floor(a.y) / this.resolution, Math.floor(a.h) / this.resolution, Math.floor(a.w) / this.resolution) : o = new fe(Math.floor(a.x) / this.resolution, Math.floor(a.y) / this.resolution, Math.floor(a.w) / this.resolution, Math.floor(a.h) / this.resolution), r.trimmed !== !1 && r.spriteSourceSize && (c = new fe(Math.floor(r.spriteSourceSize.x) / this.resolution, Math.floor(r.spriteSourceSize.y) / this.resolution, Math.floor(a.w) / this.resolution, Math.floor(a.h) / this.resolution)), this.textures[s] = new Ot({
                        source: this.textureSource,
                        frame: o,
                        orig: h,
                        trim: c,
                        rotate: r.rotated ? 2 : 0,
                        defaultAnchor: r.anchor,
                        defaultBorders: r.borders,
                        label: s.toString()
                    });
                }
                e++;
            }
        }
        _processAnimations() {
            const t = this.data.animations || {};
            for(const e in t){
                this.animations[e] = [];
                for(let n = 0; n < t[e].length; n++){
                    const s = t[e][n];
                    this.animations[e].push(this.textures[s]);
                }
            }
        }
        _parseComplete() {
            const t = this._callback;
            this._callback = null, this._batchIndex = 0, t.call(this, this.textures);
        }
        _nextBatch() {
            this._processFrames(this._batchIndex * dr.BATCH_SIZE), this._batchIndex++, setTimeout(()=>{
                this._batchIndex * dr.BATCH_SIZE < this._frameKeys.length ? this._nextBatch() : (this._processAnimations(), this._parseComplete());
            }, 0);
        }
        destroy(t = !1) {
            for(const e in this.textures)this.textures[e].destroy();
            this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, t && (this._texture?.destroy(), this.textureSource.destroy()), this._texture = null, this.textureSource = null, this.linkedSheets = [];
        }
    };
    Bp.BATCH_SIZE = 1e3;
    let wd = Bp;
    const vT = [
        "jpg",
        "png",
        "jpeg",
        "avif",
        "webp",
        "basis",
        "etc2",
        "bc7",
        "bc6h",
        "bc5",
        "bc4",
        "bc3",
        "bc2",
        "bc1",
        "eac",
        "astc"
    ];
    function Fp(i, t, e) {
        const n = {};
        if (i.forEach((s)=>{
            n[s] = t;
        }), Object.keys(t.textures).forEach((s)=>{
            n[s] = t.textures[s];
        }), !e) {
            const s = Ir.dirname(i[0]);
            t.linkedSheets.forEach((r, a)=>{
                const o = Fp([
                    `${s}/${t.data.meta.related_multi_packs[a]}`
                ], r, !0);
                Object.assign(n, o);
            });
        }
        return n;
    }
    const yT = {
        extension: st.Asset,
        cache: {
            test: (i)=>i instanceof wd,
            getCacheableAssets: (i, t)=>Fp(i, t, !1)
        },
        resolver: {
            extension: {
                type: st.ResolveParser,
                name: "resolveSpritesheet"
            },
            test: (i)=>{
                const e = i.split("?")[0].split("."), n = e.pop(), s = e.pop();
                return n === "json" && vT.includes(s);
            },
            parse: (i)=>{
                const t = i.split(".");
                return {
                    resolution: parseFloat(Np.RETINA_PREFIX.exec(i)?.[1] ?? "1"),
                    format: t[t.length - 2],
                    src: i
                };
            }
        },
        loader: {
            name: "spritesheetLoader",
            extension: {
                type: st.LoadParser,
                priority: Lp.Normal,
                name: "spritesheetLoader"
            },
            async testParse (i, t) {
                return Ir.extname(t.src).toLowerCase() === ".json" && !!i.frames;
            },
            async parse (i, t, e) {
                const { texture: n, imageFilename: s, textureOptions: r } = t?.data ?? {};
                let a = Ir.dirname(t.src);
                a && a.lastIndexOf("/") !== a.length - 1 && (a += "/");
                let o;
                if (n instanceof Ot) o = n;
                else {
                    const h = Ad(a + (s ?? i.meta.image), t.src);
                    o = (await e.load([
                        {
                            src: h,
                            data: r
                        }
                    ]))[h];
                }
                const c = new wd(o.source, i);
                await c.parse();
                const l = i?.meta?.related_multi_packs;
                if (Array.isArray(l)) {
                    const h = [];
                    for (const d of l){
                        if (typeof d != "string") continue;
                        let f = a + d;
                        t.data?.ignoreMultiPack || (f = Ad(f, t.src), h.push(e.load({
                            src: f,
                            data: {
                                textureOptions: r,
                                ignoreMultiPack: !0
                            }
                        })));
                    }
                    const u = await Promise.all(h);
                    c.linkedSheets = u, u.forEach((d)=>{
                        d.linkedSheets = [
                            c
                        ].concat(c.linkedSheets.filter((f)=>f !== d));
                    });
                }
                return c;
            },
            async unload (i, t, e) {
                await e.unload(i.textureSource._sourceOrigin), i.destroy(!1);
            }
        }
    };
    Be.add(yT);
    const Zo = Object.create(null), Rd = Object.create(null);
    function uh(i, t) {
        let e = Rd[i];
        return e === void 0 && (Zo[t] === void 0 && (Zo[t] = 1), Rd[i] = e = Zo[t]++), e;
    }
    let ga;
    function Op() {
        return (!ga || ga?.isContextLost()) && (ga = $e.get().createCanvas().getContext("webgl", {})), ga;
    }
    let xa;
    function bT() {
        if (!xa) {
            xa = "mediump";
            const i = Op();
            i && i.getShaderPrecisionFormat && (xa = i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.HIGH_FLOAT).precision ? "highp" : "mediump");
        }
        return xa;
    }
    function ST(i, t, e) {
        return t ? i : e ? (i = i.replace("out vec4 finalColor;", ""), `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${i}
        `) : `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${i}
        `;
    }
    function MT(i, t, e) {
        const n = e ? t.maxSupportedFragmentPrecision : t.maxSupportedVertexPrecision;
        if (i.substring(0, 9) !== "precision") {
            let s = e ? t.requestedFragmentPrecision : t.requestedVertexPrecision;
            return s === "highp" && n !== "highp" && (s = "mediump"), `precision ${s} float;
${i}`;
        } else if (n !== "highp" && i.substring(0, 15) === "precision highp") return i.replace("precision highp", "precision mediump");
        return i;
    }
    function TT(i, t) {
        return t ? `#version 300 es
${i}` : i;
    }
    const ET = {}, AT = {};
    function wT(i, { name: t = "pixi-program" }, e = !0) {
        t = t.replace(/\s+/g, "-"), t += e ? "-fragment" : "-vertex";
        const n = e ? ET : AT;
        return n[t] ? (n[t]++, t += `-${n[t]}`) : n[t] = 1, i.indexOf("#define SHADER_NAME") !== -1 ? i : `${`#define SHADER_NAME ${t}`}
${i}`;
    }
    function RT(i, t) {
        return t ? i.replace("#version 300 es", "") : i;
    }
    const Jo = {
        stripVersion: RT,
        ensurePrecision: MT,
        addProgramDefines: ST,
        setProgramName: wT,
        insertVersion: TT
    }, Qo = Object.create(null), kp = class yl {
        constructor(t){
            t = {
                ...yl.defaultOptions,
                ...t
            };
            const e = t.fragment.indexOf("#version 300 es") !== -1, n = {
                stripVersion: e,
                ensurePrecision: {
                    requestedFragmentPrecision: t.preferredFragmentPrecision,
                    requestedVertexPrecision: t.preferredVertexPrecision,
                    maxSupportedVertexPrecision: "highp",
                    maxSupportedFragmentPrecision: bT()
                },
                setProgramName: {
                    name: t.name
                },
                addProgramDefines: e,
                insertVersion: e
            };
            let s = t.fragment, r = t.vertex;
            Object.keys(Jo).forEach((a)=>{
                const o = n[a];
                s = Jo[a](s, o, !0), r = Jo[a](r, o, !1);
            }), this.fragment = s, this.vertex = r, this.transformFeedbackVaryings = t.transformFeedbackVaryings, this._key = uh(`${this.vertex}:${this.fragment}`, "gl-program");
        }
        destroy() {
            this.fragment = null, this.vertex = null, this._attributeData = null, this._uniformData = null, this._uniformBlockData = null, this.transformFeedbackVaryings = null;
        }
        static from(t) {
            const e = `${t.vertex}:${t.fragment}`;
            return Qo[e] || (Qo[e] = new yl(t)), Qo[e];
        }
    };
    kp.defaultOptions = {
        preferredVertexPrecision: "highp",
        preferredFragmentPrecision: "mediump"
    };
    Br = kp;
    const Cd = {
        uint8x2: {
            size: 2,
            stride: 2,
            normalised: !1
        },
        uint8x4: {
            size: 4,
            stride: 4,
            normalised: !1
        },
        sint8x2: {
            size: 2,
            stride: 2,
            normalised: !1
        },
        sint8x4: {
            size: 4,
            stride: 4,
            normalised: !1
        },
        unorm8x2: {
            size: 2,
            stride: 2,
            normalised: !0
        },
        unorm8x4: {
            size: 4,
            stride: 4,
            normalised: !0
        },
        snorm8x2: {
            size: 2,
            stride: 2,
            normalised: !0
        },
        snorm8x4: {
            size: 4,
            stride: 4,
            normalised: !0
        },
        uint16x2: {
            size: 2,
            stride: 4,
            normalised: !1
        },
        uint16x4: {
            size: 4,
            stride: 8,
            normalised: !1
        },
        sint16x2: {
            size: 2,
            stride: 4,
            normalised: !1
        },
        sint16x4: {
            size: 4,
            stride: 8,
            normalised: !1
        },
        unorm16x2: {
            size: 2,
            stride: 4,
            normalised: !0
        },
        unorm16x4: {
            size: 4,
            stride: 8,
            normalised: !0
        },
        snorm16x2: {
            size: 2,
            stride: 4,
            normalised: !0
        },
        snorm16x4: {
            size: 4,
            stride: 8,
            normalised: !0
        },
        float16x2: {
            size: 2,
            stride: 4,
            normalised: !1
        },
        float16x4: {
            size: 4,
            stride: 8,
            normalised: !1
        },
        float32: {
            size: 1,
            stride: 4,
            normalised: !1
        },
        float32x2: {
            size: 2,
            stride: 8,
            normalised: !1
        },
        float32x3: {
            size: 3,
            stride: 12,
            normalised: !1
        },
        float32x4: {
            size: 4,
            stride: 16,
            normalised: !1
        },
        uint32: {
            size: 1,
            stride: 4,
            normalised: !1
        },
        uint32x2: {
            size: 2,
            stride: 8,
            normalised: !1
        },
        uint32x3: {
            size: 3,
            stride: 12,
            normalised: !1
        },
        uint32x4: {
            size: 4,
            stride: 16,
            normalised: !1
        },
        sint32: {
            size: 1,
            stride: 4,
            normalised: !1
        },
        sint32x2: {
            size: 2,
            stride: 8,
            normalised: !1
        },
        sint32x3: {
            size: 3,
            stride: 12,
            normalised: !1
        },
        sint32x4: {
            size: 4,
            stride: 16,
            normalised: !1
        }
    };
    Dr = function(i) {
        return Cd[i] ?? Cd.float32;
    };
    const CT = {
        f32: "float32",
        "vec2<f32>": "float32x2",
        "vec3<f32>": "float32x3",
        "vec4<f32>": "float32x4",
        vec2f: "float32x2",
        vec3f: "float32x3",
        vec4f: "float32x4",
        i32: "sint32",
        "vec2<i32>": "sint32x2",
        "vec3<i32>": "sint32x3",
        "vec4<i32>": "sint32x4",
        u32: "uint32",
        "vec2<u32>": "uint32x2",
        "vec3<u32>": "uint32x3",
        "vec4<u32>": "uint32x4",
        bool: "uint32",
        "vec2<bool>": "uint32x2",
        "vec3<bool>": "uint32x3",
        "vec4<bool>": "uint32x4"
    };
    function PT({ source: i, entryPoint: t }) {
        const e = {}, n = i.indexOf(`fn ${t}`);
        if (n !== -1) {
            const s = i.indexOf("->", n);
            if (s !== -1) {
                const r = i.substring(n, s), a = /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;
                let o;
                for(; (o = a.exec(r)) !== null;){
                    const c = CT[o[3]] ?? "float32";
                    e[o[2]] = {
                        location: parseInt(o[1], 10),
                        format: c,
                        stride: Dr(c).stride,
                        offset: 0,
                        instance: !1,
                        start: 0
                    };
                }
            }
        }
        return e;
    }
    function tc(i) {
        const t = /(^|[^/])@(group|binding)\(\d+\)[^;]+;/g, e = /@group\((\d+)\)/, n = /@binding\((\d+)\)/, s = /var(<[^>]+>)? (\w+)/, r = /:\s*(\w+)/, a = /struct\s+(\w+)\s*{([^}]+)}/g, o = /(\w+)\s*:\s*([\w\<\>]+)/g, c = /struct\s+(\w+)/, l = i.match(t)?.map((u)=>({
                group: parseInt(u.match(e)[1], 10),
                binding: parseInt(u.match(n)[1], 10),
                name: u.match(s)[2],
                isUniform: u.match(s)[1] === "<uniform>",
                type: u.match(r)[1]
            }));
        if (!l) return {
            groups: [],
            structs: []
        };
        const h = i.match(a)?.map((u)=>{
            const d = u.match(c)[1], f = u.match(o).reduce((_, g)=>{
                const [p, m] = g.split(":");
                return _[p.trim()] = m.trim(), _;
            }, {});
            return f ? {
                name: d,
                members: f
            } : null;
        }).filter(({ name: u })=>l.some((d)=>d.type === u)) ?? [];
        return {
            groups: l,
            structs: h
        };
    }
    var fr = ((i)=>(i[i.VERTEX = 1] = "VERTEX", i[i.FRAGMENT = 2] = "FRAGMENT", i[i.COMPUTE = 4] = "COMPUTE", i))(fr || {});
    function IT({ groups: i }) {
        const t = [];
        for(let e = 0; e < i.length; e++){
            const n = i[e];
            t[n.group] || (t[n.group] = []), n.isUniform ? t[n.group].push({
                binding: n.binding,
                visibility: fr.VERTEX | fr.FRAGMENT,
                buffer: {
                    type: "uniform"
                }
            }) : n.type === "sampler" ? t[n.group].push({
                binding: n.binding,
                visibility: fr.FRAGMENT,
                sampler: {
                    type: "filtering"
                }
            }) : n.type === "texture_2d" && t[n.group].push({
                binding: n.binding,
                visibility: fr.FRAGMENT,
                texture: {
                    sampleType: "float",
                    viewDimension: "2d",
                    multisampled: !1
                }
            });
        }
        return t;
    }
    function DT({ groups: i }) {
        const t = [];
        for(let e = 0; e < i.length; e++){
            const n = i[e];
            t[n.group] || (t[n.group] = {}), t[n.group][n.name] = n.binding;
        }
        return t;
    }
    function LT(i, t) {
        const e = new Set, n = new Set, s = [
            ...i.structs,
            ...t.structs
        ].filter((a)=>e.has(a.name) ? !1 : (e.add(a.name), !0)), r = [
            ...i.groups,
            ...t.groups
        ].filter((a)=>{
            const o = `${a.name}-${a.binding}`;
            return n.has(o) ? !1 : (n.add(o), !0);
        });
        return {
            structs: s,
            groups: r
        };
    }
    const ec = Object.create(null);
    qs = class {
        constructor(t){
            this._layoutKey = 0, this._attributeLocationsKey = 0;
            const { fragment: e, vertex: n, layout: s, gpuLayout: r, name: a } = t;
            if (this.name = a, this.fragment = e, this.vertex = n, e.source === n.source) {
                const o = tc(e.source);
                this.structsAndGroups = o;
            } else {
                const o = tc(n.source), c = tc(e.source);
                this.structsAndGroups = LT(o, c);
            }
            this.layout = s ?? DT(this.structsAndGroups), this.gpuLayout = r ?? IT(this.structsAndGroups), this.autoAssignGlobalUniforms = this.layout[0]?.globalUniforms !== void 0, this.autoAssignLocalUniforms = this.layout[1]?.localUniforms !== void 0, this._generateProgramKey();
        }
        _generateProgramKey() {
            const { vertex: t, fragment: e } = this, n = t.source + e.source + t.entryPoint + e.entryPoint;
            this._layoutKey = uh(n, "program");
        }
        get attributeData() {
            return this._attributeData ?? (this._attributeData = PT(this.vertex)), this._attributeData;
        }
        destroy() {
            this.gpuLayout = null, this.layout = null, this.structsAndGroups = null, this.fragment = null, this.vertex = null;
        }
        static from(t) {
            const e = `${t.vertex.source}:${t.fragment.source}:${t.fragment.entryPoint}:${t.vertex.entryPoint}`;
            return ec[e] || (ec[e] = new qs(t)), ec[e];
        }
    };
    const Gp = [
        "f32",
        "i32",
        "vec2<f32>",
        "vec3<f32>",
        "vec4<f32>",
        "mat2x2<f32>",
        "mat3x3<f32>",
        "mat4x4<f32>",
        "mat3x2<f32>",
        "mat4x2<f32>",
        "mat2x3<f32>",
        "mat4x3<f32>",
        "mat2x4<f32>",
        "mat3x4<f32>",
        "vec2<i32>",
        "vec3<i32>",
        "vec4<i32>"
    ], UT = Gp.reduce((i, t)=>(i[t] = !0, i), {});
    function NT(i, t) {
        switch(i){
            case "f32":
                return 0;
            case "vec2<f32>":
                return new Float32Array(2 * t);
            case "vec3<f32>":
                return new Float32Array(3 * t);
            case "vec4<f32>":
                return new Float32Array(4 * t);
            case "mat2x2<f32>":
                return new Float32Array([
                    1,
                    0,
                    0,
                    1
                ]);
            case "mat3x3<f32>":
                return new Float32Array([
                    1,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    1
                ]);
            case "mat4x4<f32>":
                return new Float32Array([
                    1,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    1
                ]);
        }
        return null;
    }
    const Hp = class zp {
        constructor(t, e){
            this._touched = 0, this.uid = pe("uniform"), this._resourceType = "uniformGroup", this._resourceId = pe("resource"), this.isUniformGroup = !0, this._dirtyId = 0, this.destroyed = !1, e = {
                ...zp.defaultOptions,
                ...e
            }, this.uniformStructures = t;
            const n = {};
            for(const s in t){
                const r = t[s];
                if (r.name = s, r.size = r.size ?? 1, !UT[r.type]) throw new Error(`Uniform type ${r.type} is not supported. Supported uniform types are: ${Gp.join(", ")}`);
                r.value ?? (r.value = NT(r.type, r.size)), n[s] = r.value;
            }
            this.uniforms = n, this._dirtyId = 1, this.ubo = e.ubo, this.isStatic = e.isStatic, this._signature = uh(Object.keys(n).map((s)=>`${s}-${t[s].type}`).join("-"), "uniform-group");
        }
        update() {
            this._dirtyId++;
        }
    };
    Hp.defaultOptions = {
        ubo: !1,
        isStatic: !1
    };
    Ki = Hp;
    vr = class {
        constructor(t){
            this.resources = Object.create(null), this._dirty = !0;
            let e = 0;
            for(const n in t){
                const s = t[n];
                this.setResource(s, e++);
            }
            this._updateKey();
        }
        _updateKey() {
            if (!this._dirty) return;
            this._dirty = !1;
            const t = [];
            let e = 0;
            for(const n in this.resources)t[e++] = this.resources[n]._resourceId;
            this._key = t.join("|");
        }
        setResource(t, e) {
            const n = this.resources[e];
            t !== n && (n && t.off?.("change", this.onResourceChange, this), t.on?.("change", this.onResourceChange, this), this.resources[e] = t, this._dirty = !0);
        }
        getResource(t) {
            return this.resources[t];
        }
        _touch(t) {
            const e = this.resources;
            for(const n in e)e[n]._touched = t;
        }
        destroy() {
            const t = this.resources;
            for(const e in t)t[e].off?.("change", this.onResourceChange, this);
            this.resources = null;
        }
        onResourceChange(t) {
            if (this._dirty = !0, t.destroyed) {
                const e = this.resources;
                for(const n in e)e[n] === t && (e[n] = null);
            } else this._updateKey();
        }
    };
    Yi = ((i)=>(i[i.WEBGL = 1] = "WEBGL", i[i.WEBGPU = 2] = "WEBGPU", i[i.BOTH = 3] = "BOTH", i))(Yi || {});
    Zi = class extends In {
        constructor(t){
            super(), this.uid = pe("shader"), this._uniformBindMap = Object.create(null), this._ownedBindGroups = [];
            let { gpuProgram: e, glProgram: n, groups: s, resources: r, compatibleRenderers: a, groupMap: o } = t;
            this.gpuProgram = e, this.glProgram = n, a === void 0 && (a = 0, e && (a |= Yi.WEBGPU), n && (a |= Yi.WEBGL)), this.compatibleRenderers = a;
            const c = {};
            if (!r && !s && (r = {}), r && s) throw new Error("[Shader] Cannot have both resources and groups");
            if (!e && s && !o) throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");
            if (!e && s && o) for(const l in o)for(const h in o[l]){
                const u = o[l][h];
                c[u] = {
                    group: l,
                    binding: h,
                    name: u
                };
            }
            else if (e && s && !o) {
                const l = e.structsAndGroups.groups;
                o = {}, l.forEach((h)=>{
                    o[h.group] = o[h.group] || {}, o[h.group][h.binding] = h.name, c[h.name] = h;
                });
            } else if (r) {
                s = {}, o = {}, e && e.structsAndGroups.groups.forEach((u)=>{
                    o[u.group] = o[u.group] || {}, o[u.group][u.binding] = u.name, c[u.name] = u;
                });
                let l = 0;
                for(const h in r)c[h] || (s[99] || (s[99] = new vr, this._ownedBindGroups.push(s[99])), c[h] = {
                    group: 99,
                    binding: l,
                    name: h
                }, o[99] = o[99] || {}, o[99][l] = h, l++);
                for(const h in r){
                    const u = h;
                    let d = r[h];
                    !d.source && !d._resourceType && (d = new Ki(d));
                    const f = c[u];
                    f && (s[f.group] || (s[f.group] = new vr, this._ownedBindGroups.push(s[f.group])), s[f.group].setResource(d, f.binding));
                }
            }
            this.groups = s, this._uniformBindMap = o, this.resources = this._buildResourceAccessor(s, c);
        }
        addResource(t, e, n) {
            var s, r;
            (s = this._uniformBindMap)[e] || (s[e] = {}), (r = this._uniformBindMap[e])[n] || (r[n] = t), this.groups[e] || (this.groups[e] = new vr, this._ownedBindGroups.push(this.groups[e]));
        }
        _buildResourceAccessor(t, e) {
            const n = {};
            for(const s in e){
                const r = e[s];
                Object.defineProperty(n, r.name, {
                    get () {
                        return t[r.group].getResource(r.binding);
                    },
                    set (a) {
                        t[r.group].setResource(a, r.binding);
                    }
                });
            }
            return n;
        }
        destroy(t = !1) {
            this.emit("destroy", this), t && (this.gpuProgram?.destroy(), this.glProgram?.destroy()), this.gpuProgram = null, this.glProgram = null, this.removeAllListeners(), this._uniformBindMap = null, this._ownedBindGroups.forEach((e)=>{
                e.destroy();
            }), this._ownedBindGroups = null, this.resources = null, this.groups = null;
        }
        static from(t) {
            const { gpu: e, gl: n, ...s } = t;
            let r, a;
            return e && (r = qs.from(e)), n && (a = Br.from(n)), new Zi({
                gpuProgram: r,
                glProgram: a,
                ...s
            });
        }
    };
    const BT = {
        normal: 0,
        add: 1,
        multiply: 2,
        screen: 3,
        overlay: 4,
        erase: 5,
        "normal-npm": 6,
        "add-npm": 7,
        "screen-npm": 8,
        min: 9,
        max: 10
    }, nc = 0, ic = 1, sc = 2, rc = 3, ac = 4, oc = 5, bl = class Vp {
        constructor(){
            this.data = 0, this.blendMode = "normal", this.polygonOffset = 0, this.blend = !0, this.depthMask = !0;
        }
        get blend() {
            return !!(this.data & 1 << nc);
        }
        set blend(t) {
            !!(this.data & 1 << nc) !== t && (this.data ^= 1 << nc);
        }
        get offsets() {
            return !!(this.data & 1 << ic);
        }
        set offsets(t) {
            !!(this.data & 1 << ic) !== t && (this.data ^= 1 << ic);
        }
        set cullMode(t) {
            if (t === "none") {
                this.culling = !1;
                return;
            }
            this.culling = !0, this.clockwiseFrontFace = t === "front";
        }
        get cullMode() {
            return this.culling ? this.clockwiseFrontFace ? "front" : "back" : "none";
        }
        get culling() {
            return !!(this.data & 1 << sc);
        }
        set culling(t) {
            !!(this.data & 1 << sc) !== t && (this.data ^= 1 << sc);
        }
        get depthTest() {
            return !!(this.data & 1 << rc);
        }
        set depthTest(t) {
            !!(this.data & 1 << rc) !== t && (this.data ^= 1 << rc);
        }
        get depthMask() {
            return !!(this.data & 1 << oc);
        }
        set depthMask(t) {
            !!(this.data & 1 << oc) !== t && (this.data ^= 1 << oc);
        }
        get clockwiseFrontFace() {
            return !!(this.data & 1 << ac);
        }
        set clockwiseFrontFace(t) {
            !!(this.data & 1 << ac) !== t && (this.data ^= 1 << ac);
        }
        get blendMode() {
            return this._blendMode;
        }
        set blendMode(t) {
            this.blend = t !== "none", this._blendMode = t, this._blendModeId = BT[t] || 0;
        }
        get polygonOffset() {
            return this._polygonOffset;
        }
        set polygonOffset(t) {
            this.offsets = !!t, this._polygonOffset = t;
        }
        toString() {
            return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
        }
        static for2d() {
            const t = new Vp;
            return t.depthTest = !1, t.blend = !0, t;
        }
    };
    bl.default2d = bl.for2d();
    Fr = bl;
    const Wp = class Sl extends Zi {
        constructor(t){
            t = {
                ...Sl.defaultOptions,
                ...t
            }, super(t), this.enabled = !0, this._state = Fr.for2d(), this.blendMode = t.blendMode, this.padding = t.padding, typeof t.antialias == "boolean" ? this.antialias = t.antialias ? "on" : "off" : this.antialias = t.antialias, this.resolution = t.resolution, this.blendRequired = t.blendRequired, this.clipToViewport = t.clipToViewport, this.addResource("uTexture", 0, 1);
        }
        apply(t, e, n, s) {
            t.applyFilter(this, e, n, s);
        }
        get blendMode() {
            return this._state.blendMode;
        }
        set blendMode(t) {
            this._state.blendMode = t;
        }
        static from(t) {
            const { gpu: e, gl: n, ...s } = t;
            let r, a;
            return e && (r = qs.from(e)), n && (a = Br.from(n)), new Sl({
                gpuProgram: r,
                glProgram: a,
                ...s
            });
        }
    };
    Wp.defaultOptions = {
        blendMode: "normal",
        resolution: 1,
        padding: 0,
        antialias: "off",
        blendRequired: !1,
        clipToViewport: !0
    };
    let FT = Wp;
    const Ml = [];
    Be.handleByNamedList(st.Environment, Ml);
    async function OT(i) {
        if (!i) for(let t = 0; t < Ml.length; t++){
            const e = Ml[t];
            if (e.value.test()) {
                await e.value.load();
                return;
            }
        }
    }
    let rr;
    function Xp() {
        if (typeof rr == "boolean") return rr;
        try {
            rr = new Function("param1", "param2", "param3", "return param1[param2] === param3;")({
                a: "b"
            }, "a", "b") === !0;
        } catch  {
            rr = !1;
        }
        return rr;
    }
    var va = {
        exports: {}
    }, Pd;
    function kT() {
        if (Pd) return va.exports;
        Pd = 1, va.exports = i, va.exports.default = i;
        function i(b, C, A) {
            A = A || 2;
            var U = C && C.length, B = U ? C[0] * A : b.length, V = t(b, 0, B, A, !0), q = [];
            if (!V || V.next === V.prev) return q;
            var et, H, $, ot, it, lt, wt;
            if (U && (V = c(b, C, V, A)), b.length > 80 * A) {
                et = $ = b[0], H = ot = b[1];
                for(var ht = A; ht < B; ht += A)it = b[ht], lt = b[ht + 1], it < et && (et = it), lt < H && (H = lt), it > $ && ($ = it), lt > ot && (ot = lt);
                wt = Math.max($ - et, ot - H), wt = wt !== 0 ? 32767 / wt : 0;
            }
            return n(V, q, A, et, H, wt, 0), q;
        }
        function t(b, C, A, U, B) {
            var V, q;
            if (B === nt(b, C, A, U) > 0) for(V = C; V < A; V += U)q = j(V, b[V], b[V + 1], q);
            else for(V = A - U; V >= C; V -= U)q = j(V, b[V], b[V + 1], q);
            return q && v(q, q.next) && (z(q), q = q.next), q;
        }
        function e(b, C) {
            if (!b) return b;
            C || (C = b);
            var A = b, U;
            do if (U = !1, !A.steiner && (v(A, A.next) || y(A.prev, A, A.next) === 0)) {
                if (z(A), A = C = A.prev, A === A.next) break;
                U = !0;
            } else A = A.next;
            while (U || A !== C);
            return C;
        }
        function n(b, C, A, U, B, V, q) {
            if (b) {
                !q && V && f(b, U, B, V);
                for(var et = b, H, $; b.prev !== b.next;){
                    if (H = b.prev, $ = b.next, V ? r(b, U, B, V) : s(b)) {
                        C.push(H.i / A | 0), C.push(b.i / A | 0), C.push($.i / A | 0), z(b), b = $.next, et = $.next;
                        continue;
                    }
                    if (b = $, b === et) {
                        q ? q === 1 ? (b = a(e(b), C, A), n(b, C, A, U, B, V, 2)) : q === 2 && o(b, C, A, U, B, V) : n(e(b), C, A, U, B, V, 1);
                        break;
                    }
                }
            }
        }
        function s(b) {
            var C = b.prev, A = b, U = b.next;
            if (y(C, A, U) >= 0) return !1;
            for(var B = C.x, V = A.x, q = U.x, et = C.y, H = A.y, $ = U.y, ot = B < V ? B < q ? B : q : V < q ? V : q, it = et < H ? et < $ ? et : $ : H < $ ? H : $, lt = B > V ? B > q ? B : q : V > q ? V : q, wt = et > H ? et > $ ? et : $ : H > $ ? H : $, ht = U.next; ht !== C;){
                if (ht.x >= ot && ht.x <= lt && ht.y >= it && ht.y <= wt && m(B, et, V, H, q, $, ht.x, ht.y) && y(ht.prev, ht, ht.next) >= 0) return !1;
                ht = ht.next;
            }
            return !0;
        }
        function r(b, C, A, U) {
            var B = b.prev, V = b, q = b.next;
            if (y(B, V, q) >= 0) return !1;
            for(var et = B.x, H = V.x, $ = q.x, ot = B.y, it = V.y, lt = q.y, wt = et < H ? et < $ ? et : $ : H < $ ? H : $, ht = ot < it ? ot < lt ? ot : lt : it < lt ? it : lt, ee = et > H ? et > $ ? et : $ : H > $ ? H : $, Wt = ot > it ? ot > lt ? ot : lt : it > lt ? it : lt, Lt = g(wt, ht, C, A, U), L = g(ee, Wt, C, A, U), Ct = b.prevZ, gt = b.nextZ; Ct && Ct.z >= Lt && gt && gt.z <= L;){
                if (Ct.x >= wt && Ct.x <= ee && Ct.y >= ht && Ct.y <= Wt && Ct !== B && Ct !== q && m(et, ot, H, it, $, lt, Ct.x, Ct.y) && y(Ct.prev, Ct, Ct.next) >= 0 || (Ct = Ct.prevZ, gt.x >= wt && gt.x <= ee && gt.y >= ht && gt.y <= Wt && gt !== B && gt !== q && m(et, ot, H, it, $, lt, gt.x, gt.y) && y(gt.prev, gt, gt.next) >= 0)) return !1;
                gt = gt.nextZ;
            }
            for(; Ct && Ct.z >= Lt;){
                if (Ct.x >= wt && Ct.x <= ee && Ct.y >= ht && Ct.y <= Wt && Ct !== B && Ct !== q && m(et, ot, H, it, $, lt, Ct.x, Ct.y) && y(Ct.prev, Ct, Ct.next) >= 0) return !1;
                Ct = Ct.prevZ;
            }
            for(; gt && gt.z <= L;){
                if (gt.x >= wt && gt.x <= ee && gt.y >= ht && gt.y <= Wt && gt !== B && gt !== q && m(et, ot, H, it, $, lt, gt.x, gt.y) && y(gt.prev, gt, gt.next) >= 0) return !1;
                gt = gt.nextZ;
            }
            return !0;
        }
        function a(b, C, A) {
            var U = b;
            do {
                var B = U.prev, V = U.next.next;
                !v(B, V) && I(B, U, U.next, V) && E(B, V) && E(V, B) && (C.push(B.i / A | 0), C.push(U.i / A | 0), C.push(V.i / A | 0), z(U), z(U.next), U = b = V), U = U.next;
            }while (U !== b);
            return e(U);
        }
        function o(b, C, A, U, B, V) {
            var q = b;
            do {
                for(var et = q.next.next; et !== q.prev;){
                    if (q.i !== et.i && x(q, et)) {
                        var H = D(q, et);
                        q = e(q, q.next), H = e(H, H.next), n(q, C, A, U, B, V, 0), n(H, C, A, U, B, V, 0);
                        return;
                    }
                    et = et.next;
                }
                q = q.next;
            }while (q !== b);
        }
        function c(b, C, A, U) {
            var B = [], V, q, et, H, $;
            for(V = 0, q = C.length; V < q; V++)et = C[V] * U, H = V < q - 1 ? C[V + 1] * U : b.length, $ = t(b, et, H, U, !1), $ === $.next && ($.steiner = !0), B.push(p($));
            for(B.sort(l), V = 0; V < B.length; V++)A = h(B[V], A);
            return A;
        }
        function l(b, C) {
            return b.x - C.x;
        }
        function h(b, C) {
            var A = u(b, C);
            if (!A) return C;
            var U = D(A, b);
            return e(U, U.next), e(A, A.next);
        }
        function u(b, C) {
            var A = C, U = b.x, B = b.y, V = -1 / 0, q;
            do {
                if (B <= A.y && B >= A.next.y && A.next.y !== A.y) {
                    var et = A.x + (B - A.y) * (A.next.x - A.x) / (A.next.y - A.y);
                    if (et <= U && et > V && (V = et, q = A.x < A.next.x ? A : A.next, et === U)) return q;
                }
                A = A.next;
            }while (A !== C);
            if (!q) return null;
            var H = q, $ = q.x, ot = q.y, it = 1 / 0, lt;
            A = q;
            do U >= A.x && A.x >= $ && U !== A.x && m(B < ot ? U : V, B, $, ot, B < ot ? V : U, B, A.x, A.y) && (lt = Math.abs(B - A.y) / (U - A.x), E(A, b) && (lt < it || lt === it && (A.x > q.x || A.x === q.x && d(q, A))) && (q = A, it = lt)), A = A.next;
            while (A !== H);
            return q;
        }
        function d(b, C) {
            return y(b.prev, b, C.prev) < 0 && y(C.next, b, b.next) < 0;
        }
        function f(b, C, A, U) {
            var B = b;
            do B.z === 0 && (B.z = g(B.x, B.y, C, A, U)), B.prevZ = B.prev, B.nextZ = B.next, B = B.next;
            while (B !== b);
            B.prevZ.nextZ = null, B.prevZ = null, _(B);
        }
        function _(b) {
            var C, A, U, B, V, q, et, H, $ = 1;
            do {
                for(A = b, b = null, V = null, q = 0; A;){
                    for(q++, U = A, et = 0, C = 0; C < $ && (et++, U = U.nextZ, !!U); C++);
                    for(H = $; et > 0 || H > 0 && U;)et !== 0 && (H === 0 || !U || A.z <= U.z) ? (B = A, A = A.nextZ, et--) : (B = U, U = U.nextZ, H--), V ? V.nextZ = B : b = B, B.prevZ = V, V = B;
                    A = U;
                }
                V.nextZ = null, $ *= 2;
            }while (q > 1);
            return b;
        }
        function g(b, C, A, U, B) {
            return b = (b - A) * B | 0, C = (C - U) * B | 0, b = (b | b << 8) & 16711935, b = (b | b << 4) & 252645135, b = (b | b << 2) & 858993459, b = (b | b << 1) & 1431655765, C = (C | C << 8) & 16711935, C = (C | C << 4) & 252645135, C = (C | C << 2) & 858993459, C = (C | C << 1) & 1431655765, b | C << 1;
        }
        function p(b) {
            var C = b, A = b;
            do (C.x < A.x || C.x === A.x && C.y < A.y) && (A = C), C = C.next;
            while (C !== b);
            return A;
        }
        function m(b, C, A, U, B, V, q, et) {
            return (B - q) * (C - et) >= (b - q) * (V - et) && (b - q) * (U - et) >= (A - q) * (C - et) && (A - q) * (V - et) >= (B - q) * (U - et);
        }
        function x(b, C) {
            return b.next.i !== C.i && b.prev.i !== C.i && !N(b, C) && (E(b, C) && E(C, b) && S(b, C) && (y(b.prev, b, C.prev) || y(b, C.prev, C)) || v(b, C) && y(b.prev, b, b.next) > 0 && y(C.prev, C, C.next) > 0);
        }
        function y(b, C, A) {
            return (C.y - b.y) * (A.x - C.x) - (C.x - b.x) * (A.y - C.y);
        }
        function v(b, C) {
            return b.x === C.x && b.y === C.y;
        }
        function I(b, C, A, U) {
            var B = R(y(b, C, A)), V = R(y(b, C, U)), q = R(y(A, U, b)), et = R(y(A, U, C));
            return !!(B !== V && q !== et || B === 0 && w(b, A, C) || V === 0 && w(b, U, C) || q === 0 && w(A, b, U) || et === 0 && w(A, C, U));
        }
        function w(b, C, A) {
            return C.x <= Math.max(b.x, A.x) && C.x >= Math.min(b.x, A.x) && C.y <= Math.max(b.y, A.y) && C.y >= Math.min(b.y, A.y);
        }
        function R(b) {
            return b > 0 ? 1 : b < 0 ? -1 : 0;
        }
        function N(b, C) {
            var A = b;
            do {
                if (A.i !== b.i && A.next.i !== b.i && A.i !== C.i && A.next.i !== C.i && I(A, A.next, b, C)) return !0;
                A = A.next;
            }while (A !== b);
            return !1;
        }
        function E(b, C) {
            return y(b.prev, b, b.next) < 0 ? y(b, C, b.next) >= 0 && y(b, b.prev, C) >= 0 : y(b, C, b.prev) < 0 || y(b, b.next, C) < 0;
        }
        function S(b, C) {
            var A = b, U = !1, B = (b.x + C.x) / 2, V = (b.y + C.y) / 2;
            do A.y > V != A.next.y > V && A.next.y !== A.y && B < (A.next.x - A.x) * (V - A.y) / (A.next.y - A.y) + A.x && (U = !U), A = A.next;
            while (A !== b);
            return U;
        }
        function D(b, C) {
            var A = new K(b.i, b.x, b.y), U = new K(C.i, C.x, C.y), B = b.next, V = C.prev;
            return b.next = C, C.prev = b, A.next = B, B.prev = A, U.next = A, A.prev = U, V.next = U, U.prev = V, U;
        }
        function j(b, C, A, U) {
            var B = new K(b, C, A);
            return U ? (B.next = U.next, B.prev = U, U.next.prev = B, U.next = B) : (B.prev = B, B.next = B), B;
        }
        function z(b) {
            b.next.prev = b.prev, b.prev.next = b.next, b.prevZ && (b.prevZ.nextZ = b.nextZ), b.nextZ && (b.nextZ.prevZ = b.prevZ);
        }
        function K(b, C, A) {
            this.i = b, this.x = C, this.y = A, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
        }
        i.deviation = function(b, C, A, U) {
            var B = C && C.length, V = B ? C[0] * A : b.length, q = Math.abs(nt(b, 0, V, A));
            if (B) for(var et = 0, H = C.length; et < H; et++){
                var $ = C[et] * A, ot = et < H - 1 ? C[et + 1] * A : b.length;
                q -= Math.abs(nt(b, $, ot, A));
            }
            var it = 0;
            for(et = 0; et < U.length; et += 3){
                var lt = U[et] * A, wt = U[et + 1] * A, ht = U[et + 2] * A;
                it += Math.abs((b[lt] - b[ht]) * (b[wt + 1] - b[lt + 1]) - (b[lt] - b[wt]) * (b[ht + 1] - b[lt + 1]));
            }
            return q === 0 && it === 0 ? 0 : Math.abs((it - q) / q);
        };
        function nt(b, C, A, U) {
            for(var B = 0, V = C, q = A - U; V < A; V += U)B += (b[q] - b[V]) * (b[V + 1] + b[q + 1]), q = V;
            return B;
        }
        return i.flatten = function(b) {
            for(var C = b[0][0].length, A = {
                vertices: [],
                holes: [],
                dimensions: C
            }, U = 0, B = 0; B < b.length; B++){
                for(var V = 0; V < b[B].length; V++)for(var q = 0; q < C; q++)A.vertices.push(b[B][V][q]);
                B > 0 && (U += b[B - 1].length, A.holes.push(U));
            }
            return A;
        }, va.exports;
    }
    var GT = kT();
    const HT = ih(GT);
    var vi = ((i)=>(i[i.NONE = 0] = "NONE", i[i.COLOR = 16384] = "COLOR", i[i.STENCIL = 1024] = "STENCIL", i[i.DEPTH = 256] = "DEPTH", i[i.COLOR_DEPTH = 16640] = "COLOR_DEPTH", i[i.COLOR_STENCIL = 17408] = "COLOR_STENCIL", i[i.DEPTH_STENCIL = 1280] = "DEPTH_STENCIL", i[i.ALL = 17664] = "ALL", i))(vi || {});
    class Yp {
        constructor(t){
            this.items = [], this._name = t;
        }
        emit(t, e, n, s, r, a, o, c) {
            const { name: l, items: h } = this;
            for(let u = 0, d = h.length; u < d; u++)h[u][l](t, e, n, s, r, a, o, c);
            return this;
        }
        add(t) {
            return t[this._name] && (this.remove(t), this.items.push(t)), this;
        }
        remove(t) {
            const e = this.items.indexOf(t);
            return e !== -1 && this.items.splice(e, 1), this;
        }
        contains(t) {
            return this.items.indexOf(t) !== -1;
        }
        removeAll() {
            return this.items.length = 0, this;
        }
        destroy() {
            this.removeAll(), this.items = null, this._name = null;
        }
        get empty() {
            return this.items.length === 0;
        }
        get name() {
            return this._name;
        }
    }
    const zT = [
        "init",
        "destroy",
        "contextChange",
        "resolutionChange",
        "resetState",
        "renderEnd",
        "renderStart",
        "render",
        "update",
        "postrender",
        "prerender"
    ], qp = class jp extends In {
        constructor(t){
            super(), this.runners = Object.create(null), this.renderPipes = Object.create(null), this._initOptions = {}, this._systemsHash = Object.create(null), this.type = t.type, this.name = t.name, this.config = t;
            const e = [
                ...zT,
                ...this.config.runners ?? []
            ];
            this._addRunners(...e), this._unsafeEvalCheck();
        }
        async init(t = {}) {
            const e = t.skipExtensionImports === !0 ? !0 : t.manageImports === !1;
            await OT(e), this._addSystems(this.config.systems), this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);
            for(const n in this._systemsHash)t = {
                ...this._systemsHash[n].constructor.defaultOptions,
                ...t
            };
            t = {
                ...jp.defaultOptions,
                ...t
            }, this._roundPixels = t.roundPixels ? 1 : 0;
            for(let n = 0; n < this.runners.init.items.length; n++)await this.runners.init.items[n].init(t);
            this._initOptions = t;
        }
        render(t, e) {
            let n = t;
            if (n instanceof mn && (n = {
                container: n
            }, e && (ue(be, "passing a second argument is deprecated, please use render options instead"), n.target = e.renderTexture)), n.target || (n.target = this.view.renderTarget), n.target === this.view.renderTarget && (this._lastObjectRendered = n.container, n.clearColor ?? (n.clearColor = this.background.colorRgba), n.clear ?? (n.clear = this.background.clearBeforeRender)), n.clearColor) {
                const s = Array.isArray(n.clearColor) && n.clearColor.length === 4;
                n.clearColor = s ? n.clearColor : Pe.shared.setValue(n.clearColor).toArray();
            }
            n.transform || (n.container.updateLocalTransform(), n.transform = n.container.localTransform), n.container.enableRenderGroup(), this.runners.prerender.emit(n), this.runners.renderStart.emit(n), this.runners.render.emit(n), this.runners.renderEnd.emit(n), this.runners.postrender.emit(n);
        }
        resize(t, e, n) {
            const s = this.view.resolution;
            this.view.resize(t, e, n), this.emit("resize", this.view.screen.width, this.view.screen.height, this.view.resolution), n !== void 0 && n !== s && this.runners.resolutionChange.emit(n);
        }
        clear(t = {}) {
            const e = this;
            t.target || (t.target = e.renderTarget.renderTarget), t.clearColor || (t.clearColor = this.background.colorRgba), t.clear ?? (t.clear = vi.ALL);
            const { clear: n, clearColor: s, target: r } = t;
            Pe.shared.setValue(s ?? this.background.colorRgba), e.renderTarget.clear(r, n, Pe.shared.toArray());
        }
        get resolution() {
            return this.view.resolution;
        }
        set resolution(t) {
            this.view.resolution = t, this.runners.resolutionChange.emit(t);
        }
        get width() {
            return this.view.texture.frame.width;
        }
        get height() {
            return this.view.texture.frame.height;
        }
        get canvas() {
            return this.view.canvas;
        }
        get lastObjectRendered() {
            return this._lastObjectRendered;
        }
        get renderingToScreen() {
            return this.renderTarget.renderingToScreen;
        }
        get screen() {
            return this.view.screen;
        }
        _addRunners(...t) {
            t.forEach((e)=>{
                this.runners[e] = new Yp(e);
            });
        }
        _addSystems(t) {
            let e;
            for(e in t){
                const n = t[e];
                this._addSystem(n.value, n.name);
            }
        }
        _addSystem(t, e) {
            const n = new t(this);
            if (this[e]) throw new Error(`Whoops! The name "${e}" is already in use`);
            this[e] = n, this._systemsHash[e] = n;
            for(const s in this.runners)this.runners[s].add(n);
            return this;
        }
        _addPipes(t, e) {
            const n = e.reduce((s, r)=>(s[r.name] = r.value, s), {});
            t.forEach((s)=>{
                const r = s.value, a = s.name, o = n[a];
                this.renderPipes[a] = new r(this, o ? new o : null);
            });
        }
        destroy(t = !1) {
            this.runners.destroy.items.reverse(), this.runners.destroy.emit(t), Object.values(this.runners).forEach((e)=>{
                e.destroy();
            }), this._systemsHash = null, this.renderPipes = null;
        }
        generateTexture(t) {
            return this.textureGenerator.generateTexture(t);
        }
        get roundPixels() {
            return !!this._roundPixels;
        }
        _unsafeEvalCheck() {
            if (!Xp()) throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
        }
        resetState() {
            this.runners.resetState.emit();
        }
    };
    qp.defaultOptions = {
        resolution: 1,
        failIfMajorPerformanceCaveat: !1,
        roundPixels: !1
    };
    let VT = qp;
    const Tl = "8.9.1";
    st.Application;
    class $p {
        constructor(t){
            this._renderer = t;
        }
        init() {
            globalThis.__PIXI_RENDERER_INIT__?.(this._renderer, Tl);
        }
        destroy() {
            this._renderer = null;
        }
    }
    $p.extension = {
        type: [
            st.WebGLSystem,
            st.WebGPUSystem
        ],
        name: "initHook",
        priority: -10
    };
    const Id = [
        {
            offset: 0,
            color: "white"
        },
        {
            offset: 1,
            color: "black"
        }
    ], dh = class El {
        constructor(...t){
            this.uid = pe("fillGradient"), this.type = "linear", this.colorStops = [];
            let e = WT(t);
            e = {
                ...e.type === "radial" ? El.defaultRadialOptions : El.defaultLinearOptions,
                ...hp(e)
            }, this._textureSize = e.textureSize, e.type === "radial" ? (this.center = e.center, this.outerCenter = e.outerCenter ?? this.center, this.innerRadius = e.innerRadius, this.outerRadius = e.outerRadius, this.scale = e.scale, this.rotation = e.rotation) : (this.start = e.start, this.end = e.end), this.textureSpace = e.textureSpace, this.type = e.type, e.colorStops.forEach((s)=>{
                this.addColorStop(s.offset, s.color);
            });
        }
        addColorStop(t, e) {
            return this.colorStops.push({
                offset: t,
                color: Pe.shared.setValue(e).toHexa()
            }), this;
        }
        buildLinearGradient() {
            if (this.texture) return;
            const t = this.colorStops.length ? this.colorStops : Id, e = this._textureSize, { canvas: n, context: s } = Ld(e, 1), r = s.createLinearGradient(0, 0, this._textureSize, 0);
            Dd(r, t), s.fillStyle = r, s.fillRect(0, 0, e, 1), this.texture = new Ot({
                source: new Xa({
                    resource: n
                })
            });
            const { x: a, y: o } = this.start, { x: c, y: l } = this.end, h = new Ft, u = c - a, d = l - o, f = Math.sqrt(u * u + d * d), _ = Math.atan2(d, u);
            h.scale(f / e, 1), h.rotate(_), h.translate(a, o), this.textureSpace === "local" && h.scale(e, e), this.transform = h;
        }
        buildGradient() {
            this.type === "linear" ? this.buildLinearGradient() : this.buildRadialGradient();
        }
        buildRadialGradient() {
            if (this.texture) return;
            const t = this.colorStops.length ? this.colorStops : Id, e = this._textureSize, { canvas: n, context: s } = Ld(e, e), { x: r, y: a } = this.center, { x: o, y: c } = this.outerCenter, l = this.innerRadius, h = this.outerRadius, u = o - h, d = c - h, f = e / (h * 2), _ = (r - u) * f, g = (a - d) * f, p = s.createRadialGradient(_, g, l * f, (o - u) * f, (c - d) * f, h * f);
            Dd(p, t), s.fillStyle = t[t.length - 1].color, s.fillRect(0, 0, e, e), s.fillStyle = p, s.translate(_, g), s.rotate(this.rotation), s.scale(1, this.scale), s.translate(-_, -g), s.fillRect(0, 0, e, e), this.texture = new Ot({
                source: new Xa({
                    resource: n,
                    addressModeU: "clamp-to-edge",
                    addressModeV: "clamp-to-edge"
                })
            });
            const m = new Ft;
            m.scale(1 / f, 1 / f), m.translate(u, d), this.textureSpace === "local" && m.scale(e, e), this.transform = m;
        }
        get styleKey() {
            return this.uid;
        }
        destroy() {
            this.texture?.destroy(!0), this.texture = null;
        }
    };
    dh.defaultLinearOptions = {
        start: {
            x: 0,
            y: 0
        },
        end: {
            x: 0,
            y: 1
        },
        colorStops: [],
        textureSpace: "local",
        type: "linear",
        textureSize: 256
    };
    dh.defaultRadialOptions = {
        center: {
            x: .5,
            y: .5
        },
        innerRadius: 0,
        outerRadius: .5,
        colorStops: [],
        scale: 1,
        textureSpace: "local",
        type: "radial",
        textureSize: 256
    };
    qi = dh;
    function Dd(i, t) {
        for(let e = 0; e < t.length; e++){
            const n = t[e];
            i.addColorStop(n.offset, n.color);
        }
    }
    function Ld(i, t) {
        const e = $e.get().createCanvas(i, t), n = e.getContext("2d");
        return {
            canvas: e,
            context: n
        };
    }
    function WT(i) {
        let t = i[0] ?? {};
        return (typeof t == "number" || i[1]) && (ue("8.5.2", "use options object instead"), t = {
            type: "linear",
            start: {
                x: i[0],
                y: i[1]
            },
            end: {
                x: i[2],
                y: i[3]
            },
            textureSpace: i[4],
            textureSize: i[5] ?? qi.defaultLinearOptions.textureSize
        }), t;
    }
    const Ud = {
        repeat: {
            addressModeU: "repeat",
            addressModeV: "repeat"
        },
        "repeat-x": {
            addressModeU: "repeat",
            addressModeV: "clamp-to-edge"
        },
        "repeat-y": {
            addressModeU: "clamp-to-edge",
            addressModeV: "repeat"
        },
        "no-repeat": {
            addressModeU: "clamp-to-edge",
            addressModeV: "clamp-to-edge"
        }
    };
    fh = class {
        constructor(t, e){
            this.uid = pe("fillPattern"), this.transform = new Ft, this._styleKey = null, this.texture = t, this.transform.scale(1 / t.frame.width, 1 / t.frame.height), e && (t.source.style.addressModeU = Ud[e].addressModeU, t.source.style.addressModeV = Ud[e].addressModeV);
        }
        setTransform(t) {
            const e = this.texture;
            this.transform.copyFrom(t), this.transform.invert(), this.transform.scale(1 / e.frame.width, 1 / e.frame.height), this._styleKey = null;
        }
        get styleKey() {
            return this._styleKey ? this._styleKey : (this._styleKey = `fill-pattern-${this.uid}-${this.texture.uid}-${this.transform.toArray().join("-")}`, this._styleKey);
        }
    };
    var cc, Nd;
    function XT() {
        if (Nd) return cc;
        Nd = 1, cc = e;
        var i = {
            a: 7,
            c: 6,
            h: 1,
            l: 2,
            m: 2,
            q: 4,
            s: 4,
            t: 2,
            v: 1,
            z: 0
        }, t = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
        function e(r) {
            var a = [];
            return r.replace(t, function(o, c, l) {
                var h = c.toLowerCase();
                for(l = s(l), h == "m" && l.length > 2 && (a.push([
                    c
                ].concat(l.splice(0, 2))), h = "l", c = c == "m" ? "l" : "L");;){
                    if (l.length == i[h]) return l.unshift(c), a.push(l);
                    if (l.length < i[h]) throw new Error("malformed path data");
                    a.push([
                        c
                    ].concat(l.splice(0, i[h])));
                }
            }), a;
        }
        var n = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
        function s(r) {
            var a = r.match(n);
            return a ? a.map(Number) : [];
        }
        return cc;
    }
    var YT = XT();
    const qT = ih(YT);
    function jT(i, t) {
        const e = qT(i), n = [];
        let s = null, r = 0, a = 0;
        for(let o = 0; o < e.length; o++){
            const c = e[o], l = c[0], h = c;
            switch(l){
                case "M":
                    r = h[1], a = h[2], t.moveTo(r, a);
                    break;
                case "m":
                    r += h[1], a += h[2], t.moveTo(r, a);
                    break;
                case "H":
                    r = h[1], t.lineTo(r, a);
                    break;
                case "h":
                    r += h[1], t.lineTo(r, a);
                    break;
                case "V":
                    a = h[1], t.lineTo(r, a);
                    break;
                case "v":
                    a += h[1], t.lineTo(r, a);
                    break;
                case "L":
                    r = h[1], a = h[2], t.lineTo(r, a);
                    break;
                case "l":
                    r += h[1], a += h[2], t.lineTo(r, a);
                    break;
                case "C":
                    r = h[5], a = h[6], t.bezierCurveTo(h[1], h[2], h[3], h[4], r, a);
                    break;
                case "c":
                    t.bezierCurveTo(r + h[1], a + h[2], r + h[3], a + h[4], r + h[5], a + h[6]), r += h[5], a += h[6];
                    break;
                case "S":
                    r = h[3], a = h[4], t.bezierCurveToShort(h[1], h[2], r, a);
                    break;
                case "s":
                    t.bezierCurveToShort(r + h[1], a + h[2], r + h[3], a + h[4]), r += h[3], a += h[4];
                    break;
                case "Q":
                    r = h[3], a = h[4], t.quadraticCurveTo(h[1], h[2], r, a);
                    break;
                case "q":
                    t.quadraticCurveTo(r + h[1], a + h[2], r + h[3], a + h[4]), r += h[3], a += h[4];
                    break;
                case "T":
                    r = h[1], a = h[2], t.quadraticCurveToShort(r, a);
                    break;
                case "t":
                    r += h[1], a += h[2], t.quadraticCurveToShort(r, a);
                    break;
                case "A":
                    r = h[6], a = h[7], t.arcToSvg(h[1], h[2], h[3], h[4], h[5], r, a);
                    break;
                case "a":
                    r += h[6], a += h[7], t.arcToSvg(h[1], h[2], h[3], h[4], h[5], r, a);
                    break;
                case "Z":
                case "z":
                    t.closePath(), n.length > 0 && (s = n.pop(), s ? (r = s.startX, a = s.startY) : (r = 0, a = 0)), s = null;
                    break;
                default:
                    _e(`Unknown SVG path command: ${l}`);
            }
            l !== "Z" && l !== "z" && s === null && (s = {
                startX: r,
                startY: a
            }, n.push(s));
        }
        return t;
    }
    class ph {
        constructor(t = 0, e = 0, n = 0){
            this.type = "circle", this.x = t, this.y = e, this.radius = n;
        }
        clone() {
            return new ph(this.x, this.y, this.radius);
        }
        contains(t, e) {
            if (this.radius <= 0) return !1;
            const n = this.radius * this.radius;
            let s = this.x - t, r = this.y - e;
            return s *= s, r *= r, s + r <= n;
        }
        strokeContains(t, e, n, s = .5) {
            if (this.radius === 0) return !1;
            const r = this.x - t, a = this.y - e, o = this.radius, c = (1 - s) * n, l = Math.sqrt(r * r + a * a);
            return l <= o + c && l > o - (n - c);
        }
        getBounds(t) {
            return t || (t = new fe), t.x = this.x - this.radius, t.y = this.y - this.radius, t.width = this.radius * 2, t.height = this.radius * 2, t;
        }
        copyFrom(t) {
            return this.x = t.x, this.y = t.y, this.radius = t.radius, this;
        }
        copyTo(t) {
            return t.copyFrom(this), t;
        }
        toString() {
            return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
        }
    }
    class mh {
        constructor(t = 0, e = 0, n = 0, s = 0){
            this.type = "ellipse", this.x = t, this.y = e, this.halfWidth = n, this.halfHeight = s;
        }
        clone() {
            return new mh(this.x, this.y, this.halfWidth, this.halfHeight);
        }
        contains(t, e) {
            if (this.halfWidth <= 0 || this.halfHeight <= 0) return !1;
            let n = (t - this.x) / this.halfWidth, s = (e - this.y) / this.halfHeight;
            return n *= n, s *= s, n + s <= 1;
        }
        strokeContains(t, e, n, s = .5) {
            const { halfWidth: r, halfHeight: a } = this;
            if (r <= 0 || a <= 0) return !1;
            const o = n * (1 - s), c = n - o, l = r - c, h = a - c, u = r + o, d = a + o, f = t - this.x, _ = e - this.y, g = f * f / (l * l) + _ * _ / (h * h), p = f * f / (u * u) + _ * _ / (d * d);
            return g > 1 && p <= 1;
        }
        getBounds(t) {
            return t || (t = new fe), t.x = this.x - this.halfWidth, t.y = this.y - this.halfHeight, t.width = this.halfWidth * 2, t.height = this.halfHeight * 2, t;
        }
        copyFrom(t) {
            return this.x = t.x, this.y = t.y, this.halfWidth = t.halfWidth, this.halfHeight = t.halfHeight, this;
        }
        copyTo(t) {
            return t.copyFrom(this), t;
        }
        toString() {
            return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;
        }
    }
    function $T(i, t, e, n, s, r) {
        const a = i - e, o = t - n, c = s - e, l = r - n, h = a * c + o * l, u = c * c + l * l;
        let d = -1;
        u !== 0 && (d = h / u);
        let f, _;
        d < 0 ? (f = e, _ = n) : d > 1 ? (f = s, _ = r) : (f = e + d * c, _ = n + d * l);
        const g = i - f, p = t - _;
        return g * g + p * p;
    }
    let KT, ZT;
    class yr {
        constructor(...t){
            this.type = "polygon";
            let e = Array.isArray(t[0]) ? t[0] : t;
            if (typeof e[0] != "number") {
                const n = [];
                for(let s = 0, r = e.length; s < r; s++)n.push(e[s].x, e[s].y);
                e = n;
            }
            this.points = e, this.closePath = !0;
        }
        isClockwise() {
            let t = 0;
            const e = this.points, n = e.length;
            for(let s = 0; s < n; s += 2){
                const r = e[s], a = e[s + 1], o = e[(s + 2) % n], c = e[(s + 3) % n];
                t += (o - r) * (c + a);
            }
            return t < 0;
        }
        containsPolygon(t) {
            const e = this.getBounds(KT), n = t.getBounds(ZT);
            if (!e.containsRect(n)) return !1;
            const s = t.points;
            for(let r = 0; r < s.length; r += 2){
                const a = s[r], o = s[r + 1];
                if (!this.contains(a, o)) return !1;
            }
            return !0;
        }
        clone() {
            const t = this.points.slice(), e = new yr(t);
            return e.closePath = this.closePath, e;
        }
        contains(t, e) {
            let n = !1;
            const s = this.points.length / 2;
            for(let r = 0, a = s - 1; r < s; a = r++){
                const o = this.points[r * 2], c = this.points[r * 2 + 1], l = this.points[a * 2], h = this.points[a * 2 + 1];
                c > e != h > e && t < (l - o) * ((e - c) / (h - c)) + o && (n = !n);
            }
            return n;
        }
        strokeContains(t, e, n, s = .5) {
            const r = n * n, a = r * (1 - s), o = r - a, { points: c } = this, l = c.length - (this.closePath ? 0 : 2);
            for(let h = 0; h < l; h += 2){
                const u = c[h], d = c[h + 1], f = c[(h + 2) % c.length], _ = c[(h + 3) % c.length], g = $T(t, e, u, d, f, _), p = Math.sign((f - u) * (e - d) - (_ - d) * (t - u));
                if (g <= (p < 0 ? o : a)) return !0;
            }
            return !1;
        }
        getBounds(t) {
            t || (t = new fe);
            const e = this.points;
            let n = 1 / 0, s = -1 / 0, r = 1 / 0, a = -1 / 0;
            for(let o = 0, c = e.length; o < c; o += 2){
                const l = e[o], h = e[o + 1];
                n = l < n ? l : n, s = l > s ? l : s, r = h < r ? h : r, a = h > a ? h : a;
            }
            return t.x = n, t.width = s - n, t.y = r, t.height = a - r, t;
        }
        copyFrom(t) {
            return this.points = t.points.slice(), this.closePath = t.closePath, this;
        }
        copyTo(t) {
            return t.copyFrom(this), t;
        }
        toString() {
            return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((t, e)=>`${t}, ${e}`, "")}]`;
        }
        get lastX() {
            return this.points[this.points.length - 2];
        }
        get lastY() {
            return this.points[this.points.length - 1];
        }
        get x() {
            return this.points[this.points.length - 2];
        }
        get y() {
            return this.points[this.points.length - 1];
        }
    }
    const ya = (i, t, e, n, s, r, a)=>{
        const o = i - e, c = t - n, l = Math.sqrt(o * o + c * c);
        return l >= s - r && l <= s + a;
    };
    class _h {
        constructor(t = 0, e = 0, n = 0, s = 0, r = 20){
            this.type = "roundedRectangle", this.x = t, this.y = e, this.width = n, this.height = s, this.radius = r;
        }
        getBounds(t) {
            return t || (t = new fe), t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t;
        }
        clone() {
            return new _h(this.x, this.y, this.width, this.height, this.radius);
        }
        copyFrom(t) {
            return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this;
        }
        copyTo(t) {
            return t.copyFrom(this), t;
        }
        contains(t, e) {
            if (this.width <= 0 || this.height <= 0) return !1;
            if (t >= this.x && t <= this.x + this.width && e >= this.y && e <= this.y + this.height) {
                const n = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
                if (e >= this.y + n && e <= this.y + this.height - n || t >= this.x + n && t <= this.x + this.width - n) return !0;
                let s = t - (this.x + n), r = e - (this.y + n);
                const a = n * n;
                if (s * s + r * r <= a || (s = t - (this.x + this.width - n), s * s + r * r <= a) || (r = e - (this.y + this.height - n), s * s + r * r <= a) || (s = t - (this.x + n), s * s + r * r <= a)) return !0;
            }
            return !1;
        }
        strokeContains(t, e, n, s = .5) {
            const { x: r, y: a, width: o, height: c, radius: l } = this, h = n * (1 - s), u = n - h, d = r + l, f = a + l, _ = o - l * 2, g = c - l * 2, p = r + o, m = a + c;
            return (t >= r - h && t <= r + u || t >= p - u && t <= p + h) && e >= f && e <= f + g || (e >= a - h && e <= a + u || e >= m - u && e <= m + h) && t >= d && t <= d + _ ? !0 : t < d && e < f && ya(t, e, d, f, l, u, h) || t > p - l && e < f && ya(t, e, p - l, f, l, u, h) || t > p - l && e > m - l && ya(t, e, p - l, m - l, l, u, h) || t < d && e > m - l && ya(t, e, d, m - l, l, u, h);
        }
        toString() {
            return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
        }
    }
    const JT = [
        "precision mediump float;",
        "void main(void){",
        "float test = 0.1;",
        "%forloop%",
        "gl_FragColor = vec4(0.0);",
        "}"
    ].join(`
`);
    function QT(i) {
        let t = "";
        for(let e = 0; e < i; ++e)e > 0 && (t += `
else `), e < i - 1 && (t += `if(test == ${e}.0){}`);
        return t;
    }
    function tE(i, t) {
        if (i === 0) throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
        const e = t.createShader(t.FRAGMENT_SHADER);
        try {
            for(;;){
                const n = JT.replace(/%forloop%/gi, QT(i));
                if (t.shaderSource(e, n), t.compileShader(e), !t.getShaderParameter(e, t.COMPILE_STATUS)) i = i / 2 | 0;
                else break;
            }
        } finally{
            t.deleteShader(e);
        }
        return i;
    }
    let ms = null;
    Ja = function() {
        if (ms) return ms;
        const i = Op();
        return ms = i.getParameter(i.MAX_TEXTURE_IMAGE_UNITS), ms = tE(ms, i), i.getExtension("WEBGL_lose_context")?.loseContext(), ms;
    };
    const Kp = {};
    function eE(i, t) {
        let e = 2166136261;
        for(let n = 0; n < t; n++)e ^= i[n].uid, e = Math.imul(e, 16777619), e >>>= 0;
        return Kp[e] || nE(i, t, e);
    }
    let lc = 0;
    function nE(i, t, e) {
        const n = {};
        let s = 0;
        lc || (lc = Ja());
        for(let a = 0; a < lc; a++){
            const o = a < t ? i[a] : Ot.EMPTY.source;
            n[s++] = o.source, n[s++] = o.style;
        }
        const r = new vr(n);
        return Kp[e] = r, r;
    }
    Bd = class {
        constructor(t){
            typeof t == "number" ? this.rawBinaryData = new ArrayBuffer(t) : t instanceof Uint8Array ? this.rawBinaryData = t.buffer : this.rawBinaryData = t, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData), this.size = this.rawBinaryData.byteLength;
        }
        get int8View() {
            return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;
        }
        get uint8View() {
            return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;
        }
        get int16View() {
            return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;
        }
        get int32View() {
            return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;
        }
        get float64View() {
            return this._float64Array || (this._float64Array = new Float64Array(this.rawBinaryData)), this._float64Array;
        }
        get bigUint64View() {
            return this._bigUint64Array || (this._bigUint64Array = new BigUint64Array(this.rawBinaryData)), this._bigUint64Array;
        }
        view(t) {
            return this[`${t}View`];
        }
        destroy() {
            this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this.uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null;
        }
        static sizeOf(t) {
            switch(t){
                case "int8":
                case "uint8":
                    return 1;
                case "int16":
                case "uint16":
                    return 2;
                case "int32":
                case "uint32":
                case "float32":
                    return 4;
                default:
                    throw new Error(`${t} isn't a valid view type`);
            }
        }
    };
    function Fd(i, t) {
        const e = i.byteLength / 8 | 0, n = new Float64Array(i, 0, e);
        new Float64Array(t, 0, e).set(n);
        const r = i.byteLength - e * 8;
        if (r > 0) {
            const a = new Uint8Array(i, e * 8, r);
            new Uint8Array(t, e * 8, r).set(a);
        }
    }
    const iE = {
        normal: "normal-npm",
        add: "add-npm",
        screen: "screen-npm"
    };
    var Ce = ((i)=>(i[i.DISABLED = 0] = "DISABLED", i[i.RENDERING_MASK_ADD = 1] = "RENDERING_MASK_ADD", i[i.MASK_ACTIVE = 2] = "MASK_ACTIVE", i[i.INVERSE_MASK_ACTIVE = 3] = "INVERSE_MASK_ACTIVE", i[i.RENDERING_MASK_REMOVE = 4] = "RENDERING_MASK_REMOVE", i[i.NONE = 5] = "NONE", i))(Ce || {});
    Od = function(i, t) {
        return t.alphaMode === "no-premultiply-alpha" && iE[i] || i;
    };
    class sE {
        constructor(){
            this.ids = Object.create(null), this.textures = [], this.count = 0;
        }
        clear() {
            for(let t = 0; t < this.count; t++){
                const e = this.textures[t];
                this.textures[t] = null, this.ids[e.uid] = null;
            }
            this.count = 0;
        }
    }
    class rE {
        constructor(){
            this.renderPipeId = "batch", this.action = "startBatch", this.start = 0, this.size = 0, this.textures = new sE, this.blendMode = "normal", this.topology = "triangle-strip", this.canBundle = !0;
        }
        destroy() {
            this.textures = null, this.gpuBindGroup = null, this.bindGroup = null, this.batcher = null;
        }
    }
    const Zp = [];
    let Al = 0;
    function kd() {
        return Al > 0 ? Zp[--Al] : new rE;
    }
    function Gd(i) {
        Zp[Al++] = i;
    }
    let ar = 0;
    const Jp = class Ua {
        constructor(t = {}){
            this.uid = pe("batcher"), this.dirty = !0, this.batchIndex = 0, this.batches = [], this._elements = [], Ua.defaultOptions.maxTextures = Ua.defaultOptions.maxTextures ?? Ja(), t = {
                ...Ua.defaultOptions,
                ...t
            };
            const { maxTextures: e, attributesInitialSize: n, indicesInitialSize: s } = t;
            this.attributeBuffer = new Bd(n * 4), this.indexBuffer = new Uint16Array(s), this.maxTextures = e;
        }
        begin() {
            this.elementSize = 0, this.elementStart = 0, this.indexSize = 0, this.attributeSize = 0;
            for(let t = 0; t < this.batchIndex; t++)Gd(this.batches[t]);
            this.batchIndex = 0, this._batchIndexStart = 0, this._batchIndexSize = 0, this.dirty = !0;
        }
        add(t) {
            this._elements[this.elementSize++] = t, t._indexStart = this.indexSize, t._attributeStart = this.attributeSize, t._batcher = this, this.indexSize += t.indexSize, this.attributeSize += t.attributeSize * this.vertexSize;
        }
        checkAndUpdateTexture(t, e) {
            const n = t._batch.textures.ids[e._source.uid];
            return !n && n !== 0 ? !1 : (t._textureId = n, t.texture = e, !0);
        }
        updateElement(t) {
            this.dirty = !0;
            const e = this.attributeBuffer;
            t.packAsQuad ? this.packQuadAttributes(t, e.float32View, e.uint32View, t._attributeStart, t._textureId) : this.packAttributes(t, e.float32View, e.uint32View, t._attributeStart, t._textureId);
        }
        break(t) {
            const e = this._elements;
            if (!e[this.elementStart]) return;
            let n = kd(), s = n.textures;
            s.clear();
            const r = e[this.elementStart];
            let a = Od(r.blendMode, r.texture._source), o = r.topology;
            this.attributeSize * 4 > this.attributeBuffer.size && this._resizeAttributeBuffer(this.attributeSize * 4), this.indexSize > this.indexBuffer.length && this._resizeIndexBuffer(this.indexSize);
            const c = this.attributeBuffer.float32View, l = this.attributeBuffer.uint32View, h = this.indexBuffer;
            let u = this._batchIndexSize, d = this._batchIndexStart, f = "startBatch";
            const _ = this.maxTextures;
            for(let g = this.elementStart; g < this.elementSize; ++g){
                const p = e[g];
                e[g] = null;
                const x = p.texture._source, y = Od(p.blendMode, x), v = a !== y || o !== p.topology;
                if (x._batchTick === ar && !v) {
                    p._textureId = x._textureBindLocation, u += p.indexSize, p.packAsQuad ? (this.packQuadAttributes(p, c, l, p._attributeStart, p._textureId), this.packQuadIndex(h, p._indexStart, p._attributeStart / this.vertexSize)) : (this.packAttributes(p, c, l, p._attributeStart, p._textureId), this.packIndex(p, h, p._indexStart, p._attributeStart / this.vertexSize)), p._batch = n;
                    continue;
                }
                x._batchTick = ar, (s.count >= _ || v) && (this._finishBatch(n, d, u - d, s, a, o, t, f), f = "renderBatch", d = u, a = y, o = p.topology, n = kd(), s = n.textures, s.clear(), ++ar), p._textureId = x._textureBindLocation = s.count, s.ids[x.uid] = s.count, s.textures[s.count++] = x, p._batch = n, u += p.indexSize, p.packAsQuad ? (this.packQuadAttributes(p, c, l, p._attributeStart, p._textureId), this.packQuadIndex(h, p._indexStart, p._attributeStart / this.vertexSize)) : (this.packAttributes(p, c, l, p._attributeStart, p._textureId), this.packIndex(p, h, p._indexStart, p._attributeStart / this.vertexSize));
            }
            s.count > 0 && (this._finishBatch(n, d, u - d, s, a, o, t, f), d = u, ++ar), this.elementStart = this.elementSize, this._batchIndexStart = d, this._batchIndexSize = u;
        }
        _finishBatch(t, e, n, s, r, a, o, c) {
            t.gpuBindGroup = null, t.bindGroup = null, t.action = c, t.batcher = this, t.textures = s, t.blendMode = r, t.topology = a, t.start = e, t.size = n, ++ar, this.batches[this.batchIndex++] = t, o.add(t);
        }
        finish(t) {
            this.break(t);
        }
        ensureAttributeBuffer(t) {
            t * 4 <= this.attributeBuffer.size || this._resizeAttributeBuffer(t * 4);
        }
        ensureIndexBuffer(t) {
            t <= this.indexBuffer.length || this._resizeIndexBuffer(t);
        }
        _resizeAttributeBuffer(t) {
            const e = Math.max(t, this.attributeBuffer.size * 2), n = new Bd(e);
            Fd(this.attributeBuffer.rawBinaryData, n.rawBinaryData), this.attributeBuffer = n;
        }
        _resizeIndexBuffer(t) {
            const e = this.indexBuffer;
            let n = Math.max(t, e.length * 1.5);
            n += n % 2;
            const s = n > 65535 ? new Uint32Array(n) : new Uint16Array(n);
            if (s.BYTES_PER_ELEMENT !== e.BYTES_PER_ELEMENT) for(let r = 0; r < e.length; r++)s[r] = e[r];
            else Fd(e.buffer, s.buffer);
            this.indexBuffer = s;
        }
        packQuadIndex(t, e, n) {
            t[e] = n + 0, t[e + 1] = n + 1, t[e + 2] = n + 2, t[e + 3] = n + 0, t[e + 4] = n + 2, t[e + 5] = n + 3;
        }
        packIndex(t, e, n, s) {
            const r = t.indices, a = t.indexSize, o = t.indexOffset, c = t.attributeOffset;
            for(let l = 0; l < a; l++)e[n++] = s + r[l + o] - c;
        }
        destroy() {
            for(let t = 0; t < this.batches.length; t++)Gd(this.batches[t]);
            this.batches = null;
            for(let t = 0; t < this._elements.length; t++)this._elements[t]._batch = null;
            this._elements = null, this.indexBuffer = null, this.attributeBuffer.destroy(), this.attributeBuffer = null;
        }
    };
    Jp.defaultOptions = {
        maxTextures: null,
        attributesInitialSize: 4,
        indicesInitialSize: 6
    };
    let aE = Jp;
    Se = ((i)=>(i[i.MAP_READ = 1] = "MAP_READ", i[i.MAP_WRITE = 2] = "MAP_WRITE", i[i.COPY_SRC = 4] = "COPY_SRC", i[i.COPY_DST = 8] = "COPY_DST", i[i.INDEX = 16] = "INDEX", i[i.VERTEX = 32] = "VERTEX", i[i.UNIFORM = 64] = "UNIFORM", i[i.STORAGE = 128] = "STORAGE", i[i.INDIRECT = 256] = "INDIRECT", i[i.QUERY_RESOLVE = 512] = "QUERY_RESOLVE", i[i.STATIC = 1024] = "STATIC", i))(Se || {});
    ji = class extends In {
        constructor(t){
            let { data: e, size: n } = t;
            const { usage: s, label: r, shrinkToFit: a } = t;
            super(), this.uid = pe("buffer"), this._resourceType = "buffer", this._resourceId = pe("resource"), this._touched = 0, this._updateID = 1, this._dataInt32 = null, this.shrinkToFit = !0, this.destroyed = !1, e instanceof Array && (e = new Float32Array(e)), this._data = e, n ?? (n = e?.byteLength);
            const o = !!e;
            this.descriptor = {
                size: n,
                usage: s,
                mappedAtCreation: o,
                label: r
            }, this.shrinkToFit = a ?? !0;
        }
        get data() {
            return this._data;
        }
        set data(t) {
            this.setDataWithSize(t, t.length, !0);
        }
        get dataInt32() {
            return this._dataInt32 || (this._dataInt32 = new Int32Array(this.data.buffer)), this._dataInt32;
        }
        get static() {
            return !!(this.descriptor.usage & Se.STATIC);
        }
        set static(t) {
            t ? this.descriptor.usage |= Se.STATIC : this.descriptor.usage &= ~Se.STATIC;
        }
        setDataWithSize(t, e, n) {
            if (this._updateID++, this._updateSize = e * t.BYTES_PER_ELEMENT, this._data === t) {
                n && this.emit("update", this);
                return;
            }
            const s = this._data;
            if (this._data = t, this._dataInt32 = null, !s || s.length !== t.length) {
                !this.shrinkToFit && s && t.byteLength < s.byteLength ? n && this.emit("update", this) : (this.descriptor.size = t.byteLength, this._resourceId = pe("resource"), this.emit("change", this));
                return;
            }
            n && this.emit("update", this);
        }
        update(t) {
            this._updateSize = t ?? this._updateSize, this._updateID++, this.emit("update", this);
        }
        destroy() {
            this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this._data = null, this.descriptor = null, this.removeAllListeners();
        }
    };
    function Qp(i, t) {
        if (!(i instanceof ji)) {
            let e = t ? Se.INDEX : Se.VERTEX;
            i instanceof Array && (t ? (i = new Uint32Array(i), e = Se.INDEX | Se.COPY_DST) : (i = new Float32Array(i), e = Se.VERTEX | Se.COPY_DST)), i = new ji({
                data: i,
                label: t ? "index-mesh-buffer" : "vertex-mesh-buffer",
                usage: e
            });
        }
        return i;
    }
    function oE(i, t, e) {
        const n = i.getAttribute(t);
        if (!n) return e.minX = 0, e.minY = 0, e.maxX = 0, e.maxY = 0, e;
        const s = n.buffer.data;
        let r = 1 / 0, a = 1 / 0, o = -1 / 0, c = -1 / 0;
        const l = s.BYTES_PER_ELEMENT, h = (n.offset || 0) / l, u = (n.stride || 2 * 4) / l;
        for(let d = h; d < s.length; d += u){
            const f = s[d], _ = s[d + 1];
            f > o && (o = f), _ > c && (c = _), f < r && (r = f), _ < a && (a = _);
        }
        return e.minX = r, e.minY = a, e.maxX = o, e.maxY = c, e;
    }
    function cE(i) {
        return (i instanceof ji || Array.isArray(i) || i.BYTES_PER_ELEMENT) && (i = {
            buffer: i
        }), i.buffer = Qp(i.buffer, !1), i;
    }
    tm = class extends In {
        constructor(t = {}){
            super(), this.uid = pe("geometry"), this._layoutKey = 0, this.instanceCount = 1, this._bounds = new en, this._boundsDirty = !0;
            const { attributes: e, indexBuffer: n, topology: s } = t;
            if (this.buffers = [], this.attributes = {}, e) for(const r in e)this.addAttribute(r, e[r]);
            this.instanceCount = t.instanceCount ?? 1, n && this.addIndex(n), this.topology = s || "triangle-list";
        }
        onBufferUpdate() {
            this._boundsDirty = !0, this.emit("update", this);
        }
        getAttribute(t) {
            return this.attributes[t];
        }
        getIndex() {
            return this.indexBuffer;
        }
        getBuffer(t) {
            return this.getAttribute(t).buffer;
        }
        getSize() {
            for(const t in this.attributes){
                const e = this.attributes[t];
                return e.buffer.data.length / (e.stride / 4 || e.size);
            }
            return 0;
        }
        addAttribute(t, e) {
            const n = cE(e);
            this.buffers.indexOf(n.buffer) === -1 && (this.buffers.push(n.buffer), n.buffer.on("update", this.onBufferUpdate, this), n.buffer.on("change", this.onBufferUpdate, this)), this.attributes[t] = n;
        }
        addIndex(t) {
            this.indexBuffer = Qp(t, !0), this.buffers.push(this.indexBuffer);
        }
        get bounds() {
            return this._boundsDirty ? (this._boundsDirty = !1, oE(this, "aPosition", this._bounds)) : this._bounds;
        }
        destroy(t = !1) {
            this.emit("destroy", this), this.removeAllListeners(), t && this.buffers.forEach((e)=>e.destroy()), this.attributes = null, this.buffers = null, this.indexBuffer = null, this._bounds = null;
        }
    };
    const lE = new Float32Array(1), hE = new Uint32Array(1);
    class uE extends tm {
        constructor(){
            const e = new ji({
                data: lE,
                label: "attribute-batch-buffer",
                usage: Se.VERTEX | Se.COPY_DST,
                shrinkToFit: !1
            }), n = new ji({
                data: hE,
                label: "index-batch-buffer",
                usage: Se.INDEX | Se.COPY_DST,
                shrinkToFit: !1
            }), s = 6 * 4;
            super({
                attributes: {
                    aPosition: {
                        buffer: e,
                        format: "float32x2",
                        stride: s,
                        offset: 0
                    },
                    aUV: {
                        buffer: e,
                        format: "float32x2",
                        stride: s,
                        offset: 2 * 4
                    },
                    aColor: {
                        buffer: e,
                        format: "unorm8x4",
                        stride: s,
                        offset: 4 * 4
                    },
                    aTextureIdAndRound: {
                        buffer: e,
                        format: "uint16x2",
                        stride: s,
                        offset: 5 * 4
                    }
                },
                indexBuffer: n
            });
        }
    }
    function Hd(i, t, e) {
        if (i) for(const n in i){
            const s = n.toLocaleLowerCase(), r = t[s];
            if (r) {
                let a = i[n];
                n === "header" && (a = a.replace(/@in\s+[^;]+;\s*/g, "").replace(/@out\s+[^;]+;\s*/g, "")), e && r.push(`//----${e}----//`), r.push(a);
            } else _e(`${n} placement hook does not exist in shader`);
        }
    }
    const dE = /\{\{(.*?)\}\}/g;
    function zd(i) {
        const t = {};
        return (i.match(dE)?.map((n)=>n.replace(/[{()}]/g, "")) ?? []).forEach((n)=>{
            t[n] = [];
        }), t;
    }
    function Vd(i, t) {
        let e;
        const n = /@in\s+([^;]+);/g;
        for(; (e = n.exec(i)) !== null;)t.push(e[1]);
    }
    function Wd(i, t, e = !1) {
        const n = [];
        Vd(t, n), i.forEach((o)=>{
            o.header && Vd(o.header, n);
        });
        const s = n;
        e && s.sort();
        const r = s.map((o, c)=>`       @location(${c}) ${o},`).join(`
`);
        let a = t.replace(/@in\s+[^;]+;\s*/g, "");
        return a = a.replace("{{in}}", `
${r}
`), a;
    }
    function Xd(i, t) {
        let e;
        const n = /@out\s+([^;]+);/g;
        for(; (e = n.exec(i)) !== null;)t.push(e[1]);
    }
    function fE(i) {
        const e = /\b(\w+)\s*:/g.exec(i);
        return e ? e[1] : "";
    }
    function pE(i) {
        const t = /@.*?\s+/g;
        return i.replace(t, "");
    }
    function mE(i, t) {
        const e = [];
        Xd(t, e), i.forEach((c)=>{
            c.header && Xd(c.header, e);
        });
        let n = 0;
        const s = e.sort().map((c)=>c.indexOf("builtin") > -1 ? c : `@location(${n++}) ${c}`).join(`,
`), r = e.sort().map((c)=>`       var ${pE(c)};`).join(`
`), a = `return VSOutput(
            ${e.sort().map((c)=>` ${fE(c)}`).join(`,
`)});`;
        let o = t.replace(/@out\s+[^;]+;\s*/g, "");
        return o = o.replace("{{struct}}", `
${s}
`), o = o.replace("{{start}}", `
${r}
`), o = o.replace("{{return}}", `
${a}
`), o;
    }
    function Yd(i, t) {
        let e = i;
        for(const n in t){
            const s = t[n];
            s.join(`
`).length ? e = e.replace(`{{${n}}}`, `//-----${n} START-----//
${s.join(`
`)}
//----${n} FINISH----//`) : e = e.replace(`{{${n}}}`, "");
        }
        return e;
    }
    const mi = Object.create(null), hc = new Map;
    let _E = 0;
    function gE({ template: i, bits: t }) {
        const e = em(i, t);
        if (mi[e]) return mi[e];
        const { vertex: n, fragment: s } = vE(i, t);
        return mi[e] = nm(n, s, t), mi[e];
    }
    function xE({ template: i, bits: t }) {
        const e = em(i, t);
        return mi[e] || (mi[e] = nm(i.vertex, i.fragment, t)), mi[e];
    }
    function vE(i, t) {
        const e = t.map((a)=>a.vertex).filter((a)=>!!a), n = t.map((a)=>a.fragment).filter((a)=>!!a);
        let s = Wd(e, i.vertex, !0);
        s = mE(e, s);
        const r = Wd(n, i.fragment, !0);
        return {
            vertex: s,
            fragment: r
        };
    }
    function em(i, t) {
        return t.map((e)=>(hc.has(e) || hc.set(e, _E++), hc.get(e))).sort((e, n)=>e - n).join("-") + i.vertex + i.fragment;
    }
    function nm(i, t, e) {
        const n = zd(i), s = zd(t);
        return e.forEach((r)=>{
            Hd(r.vertex, n, r.name), Hd(r.fragment, s, r.name);
        }), {
            vertex: Yd(i, n),
            fragment: Yd(t, s)
        };
    }
    const yE = `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}
        
        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);
       
        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`, bE = `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;
   
    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {
        
        {{start}}

        var outColor:vec4<f32>;
      
        {{main}}
        
        var finalColor:vec4<f32> = outColor * vColor;

        {{end}}

        return finalColor;
      };
`, SE = `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;
        
        {{start}}
        
        vColor = vec4(1.);
        
        {{main}}
        
        vUV = uv;
        
        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`, ME = `
   
    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {
        
        {{start}}

        vec4 outColor;
      
        {{main}}
        
        finalColor = outColor * vColor;
        
        {{end}}
    }
`, TE = {
        name: "global-uniforms-bit",
        vertex: {
            header: `
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `
        }
    }, EE = {
        name: "global-uniforms-bit",
        vertex: {
            header: `
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `
        }
    };
    AE = function({ bits: i, name: t }) {
        const e = gE({
            template: {
                fragment: bE,
                vertex: yE
            },
            bits: [
                TE,
                ...i
            ]
        });
        return qs.from({
            name: t,
            vertex: {
                source: e.vertex,
                entryPoint: "main"
            },
            fragment: {
                source: e.fragment,
                entryPoint: "main"
            }
        });
    };
    gh = function({ bits: i, name: t }) {
        return new Br({
            name: t,
            ...xE({
                template: {
                    vertex: SE,
                    fragment: ME
                },
                bits: [
                    EE,
                    ...i
                ]
            })
        });
    };
    let uc;
    wE = {
        name: "color-bit",
        vertex: {
            header: `
            @in aColor: vec4<f32>;
        `,
            main: `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `
        }
    };
    im = {
        name: "color-bit",
        vertex: {
            header: `
            in vec4 aColor;
        `,
            main: `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `
        }
    };
    uc = {};
    function RE(i) {
        const t = [];
        if (i === 1) t.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"), t.push("@group(1) @binding(1) var textureSampler1: sampler;");
        else {
            let e = 0;
            for(let n = 0; n < i; n++)t.push(`@group(1) @binding(${e++}) var textureSource${n + 1}: texture_2d<f32>;`), t.push(`@group(1) @binding(${e++}) var textureSampler${n + 1}: sampler;`);
        }
        return t.join(`
`);
    }
    function CE(i) {
        const t = [];
        if (i === 1) t.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");
        else {
            t.push("switch vTextureId {");
            for(let e = 0; e < i; e++)e === i - 1 ? t.push("  default:{") : t.push(`  case ${e}:{`), t.push(`      outColor = textureSampleGrad(textureSource${e + 1}, textureSampler${e + 1}, vUV, uvDx, uvDy);`), t.push("      break;}");
            t.push("}");
        }
        return t.join(`
`);
    }
    PE = function(i) {
        return uc[i] || (uc[i] = {
            name: "texture-batch-bit",
            vertex: {
                header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,
                main: `
                vTextureId = aTextureIdAndRound.y;
            `,
                end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `
            },
            fragment: {
                header: `
                @in @interpolate(flat) vTextureId: u32;

                ${RE(i)}
            `,
                main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${CE(i)}
            `
            }
        }), uc[i];
    };
    const dc = {};
    function IE(i) {
        const t = [];
        for(let e = 0; e < i; e++)e > 0 && t.push("else"), e < i - 1 && t.push(`if(vTextureId < ${e}.5)`), t.push("{"), t.push(`	outColor = texture(uTextures[${e}], vUV);`), t.push("}");
        return t.join(`
`);
    }
    sm = function(i) {
        return dc[i] || (dc[i] = {
            name: "texture-batch-bit",
            vertex: {
                header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `,
                main: `
                vTextureId = aTextureIdAndRound.y;
            `,
                end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `
            },
            fragment: {
                header: `
                in float vTextureId;

                uniform sampler2D uTextures[${i}];

            `,
                main: `

                ${IE(i)}
            `
            }
        }), dc[i];
    };
    let qd;
    DE = {
        name: "round-pixels-bit",
        vertex: {
            header: `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> 
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
        }
    };
    xh = {
        name: "round-pixels-bit",
        vertex: {
            header: `   
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {       
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
        }
    };
    qd = {};
    rm = function(i) {
        let t = qd[i];
        if (t) return t;
        const e = new Int32Array(i);
        for(let n = 0; n < i; n++)e[n] = n;
        return t = qd[i] = new Ki({
            uTextures: {
                value: e,
                type: "i32",
                size: i
            }
        }, {
            isStatic: !0
        }), t;
    };
    class LE extends Zi {
        constructor(t){
            const e = gh({
                name: "batch",
                bits: [
                    im,
                    sm(t),
                    xh
                ]
            }), n = AE({
                name: "batch",
                bits: [
                    wE,
                    PE(t),
                    DE
                ]
            });
            super({
                glProgram: e,
                gpuProgram: n,
                resources: {
                    batchSamplers: rm(t)
                }
            });
        }
    }
    let jd = null;
    const am = class om extends aE {
        constructor(){
            super(...arguments), this.geometry = new uE, this.shader = jd || (jd = new LE(this.maxTextures)), this.name = om.extension.name, this.vertexSize = 6;
        }
        packAttributes(t, e, n, s, r) {
            const a = r << 16 | t.roundPixels & 65535, o = t.transform, c = o.a, l = o.b, h = o.c, u = o.d, d = o.tx, f = o.ty, { positions: _, uvs: g } = t, p = t.color, m = t.attributeOffset, x = m + t.attributeSize;
            for(let y = m; y < x; y++){
                const v = y * 2, I = _[v], w = _[v + 1];
                e[s++] = c * I + h * w + d, e[s++] = u * w + l * I + f, e[s++] = g[v], e[s++] = g[v + 1], n[s++] = p, n[s++] = a;
            }
        }
        packQuadAttributes(t, e, n, s, r) {
            const a = t.texture, o = t.transform, c = o.a, l = o.b, h = o.c, u = o.d, d = o.tx, f = o.ty, _ = t.bounds, g = _.maxX, p = _.minX, m = _.maxY, x = _.minY, y = a.uvs, v = t.color, I = r << 16 | t.roundPixels & 65535;
            e[s + 0] = c * p + h * x + d, e[s + 1] = u * x + l * p + f, e[s + 2] = y.x0, e[s + 3] = y.y0, n[s + 4] = v, n[s + 5] = I, e[s + 6] = c * g + h * x + d, e[s + 7] = u * x + l * g + f, e[s + 8] = y.x1, e[s + 9] = y.y1, n[s + 10] = v, n[s + 11] = I, e[s + 12] = c * g + h * m + d, e[s + 13] = u * m + l * g + f, e[s + 14] = y.x2, e[s + 15] = y.y2, n[s + 16] = v, n[s + 17] = I, e[s + 18] = c * p + h * m + d, e[s + 19] = u * m + l * p + f, e[s + 20] = y.x3, e[s + 21] = y.y3, n[s + 22] = v, n[s + 23] = I;
        }
    };
    am.extension = {
        type: [
            st.Batcher
        ],
        name: "default"
    };
    let vh = am;
    function UE(i, t, e, n, s, r, a, o = null) {
        let c = 0;
        e *= t, s *= r;
        const l = o.a, h = o.b, u = o.c, d = o.d, f = o.tx, _ = o.ty;
        for(; c < a;){
            const g = i[e], p = i[e + 1];
            n[s] = l * g + u * p + f, n[s + 1] = h * g + d * p + _, s += r, e += t, c++;
        }
    }
    function NE(i, t, e, n) {
        let s = 0;
        for(t *= e; s < n;)i[t] = 0, i[t + 1] = 0, t += e, s++;
    }
    function cm(i, t, e, n, s) {
        const r = t.a, a = t.b, o = t.c, c = t.d, l = t.tx, h = t.ty;
        e || (e = 0), n || (n = 2), s || (s = i.length / n - e);
        let u = e * n;
        for(let d = 0; d < s; d++){
            const f = i[u], _ = i[u + 1];
            i[u] = r * f + o * _ + l, i[u + 1] = a * f + c * _ + h, u += n;
        }
    }
    const BE = new Ft;
    lm = class {
        constructor(){
            this.packAsQuad = !1, this.batcherName = "default", this.topology = "triangle-list", this.applyTransform = !0, this.roundPixels = 0, this._batcher = null, this._batch = null;
        }
        get uvs() {
            return this.geometryData.uvs;
        }
        get positions() {
            return this.geometryData.vertices;
        }
        get indices() {
            return this.geometryData.indices;
        }
        get blendMode() {
            return this.applyTransform ? this.renderable.groupBlendMode : "normal";
        }
        get color() {
            const t = this.baseColor, e = t >> 16 | t & 65280 | (t & 255) << 16, n = this.renderable;
            return n ? yp(e, n.groupColor) + (this.alpha * n.groupAlpha * 255 << 24) : e + (this.alpha * 255 << 24);
        }
        get transform() {
            return this.renderable?.groupTransform || BE;
        }
        copyTo(t) {
            t.indexOffset = this.indexOffset, t.indexSize = this.indexSize, t.attributeOffset = this.attributeOffset, t.attributeSize = this.attributeSize, t.baseColor = this.baseColor, t.alpha = this.alpha, t.texture = this.texture, t.geometryData = this.geometryData, t.topology = this.topology;
        }
        reset() {
            this.applyTransform = !0, this.renderable = null, this.topology = "triangle-list";
        }
    };
    const Lr = {
        extension: {
            type: st.ShapeBuilder,
            name: "circle"
        },
        build (i, t) {
            let e, n, s, r, a, o;
            if (i.type === "circle") {
                const v = i;
                e = v.x, n = v.y, a = o = v.radius, s = r = 0;
            } else if (i.type === "ellipse") {
                const v = i;
                e = v.x, n = v.y, a = v.halfWidth, o = v.halfHeight, s = r = 0;
            } else {
                const v = i, I = v.width / 2, w = v.height / 2;
                e = v.x + I, n = v.y + w, a = o = Math.max(0, Math.min(v.radius, Math.min(I, w))), s = I - a, r = w - o;
            }
            if (!(a >= 0 && o >= 0 && s >= 0 && r >= 0)) return t;
            const c = Math.ceil(2.3 * Math.sqrt(a + o)), l = c * 8 + (s ? 4 : 0) + (r ? 4 : 0);
            if (l === 0) return t;
            if (c === 0) return t[0] = t[6] = e + s, t[1] = t[3] = n + r, t[2] = t[4] = e - s, t[5] = t[7] = n - r, t;
            let h = 0, u = c * 4 + (s ? 2 : 0) + 2, d = u, f = l, _ = s + a, g = r, p = e + _, m = e - _, x = n + g;
            if (t[h++] = p, t[h++] = x, t[--u] = x, t[--u] = m, r) {
                const v = n - g;
                t[d++] = m, t[d++] = v, t[--f] = v, t[--f] = p;
            }
            for(let v = 1; v < c; v++){
                const I = Math.PI / 2 * (v / c), w = s + Math.cos(I) * a, R = r + Math.sin(I) * o, N = e + w, E = e - w, S = n + R, D = n - R;
                t[h++] = N, t[h++] = S, t[--u] = S, t[--u] = E, t[d++] = E, t[d++] = D, t[--f] = D, t[--f] = N;
            }
            _ = s, g = r + o, p = e + _, m = e - _, x = n + g;
            const y = n - g;
            return t[h++] = p, t[h++] = x, t[--f] = y, t[--f] = p, s && (t[h++] = m, t[h++] = x, t[--f] = y, t[--f] = m), t;
        },
        triangulate (i, t, e, n, s, r) {
            if (i.length === 0) return;
            let a = 0, o = 0;
            for(let h = 0; h < i.length; h += 2)a += i[h], o += i[h + 1];
            a /= i.length / 2, o /= i.length / 2;
            let c = n;
            t[c * e] = a, t[c * e + 1] = o;
            const l = c++;
            for(let h = 0; h < i.length; h += 2)t[c * e] = i[h], t[c * e + 1] = i[h + 1], h > 0 && (s[r++] = c, s[r++] = l, s[r++] = c - 1), c++;
            s[r++] = l + 1, s[r++] = l, s[r++] = c - 1;
        }
    }, FE = {
        ...Lr,
        extension: {
            ...Lr.extension,
            name: "ellipse"
        }
    }, OE = {
        ...Lr,
        extension: {
            ...Lr.extension,
            name: "roundedRectangle"
        }
    }, hm = 1e-4, $d = 1e-4;
    function kE(i) {
        const t = i.length;
        if (t < 6) return 1;
        let e = 0;
        for(let n = 0, s = i[t - 2], r = i[t - 1]; n < t; n += 2){
            const a = i[n], o = i[n + 1];
            e += (a - s) * (o + r), s = a, r = o;
        }
        return e < 0 ? -1 : 1;
    }
    function Kd(i, t, e, n, s, r, a, o) {
        const c = i - e * s, l = t - n * s, h = i + e * r, u = t + n * r;
        let d, f;
        a ? (d = n, f = -e) : (d = -n, f = e);
        const _ = c + d, g = l + f, p = h + d, m = u + f;
        return o.push(_, g), o.push(p, m), 2;
    }
    function Pi(i, t, e, n, s, r, a, o) {
        const c = e - i, l = n - t;
        let h = Math.atan2(c, l), u = Math.atan2(s - i, r - t);
        o && h < u ? h += Math.PI * 2 : !o && h > u && (u += Math.PI * 2);
        let d = h;
        const f = u - h, _ = Math.abs(f), g = Math.sqrt(c * c + l * l), p = (15 * _ * Math.sqrt(g) / Math.PI >> 0) + 1, m = f / p;
        if (d += m, o) {
            a.push(i, t), a.push(e, n);
            for(let x = 1, y = d; x < p; x++, y += m)a.push(i, t), a.push(i + Math.sin(y) * g, t + Math.cos(y) * g);
            a.push(i, t), a.push(s, r);
        } else {
            a.push(e, n), a.push(i, t);
            for(let x = 1, y = d; x < p; x++, y += m)a.push(i + Math.sin(y) * g, t + Math.cos(y) * g), a.push(i, t);
            a.push(s, r), a.push(i, t);
        }
        return p * 2;
    }
    function GE(i, t, e, n, s, r) {
        const a = hm;
        if (i.length === 0) return;
        const o = t;
        let c = o.alignment;
        if (t.alignment !== .5) {
            let U = kE(i);
            c = (c - .5) * U + .5;
        }
        const l = new Ue(i[0], i[1]), h = new Ue(i[i.length - 2], i[i.length - 1]), u = n, d = Math.abs(l.x - h.x) < a && Math.abs(l.y - h.y) < a;
        if (u) {
            i = i.slice(), d && (i.pop(), i.pop(), h.set(i[i.length - 2], i[i.length - 1]));
            const U = (l.x + h.x) * .5, B = (h.y + l.y) * .5;
            i.unshift(U, B), i.push(U, B);
        }
        const f = s, _ = i.length / 2;
        let g = i.length;
        const p = f.length / 2, m = o.width / 2, x = m * m, y = o.miterLimit * o.miterLimit;
        let v = i[0], I = i[1], w = i[2], R = i[3], N = 0, E = 0, S = -(I - R), D = v - w, j = 0, z = 0, K = Math.sqrt(S * S + D * D);
        S /= K, D /= K, S *= m, D *= m;
        const nt = c, b = (1 - nt) * 2, C = nt * 2;
        u || (o.cap === "round" ? g += Pi(v - S * (b - C) * .5, I - D * (b - C) * .5, v - S * b, I - D * b, v + S * C, I + D * C, f, !0) + 2 : o.cap === "square" && (g += Kd(v, I, S, D, b, C, !0, f))), f.push(v - S * b, I - D * b), f.push(v + S * C, I + D * C);
        for(let U = 1; U < _ - 1; ++U){
            v = i[(U - 1) * 2], I = i[(U - 1) * 2 + 1], w = i[U * 2], R = i[U * 2 + 1], N = i[(U + 1) * 2], E = i[(U + 1) * 2 + 1], S = -(I - R), D = v - w, K = Math.sqrt(S * S + D * D), S /= K, D /= K, S *= m, D *= m, j = -(R - E), z = w - N, K = Math.sqrt(j * j + z * z), j /= K, z /= K, j *= m, z *= m;
            const B = w - v, V = I - R, q = w - N, et = E - R, H = B * q + V * et, $ = V * q - et * B, ot = $ < 0;
            if (Math.abs($) < .001 * Math.abs(H)) {
                f.push(w - S * b, R - D * b), f.push(w + S * C, R + D * C), H >= 0 && (o.join === "round" ? g += Pi(w, R, w - S * b, R - D * b, w - j * b, R - z * b, f, !1) + 4 : g += 2, f.push(w - j * C, R - z * C), f.push(w + j * b, R + z * b));
                continue;
            }
            const it = (-S + v) * (-D + R) - (-S + w) * (-D + I), lt = (-j + N) * (-z + R) - (-j + w) * (-z + E), wt = (B * lt - q * it) / $, ht = (et * it - V * lt) / $, ee = (wt - w) * (wt - w) + (ht - R) * (ht - R), Wt = w + (wt - w) * b, Lt = R + (ht - R) * b, L = w - (wt - w) * C, Ct = R - (ht - R) * C, gt = Math.min(B * B + V * V, q * q + et * et), Xt = ot ? b : C, Et = gt + Xt * Xt * x;
            ee <= Et ? o.join === "bevel" || ee / x > y ? (ot ? (f.push(Wt, Lt), f.push(w + S * C, R + D * C), f.push(Wt, Lt), f.push(w + j * C, R + z * C)) : (f.push(w - S * b, R - D * b), f.push(L, Ct), f.push(w - j * b, R - z * b), f.push(L, Ct)), g += 2) : o.join === "round" ? ot ? (f.push(Wt, Lt), f.push(w + S * C, R + D * C), g += Pi(w, R, w + S * C, R + D * C, w + j * C, R + z * C, f, !0) + 4, f.push(Wt, Lt), f.push(w + j * C, R + z * C)) : (f.push(w - S * b, R - D * b), f.push(L, Ct), g += Pi(w, R, w - S * b, R - D * b, w - j * b, R - z * b, f, !1) + 4, f.push(w - j * b, R - z * b), f.push(L, Ct)) : (f.push(Wt, Lt), f.push(L, Ct)) : (f.push(w - S * b, R - D * b), f.push(w + S * C, R + D * C), o.join === "round" ? ot ? g += Pi(w, R, w + S * C, R + D * C, w + j * C, R + z * C, f, !0) + 2 : g += Pi(w, R, w - S * b, R - D * b, w - j * b, R - z * b, f, !1) + 2 : o.join === "miter" && ee / x <= y && (ot ? (f.push(L, Ct), f.push(L, Ct)) : (f.push(Wt, Lt), f.push(Wt, Lt)), g += 2), f.push(w - j * b, R - z * b), f.push(w + j * C, R + z * C), g += 2);
        }
        v = i[(_ - 2) * 2], I = i[(_ - 2) * 2 + 1], w = i[(_ - 1) * 2], R = i[(_ - 1) * 2 + 1], S = -(I - R), D = v - w, K = Math.sqrt(S * S + D * D), S /= K, D /= K, S *= m, D *= m, f.push(w - S * b, R - D * b), f.push(w + S * C, R + D * C), u || (o.cap === "round" ? g += Pi(w - S * (b - C) * .5, R - D * (b - C) * .5, w - S * b, R - D * b, w + S * C, R + D * C, f, !1) + 2 : o.cap === "square" && (g += Kd(w, R, S, D, b, C, !1, f)));
        const A = $d * $d;
        for(let U = p; U < g + p - 2; ++U)v = f[U * 2], I = f[U * 2 + 1], w = f[(U + 1) * 2], R = f[(U + 1) * 2 + 1], N = f[(U + 2) * 2], E = f[(U + 2) * 2 + 1], !(Math.abs(v * (R - E) + w * (E - I) + N * (I - R)) < A) && r.push(U, U + 1, U + 2);
    }
    function HE(i, t, e, n) {
        const s = hm;
        if (i.length === 0) return;
        const r = i[0], a = i[1], o = i[i.length - 2], c = i[i.length - 1], l = t || Math.abs(r - o) < s && Math.abs(a - c) < s, h = e, u = i.length / 2, d = h.length / 2;
        for(let f = 0; f < u; f++)h.push(i[f * 2]), h.push(i[f * 2 + 1]);
        for(let f = 0; f < u - 1; f++)n.push(d + f, d + f + 1);
        l && n.push(d + u - 1, d);
    }
    function um(i, t, e, n, s, r, a) {
        const o = HT(i, t, 2);
        if (!o) return;
        for(let l = 0; l < o.length; l += 3)r[a++] = o[l] + s, r[a++] = o[l + 1] + s, r[a++] = o[l + 2] + s;
        let c = s * n;
        for(let l = 0; l < i.length; l += 2)e[c] = i[l], e[c + 1] = i[l + 1], c += n;
    }
    const zE = [], VE = {
        extension: {
            type: st.ShapeBuilder,
            name: "polygon"
        },
        build (i, t) {
            for(let e = 0; e < i.points.length; e++)t[e] = i.points[e];
            return t;
        },
        triangulate (i, t, e, n, s, r) {
            um(i, zE, t, e, n, s, r);
        }
    }, WE = {
        extension: {
            type: st.ShapeBuilder,
            name: "rectangle"
        },
        build (i, t) {
            const e = i, n = e.x, s = e.y, r = e.width, a = e.height;
            return r >= 0 && a >= 0 && (t[0] = n, t[1] = s, t[2] = n + r, t[3] = s, t[4] = n + r, t[5] = s + a, t[6] = n, t[7] = s + a), t;
        },
        triangulate (i, t, e, n, s, r) {
            let a = 0;
            n *= e, t[n + a] = i[0], t[n + a + 1] = i[1], a += e, t[n + a] = i[2], t[n + a + 1] = i[3], a += e, t[n + a] = i[6], t[n + a + 1] = i[7], a += e, t[n + a] = i[4], t[n + a + 1] = i[5], a += e;
            const o = n / e;
            s[r++] = o, s[r++] = o + 1, s[r++] = o + 2, s[r++] = o + 1, s[r++] = o + 3, s[r++] = o + 2;
        }
    }, XE = {
        extension: {
            type: st.ShapeBuilder,
            name: "triangle"
        },
        build (i, t) {
            return t[0] = i.x, t[1] = i.y, t[2] = i.x2, t[3] = i.y2, t[4] = i.x3, t[5] = i.y3, t;
        },
        triangulate (i, t, e, n, s, r) {
            let a = 0;
            n *= e, t[n + a] = i[0], t[n + a + 1] = i[1], a += e, t[n + a] = i[2], t[n + a + 1] = i[3], a += e, t[n + a] = i[4], t[n + a + 1] = i[5];
            const o = n / e;
            s[r++] = o, s[r++] = o + 1, s[r++] = o + 2;
        }
    }, YE = new Ft, qE = new fe;
    function jE(i, t, e, n) {
        const s = t.matrix ? i.copyFrom(t.matrix).invert() : i.identity();
        if (t.textureSpace === "local") {
            const r = e.getBounds(qE);
            s.translate(-r.x, -r.y), s.scale(1 / r.width, 1 / r.height);
        } else {
            s.translate(t.texture.frame.x, t.texture.frame.y), s.scale(1 / t.texture.source.width, 1 / t.texture.source.height);
            const r = t.texture.source.style;
            r.addressMode === "clamp-to-edge" && (r.addressMode = "repeat", r.update());
        }
        return n && s.append(YE.copyFrom(n).invert()), s;
    }
    const Qa = {};
    Be.handleByMap(st.ShapeBuilder, Qa);
    Be.add(WE, VE, XE, Lr, FE, OE);
    const $E = new fe, KE = new Ft;
    function ZE(i, t) {
        const { geometryData: e, batches: n } = t;
        n.length = 0, e.indices.length = 0, e.vertices.length = 0, e.uvs.length = 0;
        for(let s = 0; s < i.instructions.length; s++){
            const r = i.instructions[s];
            if (r.action === "texture") JE(r.data, n, e);
            else if (r.action === "fill" || r.action === "stroke") {
                const a = r.action === "stroke", o = r.data.path.shapePath, c = r.data.style, l = r.data.hole;
                a && l && Zd(l.shapePath, c, !0, n, e), l && (o.shapePrimitives[o.shapePrimitives.length - 1].holes = l.shapePath.shapePrimitives), Zd(o, c, a, n, e);
            }
        }
    }
    function JE(i, t, e) {
        const { vertices: n, uvs: s, indices: r } = e, a = r.length, o = n.length / 2, c = [], l = Qa.rectangle, h = $E, u = i.image;
        h.x = i.dx, h.y = i.dy, h.width = i.dw, h.height = i.dh;
        const d = i.transform;
        l.build(h, c), d && cm(c, d), l.triangulate(c, n, 2, o, r, a);
        const f = u.uvs;
        s.push(f.x0, f.y0, f.x1, f.y1, f.x3, f.y3, f.x2, f.y2);
        const _ = Ge.get(lm);
        _.indexOffset = a, _.indexSize = r.length - a, _.attributeOffset = o, _.attributeSize = n.length / 2 - o, _.baseColor = i.style, _.alpha = i.alpha, _.texture = u, _.geometryData = e, t.push(_);
    }
    function Zd(i, t, e, n, s) {
        const { vertices: r, uvs: a, indices: o } = s;
        i.shapePrimitives.forEach(({ shape: c, transform: l, holes: h })=>{
            const u = o.length, d = r.length / 2, f = [], _ = Qa[c.type];
            let g = "triangle-list";
            if (_.build(c, f), l && cm(f, l), e) {
                const y = c.closePath ?? !0, v = t;
                v.pixelLine ? (HE(f, y, r, o), g = "line-list") : GE(f, v, !1, y, r, o);
            } else if (h) {
                const y = [], v = f.slice();
                QE(h).forEach((w)=>{
                    y.push(v.length / 2), v.push(...w);
                }), um(v, y, r, 2, d, o, u);
            } else _.triangulate(f, r, 2, d, o, u);
            const p = a.length / 2, m = t.texture;
            if (m !== Ot.WHITE) {
                const y = jE(KE, t, c, l);
                UE(r, 2, d, a, p, 2, r.length / 2 - d, y);
            } else NE(a, p, 2, r.length / 2 - d);
            const x = Ge.get(lm);
            x.indexOffset = u, x.indexSize = o.length - u, x.attributeOffset = d, x.attributeSize = r.length / 2 - d, x.baseColor = t.color, x.alpha = t.alpha, x.texture = m, x.geometryData = s, x.topology = g, n.push(x);
        });
    }
    function QE(i) {
        const t = [];
        for(let e = 0; e < i.length; e++){
            const n = i[e].shape, s = [];
            Qa[n.type].build(n, s), t.push(s);
        }
        return t;
    }
    class tA {
        constructor(){
            this.batches = [], this.geometryData = {
                vertices: [],
                uvs: [],
                indices: []
            };
        }
    }
    class eA {
        constructor(){
            this.batcher = new vh, this.instructions = new Mp;
        }
        init() {
            this.instructions.reset();
        }
        get geometry() {
            return ue(AM, "GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead."), this.batcher.geometry;
        }
    }
    const yh = class wl {
        constructor(t){
            this._gpuContextHash = {}, this._graphicsDataContextHash = Object.create(null), t.renderableGC.addManagedHash(this, "_gpuContextHash"), t.renderableGC.addManagedHash(this, "_graphicsDataContextHash");
        }
        init(t) {
            wl.defaultOptions.bezierSmoothness = t?.bezierSmoothness ?? wl.defaultOptions.bezierSmoothness;
        }
        getContextRenderData(t) {
            return this._graphicsDataContextHash[t.uid] || this._initContextRenderData(t);
        }
        updateGpuContext(t) {
            let e = this._gpuContextHash[t.uid] || this._initContext(t);
            if (t.dirty) {
                e ? this._cleanGraphicsContextData(t) : e = this._initContext(t), ZE(t, e);
                const n = t.batchMode;
                t.customShader || n === "no-batch" ? e.isBatchable = !1 : n === "auto" && (e.isBatchable = e.geometryData.vertices.length < 400), t.dirty = !1;
            }
            return e;
        }
        getGpuContext(t) {
            return this._gpuContextHash[t.uid] || this._initContext(t);
        }
        _initContextRenderData(t) {
            const e = Ge.get(eA), { batches: n, geometryData: s } = this._gpuContextHash[t.uid], r = s.vertices.length, a = s.indices.length;
            for(let h = 0; h < n.length; h++)n[h].applyTransform = !1;
            const o = e.batcher;
            o.ensureAttributeBuffer(r), o.ensureIndexBuffer(a), o.begin();
            for(let h = 0; h < n.length; h++){
                const u = n[h];
                o.add(u);
            }
            o.finish(e.instructions);
            const c = o.geometry;
            c.indexBuffer.setDataWithSize(o.indexBuffer, o.indexSize, !0), c.buffers[0].setDataWithSize(o.attributeBuffer.float32View, o.attributeSize, !0);
            const l = o.batches;
            for(let h = 0; h < l.length; h++){
                const u = l[h];
                u.bindGroup = eE(u.textures.textures, u.textures.count);
            }
            return this._graphicsDataContextHash[t.uid] = e, e;
        }
        _initContext(t) {
            const e = new tA;
            return e.context = t, this._gpuContextHash[t.uid] = e, t.on("destroy", this.onGraphicsContextDestroy, this), this._gpuContextHash[t.uid];
        }
        onGraphicsContextDestroy(t) {
            this._cleanGraphicsContextData(t), t.off("destroy", this.onGraphicsContextDestroy, this), this._gpuContextHash[t.uid] = null;
        }
        _cleanGraphicsContextData(t) {
            const e = this._gpuContextHash[t.uid];
            e.isBatchable || this._graphicsDataContextHash[t.uid] && (Ge.return(this.getContextRenderData(t)), this._graphicsDataContextHash[t.uid] = null), e.batches && e.batches.forEach((n)=>{
                Ge.return(n);
            });
        }
        destroy() {
            for(const t in this._gpuContextHash)this._gpuContextHash[t] && this.onGraphicsContextDestroy(this._gpuContextHash[t].context);
        }
    };
    yh.extension = {
        type: [
            st.WebGLSystem,
            st.WebGPUSystem,
            st.CanvasSystem
        ],
        name: "graphicsContext"
    };
    yh.defaultOptions = {
        bezierSmoothness: .5
    };
    dm = yh;
    const nA = 8, ba = 11920929e-14, iA = 1;
    function fm(i, t, e, n, s, r, a, o, c, l) {
        const u = Math.min(.99, Math.max(0, l ?? dm.defaultOptions.bezierSmoothness));
        let d = (iA - u) / 1;
        return d *= d, sA(t, e, n, s, r, a, o, c, i, d), i;
    }
    function sA(i, t, e, n, s, r, a, o, c, l) {
        Rl(i, t, e, n, s, r, a, o, c, l, 0), c.push(a, o);
    }
    function Rl(i, t, e, n, s, r, a, o, c, l, h) {
        if (h > nA) return;
        const u = (i + e) / 2, d = (t + n) / 2, f = (e + s) / 2, _ = (n + r) / 2, g = (s + a) / 2, p = (r + o) / 2, m = (u + f) / 2, x = (d + _) / 2, y = (f + g) / 2, v = (_ + p) / 2, I = (m + y) / 2, w = (x + v) / 2;
        if (h > 0) {
            let R = a - i, N = o - t;
            const E = Math.abs((e - a) * N - (n - o) * R), S = Math.abs((s - a) * N - (r - o) * R);
            if (E > ba && S > ba) {
                if ((E + S) * (E + S) <= l * (R * R + N * N)) {
                    c.push(I, w);
                    return;
                }
            } else if (E > ba) {
                if (E * E <= l * (R * R + N * N)) {
                    c.push(I, w);
                    return;
                }
            } else if (S > ba) {
                if (S * S <= l * (R * R + N * N)) {
                    c.push(I, w);
                    return;
                }
            } else if (R = I - (i + a) / 2, N = w - (t + o) / 2, R * R + N * N <= l) {
                c.push(I, w);
                return;
            }
        }
        Rl(i, t, u, d, m, x, I, w, c, l, h + 1), Rl(I, w, y, v, g, p, a, o, c, l, h + 1);
    }
    const rA = 8, aA = 11920929e-14, oA = 1;
    function cA(i, t, e, n, s, r, a, o) {
        const l = Math.min(.99, Math.max(0, o ?? dm.defaultOptions.bezierSmoothness));
        let h = (oA - l) / 1;
        return h *= h, lA(t, e, n, s, r, a, i, h), i;
    }
    function lA(i, t, e, n, s, r, a, o) {
        Cl(a, i, t, e, n, s, r, o, 0), a.push(s, r);
    }
    function Cl(i, t, e, n, s, r, a, o, c) {
        if (c > rA) return;
        const l = (t + n) / 2, h = (e + s) / 2, u = (n + r) / 2, d = (s + a) / 2, f = (l + u) / 2, _ = (h + d) / 2;
        let g = r - t, p = a - e;
        const m = Math.abs((n - r) * p - (s - a) * g);
        if (m > aA) {
            if (m * m <= o * (g * g + p * p)) {
                i.push(f, _);
                return;
            }
        } else if (g = f - (t + r) / 2, p = _ - (e + a) / 2, g * g + p * p <= o) {
            i.push(f, _);
            return;
        }
        Cl(i, t, e, l, h, f, _, o, c + 1), Cl(i, f, _, u, d, r, a, o, c + 1);
    }
    function pm(i, t, e, n, s, r, a, o) {
        let c = Math.abs(s - r);
        (!a && s > r || a && r > s) && (c = 2 * Math.PI - c), o || (o = Math.max(6, Math.floor(6 * Math.pow(n, 1 / 3) * (c / Math.PI)))), o = Math.max(o, 3);
        let l = c / o, h = s;
        l *= a ? -1 : 1;
        for(let u = 0; u < o + 1; u++){
            const d = Math.cos(h), f = Math.sin(h), _ = t + d * n, g = e + f * n;
            i.push(_, g), h += l;
        }
    }
    function hA(i, t, e, n, s, r) {
        const a = i[i.length - 2], c = i[i.length - 1] - e, l = a - t, h = s - e, u = n - t, d = Math.abs(c * u - l * h);
        if (d < 1e-8 || r === 0) {
            (i[i.length - 2] !== t || i[i.length - 1] !== e) && i.push(t, e);
            return;
        }
        const f = c * c + l * l, _ = h * h + u * u, g = c * h + l * u, p = r * Math.sqrt(f) / d, m = r * Math.sqrt(_) / d, x = p * g / f, y = m * g / _, v = p * u + m * l, I = p * h + m * c, w = l * (m + x), R = c * (m + x), N = u * (p + y), E = h * (p + y), S = Math.atan2(R - I, w - v), D = Math.atan2(E - I, N - v);
        pm(i, v + t, I + e, r, S, D, l * h > u * c);
    }
    const br = Math.PI * 2, fc = {
        centerX: 0,
        centerY: 0,
        ang1: 0,
        ang2: 0
    }, pc = ({ x: i, y: t }, e, n, s, r, a, o, c)=>{
        i *= e, t *= n;
        const l = s * i - r * t, h = r * i + s * t;
        return c.x = l + a, c.y = h + o, c;
    };
    function uA(i, t) {
        const e = t === -1.5707963267948966 ? -.551915024494 : 1.3333333333333333 * Math.tan(t / 4), n = t === 1.5707963267948966 ? .551915024494 : e, s = Math.cos(i), r = Math.sin(i), a = Math.cos(i + t), o = Math.sin(i + t);
        return [
            {
                x: s - r * n,
                y: r + s * n
            },
            {
                x: a + o * n,
                y: o - a * n
            },
            {
                x: a,
                y: o
            }
        ];
    }
    const Jd = (i, t, e, n)=>{
        const s = i * n - t * e < 0 ? -1 : 1;
        let r = i * e + t * n;
        return r > 1 && (r = 1), r < -1 && (r = -1), s * Math.acos(r);
    }, dA = (i, t, e, n, s, r, a, o, c, l, h, u, d)=>{
        const f = Math.pow(s, 2), _ = Math.pow(r, 2), g = Math.pow(h, 2), p = Math.pow(u, 2);
        let m = f * _ - f * p - _ * g;
        m < 0 && (m = 0), m /= f * p + _ * g, m = Math.sqrt(m) * (a === o ? -1 : 1);
        const x = m * s / r * u, y = m * -r / s * h, v = l * x - c * y + (i + e) / 2, I = c * x + l * y + (t + n) / 2, w = (h - x) / s, R = (u - y) / r, N = (-h - x) / s, E = (-u - y) / r, S = Jd(1, 0, w, R);
        let D = Jd(w, R, N, E);
        o === 0 && D > 0 && (D -= br), o === 1 && D < 0 && (D += br), d.centerX = v, d.centerY = I, d.ang1 = S, d.ang2 = D;
    };
    function fA(i, t, e, n, s, r, a, o = 0, c = 0, l = 0) {
        if (r === 0 || a === 0) return;
        const h = Math.sin(o * br / 360), u = Math.cos(o * br / 360), d = u * (t - n) / 2 + h * (e - s) / 2, f = -h * (t - n) / 2 + u * (e - s) / 2;
        if (d === 0 && f === 0) return;
        r = Math.abs(r), a = Math.abs(a);
        const _ = Math.pow(d, 2) / Math.pow(r, 2) + Math.pow(f, 2) / Math.pow(a, 2);
        _ > 1 && (r *= Math.sqrt(_), a *= Math.sqrt(_)), dA(t, e, n, s, r, a, c, l, h, u, d, f, fc);
        let { ang1: g, ang2: p } = fc;
        const { centerX: m, centerY: x } = fc;
        let y = Math.abs(p) / (br / 4);
        Math.abs(1 - y) < 1e-7 && (y = 1);
        const v = Math.max(Math.ceil(y), 1);
        p /= v;
        let I = i[i.length - 2], w = i[i.length - 1];
        const R = {
            x: 0,
            y: 0
        };
        for(let N = 0; N < v; N++){
            const E = uA(g, p), { x: S, y: D } = pc(E[0], r, a, u, h, m, x, R), { x: j, y: z } = pc(E[1], r, a, u, h, m, x, R), { x: K, y: nt } = pc(E[2], r, a, u, h, m, x, R);
            fm(i, I, w, S, D, j, z, K, nt), I = K, w = nt, g += p;
        }
    }
    function pA(i, t, e) {
        const n = (a, o)=>{
            const c = o.x - a.x, l = o.y - a.y, h = Math.sqrt(c * c + l * l), u = c / h, d = l / h;
            return {
                len: h,
                nx: u,
                ny: d
            };
        }, s = (a, o)=>{
            a === 0 ? i.moveTo(o.x, o.y) : i.lineTo(o.x, o.y);
        };
        let r = t[t.length - 1];
        for(let a = 0; a < t.length; a++){
            const o = t[a % t.length], c = o.radius ?? e;
            if (c <= 0) {
                s(a, o), r = o;
                continue;
            }
            const l = t[(a + 1) % t.length], h = n(o, r), u = n(o, l);
            if (h.len < 1e-4 || u.len < 1e-4) {
                s(a, o), r = o;
                continue;
            }
            let d = Math.asin(h.nx * u.ny - h.ny * u.nx), f = 1, _ = !1;
            h.nx * u.nx - h.ny * -u.ny < 0 ? d < 0 ? d = Math.PI + d : (d = Math.PI - d, f = -1, _ = !0) : d > 0 && (f = -1, _ = !0);
            const g = d / 2;
            let p, m = Math.abs(Math.cos(g) * c / Math.sin(g));
            m > Math.min(h.len / 2, u.len / 2) ? (m = Math.min(h.len / 2, u.len / 2), p = Math.abs(m * Math.sin(g) / Math.cos(g))) : p = c;
            const x = o.x + u.nx * m + -u.ny * p * f, y = o.y + u.ny * m + u.nx * p * f, v = Math.atan2(h.ny, h.nx) + Math.PI / 2 * f, I = Math.atan2(u.ny, u.nx) - Math.PI / 2 * f;
            a === 0 && i.moveTo(x + Math.cos(v) * p, y + Math.sin(v) * p), i.arc(x, y, p, v, I, _), r = o;
        }
    }
    function mA(i, t, e, n) {
        const s = (o, c)=>Math.sqrt((o.x - c.x) ** 2 + (o.y - c.y) ** 2), r = (o, c, l)=>({
                x: o.x + (c.x - o.x) * l,
                y: o.y + (c.y - o.y) * l
            }), a = t.length;
        for(let o = 0; o < a; o++){
            const c = t[(o + 1) % a], l = c.radius ?? e;
            if (l <= 0) {
                o === 0 ? i.moveTo(c.x, c.y) : i.lineTo(c.x, c.y);
                continue;
            }
            const h = t[o], u = t[(o + 2) % a], d = s(h, c);
            let f;
            if (d < 1e-4) f = c;
            else {
                const p = Math.min(d / 2, l);
                f = r(c, h, p / d);
            }
            const _ = s(u, c);
            let g;
            if (_ < 1e-4) g = c;
            else {
                const p = Math.min(_ / 2, l);
                g = r(c, u, p / _);
            }
            o === 0 ? i.moveTo(f.x, f.y) : i.lineTo(f.x, f.y), i.quadraticCurveTo(c.x, c.y, g.x, g.y, n);
        }
    }
    const _A = new fe;
    class gA {
        constructor(t){
            this.shapePrimitives = [], this._currentPoly = null, this._bounds = new en, this._graphicsPath2D = t, this.signed = t.checkForHoles;
        }
        moveTo(t, e) {
            return this.startPoly(t, e), this;
        }
        lineTo(t, e) {
            this._ensurePoly();
            const n = this._currentPoly.points, s = n[n.length - 2], r = n[n.length - 1];
            return (s !== t || r !== e) && n.push(t, e), this;
        }
        arc(t, e, n, s, r, a) {
            this._ensurePoly(!1);
            const o = this._currentPoly.points;
            return pm(o, t, e, n, s, r, a), this;
        }
        arcTo(t, e, n, s, r) {
            this._ensurePoly();
            const a = this._currentPoly.points;
            return hA(a, t, e, n, s, r), this;
        }
        arcToSvg(t, e, n, s, r, a, o) {
            const c = this._currentPoly.points;
            return fA(c, this._currentPoly.lastX, this._currentPoly.lastY, a, o, t, e, n, s, r), this;
        }
        bezierCurveTo(t, e, n, s, r, a, o) {
            this._ensurePoly();
            const c = this._currentPoly;
            return fm(this._currentPoly.points, c.lastX, c.lastY, t, e, n, s, r, a, o), this;
        }
        quadraticCurveTo(t, e, n, s, r) {
            this._ensurePoly();
            const a = this._currentPoly;
            return cA(this._currentPoly.points, a.lastX, a.lastY, t, e, n, s, r), this;
        }
        closePath() {
            return this.endPoly(!0), this;
        }
        addPath(t, e) {
            this.endPoly(), e && !e.isIdentity() && (t = t.clone(!0), t.transform(e));
            const n = this.shapePrimitives, s = n.length;
            for(let r = 0; r < t.instructions.length; r++){
                const a = t.instructions[r];
                this[a.action](...a.data);
            }
            if (t.checkForHoles && n.length - s > 1) {
                let r = null;
                for(let a = s; a < n.length; a++){
                    const o = n[a];
                    if (o.shape.type === "polygon") {
                        const c = o.shape, l = r?.shape;
                        l && l.containsPolygon(c) ? (r.holes || (r.holes = []), r.holes.push(o), n.copyWithin(a, a + 1), n.length--, a--) : r = o;
                    }
                }
            }
            return this;
        }
        finish(t = !1) {
            this.endPoly(t);
        }
        rect(t, e, n, s, r) {
            return this.drawShape(new fe(t, e, n, s), r), this;
        }
        circle(t, e, n, s) {
            return this.drawShape(new ph(t, e, n), s), this;
        }
        poly(t, e, n) {
            const s = new yr(t);
            return s.closePath = e, this.drawShape(s, n), this;
        }
        regularPoly(t, e, n, s, r = 0, a) {
            s = Math.max(s | 0, 3);
            const o = -1 * Math.PI / 2 + r, c = Math.PI * 2 / s, l = [];
            for(let h = 0; h < s; h++){
                const u = o - h * c;
                l.push(t + n * Math.cos(u), e + n * Math.sin(u));
            }
            return this.poly(l, !0, a), this;
        }
        roundPoly(t, e, n, s, r, a = 0, o) {
            if (s = Math.max(s | 0, 3), r <= 0) return this.regularPoly(t, e, n, s, a);
            const c = n * Math.sin(Math.PI / s) - .001;
            r = Math.min(r, c);
            const l = -1 * Math.PI / 2 + a, h = Math.PI * 2 / s, u = (s - 2) * Math.PI / s / 2;
            for(let d = 0; d < s; d++){
                const f = d * h + l, _ = t + n * Math.cos(f), g = e + n * Math.sin(f), p = f + Math.PI + u, m = f - Math.PI - u, x = _ + r * Math.cos(p), y = g + r * Math.sin(p), v = _ + r * Math.cos(m), I = g + r * Math.sin(m);
                d === 0 ? this.moveTo(x, y) : this.lineTo(x, y), this.quadraticCurveTo(_, g, v, I, o);
            }
            return this.closePath();
        }
        roundShape(t, e, n = !1, s) {
            return t.length < 3 ? this : (n ? mA(this, t, e, s) : pA(this, t, e), this.closePath());
        }
        filletRect(t, e, n, s, r) {
            if (r === 0) return this.rect(t, e, n, s);
            const a = Math.min(n, s) / 2, o = Math.min(a, Math.max(-a, r)), c = t + n, l = e + s, h = o < 0 ? -o : 0, u = Math.abs(o);
            return this.moveTo(t, e + u).arcTo(t + h, e + h, t + u, e, u).lineTo(c - u, e).arcTo(c - h, e + h, c, e + u, u).lineTo(c, l - u).arcTo(c - h, l - h, t + n - u, l, u).lineTo(t + u, l).arcTo(t + h, l - h, t, l - u, u).closePath();
        }
        chamferRect(t, e, n, s, r, a) {
            if (r <= 0) return this.rect(t, e, n, s);
            const o = Math.min(r, Math.min(n, s) / 2), c = t + n, l = e + s, h = [
                t + o,
                e,
                c - o,
                e,
                c,
                e + o,
                c,
                l - o,
                c - o,
                l,
                t + o,
                l,
                t,
                l - o,
                t,
                e + o
            ];
            for(let u = h.length - 1; u >= 2; u -= 2)h[u] === h[u - 2] && h[u - 1] === h[u - 3] && h.splice(u - 1, 2);
            return this.poly(h, !0, a);
        }
        ellipse(t, e, n, s, r) {
            return this.drawShape(new mh(t, e, n, s), r), this;
        }
        roundRect(t, e, n, s, r, a) {
            return this.drawShape(new _h(t, e, n, s, r), a), this;
        }
        drawShape(t, e) {
            return this.endPoly(), this.shapePrimitives.push({
                shape: t,
                transform: e
            }), this;
        }
        startPoly(t, e) {
            let n = this._currentPoly;
            return n && this.endPoly(), n = new yr, n.points.push(t, e), this._currentPoly = n, this;
        }
        endPoly(t = !1) {
            const e = this._currentPoly;
            return e && e.points.length > 2 && (e.closePath = t, this.shapePrimitives.push({
                shape: e
            })), this._currentPoly = null, this;
        }
        _ensurePoly(t = !0) {
            if (!this._currentPoly && (this._currentPoly = new yr, t)) {
                const e = this.shapePrimitives[this.shapePrimitives.length - 1];
                if (e) {
                    let n = e.shape.x, s = e.shape.y;
                    if (e.transform && !e.transform.isIdentity()) {
                        const r = e.transform, a = n;
                        n = r.a * n + r.c * s + r.tx, s = r.b * a + r.d * s + r.ty;
                    }
                    this._currentPoly.points.push(n, s);
                } else this._currentPoly.points.push(0, 0);
            }
        }
        buildPath() {
            const t = this._graphicsPath2D;
            this.shapePrimitives.length = 0, this._currentPoly = null;
            for(let e = 0; e < t.instructions.length; e++){
                const n = t.instructions[e];
                this[n.action](...n.data);
            }
            this.finish();
        }
        get bounds() {
            const t = this._bounds;
            t.clear();
            const e = this.shapePrimitives;
            for(let n = 0; n < e.length; n++){
                const s = e[n], r = s.shape.getBounds(_A);
                s.transform ? t.addRect(r, s.transform) : t.addRect(r);
            }
            return t;
        }
    }
    class Gs {
        constructor(t, e = !1){
            this.instructions = [], this.uid = pe("graphicsPath"), this._dirty = !0, this.checkForHoles = e, typeof t == "string" ? jT(t, this) : this.instructions = t?.slice() ?? [];
        }
        get shapePath() {
            return this._shapePath || (this._shapePath = new gA(this)), this._dirty && (this._dirty = !1, this._shapePath.buildPath()), this._shapePath;
        }
        addPath(t, e) {
            return t = t.clone(), this.instructions.push({
                action: "addPath",
                data: [
                    t,
                    e
                ]
            }), this._dirty = !0, this;
        }
        arc(...t) {
            return this.instructions.push({
                action: "arc",
                data: t
            }), this._dirty = !0, this;
        }
        arcTo(...t) {
            return this.instructions.push({
                action: "arcTo",
                data: t
            }), this._dirty = !0, this;
        }
        arcToSvg(...t) {
            return this.instructions.push({
                action: "arcToSvg",
                data: t
            }), this._dirty = !0, this;
        }
        bezierCurveTo(...t) {
            return this.instructions.push({
                action: "bezierCurveTo",
                data: t
            }), this._dirty = !0, this;
        }
        bezierCurveToShort(t, e, n, s, r) {
            const a = this.instructions[this.instructions.length - 1], o = this.getLastPoint(Ue.shared);
            let c = 0, l = 0;
            if (!a || a.action !== "bezierCurveTo") c = o.x, l = o.y;
            else {
                c = a.data[2], l = a.data[3];
                const h = o.x, u = o.y;
                c = h + (h - c), l = u + (u - l);
            }
            return this.instructions.push({
                action: "bezierCurveTo",
                data: [
                    c,
                    l,
                    t,
                    e,
                    n,
                    s,
                    r
                ]
            }), this._dirty = !0, this;
        }
        closePath() {
            return this.instructions.push({
                action: "closePath",
                data: []
            }), this._dirty = !0, this;
        }
        ellipse(...t) {
            return this.instructions.push({
                action: "ellipse",
                data: t
            }), this._dirty = !0, this;
        }
        lineTo(...t) {
            return this.instructions.push({
                action: "lineTo",
                data: t
            }), this._dirty = !0, this;
        }
        moveTo(...t) {
            return this.instructions.push({
                action: "moveTo",
                data: t
            }), this;
        }
        quadraticCurveTo(...t) {
            return this.instructions.push({
                action: "quadraticCurveTo",
                data: t
            }), this._dirty = !0, this;
        }
        quadraticCurveToShort(t, e, n) {
            const s = this.instructions[this.instructions.length - 1], r = this.getLastPoint(Ue.shared);
            let a = 0, o = 0;
            if (!s || s.action !== "quadraticCurveTo") a = r.x, o = r.y;
            else {
                a = s.data[0], o = s.data[1];
                const c = r.x, l = r.y;
                a = c + (c - a), o = l + (l - o);
            }
            return this.instructions.push({
                action: "quadraticCurveTo",
                data: [
                    a,
                    o,
                    t,
                    e,
                    n
                ]
            }), this._dirty = !0, this;
        }
        rect(t, e, n, s, r) {
            return this.instructions.push({
                action: "rect",
                data: [
                    t,
                    e,
                    n,
                    s,
                    r
                ]
            }), this._dirty = !0, this;
        }
        circle(t, e, n, s) {
            return this.instructions.push({
                action: "circle",
                data: [
                    t,
                    e,
                    n,
                    s
                ]
            }), this._dirty = !0, this;
        }
        roundRect(...t) {
            return this.instructions.push({
                action: "roundRect",
                data: t
            }), this._dirty = !0, this;
        }
        poly(...t) {
            return this.instructions.push({
                action: "poly",
                data: t
            }), this._dirty = !0, this;
        }
        regularPoly(...t) {
            return this.instructions.push({
                action: "regularPoly",
                data: t
            }), this._dirty = !0, this;
        }
        roundPoly(...t) {
            return this.instructions.push({
                action: "roundPoly",
                data: t
            }), this._dirty = !0, this;
        }
        roundShape(...t) {
            return this.instructions.push({
                action: "roundShape",
                data: t
            }), this._dirty = !0, this;
        }
        filletRect(...t) {
            return this.instructions.push({
                action: "filletRect",
                data: t
            }), this._dirty = !0, this;
        }
        chamferRect(...t) {
            return this.instructions.push({
                action: "chamferRect",
                data: t
            }), this._dirty = !0, this;
        }
        star(t, e, n, s, r, a, o) {
            r || (r = s / 2);
            const c = -1 * Math.PI / 2 + a, l = n * 2, h = Math.PI * 2 / l, u = [];
            for(let d = 0; d < l; d++){
                const f = d % 2 ? r : s, _ = d * h + c;
                u.push(t + f * Math.cos(_), e + f * Math.sin(_));
            }
            return this.poly(u, !0, o), this;
        }
        clone(t = !1) {
            const e = new Gs;
            if (e.checkForHoles = this.checkForHoles, !t) e.instructions = this.instructions.slice();
            else for(let n = 0; n < this.instructions.length; n++){
                const s = this.instructions[n];
                e.instructions.push({
                    action: s.action,
                    data: s.data.slice()
                });
            }
            return e;
        }
        clear() {
            return this.instructions.length = 0, this._dirty = !0, this;
        }
        transform(t) {
            if (t.isIdentity()) return this;
            const e = t.a, n = t.b, s = t.c, r = t.d, a = t.tx, o = t.ty;
            let c = 0, l = 0, h = 0, u = 0, d = 0, f = 0, _ = 0, g = 0;
            for(let p = 0; p < this.instructions.length; p++){
                const m = this.instructions[p], x = m.data;
                switch(m.action){
                    case "moveTo":
                    case "lineTo":
                        c = x[0], l = x[1], x[0] = e * c + s * l + a, x[1] = n * c + r * l + o;
                        break;
                    case "bezierCurveTo":
                        h = x[0], u = x[1], d = x[2], f = x[3], c = x[4], l = x[5], x[0] = e * h + s * u + a, x[1] = n * h + r * u + o, x[2] = e * d + s * f + a, x[3] = n * d + r * f + o, x[4] = e * c + s * l + a, x[5] = n * c + r * l + o;
                        break;
                    case "quadraticCurveTo":
                        h = x[0], u = x[1], c = x[2], l = x[3], x[0] = e * h + s * u + a, x[1] = n * h + r * u + o, x[2] = e * c + s * l + a, x[3] = n * c + r * l + o;
                        break;
                    case "arcToSvg":
                        c = x[5], l = x[6], _ = x[0], g = x[1], x[0] = e * _ + s * g, x[1] = n * _ + r * g, x[5] = e * c + s * l + a, x[6] = n * c + r * l + o;
                        break;
                    case "circle":
                        x[4] = or(x[3], t);
                        break;
                    case "rect":
                        x[4] = or(x[4], t);
                        break;
                    case "ellipse":
                        x[8] = or(x[8], t);
                        break;
                    case "roundRect":
                        x[5] = or(x[5], t);
                        break;
                    case "addPath":
                        x[0].transform(t);
                        break;
                    case "poly":
                        x[2] = or(x[2], t);
                        break;
                    default:
                        _e("unknown transform action", m.action);
                        break;
                }
            }
            return this._dirty = !0, this;
        }
        get bounds() {
            return this.shapePath.bounds;
        }
        getLastPoint(t) {
            let e = this.instructions.length - 1, n = this.instructions[e];
            if (!n) return t.x = 0, t.y = 0, t;
            for(; n.action === "closePath";){
                if (e--, e < 0) return t.x = 0, t.y = 0, t;
                n = this.instructions[e];
            }
            switch(n.action){
                case "moveTo":
                case "lineTo":
                    t.x = n.data[0], t.y = n.data[1];
                    break;
                case "quadraticCurveTo":
                    t.x = n.data[2], t.y = n.data[3];
                    break;
                case "bezierCurveTo":
                    t.x = n.data[4], t.y = n.data[5];
                    break;
                case "arc":
                case "arcToSvg":
                    t.x = n.data[5], t.y = n.data[6];
                    break;
                case "addPath":
                    n.data[0].getLastPoint(t);
                    break;
            }
            return t;
        }
    }
    function or(i, t) {
        return i ? i.prepend(t) : t.clone();
    }
    function ye(i, t, e) {
        const n = i.getAttribute(t);
        return n ? Number(n) : e;
    }
    function xA(i, t) {
        const e = i.querySelectorAll("defs");
        for(let n = 0; n < e.length; n++){
            const s = e[n];
            for(let r = 0; r < s.children.length; r++){
                const a = s.children[r];
                switch(a.nodeName.toLowerCase()){
                    case "lineargradient":
                        t.defs[a.id] = vA(a);
                        break;
                    case "radialgradient":
                        t.defs[a.id] = yA();
                        break;
                }
            }
        }
    }
    function vA(i) {
        const t = ye(i, "x1", 0), e = ye(i, "y1", 0), n = ye(i, "x2", 1), s = ye(i, "y2", 0), r = i.getAttribute("gradientUnits") || "objectBoundingBox", a = new qi(t, e, n, s, r === "objectBoundingBox" ? "local" : "global");
        for(let o = 0; o < i.children.length; o++){
            const c = i.children[o], l = ye(c, "offset", 0), h = Pe.shared.setValue(c.getAttribute("stop-color")).toNumber();
            a.addColorStop(l, h);
        }
        return a;
    }
    function yA(i) {
        return _e("[SVG Parser] Radial gradients are not yet supported"), new qi(0, 0, 1, 0);
    }
    function Qd(i) {
        const t = i.match(/url\s*\(\s*['"]?\s*#([^'"\s)]+)\s*['"]?\s*\)/i);
        return t ? t[1] : "";
    }
    const tf = {
        fill: {
            type: "paint",
            default: 0
        },
        "fill-opacity": {
            type: "number",
            default: 1
        },
        stroke: {
            type: "paint",
            default: 0
        },
        "stroke-width": {
            type: "number",
            default: 1
        },
        "stroke-opacity": {
            type: "number",
            default: 1
        },
        "stroke-linecap": {
            type: "string",
            default: "butt"
        },
        "stroke-linejoin": {
            type: "string",
            default: "miter"
        },
        "stroke-miterlimit": {
            type: "number",
            default: 10
        },
        "stroke-dasharray": {
            type: "string",
            default: "none"
        },
        "stroke-dashoffset": {
            type: "number",
            default: 0
        },
        opacity: {
            type: "number",
            default: 1
        }
    };
    function mm(i, t) {
        const e = i.getAttribute("style"), n = {}, s = {}, r = {
            strokeStyle: n,
            fillStyle: s,
            useFill: !1,
            useStroke: !1
        };
        for(const a in tf){
            const o = i.getAttribute(a);
            o && ef(t, r, a, o.trim());
        }
        if (e) {
            const a = e.split(";");
            for(let o = 0; o < a.length; o++){
                const c = a[o].trim(), [l, h] = c.split(":");
                tf[l] && ef(t, r, l, h.trim());
            }
        }
        return {
            strokeStyle: r.useStroke ? n : null,
            fillStyle: r.useFill ? s : null,
            useFill: r.useFill,
            useStroke: r.useStroke
        };
    }
    function ef(i, t, e, n) {
        switch(e){
            case "stroke":
                if (n !== "none") {
                    if (n.startsWith("url(")) {
                        const s = Qd(n);
                        t.strokeStyle.fill = i.defs[s];
                    } else t.strokeStyle.color = Pe.shared.setValue(n).toNumber();
                    t.useStroke = !0;
                }
                break;
            case "stroke-width":
                t.strokeStyle.width = Number(n);
                break;
            case "fill":
                if (n !== "none") {
                    if (n.startsWith("url(")) {
                        const s = Qd(n);
                        t.fillStyle.fill = i.defs[s];
                    } else t.fillStyle.color = Pe.shared.setValue(n).toNumber();
                    t.useFill = !0;
                }
                break;
            case "fill-opacity":
                t.fillStyle.alpha = Number(n);
                break;
            case "stroke-opacity":
                t.strokeStyle.alpha = Number(n);
                break;
            case "opacity":
                t.fillStyle.alpha = Number(n), t.strokeStyle.alpha = Number(n);
                break;
        }
    }
    function bA(i, t) {
        if (typeof i == "string") {
            const a = document.createElement("div");
            a.innerHTML = i.trim(), i = a.querySelector("svg");
        }
        const e = {
            context: t,
            defs: {},
            path: new Gs
        };
        xA(i, e);
        const n = i.children, { fillStyle: s, strokeStyle: r } = mm(i, e);
        for(let a = 0; a < n.length; a++){
            const o = n[a];
            o.nodeName.toLowerCase() !== "defs" && _m(o, e, s, r);
        }
        return t;
    }
    function _m(i, t, e, n) {
        const s = i.children, { fillStyle: r, strokeStyle: a } = mm(i, t);
        r && e ? e = {
            ...e,
            ...r
        } : r && (e = r), a && n ? n = {
            ...n,
            ...a
        } : a && (n = a);
        const o = !e && !n;
        o && (e = {
            color: 0
        });
        let c, l, h, u, d, f, _, g, p, m, x, y, v, I, w, R, N;
        switch(i.nodeName.toLowerCase()){
            case "path":
                I = i.getAttribute("d"), i.getAttribute("fill-rule") === "evenodd" && _e("SVG Evenodd fill rule not supported, your svg may render incorrectly"), w = new Gs(I, !0), t.context.path(w), e && t.context.fill(e), n && t.context.stroke(n);
                break;
            case "circle":
                _ = ye(i, "cx", 0), g = ye(i, "cy", 0), p = ye(i, "r", 0), t.context.ellipse(_, g, p, p), e && t.context.fill(e), n && t.context.stroke(n);
                break;
            case "rect":
                c = ye(i, "x", 0), l = ye(i, "y", 0), R = ye(i, "width", 0), N = ye(i, "height", 0), m = ye(i, "rx", 0), x = ye(i, "ry", 0), m || x ? t.context.roundRect(c, l, R, N, m || x) : t.context.rect(c, l, R, N), e && t.context.fill(e), n && t.context.stroke(n);
                break;
            case "ellipse":
                _ = ye(i, "cx", 0), g = ye(i, "cy", 0), m = ye(i, "rx", 0), x = ye(i, "ry", 0), t.context.beginPath(), t.context.ellipse(_, g, m, x), e && t.context.fill(e), n && t.context.stroke(n);
                break;
            case "line":
                h = ye(i, "x1", 0), u = ye(i, "y1", 0), d = ye(i, "x2", 0), f = ye(i, "y2", 0), t.context.beginPath(), t.context.moveTo(h, u), t.context.lineTo(d, f), n && t.context.stroke(n);
                break;
            case "polygon":
                v = i.getAttribute("points"), y = v.match(/\d+/g).map((E)=>parseInt(E, 10)), t.context.poly(y, !0), e && t.context.fill(e), n && t.context.stroke(n);
                break;
            case "polyline":
                v = i.getAttribute("points"), y = v.match(/\d+/g).map((E)=>parseInt(E, 10)), t.context.poly(y, !1), n && t.context.stroke(n);
                break;
            case "g":
            case "svg":
                break;
            default:
                {
                    _e(`[SVG parser] <${i.nodeName}> elements unsupported`);
                    break;
                }
        }
        o && (e = null);
        for(let E = 0; E < s.length; E++)_m(s[E], t, e, n);
    }
    function SA(i) {
        return Pe.isColorLike(i);
    }
    function nf(i) {
        return i instanceof fh;
    }
    function sf(i) {
        return i instanceof qi;
    }
    function MA(i) {
        return i instanceof Ot;
    }
    function TA(i, t, e) {
        const n = Pe.shared.setValue(t ?? 0);
        return i.color = n.toNumber(), i.alpha = n.alpha === 1 ? e.alpha : n.alpha, i.texture = Ot.WHITE, {
            ...e,
            ...i
        };
    }
    function EA(i, t, e) {
        return i.texture = t, {
            ...e,
            ...i
        };
    }
    function rf(i, t, e) {
        return i.fill = t, i.color = 16777215, i.texture = t.texture, i.matrix = t.transform, {
            ...e,
            ...i
        };
    }
    function af(i, t, e) {
        return t.buildGradient(), i.fill = t, i.color = 16777215, i.texture = t.texture, i.matrix = t.transform, i.textureSpace = t.textureSpace, {
            ...e,
            ...i
        };
    }
    function AA(i, t) {
        const e = {
            ...t,
            ...i
        }, n = Pe.shared.setValue(e.color);
        return e.alpha *= n.alpha, e.color = n.toNumber(), e;
    }
    function Hi(i, t) {
        if (i == null) return null;
        const e = {}, n = i;
        return SA(i) ? TA(e, i, t) : MA(i) ? EA(e, i, t) : nf(i) ? rf(e, i, t) : sf(i) ? af(e, i, t) : n.fill && nf(n.fill) ? rf(n, n.fill, t) : n.fill && sf(n.fill) ? af(n, n.fill, t) : AA(n, t);
    }
    function Ya(i, t) {
        const { width: e, alignment: n, miterLimit: s, cap: r, join: a, pixelLine: o, ...c } = t, l = Hi(i, c);
        return l ? {
            width: e,
            alignment: n,
            miterLimit: s,
            cap: r,
            join: a,
            pixelLine: o,
            ...l
        } : null;
    }
    const wA = new Ue, of = new Ft, bh = class Un extends In {
        constructor(){
            super(...arguments), this.uid = pe("graphicsContext"), this.dirty = !0, this.batchMode = "auto", this.instructions = [], this._activePath = new Gs, this._transform = new Ft, this._fillStyle = {
                ...Un.defaultFillStyle
            }, this._strokeStyle = {
                ...Un.defaultStrokeStyle
            }, this._stateStack = [], this._tick = 0, this._bounds = new en, this._boundsDirty = !0;
        }
        clone() {
            const t = new Un;
            return t.batchMode = this.batchMode, t.instructions = this.instructions.slice(), t._activePath = this._activePath.clone(), t._transform = this._transform.clone(), t._fillStyle = {
                ...this._fillStyle
            }, t._strokeStyle = {
                ...this._strokeStyle
            }, t._stateStack = this._stateStack.slice(), t._bounds = this._bounds.clone(), t._boundsDirty = !0, t;
        }
        get fillStyle() {
            return this._fillStyle;
        }
        set fillStyle(t) {
            this._fillStyle = Hi(t, Un.defaultFillStyle);
        }
        get strokeStyle() {
            return this._strokeStyle;
        }
        set strokeStyle(t) {
            this._strokeStyle = Ya(t, Un.defaultStrokeStyle);
        }
        setFillStyle(t) {
            return this._fillStyle = Hi(t, Un.defaultFillStyle), this;
        }
        setStrokeStyle(t) {
            return this._strokeStyle = Hi(t, Un.defaultStrokeStyle), this;
        }
        texture(t, e, n, s, r, a) {
            return this.instructions.push({
                action: "texture",
                data: {
                    image: t,
                    dx: n || 0,
                    dy: s || 0,
                    dw: r || t.frame.width,
                    dh: a || t.frame.height,
                    transform: this._transform.clone(),
                    alpha: this._fillStyle.alpha,
                    style: e ? Pe.shared.setValue(e).toNumber() : 16777215
                }
            }), this.onUpdate(), this;
        }
        beginPath() {
            return this._activePath = new Gs, this;
        }
        fill(t, e) {
            let n;
            const s = this.instructions[this.instructions.length - 1];
            return this._tick === 0 && s && s.action === "stroke" ? n = s.data.path : n = this._activePath.clone(), n ? (t != null && (e !== void 0 && typeof t == "number" && (ue(be, "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead"), t = {
                color: t,
                alpha: e
            }), this._fillStyle = Hi(t, Un.defaultFillStyle)), this.instructions.push({
                action: "fill",
                data: {
                    style: this.fillStyle,
                    path: n
                }
            }), this.onUpdate(), this._initNextPathLocation(), this._tick = 0, this) : this;
        }
        _initNextPathLocation() {
            const { x: t, y: e } = this._activePath.getLastPoint(Ue.shared);
            this._activePath.clear(), this._activePath.moveTo(t, e);
        }
        stroke(t) {
            let e;
            const n = this.instructions[this.instructions.length - 1];
            return this._tick === 0 && n && n.action === "fill" ? e = n.data.path : e = this._activePath.clone(), e ? (t != null && (this._strokeStyle = Ya(t, Un.defaultStrokeStyle)), this.instructions.push({
                action: "stroke",
                data: {
                    style: this.strokeStyle,
                    path: e
                }
            }), this.onUpdate(), this._initNextPathLocation(), this._tick = 0, this) : this;
        }
        cut() {
            for(let t = 0; t < 2; t++){
                const e = this.instructions[this.instructions.length - 1 - t], n = this._activePath.clone();
                if (e && (e.action === "stroke" || e.action === "fill")) if (e.data.hole) e.data.hole.addPath(n);
                else {
                    e.data.hole = n;
                    break;
                }
            }
            return this._initNextPathLocation(), this;
        }
        arc(t, e, n, s, r, a) {
            this._tick++;
            const o = this._transform;
            return this._activePath.arc(o.a * t + o.c * e + o.tx, o.b * t + o.d * e + o.ty, n, s, r, a), this;
        }
        arcTo(t, e, n, s, r) {
            this._tick++;
            const a = this._transform;
            return this._activePath.arcTo(a.a * t + a.c * e + a.tx, a.b * t + a.d * e + a.ty, a.a * n + a.c * s + a.tx, a.b * n + a.d * s + a.ty, r), this;
        }
        arcToSvg(t, e, n, s, r, a, o) {
            this._tick++;
            const c = this._transform;
            return this._activePath.arcToSvg(t, e, n, s, r, c.a * a + c.c * o + c.tx, c.b * a + c.d * o + c.ty), this;
        }
        bezierCurveTo(t, e, n, s, r, a, o) {
            this._tick++;
            const c = this._transform;
            return this._activePath.bezierCurveTo(c.a * t + c.c * e + c.tx, c.b * t + c.d * e + c.ty, c.a * n + c.c * s + c.tx, c.b * n + c.d * s + c.ty, c.a * r + c.c * a + c.tx, c.b * r + c.d * a + c.ty, o), this;
        }
        closePath() {
            return this._tick++, this._activePath?.closePath(), this;
        }
        ellipse(t, e, n, s) {
            return this._tick++, this._activePath.ellipse(t, e, n, s, this._transform.clone()), this;
        }
        circle(t, e, n) {
            return this._tick++, this._activePath.circle(t, e, n, this._transform.clone()), this;
        }
        path(t) {
            return this._tick++, this._activePath.addPath(t, this._transform.clone()), this;
        }
        lineTo(t, e) {
            this._tick++;
            const n = this._transform;
            return this._activePath.lineTo(n.a * t + n.c * e + n.tx, n.b * t + n.d * e + n.ty), this;
        }
        moveTo(t, e) {
            this._tick++;
            const n = this._transform, s = this._activePath.instructions, r = n.a * t + n.c * e + n.tx, a = n.b * t + n.d * e + n.ty;
            return s.length === 1 && s[0].action === "moveTo" ? (s[0].data[0] = r, s[0].data[1] = a, this) : (this._activePath.moveTo(r, a), this);
        }
        quadraticCurveTo(t, e, n, s, r) {
            this._tick++;
            const a = this._transform;
            return this._activePath.quadraticCurveTo(a.a * t + a.c * e + a.tx, a.b * t + a.d * e + a.ty, a.a * n + a.c * s + a.tx, a.b * n + a.d * s + a.ty, r), this;
        }
        rect(t, e, n, s) {
            return this._tick++, this._activePath.rect(t, e, n, s, this._transform.clone()), this;
        }
        roundRect(t, e, n, s, r) {
            return this._tick++, this._activePath.roundRect(t, e, n, s, r, this._transform.clone()), this;
        }
        poly(t, e) {
            return this._tick++, this._activePath.poly(t, e, this._transform.clone()), this;
        }
        regularPoly(t, e, n, s, r = 0, a) {
            return this._tick++, this._activePath.regularPoly(t, e, n, s, r, a), this;
        }
        roundPoly(t, e, n, s, r, a) {
            return this._tick++, this._activePath.roundPoly(t, e, n, s, r, a), this;
        }
        roundShape(t, e, n, s) {
            return this._tick++, this._activePath.roundShape(t, e, n, s), this;
        }
        filletRect(t, e, n, s, r) {
            return this._tick++, this._activePath.filletRect(t, e, n, s, r), this;
        }
        chamferRect(t, e, n, s, r, a) {
            return this._tick++, this._activePath.chamferRect(t, e, n, s, r, a), this;
        }
        star(t, e, n, s, r = 0, a = 0) {
            return this._tick++, this._activePath.star(t, e, n, s, r, a, this._transform.clone()), this;
        }
        svg(t) {
            return this._tick++, bA(t, this), this;
        }
        restore() {
            const t = this._stateStack.pop();
            return t && (this._transform = t.transform, this._fillStyle = t.fillStyle, this._strokeStyle = t.strokeStyle), this;
        }
        save() {
            return this._stateStack.push({
                transform: this._transform.clone(),
                fillStyle: {
                    ...this._fillStyle
                },
                strokeStyle: {
                    ...this._strokeStyle
                }
            }), this;
        }
        getTransform() {
            return this._transform;
        }
        resetTransform() {
            return this._transform.identity(), this;
        }
        rotate(t) {
            return this._transform.rotate(t), this;
        }
        scale(t, e = t) {
            return this._transform.scale(t, e), this;
        }
        setTransform(t, e, n, s, r, a) {
            return t instanceof Ft ? (this._transform.set(t.a, t.b, t.c, t.d, t.tx, t.ty), this) : (this._transform.set(t, e, n, s, r, a), this);
        }
        transform(t, e, n, s, r, a) {
            return t instanceof Ft ? (this._transform.append(t), this) : (of.set(t, e, n, s, r, a), this._transform.append(of), this);
        }
        translate(t, e = t) {
            return this._transform.translate(t, e), this;
        }
        clear() {
            return this._activePath.clear(), this.instructions.length = 0, this.resetTransform(), this.onUpdate(), this;
        }
        onUpdate() {
            this.dirty || (this.emit("update", this, 16), this.dirty = !0, this._boundsDirty = !0);
        }
        get bounds() {
            if (!this._boundsDirty) return this._bounds;
            const t = this._bounds;
            t.clear();
            for(let e = 0; e < this.instructions.length; e++){
                const n = this.instructions[e], s = n.action;
                if (s === "fill") {
                    const r = n.data;
                    t.addBounds(r.path.bounds);
                } else if (s === "texture") {
                    const r = n.data;
                    t.addFrame(r.dx, r.dy, r.dx + r.dw, r.dy + r.dh, r.transform);
                }
                if (s === "stroke") {
                    const r = n.data, a = r.style.alignment, o = r.style.width * (1 - a), c = r.path.bounds;
                    t.addFrame(c.minX - o, c.minY - o, c.maxX + o, c.maxY + o);
                }
            }
            return t;
        }
        containsPoint(t) {
            if (!this.bounds.containsPoint(t.x, t.y)) return !1;
            const e = this.instructions;
            let n = !1;
            for(let s = 0; s < e.length; s++){
                const r = e[s], a = r.data, o = a.path;
                if (!r.action || !o) continue;
                const c = a.style, l = o.shapePath.shapePrimitives;
                for(let h = 0; h < l.length; h++){
                    const u = l[h].shape;
                    if (!c || !u) continue;
                    const d = l[h].transform, f = d ? d.applyInverse(t, wA) : t;
                    if (r.action === "fill") n = u.contains(f.x, f.y);
                    else {
                        const g = c;
                        n = u.strokeContains(f.x, f.y, g.width, g.alignment);
                    }
                    const _ = a.hole;
                    if (_) {
                        const g = _.shapePath?.shapePrimitives;
                        if (g) for(let p = 0; p < g.length; p++)g[p].shape.contains(f.x, f.y) && (n = !1);
                    }
                    if (n) return !0;
                }
            }
            return n;
        }
        destroy(t = !1) {
            if (this._stateStack.length = 0, this._transform = null, this.emit("destroy", this), this.removeAllListeners(), typeof t == "boolean" ? t : t?.texture) {
                const n = typeof t == "boolean" ? t : t?.textureSource;
                this._fillStyle.texture && this._fillStyle.texture.destroy(n), this._strokeStyle.texture && this._strokeStyle.texture.destroy(n);
            }
            this._fillStyle = null, this._strokeStyle = null, this.instructions = null, this._activePath = null, this._bounds = null, this._stateStack = null, this.customShader = null, this._transform = null;
        }
    };
    bh.defaultFillStyle = {
        color: 16777215,
        alpha: 1,
        texture: Ot.WHITE,
        matrix: null,
        fill: null,
        textureSpace: "local"
    };
    bh.defaultStrokeStyle = {
        width: 1,
        color: 16777215,
        alpha: 1,
        alignment: .5,
        miterLimit: 10,
        cap: "butt",
        join: "miter",
        texture: Ot.WHITE,
        matrix: null,
        fill: null,
        textureSpace: "local",
        pixelLine: !1
    };
    let Mn = bh;
    const cf = [
        "align",
        "breakWords",
        "cssOverrides",
        "fontVariant",
        "fontWeight",
        "leading",
        "letterSpacing",
        "lineHeight",
        "padding",
        "textBaseline",
        "trim",
        "whiteSpace",
        "wordWrap",
        "wordWrapWidth",
        "fontFamily",
        "fontStyle",
        "fontSize"
    ];
    RA = function(i) {
        const t = [];
        let e = 0;
        for(let n = 0; n < cf.length; n++){
            const s = `_${cf[n]}`;
            t[e++] = i[s];
        }
        return e = gm(i._fill, t, e), e = CA(i._stroke, t, e), e = PA(i.dropShadow, t, e), t.join("-");
    };
    function gm(i, t, e) {
        return i && (t[e++] = i.color, t[e++] = i.alpha, t[e++] = i.fill?.styleKey), e;
    }
    function CA(i, t, e) {
        return i && (e = gm(i, t, e), t[e++] = i.width, t[e++] = i.alignment, t[e++] = i.cap, t[e++] = i.join, t[e++] = i.miterLimit), e;
    }
    function PA(i, t, e) {
        return i && (t[e++] = i.alpha, t[e++] = i.angle, t[e++] = i.blur, t[e++] = i.distance, t[e++] = Pe.shared.setValue(i.color).toNumber()), e;
    }
    const Sh = class vs extends In {
        constructor(t = {}){
            super(), IA(t);
            const e = {
                ...vs.defaultTextStyle,
                ...t
            };
            for(const n in e){
                const s = n;
                this[s] = e[n];
            }
            this.update();
        }
        get align() {
            return this._align;
        }
        set align(t) {
            this._align = t, this.update();
        }
        get breakWords() {
            return this._breakWords;
        }
        set breakWords(t) {
            this._breakWords = t, this.update();
        }
        get dropShadow() {
            return this._dropShadow;
        }
        set dropShadow(t) {
            t !== null && typeof t == "object" ? this._dropShadow = this._createProxy({
                ...vs.defaultDropShadow,
                ...t
            }) : this._dropShadow = t ? this._createProxy({
                ...vs.defaultDropShadow
            }) : null, this.update();
        }
        get fontFamily() {
            return this._fontFamily;
        }
        set fontFamily(t) {
            this._fontFamily = t, this.update();
        }
        get fontSize() {
            return this._fontSize;
        }
        set fontSize(t) {
            typeof t == "string" ? this._fontSize = parseInt(t, 10) : this._fontSize = t, this.update();
        }
        get fontStyle() {
            return this._fontStyle;
        }
        set fontStyle(t) {
            this._fontStyle = t.toLowerCase(), this.update();
        }
        get fontVariant() {
            return this._fontVariant;
        }
        set fontVariant(t) {
            this._fontVariant = t, this.update();
        }
        get fontWeight() {
            return this._fontWeight;
        }
        set fontWeight(t) {
            this._fontWeight = t, this.update();
        }
        get leading() {
            return this._leading;
        }
        set leading(t) {
            this._leading = t, this.update();
        }
        get letterSpacing() {
            return this._letterSpacing;
        }
        set letterSpacing(t) {
            this._letterSpacing = t, this.update();
        }
        get lineHeight() {
            return this._lineHeight;
        }
        set lineHeight(t) {
            this._lineHeight = t, this.update();
        }
        get padding() {
            return this._padding;
        }
        set padding(t) {
            this._padding = t, this.update();
        }
        get trim() {
            return this._trim;
        }
        set trim(t) {
            this._trim = t, this.update();
        }
        get textBaseline() {
            return this._textBaseline;
        }
        set textBaseline(t) {
            this._textBaseline = t, this.update();
        }
        get whiteSpace() {
            return this._whiteSpace;
        }
        set whiteSpace(t) {
            this._whiteSpace = t, this.update();
        }
        get wordWrap() {
            return this._wordWrap;
        }
        set wordWrap(t) {
            this._wordWrap = t, this.update();
        }
        get wordWrapWidth() {
            return this._wordWrapWidth;
        }
        set wordWrapWidth(t) {
            this._wordWrapWidth = t, this.update();
        }
        get fill() {
            return this._originalFill;
        }
        set fill(t) {
            t !== this._originalFill && (this._originalFill = t, this._isFillStyle(t) && (this._originalFill = this._createProxy({
                ...Mn.defaultFillStyle,
                ...t
            }, ()=>{
                this._fill = Hi({
                    ...this._originalFill
                }, Mn.defaultFillStyle);
            })), this._fill = Hi(t === 0 ? "black" : t, Mn.defaultFillStyle), this.update());
        }
        get stroke() {
            return this._originalStroke;
        }
        set stroke(t) {
            t !== this._originalStroke && (this._originalStroke = t, this._isFillStyle(t) && (this._originalStroke = this._createProxy({
                ...Mn.defaultStrokeStyle,
                ...t
            }, ()=>{
                this._stroke = Ya({
                    ...this._originalStroke
                }, Mn.defaultStrokeStyle);
            })), this._stroke = Ya(t, Mn.defaultStrokeStyle), this.update());
        }
        _generateKey() {
            return this._styleKey = RA(this), this._styleKey;
        }
        update() {
            this._styleKey = null, this.emit("update", this);
        }
        reset() {
            const t = vs.defaultTextStyle;
            for(const e in t)this[e] = t[e];
        }
        get styleKey() {
            return this._styleKey || this._generateKey();
        }
        clone() {
            return new vs({
                align: this.align,
                breakWords: this.breakWords,
                dropShadow: this._dropShadow ? {
                    ...this._dropShadow
                } : null,
                fill: this._fill,
                fontFamily: this.fontFamily,
                fontSize: this.fontSize,
                fontStyle: this.fontStyle,
                fontVariant: this.fontVariant,
                fontWeight: this.fontWeight,
                leading: this.leading,
                letterSpacing: this.letterSpacing,
                lineHeight: this.lineHeight,
                padding: this.padding,
                stroke: this._stroke,
                textBaseline: this.textBaseline,
                whiteSpace: this.whiteSpace,
                wordWrap: this.wordWrap,
                wordWrapWidth: this.wordWrapWidth
            });
        }
        destroy(t = !1) {
            if (this.removeAllListeners(), typeof t == "boolean" ? t : t?.texture) {
                const n = typeof t == "boolean" ? t : t?.textureSource;
                this._fill?.texture && this._fill.texture.destroy(n), this._originalFill?.texture && this._originalFill.texture.destroy(n), this._stroke?.texture && this._stroke.texture.destroy(n), this._originalStroke?.texture && this._originalStroke.texture.destroy(n);
            }
            this._fill = null, this._stroke = null, this.dropShadow = null, this._originalStroke = null, this._originalFill = null;
        }
        _createProxy(t, e) {
            return new Proxy(t, {
                set: (n, s, r)=>(n[s] = r, e?.(s, r), this.update(), !0)
            });
        }
        _isFillStyle(t) {
            return (t ?? null) !== null && !(Pe.isColorLike(t) || t instanceof qi || t instanceof fh);
        }
    };
    Sh.defaultDropShadow = {
        alpha: 1,
        angle: Math.PI / 6,
        blur: 0,
        color: "black",
        distance: 5
    };
    Sh.defaultTextStyle = {
        align: "left",
        breakWords: !1,
        dropShadow: null,
        fill: "black",
        fontFamily: "Arial",
        fontSize: 26,
        fontStyle: "normal",
        fontVariant: "normal",
        fontWeight: "normal",
        leading: 0,
        letterSpacing: 0,
        lineHeight: 0,
        padding: 0,
        stroke: null,
        textBaseline: "alphabetic",
        trim: !1,
        whiteSpace: "pre",
        wordWrap: !1,
        wordWrapWidth: 100
    };
    Pl = Sh;
    function IA(i) {
        const t = i;
        if (typeof t.dropShadow == "boolean" && t.dropShadow) {
            const e = Pl.defaultDropShadow;
            i.dropShadow = {
                alpha: t.dropShadowAlpha ?? e.alpha,
                angle: t.dropShadowAngle ?? e.angle,
                blur: t.dropShadowBlur ?? e.blur,
                color: t.dropShadowColor ?? e.color,
                distance: t.dropShadowDistance ?? e.distance
            };
        }
        if (t.strokeThickness !== void 0) {
            ue(be, "strokeThickness is now a part of stroke");
            const e = t.stroke;
            let n = {};
            if (Pe.isColorLike(e)) n.color = e;
            else if (e instanceof qi || e instanceof fh) n.fill = e;
            else if (Object.hasOwnProperty.call(e, "color") || Object.hasOwnProperty.call(e, "fill")) n = e;
            else throw new Error("Invalid stroke value.");
            i.stroke = {
                ...n,
                width: t.strokeThickness
            };
        }
        if (Array.isArray(t.fillGradientStops)) {
            ue(be, "gradient fill is now a fill pattern: `new FillGradient(...)`");
            let e;
            i.fontSize == null ? i.fontSize = Pl.defaultTextStyle.fontSize : typeof i.fontSize == "string" ? e = parseInt(i.fontSize, 10) : e = i.fontSize;
            const n = new qi({
                start: {
                    x: 0,
                    y: 0
                },
                end: {
                    x: 0,
                    y: (e || 0) * 1.7
                }
            }), s = t.fillGradientStops.map((r)=>Pe.shared.setValue(r).toNumber());
            s.forEach((r, a)=>{
                const o = a / (s.length - 1);
                n.addColorStop(o, r);
            }), i.fill = {
                fill: n
            };
        }
    }
    const DA = [
        "serif",
        "sans-serif",
        "monospace",
        "cursive",
        "fantasy",
        "system-ui"
    ];
    LA = function(i) {
        const t = typeof i.fontSize == "number" ? `${i.fontSize}px` : i.fontSize;
        let e = i.fontFamily;
        Array.isArray(i.fontFamily) || (e = i.fontFamily.split(","));
        for(let n = e.length - 1; n >= 0; n--){
            let s = e[n].trim();
            !/([\"\'])[^\'\"]+\1/.test(s) && !DA.includes(s) && (s = `"${s}"`), e[n] = s;
        }
        return `${i.fontStyle} ${i.fontVariant} ${i.fontWeight} ${t} ${e.join(",")}`;
    };
    const mc = {
        willReadFrequently: !0
    }, Dn = class Mt {
        static get experimentalLetterSpacingSupported() {
            let t = Mt._experimentalLetterSpacingSupported;
            if (t !== void 0) {
                const e = $e.get().getCanvasRenderingContext2D().prototype;
                t = Mt._experimentalLetterSpacingSupported = "letterSpacing" in e || "textLetterSpacing" in e;
            }
            return t;
        }
        constructor(t, e, n, s, r, a, o, c, l){
            this.text = t, this.style = e, this.width = n, this.height = s, this.lines = r, this.lineWidths = a, this.lineHeight = o, this.maxLineWidth = c, this.fontProperties = l;
        }
        static measureText(t = " ", e, n = Mt._canvas, s = e.wordWrap) {
            const r = `${t}:${e.styleKey}`;
            if (Mt._measurementCache[r]) return Mt._measurementCache[r];
            const a = LA(e), o = Mt.measureFont(a);
            o.fontSize === 0 && (o.fontSize = e.fontSize, o.ascent = e.fontSize);
            const c = Mt.__context;
            c.font = a;
            const h = (s ? Mt._wordWrap(t, e, n) : t).split(/(?:\r\n|\r|\n)/), u = new Array(h.length);
            let d = 0;
            for(let x = 0; x < h.length; x++){
                const y = Mt._measureText(h[x], e.letterSpacing, c);
                u[x] = y, d = Math.max(d, y);
            }
            const f = e._stroke?.width || 0;
            let _ = d + f;
            e.dropShadow && (_ += e.dropShadow.distance);
            const g = e.lineHeight || o.fontSize;
            let p = Math.max(g, o.fontSize + f) + (h.length - 1) * (g + e.leading);
            return e.dropShadow && (p += e.dropShadow.distance), new Mt(t, e, _, p, h, u, g + e.leading, d, o);
        }
        static _measureText(t, e, n) {
            let s = !1;
            Mt.experimentalLetterSpacingSupported && (Mt.experimentalLetterSpacing ? (n.letterSpacing = `${e}px`, n.textLetterSpacing = `${e}px`, s = !0) : (n.letterSpacing = "0px", n.textLetterSpacing = "0px"));
            const r = n.measureText(t);
            let a = r.width;
            const o = -r.actualBoundingBoxLeft;
            let l = r.actualBoundingBoxRight - o;
            if (a > 0) if (s) a -= e, l -= e;
            else {
                const h = (Mt.graphemeSegmenter(t).length - 1) * e;
                a += h, l += h;
            }
            return Math.max(a, l);
        }
        static _wordWrap(t, e, n = Mt._canvas) {
            const s = n.getContext("2d", mc);
            let r = 0, a = "", o = "";
            const c = Object.create(null), { letterSpacing: l, whiteSpace: h } = e, u = Mt._collapseSpaces(h), d = Mt._collapseNewlines(h);
            let f = !u;
            const _ = e.wordWrapWidth + l, g = Mt._tokenize(t);
            for(let p = 0; p < g.length; p++){
                let m = g[p];
                if (Mt._isNewline(m)) {
                    if (!d) {
                        o += Mt._addLine(a), f = !u, a = "", r = 0;
                        continue;
                    }
                    m = " ";
                }
                if (u) {
                    const y = Mt.isBreakingSpace(m), v = Mt.isBreakingSpace(a[a.length - 1]);
                    if (y && v) continue;
                }
                const x = Mt._getFromCache(m, l, c, s);
                if (x > _) if (a !== "" && (o += Mt._addLine(a), a = "", r = 0), Mt.canBreakWords(m, e.breakWords)) {
                    const y = Mt.wordWrapSplit(m);
                    for(let v = 0; v < y.length; v++){
                        let I = y[v], w = I, R = 1;
                        for(; y[v + R];){
                            const E = y[v + R];
                            if (!Mt.canBreakChars(w, E, m, v, e.breakWords)) I += E;
                            else break;
                            w = E, R++;
                        }
                        v += R - 1;
                        const N = Mt._getFromCache(I, l, c, s);
                        N + r > _ && (o += Mt._addLine(a), f = !1, a = "", r = 0), a += I, r += N;
                    }
                } else {
                    a.length > 0 && (o += Mt._addLine(a), a = "", r = 0);
                    const y = p === g.length - 1;
                    o += Mt._addLine(m, !y), f = !1, a = "", r = 0;
                }
                else x + r > _ && (f = !1, o += Mt._addLine(a), a = "", r = 0), (a.length > 0 || !Mt.isBreakingSpace(m) || f) && (a += m, r += x);
            }
            return o += Mt._addLine(a, !1), o;
        }
        static _addLine(t, e = !0) {
            return t = Mt._trimRight(t), t = e ? `${t}
` : t, t;
        }
        static _getFromCache(t, e, n, s) {
            let r = n[t];
            return typeof r != "number" && (r = Mt._measureText(t, e, s) + e, n[t] = r), r;
        }
        static _collapseSpaces(t) {
            return t === "normal" || t === "pre-line";
        }
        static _collapseNewlines(t) {
            return t === "normal";
        }
        static _trimRight(t) {
            if (typeof t != "string") return "";
            for(let e = t.length - 1; e >= 0; e--){
                const n = t[e];
                if (!Mt.isBreakingSpace(n)) break;
                t = t.slice(0, -1);
            }
            return t;
        }
        static _isNewline(t) {
            return typeof t != "string" ? !1 : Mt._newlines.includes(t.charCodeAt(0));
        }
        static isBreakingSpace(t, e) {
            return typeof t != "string" ? !1 : Mt._breakingSpaces.includes(t.charCodeAt(0));
        }
        static _tokenize(t) {
            const e = [];
            let n = "";
            if (typeof t != "string") return e;
            for(let s = 0; s < t.length; s++){
                const r = t[s], a = t[s + 1];
                if (Mt.isBreakingSpace(r, a) || Mt._isNewline(r)) {
                    n !== "" && (e.push(n), n = ""), e.push(r);
                    continue;
                }
                n += r;
            }
            return n !== "" && e.push(n), e;
        }
        static canBreakWords(t, e) {
            return e;
        }
        static canBreakChars(t, e, n, s, r) {
            return !0;
        }
        static wordWrapSplit(t) {
            return Mt.graphemeSegmenter(t);
        }
        static measureFont(t) {
            if (Mt._fonts[t]) return Mt._fonts[t];
            const e = Mt._context;
            e.font = t;
            const n = e.measureText(Mt.METRICS_STRING + Mt.BASELINE_SYMBOL), s = {
                ascent: n.actualBoundingBoxAscent,
                descent: n.actualBoundingBoxDescent,
                fontSize: n.actualBoundingBoxAscent + n.actualBoundingBoxDescent
            };
            return Mt._fonts[t] = s, s;
        }
        static clearMetrics(t = "") {
            t ? delete Mt._fonts[t] : Mt._fonts = {};
        }
        static get _canvas() {
            if (!Mt.__canvas) {
                let t;
                try {
                    const e = new OffscreenCanvas(0, 0);
                    if (e.getContext("2d", mc)?.measureText) return Mt.__canvas = e, e;
                    t = $e.get().createCanvas();
                } catch  {
                    t = $e.get().createCanvas();
                }
                t.width = t.height = 10, Mt.__canvas = t;
            }
            return Mt.__canvas;
        }
        static get _context() {
            return Mt.__context || (Mt.__context = Mt._canvas.getContext("2d", mc)), Mt.__context;
        }
    };
    Dn.METRICS_STRING = "|q";
    Dn.BASELINE_SYMBOL = "M";
    Dn.BASELINE_MULTIPLIER = 1.4;
    Dn.HEIGHT_MULTIPLIER = 2;
    Dn.graphemeSegmenter = (()=>{
        if (typeof Intl?.Segmenter == "function") {
            const i = new Intl.Segmenter;
            return (t)=>[
                    ...i.segment(t)
                ].map((e)=>e.segment);
        }
        return (i)=>[
                ...i
            ];
    })();
    Dn.experimentalLetterSpacing = !1;
    Dn._fonts = {};
    Dn._newlines = [
        10,
        13
    ];
    Dn._breakingSpaces = [
        9,
        32,
        8192,
        8193,
        8194,
        8195,
        8196,
        8197,
        8198,
        8200,
        8201,
        8202,
        8287,
        12288
    ];
    Dn._measurementCache = {};
    UA = Dn;
    var NA = `in vec2 vMaskCoord;
in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform sampler2D uMaskTexture;

uniform float uAlpha;
uniform vec4 uMaskClamp;
uniform float uInverse;

out vec4 finalColor;

void main(void)
{
    float clip = step(3.5,
        step(uMaskClamp.x, vMaskCoord.x) +
        step(uMaskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, uMaskClamp.z) +
        step(vMaskCoord.y, uMaskClamp.w));

    // TODO look into why this is needed
    float npmAlpha = uAlpha;
    vec4 original = texture(uTexture, vTextureCoord);
    vec4 masky = texture(uMaskTexture, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    float a = alphaMul * masky.r * npmAlpha * clip;

    if (uInverse == 1.0) {
        a = 1.0 - a;
    }

    finalColor = original * a;
}
`, BA = `in vec2 aPosition;

out vec2 vTextureCoord;
out vec2 vMaskCoord;


uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;
uniform mat3 uFilterMatrix;

vec4 filterVertexPosition(  vec2 aPosition )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
       
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord(  vec2 aPosition )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

vec2 getFilterCoord( vec2 aPosition )
{
    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}   

void main(void)
{
    gl_Position = filterVertexPosition(aPosition);
    vTextureCoord = filterTextureCoord(aPosition);
    vMaskCoord = getFilterCoord(aPosition);
}
`, lf = `struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct MaskUniforms {
  uFilterMatrix:mat3x3<f32>,
  uMaskClamp:vec4<f32>,
  uAlpha:f32,
  uInverse:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;
@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) filterUv : vec2<f32>,
};

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);
}

fn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>
{
  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}

@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>,
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition),
   getFilterCoord(aPosition)
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) filterUv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {

    var maskClamp = filterUniforms.uMaskClamp;
    var uAlpha = filterUniforms.uAlpha;

    var clip = step(3.5,
      step(maskClamp.x, filterUv.x) +
      step(maskClamp.y, filterUv.y) +
      step(filterUv.x, maskClamp.z) +
      step(filterUv.y, maskClamp.w));

    var mask = textureSample(uMaskTexture, uSampler, filterUv);
    var source = textureSample(uTexture, uSampler, uv);
    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);

    var a: f32 = alphaMul * mask.r * uAlpha * clip;

    if (filterUniforms.uInverse == 1.0) {
        a = 1.0 - a;
    }

    return source * a;
}
`;
    class FA extends FT {
        constructor(t){
            const { sprite: e, ...n } = t, s = new mp(e.texture), r = new Ki({
                uFilterMatrix: {
                    value: new Ft,
                    type: "mat3x3<f32>"
                },
                uMaskClamp: {
                    value: s.uClampFrame,
                    type: "vec4<f32>"
                },
                uAlpha: {
                    value: 1,
                    type: "f32"
                },
                uInverse: {
                    value: t.inverse ? 1 : 0,
                    type: "f32"
                }
            }), a = qs.from({
                vertex: {
                    source: lf,
                    entryPoint: "mainVertex"
                },
                fragment: {
                    source: lf,
                    entryPoint: "mainFragment"
                }
            }), o = Br.from({
                vertex: BA,
                fragment: NA,
                name: "mask-filter"
            });
            super({
                ...n,
                gpuProgram: a,
                glProgram: o,
                resources: {
                    filterUniforms: r,
                    uMaskTexture: e.texture.source
                }
            }), this.sprite = e, this._textureMatrix = s;
        }
        set inverse(t) {
            this.resources.filterUniforms.uniforms.uInverse = t ? 1 : 0;
        }
        get inverse() {
            return this.resources.filterUniforms.uniforms.uInverse === 1;
        }
        apply(t, e, n, s) {
            this._textureMatrix.texture = this.sprite.texture, t.calculateSpriteMatrix(this.resources.filterUniforms.uniforms.uFilterMatrix, this.sprite).prepend(this._textureMatrix.mapCoord), this.resources.uMaskTexture = this.sprite.texture.source, t.applyFilter(this, e, n, s);
        }
    }
    ni = class extends hh {
        constructor(t){
            t instanceof Mn && (t = {
                context: t
            });
            const { context: e, roundPixels: n, ...s } = t || {};
            super({
                label: "Graphics",
                ...s
            }), this.renderPipeId = "graphics", e ? this._context = e : this._context = this._ownedContext = new Mn, this._context.on("update", this.onViewUpdate, this), this.allowChildren = !1, this.roundPixels = n ?? !1;
        }
        set context(t) {
            t !== this._context && (this._context.off("update", this.onViewUpdate, this), this._context = t, this._context.on("update", this.onViewUpdate, this), this.onViewUpdate());
        }
        get context() {
            return this._context;
        }
        get bounds() {
            return this._context.bounds;
        }
        updateBounds() {}
        containsPoint(t) {
            return this._context.containsPoint(t);
        }
        destroy(t) {
            this._ownedContext && !t ? this._ownedContext.destroy(t) : (t === !0 || t?.context === !0) && this._context.destroy(t), this._ownedContext = null, this._context = null, super.destroy(t);
        }
        _callContextMethod(t, e) {
            return this.context[t](...e), this;
        }
        setFillStyle(...t) {
            return this._callContextMethod("setFillStyle", t);
        }
        setStrokeStyle(...t) {
            return this._callContextMethod("setStrokeStyle", t);
        }
        fill(...t) {
            return this._callContextMethod("fill", t);
        }
        stroke(...t) {
            return this._callContextMethod("stroke", t);
        }
        texture(...t) {
            return this._callContextMethod("texture", t);
        }
        beginPath() {
            return this._callContextMethod("beginPath", []);
        }
        cut() {
            return this._callContextMethod("cut", []);
        }
        arc(...t) {
            return this._callContextMethod("arc", t);
        }
        arcTo(...t) {
            return this._callContextMethod("arcTo", t);
        }
        arcToSvg(...t) {
            return this._callContextMethod("arcToSvg", t);
        }
        bezierCurveTo(...t) {
            return this._callContextMethod("bezierCurveTo", t);
        }
        closePath() {
            return this._callContextMethod("closePath", []);
        }
        ellipse(...t) {
            return this._callContextMethod("ellipse", t);
        }
        circle(...t) {
            return this._callContextMethod("circle", t);
        }
        path(...t) {
            return this._callContextMethod("path", t);
        }
        lineTo(...t) {
            return this._callContextMethod("lineTo", t);
        }
        moveTo(...t) {
            return this._callContextMethod("moveTo", t);
        }
        quadraticCurveTo(...t) {
            return this._callContextMethod("quadraticCurveTo", t);
        }
        rect(...t) {
            return this._callContextMethod("rect", t);
        }
        roundRect(...t) {
            return this._callContextMethod("roundRect", t);
        }
        poly(...t) {
            return this._callContextMethod("poly", t);
        }
        regularPoly(...t) {
            return this._callContextMethod("regularPoly", t);
        }
        roundPoly(...t) {
            return this._callContextMethod("roundPoly", t);
        }
        roundShape(...t) {
            return this._callContextMethod("roundShape", t);
        }
        filletRect(...t) {
            return this._callContextMethod("filletRect", t);
        }
        chamferRect(...t) {
            return this._callContextMethod("chamferRect", t);
        }
        star(...t) {
            return this._callContextMethod("star", t);
        }
        svg(...t) {
            return this._callContextMethod("svg", t);
        }
        restore(...t) {
            return this._callContextMethod("restore", t);
        }
        save() {
            return this._callContextMethod("save", []);
        }
        getTransform() {
            return this.context.getTransform();
        }
        resetTransform() {
            return this._callContextMethod("resetTransform", []);
        }
        rotateTransform(...t) {
            return this._callContextMethod("rotate", t);
        }
        scaleTransform(...t) {
            return this._callContextMethod("scale", t);
        }
        setTransform(...t) {
            return this._callContextMethod("setTransform", t);
        }
        transform(...t) {
            return this._callContextMethod("transform", t);
        }
        translateTransform(...t) {
            return this._callContextMethod("translate", t);
        }
        clear() {
            return this._callContextMethod("clear", []);
        }
        get fillStyle() {
            return this._context.fillStyle;
        }
        set fillStyle(t) {
            this._context.fillStyle = t;
        }
        get strokeStyle() {
            return this._context.strokeStyle;
        }
        set strokeStyle(t) {
            this._context.strokeStyle = t;
        }
        clone(t = !1) {
            return t ? new ni(this._context.clone()) : (this._ownedContext = null, new ni(this._context));
        }
        lineStyle(t, e, n) {
            ue(be, "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");
            const s = {};
            return t && (s.width = t), e && (s.color = e), n && (s.alpha = n), this.context.strokeStyle = s, this;
        }
        beginFill(t, e) {
            ue(be, "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
            const n = {};
            return t !== void 0 && (n.color = t), e !== void 0 && (n.alpha = e), this.context.fillStyle = n, this;
        }
        endFill() {
            ue(be, "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."), this.context.fill();
            const t = this.context.strokeStyle;
            return (t.width !== Mn.defaultStrokeStyle.width || t.color !== Mn.defaultStrokeStyle.color || t.alpha !== Mn.defaultStrokeStyle.alpha) && this.context.stroke(), this;
        }
        drawCircle(...t) {
            return ue(be, "Graphics#drawCircle has been renamed to Graphics#circle"), this._callContextMethod("circle", t);
        }
        drawEllipse(...t) {
            return ue(be, "Graphics#drawEllipse has been renamed to Graphics#ellipse"), this._callContextMethod("ellipse", t);
        }
        drawPolygon(...t) {
            return ue(be, "Graphics#drawPolygon has been renamed to Graphics#poly"), this._callContextMethod("poly", t);
        }
        drawRect(...t) {
            return ue(be, "Graphics#drawRect has been renamed to Graphics#rect"), this._callContextMethod("rect", t);
        }
        drawRoundedRect(...t) {
            return ue(be, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect"), this._callContextMethod("roundRect", t);
        }
        drawStar(...t) {
            return ue(be, "Graphics#drawStar has been renamed to Graphics#star"), this._callContextMethod("star", t);
        }
    };
    class OA extends hh {
        constructor(t, e){
            const { text: n, resolution: s, style: r, anchor: a, width: o, height: c, roundPixels: l, ...h } = t;
            super({
                ...h
            }), this.batched = !0, this._resolution = null, this._autoResolution = !0, this._didTextUpdate = !0, this._styleClass = e, this.text = n ?? "", this.style = r, this.resolution = s ?? null, this.allowChildren = !1, this._anchor = new Je({
                _onUpdate: ()=>{
                    this.onViewUpdate();
                }
            }), a && (this.anchor = a), this.roundPixels = l ?? !1, o !== void 0 && (this.width = o), c !== void 0 && (this.height = c);
        }
        get anchor() {
            return this._anchor;
        }
        set anchor(t) {
            typeof t == "number" ? this._anchor.set(t) : this._anchor.copyFrom(t);
        }
        set text(t) {
            t = t.toString(), this._text !== t && (this._text = t, this.onViewUpdate());
        }
        get text() {
            return this._text;
        }
        set resolution(t) {
            this._autoResolution = t === null, this._resolution = t, this.onViewUpdate();
        }
        get resolution() {
            return this._resolution;
        }
        get style() {
            return this._style;
        }
        set style(t) {
            t || (t = {}), this._style?.off("update", this.onViewUpdate, this), t instanceof this._styleClass ? this._style = t : this._style = new this._styleClass(t), this._style.on("update", this.onViewUpdate, this), this.onViewUpdate();
        }
        get width() {
            return Math.abs(this.scale.x) * this.bounds.width;
        }
        set width(t) {
            this._setWidth(t, this.bounds.width);
        }
        get height() {
            return Math.abs(this.scale.y) * this.bounds.height;
        }
        set height(t) {
            this._setHeight(t, this.bounds.height);
        }
        getSize(t) {
            return t || (t = {}), t.width = Math.abs(this.scale.x) * this.bounds.width, t.height = Math.abs(this.scale.y) * this.bounds.height, t;
        }
        setSize(t, e) {
            typeof t == "object" ? (e = t.height ?? t.width, t = t.width) : e ?? (e = t), t !== void 0 && this._setWidth(t, this.bounds.width), e !== void 0 && this._setHeight(e, this.bounds.height);
        }
        containsPoint(t) {
            const e = this.bounds.width, n = this.bounds.height, s = -e * this.anchor.x;
            let r = 0;
            return t.x >= s && t.x <= s + e && (r = -n * this.anchor.y, t.y >= r && t.y <= r + n);
        }
        onViewUpdate() {
            this.didViewUpdate || (this._didTextUpdate = !0), super.onViewUpdate();
        }
        _getKey() {
            return `${this.text}:${this._style.styleKey}:${this._resolution}`;
        }
        destroy(t = !1) {
            super.destroy(t), this.owner = null, this._bounds = null, this._anchor = null, (typeof t == "boolean" ? t : t?.style) && this._style.destroy(t), this._style = null, this._text = null;
        }
    }
    function kA(i, t) {
        let e = i[0] ?? {};
        return (typeof e == "string" || i[1]) && (ue(be, `use new ${t}({ text: "hi!", style }) instead`), e = {
            text: e,
            style: i[1]
        }), e;
    }
    class Sr extends OA {
        constructor(...t){
            const e = kA(t, "Text");
            super(e, Pl), this.renderPipeId = "text";
        }
        updateBounds() {
            const t = this._bounds, e = this._anchor, n = UA.measureText(this._text, this._style), { width: s, height: r } = n;
            t.minX = -e._x * s, t.maxX = t.minX + s, t.minY = -e._y * r, t.maxY = t.minY + r;
        }
    }
    class xm {
        constructor(){
            this._tempState = Fr.for2d(), this._didUploadHash = {};
        }
        init(t) {
            t.renderer.runners.contextChange.add(this);
        }
        contextChange() {
            this._didUploadHash = {};
        }
        start(t, e, n) {
            const s = t.renderer, r = this._didUploadHash[n.uid];
            s.shader.bind(n, r), r || (this._didUploadHash[n.uid] = !0), s.shader.updateUniformGroup(s.globalUniforms.uniformGroup), s.geometry.bind(e, n.glProgram);
        }
        execute(t, e) {
            const n = t.renderer;
            this._tempState.blendMode = e.blendMode, n.state.set(this._tempState);
            const s = e.textures.textures;
            for(let r = 0; r < e.textures.count; r++)n.texture.bind(s[r], r);
            n.geometry.draw(e.topology, e.size, e.start);
        }
    }
    xm.extension = {
        type: [
            st.WebGLPipesAdaptor
        ],
        name: "batch"
    };
    const Mh = class vm {
        constructor(t, e){
            this.state = Fr.for2d(), this._batchersByInstructionSet = Object.create(null), this._activeBatches = Object.create(null), this.renderer = t, this._adaptor = e, this._adaptor.init?.(this);
        }
        static getBatcher(t) {
            return new this._availableBatchers[t];
        }
        buildStart(t) {
            let e = this._batchersByInstructionSet[t.uid];
            e || (e = this._batchersByInstructionSet[t.uid] = Object.create(null), e.default || (e.default = new vh)), this._activeBatches = e, this._activeBatch = this._activeBatches.default;
            for(const n in this._activeBatches)this._activeBatches[n].begin();
        }
        addToBatch(t, e) {
            if (this._activeBatch.name !== t.batcherName) {
                this._activeBatch.break(e);
                let n = this._activeBatches[t.batcherName];
                n || (n = this._activeBatches[t.batcherName] = vm.getBatcher(t.batcherName), n.begin()), this._activeBatch = n;
            }
            this._activeBatch.add(t);
        }
        break(t) {
            this._activeBatch.break(t);
        }
        buildEnd(t) {
            this._activeBatch.break(t);
            const e = this._activeBatches;
            for(const n in e){
                const s = e[n], r = s.geometry;
                r.indexBuffer.setDataWithSize(s.indexBuffer, s.indexSize, !0), r.buffers[0].setDataWithSize(s.attributeBuffer.float32View, s.attributeSize, !1);
            }
        }
        upload(t) {
            const e = this._batchersByInstructionSet[t.uid];
            for(const n in e){
                const s = e[n], r = s.geometry;
                s.dirty && (s.dirty = !1, r.buffers[0].update(s.attributeSize * 4));
            }
        }
        execute(t) {
            if (t.action === "startBatch") {
                const e = t.batcher, n = e.geometry, s = e.shader;
                this._adaptor.start(this, n, s);
            }
            this._adaptor.execute(this, t);
        }
        destroy() {
            this.state = null, this.renderer = null, this._adaptor = null;
            for(const t in this._activeBatches)this._activeBatches[t].destroy();
            this._activeBatches = null;
        }
    };
    Mh.extension = {
        type: [
            st.WebGLPipes,
            st.WebGPUPipes,
            st.CanvasPipes
        ],
        name: "batch"
    };
    Mh._availableBatchers = Object.create(null);
    let ym = Mh;
    Be.handleByMap(st.Batcher, ym._availableBatchers);
    Be.add(vh);
    _c = {
        name: "local-uniform-bit",
        vertex: {
            header: `

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,
            main: `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,
            end: `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
        }
    };
    ({
        ..._c,
        vertex: {
            ..._c.vertex,
            header: _c.vertex.header.replace("group(1)", "group(2)")
        }
    });
    let GA, HA;
    bm = {
        name: "local-uniform-bit",
        vertex: {
            header: `

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,
            main: `
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `,
            end: `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
        }
    };
    GA = {
        name: "texture-bit",
        vertex: {
            header: `
            uniform mat3 uTextureMatrix;
        `,
            main: `
            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;
        `
        },
        fragment: {
            header: `
        uniform sampler2D uTexture;

         
        `,
            main: `
            outColor = texture(uTexture, vUV);
        `
        }
    };
    HA = new en;
    class zA extends za {
        constructor(){
            super(), this.filters = [
                new FA({
                    sprite: new ks(Ot.EMPTY),
                    inverse: !1,
                    resolution: "inherit",
                    antialias: "inherit"
                })
            ];
        }
        get sprite() {
            return this.filters[0].sprite;
        }
        set sprite(t) {
            this.filters[0].sprite = t;
        }
        get inverse() {
            return this.filters[0].inverse;
        }
        set inverse(t) {
            this.filters[0].inverse = t;
        }
    }
    class Sm {
        constructor(t){
            this._activeMaskStage = [], this._renderer = t;
        }
        push(t, e, n) {
            const s = this._renderer;
            if (s.renderPipes.batch.break(n), n.add({
                renderPipeId: "alphaMask",
                action: "pushMaskBegin",
                mask: t,
                inverse: e._maskOptions.inverse,
                canBundle: !1,
                maskedContainer: e
            }), t.inverse = e._maskOptions.inverse, t.renderMaskToTexture) {
                const r = t.mask;
                r.includeInBuild = !0, r.collectRenderables(n, s, null), r.includeInBuild = !1;
            }
            s.renderPipes.batch.break(n), n.add({
                renderPipeId: "alphaMask",
                action: "pushMaskEnd",
                mask: t,
                maskedContainer: e,
                inverse: e._maskOptions.inverse,
                canBundle: !1
            });
        }
        pop(t, e, n) {
            this._renderer.renderPipes.batch.break(n), n.add({
                renderPipeId: "alphaMask",
                action: "popMaskEnd",
                mask: t,
                inverse: e._maskOptions.inverse,
                canBundle: !1
            });
        }
        execute(t) {
            const e = this._renderer, n = t.mask.renderMaskToTexture;
            if (t.action === "pushMaskBegin") {
                const s = Ge.get(zA);
                if (s.inverse = t.inverse, n) {
                    t.mask.mask.measurable = !0;
                    const r = ah(t.mask.mask, !0, HA);
                    t.mask.mask.measurable = !1, r.ceil();
                    const a = e.renderTarget.renderTarget.colorTexture.source, o = ws.getOptimalTexture(r.width, r.height, a._resolution, a.antialias);
                    e.renderTarget.push(o, !0), e.globalUniforms.push({
                        offset: r,
                        worldColor: 4294967295
                    });
                    const c = s.sprite;
                    c.texture = o, c.worldTransform.tx = r.minX, c.worldTransform.ty = r.minY, this._activeMaskStage.push({
                        filterEffect: s,
                        maskedContainer: t.maskedContainer,
                        filterTexture: o
                    });
                } else s.sprite = t.mask.mask, this._activeMaskStage.push({
                    filterEffect: s,
                    maskedContainer: t.maskedContainer
                });
            } else if (t.action === "pushMaskEnd") {
                const s = this._activeMaskStage[this._activeMaskStage.length - 1];
                n && (e.type === Yi.WEBGL && e.renderTarget.finishRenderPass(), e.renderTarget.pop(), e.globalUniforms.pop()), e.filter.push({
                    renderPipeId: "filter",
                    action: "pushFilter",
                    container: s.maskedContainer,
                    filterEffect: s.filterEffect,
                    canBundle: !1
                });
            } else if (t.action === "popMaskEnd") {
                e.filter.pop();
                const s = this._activeMaskStage.pop();
                n && ws.returnTexture(s.filterTexture), Ge.return(s.filterEffect);
            }
        }
        destroy() {
            this._renderer = null, this._activeMaskStage = null;
        }
    }
    Sm.extension = {
        type: [
            st.WebGLPipes,
            st.WebGPUPipes,
            st.CanvasPipes
        ],
        name: "alphaMask"
    };
    class Mm {
        constructor(t){
            this._colorStack = [], this._colorStackIndex = 0, this._currentColor = 0, this._renderer = t;
        }
        buildStart() {
            this._colorStack[0] = 15, this._colorStackIndex = 1, this._currentColor = 15;
        }
        push(t, e, n) {
            this._renderer.renderPipes.batch.break(n);
            const r = this._colorStack;
            r[this._colorStackIndex] = r[this._colorStackIndex - 1] & t.mask;
            const a = this._colorStack[this._colorStackIndex];
            a !== this._currentColor && (this._currentColor = a, n.add({
                renderPipeId: "colorMask",
                colorMask: a,
                canBundle: !1
            })), this._colorStackIndex++;
        }
        pop(t, e, n) {
            this._renderer.renderPipes.batch.break(n);
            const r = this._colorStack;
            this._colorStackIndex--;
            const a = r[this._colorStackIndex - 1];
            a !== this._currentColor && (this._currentColor = a, n.add({
                renderPipeId: "colorMask",
                colorMask: a,
                canBundle: !1
            }));
        }
        execute(t) {
            this._renderer.colorMask.setMask(t.colorMask);
        }
        destroy() {
            this._colorStack = null;
        }
    }
    Mm.extension = {
        type: [
            st.WebGLPipes,
            st.WebGPUPipes,
            st.CanvasPipes
        ],
        name: "colorMask"
    };
    class Tm {
        constructor(t){
            this._maskStackHash = {}, this._maskHash = new WeakMap, this._renderer = t;
        }
        push(t, e, n) {
            var s;
            const r = t, a = this._renderer;
            a.renderPipes.batch.break(n), a.renderPipes.blendMode.setBlendMode(r.mask, "none", n), n.add({
                renderPipeId: "stencilMask",
                action: "pushMaskBegin",
                mask: t,
                inverse: e._maskOptions.inverse,
                canBundle: !1
            });
            const o = r.mask;
            o.includeInBuild = !0, this._maskHash.has(r) || this._maskHash.set(r, {
                instructionsStart: 0,
                instructionsLength: 0
            });
            const c = this._maskHash.get(r);
            c.instructionsStart = n.instructionSize, o.collectRenderables(n, a, null), o.includeInBuild = !1, a.renderPipes.batch.break(n), n.add({
                renderPipeId: "stencilMask",
                action: "pushMaskEnd",
                mask: t,
                inverse: e._maskOptions.inverse,
                canBundle: !1
            });
            const l = n.instructionSize - c.instructionsStart - 1;
            c.instructionsLength = l;
            const h = a.renderTarget.renderTarget.uid;
            (s = this._maskStackHash)[h] ?? (s[h] = 0);
        }
        pop(t, e, n) {
            const s = t, r = this._renderer;
            r.renderPipes.batch.break(n), r.renderPipes.blendMode.setBlendMode(s.mask, "none", n), n.add({
                renderPipeId: "stencilMask",
                action: "popMaskBegin",
                inverse: e._maskOptions.inverse,
                canBundle: !1
            });
            const a = this._maskHash.get(t);
            for(let o = 0; o < a.instructionsLength; o++)n.instructions[n.instructionSize++] = n.instructions[a.instructionsStart++];
            n.add({
                renderPipeId: "stencilMask",
                action: "popMaskEnd",
                canBundle: !1
            });
        }
        execute(t) {
            var e;
            const n = this._renderer, s = n.renderTarget.renderTarget.uid;
            let r = (e = this._maskStackHash)[s] ?? (e[s] = 0);
            t.action === "pushMaskBegin" ? (n.renderTarget.ensureDepthStencil(), n.stencil.setStencilMode(Ce.RENDERING_MASK_ADD, r), r++, n.colorMask.setMask(0)) : t.action === "pushMaskEnd" ? (t.inverse ? n.stencil.setStencilMode(Ce.INVERSE_MASK_ACTIVE, r) : n.stencil.setStencilMode(Ce.MASK_ACTIVE, r), n.colorMask.setMask(15)) : t.action === "popMaskBegin" ? (n.colorMask.setMask(0), r !== 0 ? n.stencil.setStencilMode(Ce.RENDERING_MASK_REMOVE, r) : (n.renderTarget.clear(null, vi.STENCIL), n.stencil.setStencilMode(Ce.DISABLED, r)), r--) : t.action === "popMaskEnd" && (t.inverse ? n.stencil.setStencilMode(Ce.INVERSE_MASK_ACTIVE, r) : n.stencil.setStencilMode(Ce.MASK_ACTIVE, r), n.colorMask.setMask(15)), this._maskStackHash[s] = r;
        }
        destroy() {
            this._renderer = null, this._maskStackHash = null, this._maskHash = null;
        }
    }
    Tm.extension = {
        type: [
            st.WebGLPipes,
            st.WebGPUPipes,
            st.CanvasPipes
        ],
        name: "stencilMask"
    };
    var Na = ((i)=>(i[i.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", i[i.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", i[i.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER", i))(Na || {});
    class VA {
        constructor(t, e){
            this._lastBindBaseLocation = -1, this._lastBindCallId = -1, this.buffer = t || null, this.updateID = -1, this.byteLength = -1, this.type = e;
        }
    }
    class Em {
        constructor(t){
            this._gpuBuffers = Object.create(null), this._boundBufferBases = Object.create(null), this._minBaseLocation = 0, this._nextBindBaseIndex = this._minBaseLocation, this._bindCallId = 0, this._renderer = t, this._renderer.renderableGC.addManagedHash(this, "_gpuBuffers");
        }
        destroy() {
            this._renderer = null, this._gl = null, this._gpuBuffers = null, this._boundBufferBases = null;
        }
        contextChange() {
            const t = this._gl = this._renderer.gl;
            this._gpuBuffers = Object.create(null), this._maxBindings = t.MAX_UNIFORM_BUFFER_BINDINGS ? t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
        }
        getGlBuffer(t) {
            return this._gpuBuffers[t.uid] || this.createGLBuffer(t);
        }
        bind(t) {
            const { _gl: e } = this, n = this.getGlBuffer(t);
            e.bindBuffer(n.type, n.buffer);
        }
        bindBufferBase(t, e) {
            const { _gl: n } = this;
            this._boundBufferBases[e] !== t && (this._boundBufferBases[e] = t, t._lastBindBaseLocation = e, n.bindBufferBase(n.UNIFORM_BUFFER, e, t.buffer));
        }
        nextBindBase(t) {
            this._bindCallId++, this._minBaseLocation = 0, t && (this._boundBufferBases[0] = null, this._minBaseLocation = 1, this._nextBindBaseIndex < 1 && (this._nextBindBaseIndex = 1));
        }
        freeLocationForBufferBase(t) {
            let e = this.getLastBindBaseLocation(t);
            if (e >= this._minBaseLocation) return t._lastBindCallId = this._bindCallId, e;
            let n = 0, s = this._nextBindBaseIndex;
            for(; n < 2;){
                s >= this._maxBindings && (s = this._minBaseLocation, n++);
                const r = this._boundBufferBases[s];
                if (r && r._lastBindCallId === this._bindCallId) {
                    s++;
                    continue;
                }
                break;
            }
            return e = s, this._nextBindBaseIndex = s + 1, n >= 2 ? -1 : (t._lastBindCallId = this._bindCallId, this._boundBufferBases[e] = null, e);
        }
        getLastBindBaseLocation(t) {
            const e = t._lastBindBaseLocation;
            return this._boundBufferBases[e] === t ? e : -1;
        }
        bindBufferRange(t, e, n, s) {
            const { _gl: r } = this;
            n || (n = 0), e || (e = 0), this._boundBufferBases[e] = null, r.bindBufferRange(r.UNIFORM_BUFFER, e || 0, t.buffer, n * 256, s || 256);
        }
        updateBuffer(t) {
            const { _gl: e } = this, n = this.getGlBuffer(t);
            if (t._updateID === n.updateID) return n;
            n.updateID = t._updateID, e.bindBuffer(n.type, n.buffer);
            const s = t.data, r = t.descriptor.usage & Se.STATIC ? e.STATIC_DRAW : e.DYNAMIC_DRAW;
            return s ? n.byteLength >= s.byteLength ? e.bufferSubData(n.type, 0, s, 0, t._updateSize / s.BYTES_PER_ELEMENT) : (n.byteLength = s.byteLength, e.bufferData(n.type, s, r)) : (n.byteLength = t.descriptor.size, e.bufferData(n.type, n.byteLength, r)), n;
        }
        destroyAll() {
            const t = this._gl;
            for(const e in this._gpuBuffers)t.deleteBuffer(this._gpuBuffers[e].buffer);
            this._gpuBuffers = Object.create(null);
        }
        onBufferDestroy(t, e) {
            const n = this._gpuBuffers[t.uid], s = this._gl;
            e || s.deleteBuffer(n.buffer), this._gpuBuffers[t.uid] = null;
        }
        createGLBuffer(t) {
            const { _gl: e } = this;
            let n = Na.ARRAY_BUFFER;
            t.descriptor.usage & Se.INDEX ? n = Na.ELEMENT_ARRAY_BUFFER : t.descriptor.usage & Se.UNIFORM && (n = Na.UNIFORM_BUFFER);
            const s = new VA(e.createBuffer(), n);
            return this._gpuBuffers[t.uid] = s, t.on("destroy", this.onBufferDestroy, this), s;
        }
        resetState() {
            this._boundBufferBases = Object.create(null);
        }
    }
    Em.extension = {
        type: [
            st.WebGLSystem
        ],
        name: "buffer"
    };
    const Th = class Am {
        constructor(t){
            this.supports = {
                uint32Indices: !0,
                uniformBufferObject: !0,
                vertexArrayObject: !0,
                srgbTextures: !0,
                nonPowOf2wrapping: !0,
                msaa: !0,
                nonPowOf2mipmaps: !0
            }, this._renderer = t, this.extensions = Object.create(null), this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this);
        }
        get isLost() {
            return !this.gl || this.gl.isContextLost();
        }
        contextChange(t) {
            this.gl = t, this._renderer.gl = t;
        }
        init(t) {
            t = {
                ...Am.defaultOptions,
                ...t
            };
            let e = this.multiView = t.multiView;
            if (t.context && e && (_e("Renderer created with both a context and multiview enabled. Disabling multiView as both cannot work together."), e = !1), e ? this.canvas = $e.get().createCanvas(this._renderer.canvas.width, this._renderer.canvas.height) : this.canvas = this._renderer.view.canvas, t.context) this.initFromContext(t.context);
            else {
                const n = this._renderer.background.alpha < 1, s = t.premultipliedAlpha ?? !0, r = t.antialias && !this._renderer.backBuffer.useBackBuffer;
                this.createContext(t.preferWebGLVersion, {
                    alpha: n,
                    premultipliedAlpha: s,
                    antialias: r,
                    stencil: !0,
                    preserveDrawingBuffer: t.preserveDrawingBuffer,
                    powerPreference: t.powerPreference ?? "default"
                });
            }
        }
        ensureCanvasSize(t) {
            if (!this.multiView) {
                t !== this.canvas && _e("multiView is disabled, but targetCanvas is not the main canvas");
                return;
            }
            const { canvas: e } = this;
            (e.width < t.width || e.height < t.height) && (e.width = Math.max(t.width, t.width), e.height = Math.max(t.height, t.height));
        }
        initFromContext(t) {
            this.gl = t, this.webGLVersion = t instanceof $e.get().getWebGLRenderingContext() ? 1 : 2, this.getExtensions(), this.validateContext(t), this._renderer.runners.contextChange.emit(t);
            const e = this._renderer.view.canvas;
            e.addEventListener("webglcontextlost", this.handleContextLost, !1), e.addEventListener("webglcontextrestored", this.handleContextRestored, !1);
        }
        createContext(t, e) {
            let n;
            const s = this.canvas;
            if (t === 2 && (n = s.getContext("webgl2", e)), !n && (n = s.getContext("webgl", e), !n)) throw new Error("This browser does not support WebGL. Try using the canvas renderer");
            this.gl = n, this.initFromContext(this.gl);
        }
        getExtensions() {
            const { gl: t } = this, e = {
                anisotropicFiltering: t.getExtension("EXT_texture_filter_anisotropic"),
                floatTextureLinear: t.getExtension("OES_texture_float_linear"),
                s3tc: t.getExtension("WEBGL_compressed_texture_s3tc"),
                s3tc_sRGB: t.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
                etc: t.getExtension("WEBGL_compressed_texture_etc"),
                etc1: t.getExtension("WEBGL_compressed_texture_etc1"),
                pvrtc: t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
                atc: t.getExtension("WEBGL_compressed_texture_atc"),
                astc: t.getExtension("WEBGL_compressed_texture_astc"),
                bptc: t.getExtension("EXT_texture_compression_bptc"),
                rgtc: t.getExtension("EXT_texture_compression_rgtc"),
                loseContext: t.getExtension("WEBGL_lose_context")
            };
            if (this.webGLVersion === 1) this.extensions = {
                ...e,
                drawBuffers: t.getExtension("WEBGL_draw_buffers"),
                depthTexture: t.getExtension("WEBGL_depth_texture"),
                vertexArrayObject: t.getExtension("OES_vertex_array_object") || t.getExtension("MOZ_OES_vertex_array_object") || t.getExtension("WEBKIT_OES_vertex_array_object"),
                uint32ElementIndex: t.getExtension("OES_element_index_uint"),
                floatTexture: t.getExtension("OES_texture_float"),
                floatTextureLinear: t.getExtension("OES_texture_float_linear"),
                textureHalfFloat: t.getExtension("OES_texture_half_float"),
                textureHalfFloatLinear: t.getExtension("OES_texture_half_float_linear"),
                vertexAttribDivisorANGLE: t.getExtension("ANGLE_instanced_arrays"),
                srgb: t.getExtension("EXT_sRGB")
            };
            else {
                this.extensions = {
                    ...e,
                    colorBufferFloat: t.getExtension("EXT_color_buffer_float")
                };
                const n = t.getExtension("WEBGL_provoking_vertex");
                n && n.provokingVertexWEBGL(n.FIRST_VERTEX_CONVENTION_WEBGL);
            }
        }
        handleContextLost(t) {
            t.preventDefault(), this._contextLossForced && (this._contextLossForced = !1, setTimeout(()=>{
                this.gl.isContextLost() && this.extensions.loseContext?.restoreContext();
            }, 0));
        }
        handleContextRestored() {
            this.getExtensions(), this._renderer.runners.contextChange.emit(this.gl);
        }
        destroy() {
            const t = this._renderer.view.canvas;
            this._renderer = null, t.removeEventListener("webglcontextlost", this.handleContextLost), t.removeEventListener("webglcontextrestored", this.handleContextRestored), this.gl.useProgram(null), this.extensions.loseContext?.loseContext();
        }
        forceContextLoss() {
            this.extensions.loseContext?.loseContext(), this._contextLossForced = !0;
        }
        validateContext(t) {
            const e = t.getContextAttributes();
            e && !e.stencil && _e("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
            const n = this.supports, s = this.webGLVersion === 2, r = this.extensions;
            n.uint32Indices = s || !!r.uint32ElementIndex, n.uniformBufferObject = s, n.vertexArrayObject = s || !!r.vertexArrayObject, n.srgbTextures = s || !!r.srgb, n.nonPowOf2wrapping = s, n.nonPowOf2mipmaps = s, n.msaa = s, n.uint32Indices || _e("Provided WebGL context does not support 32 index buffer, large scenes may not render correctly");
        }
    };
    Th.extension = {
        type: [
            st.WebGLSystem
        ],
        name: "context"
    };
    Th.defaultOptions = {
        context: null,
        premultipliedAlpha: !0,
        preserveDrawingBuffer: !1,
        powerPreference: void 0,
        preferWebGLVersion: 2,
        multiView: !1
    };
    let WA = Th;
    function XA(i, t) {
        for(const e in i.attributes){
            const n = i.attributes[e], s = t[e];
            s ? (n.format ?? (n.format = s.format), n.offset ?? (n.offset = s.offset), n.instance ?? (n.instance = s.instance)) : _e(`Attribute ${e} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);
        }
        YA(i);
    }
    function YA(i) {
        const { buffers: t, attributes: e } = i, n = {}, s = {};
        for(const r in t){
            const a = t[r];
            n[a.uid] = 0, s[a.uid] = 0;
        }
        for(const r in e){
            const a = e[r];
            n[a.buffer.uid] += Dr(a.format).stride;
        }
        for(const r in e){
            const a = e[r];
            a.stride ?? (a.stride = n[a.buffer.uid]), a.start ?? (a.start = s[a.buffer.uid]), s[a.buffer.uid] += Dr(a.format).stride;
        }
    }
    var Il = ((i)=>(i[i.RGBA = 6408] = "RGBA", i[i.RGB = 6407] = "RGB", i[i.RG = 33319] = "RG", i[i.RED = 6403] = "RED", i[i.RGBA_INTEGER = 36249] = "RGBA_INTEGER", i[i.RGB_INTEGER = 36248] = "RGB_INTEGER", i[i.RG_INTEGER = 33320] = "RG_INTEGER", i[i.RED_INTEGER = 36244] = "RED_INTEGER", i[i.ALPHA = 6406] = "ALPHA", i[i.LUMINANCE = 6409] = "LUMINANCE", i[i.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", i[i.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", i[i.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL", i))(Il || {}), wm = ((i)=>(i[i.TEXTURE_2D = 3553] = "TEXTURE_2D", i[i.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", i[i.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", i[i.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", i[i.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", i[i.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", i[i.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", i[i.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", i[i.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z", i))(wm || {}), te = ((i)=>(i[i.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", i[i.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", i[i.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", i[i.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", i[i.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", i[i.UNSIGNED_INT = 5125] = "UNSIGNED_INT", i[i.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", i[i.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", i[i.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", i[i.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", i[i.BYTE = 5120] = "BYTE", i[i.SHORT = 5122] = "SHORT", i[i.INT = 5124] = "INT", i[i.FLOAT = 5126] = "FLOAT", i[i.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", i[i.HALF_FLOAT = 36193] = "HALF_FLOAT", i))(te || {});
    const hf = {
        uint8x2: te.UNSIGNED_BYTE,
        uint8x4: te.UNSIGNED_BYTE,
        sint8x2: te.BYTE,
        sint8x4: te.BYTE,
        unorm8x2: te.UNSIGNED_BYTE,
        unorm8x4: te.UNSIGNED_BYTE,
        snorm8x2: te.BYTE,
        snorm8x4: te.BYTE,
        uint16x2: te.UNSIGNED_SHORT,
        uint16x4: te.UNSIGNED_SHORT,
        sint16x2: te.SHORT,
        sint16x4: te.SHORT,
        unorm16x2: te.UNSIGNED_SHORT,
        unorm16x4: te.UNSIGNED_SHORT,
        snorm16x2: te.SHORT,
        snorm16x4: te.SHORT,
        float16x2: te.HALF_FLOAT,
        float16x4: te.HALF_FLOAT,
        float32: te.FLOAT,
        float32x2: te.FLOAT,
        float32x3: te.FLOAT,
        float32x4: te.FLOAT,
        uint32: te.UNSIGNED_INT,
        uint32x2: te.UNSIGNED_INT,
        uint32x3: te.UNSIGNED_INT,
        uint32x4: te.UNSIGNED_INT,
        sint32: te.INT,
        sint32x2: te.INT,
        sint32x3: te.INT,
        sint32x4: te.INT
    };
    function qA(i) {
        return hf[i] ?? hf.float32;
    }
    const jA = {
        "point-list": 0,
        "line-list": 1,
        "line-strip": 3,
        "triangle-list": 4,
        "triangle-strip": 5
    };
    class Rm {
        constructor(t){
            this._geometryVaoHash = Object.create(null), this._renderer = t, this._activeGeometry = null, this._activeVao = null, this.hasVao = !0, this.hasInstance = !0, this._renderer.renderableGC.addManagedHash(this, "_geometryVaoHash");
        }
        contextChange() {
            const t = this.gl = this._renderer.gl;
            if (!this._renderer.context.supports.vertexArrayObject) throw new Error("[PixiJS] Vertex Array Objects are not supported on this device");
            const e = this._renderer.context.extensions.vertexArrayObject;
            e && (t.createVertexArray = ()=>e.createVertexArrayOES(), t.bindVertexArray = (s)=>e.bindVertexArrayOES(s), t.deleteVertexArray = (s)=>e.deleteVertexArrayOES(s));
            const n = this._renderer.context.extensions.vertexAttribDivisorANGLE;
            n && (t.drawArraysInstanced = (s, r, a, o)=>{
                n.drawArraysInstancedANGLE(s, r, a, o);
            }, t.drawElementsInstanced = (s, r, a, o, c)=>{
                n.drawElementsInstancedANGLE(s, r, a, o, c);
            }, t.vertexAttribDivisor = (s, r)=>n.vertexAttribDivisorANGLE(s, r)), this._activeGeometry = null, this._activeVao = null, this._geometryVaoHash = Object.create(null);
        }
        bind(t, e) {
            const n = this.gl;
            this._activeGeometry = t;
            const s = this.getVao(t, e);
            this._activeVao !== s && (this._activeVao = s, n.bindVertexArray(s)), this.updateBuffers();
        }
        resetState() {
            this.unbind();
        }
        updateBuffers() {
            const t = this._activeGeometry, e = this._renderer.buffer;
            for(let n = 0; n < t.buffers.length; n++){
                const s = t.buffers[n];
                e.updateBuffer(s);
            }
        }
        checkCompatibility(t, e) {
            const n = t.attributes, s = e._attributeData;
            for(const r in s)if (!n[r]) throw new Error(`shader and geometry incompatible, geometry missing the "${r}" attribute`);
        }
        getSignature(t, e) {
            const n = t.attributes, s = e._attributeData, r = [
                "g",
                t.uid
            ];
            for(const a in n)s[a] && r.push(a, s[a].location);
            return r.join("-");
        }
        getVao(t, e) {
            return this._geometryVaoHash[t.uid]?.[e._key] || this.initGeometryVao(t, e);
        }
        initGeometryVao(t, e, n = !0) {
            const s = this._renderer.gl, r = this._renderer.buffer;
            this._renderer.shader._getProgramData(e), this.checkCompatibility(t, e);
            const a = this.getSignature(t, e);
            this._geometryVaoHash[t.uid] || (this._geometryVaoHash[t.uid] = Object.create(null), t.on("destroy", this.onGeometryDestroy, this));
            const o = this._geometryVaoHash[t.uid];
            let c = o[a];
            if (c) return o[e._key] = c, c;
            XA(t, e._attributeData);
            const l = t.buffers;
            c = s.createVertexArray(), s.bindVertexArray(c);
            for(let h = 0; h < l.length; h++){
                const u = l[h];
                r.bind(u);
            }
            return this.activateVao(t, e), o[e._key] = c, o[a] = c, s.bindVertexArray(null), c;
        }
        onGeometryDestroy(t, e) {
            const n = this._geometryVaoHash[t.uid], s = this.gl;
            if (n) {
                if (e) for(const r in n)this._activeVao !== n[r] && this.unbind(), s.deleteVertexArray(n[r]);
                this._geometryVaoHash[t.uid] = null;
            }
        }
        destroyAll(t = !1) {
            const e = this.gl;
            for(const n in this._geometryVaoHash){
                if (t) for(const s in this._geometryVaoHash[n]){
                    const r = this._geometryVaoHash[n];
                    this._activeVao !== r && this.unbind(), e.deleteVertexArray(r[s]);
                }
                this._geometryVaoHash[n] = null;
            }
        }
        activateVao(t, e) {
            const n = this._renderer.gl, s = this._renderer.buffer, r = t.attributes;
            t.indexBuffer && s.bind(t.indexBuffer);
            let a = null;
            for(const o in r){
                const c = r[o], l = c.buffer, h = s.getGlBuffer(l), u = e._attributeData[o];
                if (u) {
                    a !== h && (s.bind(l), a = h);
                    const d = u.location;
                    n.enableVertexAttribArray(d);
                    const f = Dr(c.format), _ = qA(c.format);
                    if (u.format?.substring(1, 4) === "int" ? n.vertexAttribIPointer(d, f.size, _, c.stride, c.offset) : n.vertexAttribPointer(d, f.size, _, f.normalised, c.stride, c.offset), c.instance) if (this.hasInstance) {
                        const g = c.divisor ?? 1;
                        n.vertexAttribDivisor(d, g);
                    } else throw new Error("geometry error, GPU Instancing is not supported on this device");
                }
            }
        }
        draw(t, e, n, s) {
            const { gl: r } = this._renderer, a = this._activeGeometry, o = jA[t || a.topology];
            if (s ?? (s = a.instanceCount), a.indexBuffer) {
                const c = a.indexBuffer.data.BYTES_PER_ELEMENT, l = c === 2 ? r.UNSIGNED_SHORT : r.UNSIGNED_INT;
                s > 1 ? r.drawElementsInstanced(o, e || a.indexBuffer.data.length, l, (n || 0) * c, s) : r.drawElements(o, e || a.indexBuffer.data.length, l, (n || 0) * c);
            } else s > 1 ? r.drawArraysInstanced(o, n || 0, e || a.getSize(), s) : r.drawArrays(o, n || 0, e || a.getSize());
            return this;
        }
        unbind() {
            this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null;
        }
        destroy() {
            this._renderer = null, this.gl = null, this._activeVao = null, this._activeGeometry = null;
        }
    }
    Rm.extension = {
        type: [
            st.WebGLSystem
        ],
        name: "geometry"
    };
    const $A = new tm({
        attributes: {
            aPosition: [
                -1,
                -1,
                3,
                -1,
                -1,
                3
            ]
        }
    }), Eh = class Cm {
        constructor(t){
            this.useBackBuffer = !1, this._useBackBufferThisRender = !1, this._renderer = t;
        }
        init(t = {}) {
            const { useBackBuffer: e, antialias: n } = {
                ...Cm.defaultOptions,
                ...t
            };
            this.useBackBuffer = e, this._antialias = n, this._renderer.context.supports.msaa || (_e("antialiasing, is not supported on when using the back buffer"), this._antialias = !1), this._state = Fr.for2d();
            const s = new Br({
                vertex: `
                attribute vec2 aPosition;
                out vec2 vUv;

                void main() {
                    gl_Position = vec4(aPosition, 0.0, 1.0);

                    vUv = (aPosition + 1.0) / 2.0;

                    // flip dem UVs
                    vUv.y = 1.0 - vUv.y;
                }`,
                fragment: `
                in vec2 vUv;
                out vec4 finalColor;

                uniform sampler2D uTexture;

                void main() {
                    finalColor = texture(uTexture, vUv);
                }`,
                name: "big-triangle"
            });
            this._bigTriangleShader = new Zi({
                glProgram: s,
                resources: {
                    uTexture: Ot.WHITE.source
                }
            });
        }
        renderStart(t) {
            const e = this._renderer.renderTarget.getRenderTarget(t.target);
            if (this._useBackBufferThisRender = this.useBackBuffer && !!e.isRoot, this._useBackBufferThisRender) {
                const n = this._renderer.renderTarget.getRenderTarget(t.target);
                this._targetTexture = n.colorTexture, t.target = this._getBackBufferTexture(n.colorTexture);
            }
        }
        renderEnd() {
            this._presentBackBuffer();
        }
        _presentBackBuffer() {
            const t = this._renderer;
            t.renderTarget.finishRenderPass(), this._useBackBufferThisRender && (t.renderTarget.bind(this._targetTexture, !1), this._bigTriangleShader.resources.uTexture = this._backBufferTexture.source, t.encoder.draw({
                geometry: $A,
                shader: this._bigTriangleShader,
                state: this._state
            }));
        }
        _getBackBufferTexture(t) {
            return this._backBufferTexture = this._backBufferTexture || new Ot({
                source: new Ne({
                    width: t.width,
                    height: t.height,
                    resolution: t._resolution,
                    antialias: this._antialias
                })
            }), this._backBufferTexture.source.resize(t.width, t.height, t._resolution), this._backBufferTexture;
        }
        destroy() {
            this._backBufferTexture && (this._backBufferTexture.destroy(), this._backBufferTexture = null);
        }
    };
    Eh.extension = {
        type: [
            st.WebGLSystem
        ],
        name: "backBuffer",
        priority: 1
    };
    Eh.defaultOptions = {
        useBackBuffer: !1
    };
    let KA = Eh;
    class Pm {
        constructor(t){
            this._colorMaskCache = 15, this._renderer = t;
        }
        setMask(t) {
            this._colorMaskCache !== t && (this._colorMaskCache = t, this._renderer.gl.colorMask(!!(t & 8), !!(t & 4), !!(t & 2), !!(t & 1)));
        }
    }
    Pm.extension = {
        type: [
            st.WebGLSystem
        ],
        name: "colorMask"
    };
    class Im {
        constructor(t){
            this.commandFinished = Promise.resolve(), this._renderer = t;
        }
        setGeometry(t, e) {
            this._renderer.geometry.bind(t, e.glProgram);
        }
        finishRenderPass() {}
        draw(t) {
            const e = this._renderer, { geometry: n, shader: s, state: r, skipSync: a, topology: o, size: c, start: l, instanceCount: h } = t;
            e.shader.bind(s, a), e.geometry.bind(n, e.shader._activeProgram), r && e.state.set(r), e.geometry.draw(o, c, l, h ?? n.instanceCount);
        }
        destroy() {
            this._renderer = null;
        }
    }
    Im.extension = {
        type: [
            st.WebGLSystem
        ],
        name: "encoder"
    };
    class ZA {
        constructor(){
            this.width = -1, this.height = -1, this.msaa = !1, this.msaaRenderBuffer = [];
        }
    }
    const Ji = [];
    Ji[Ce.NONE] = void 0;
    Ji[Ce.DISABLED] = {
        stencilWriteMask: 0,
        stencilReadMask: 0
    };
    Ji[Ce.RENDERING_MASK_ADD] = {
        stencilFront: {
            compare: "equal",
            passOp: "increment-clamp"
        },
        stencilBack: {
            compare: "equal",
            passOp: "increment-clamp"
        }
    };
    Ji[Ce.RENDERING_MASK_REMOVE] = {
        stencilFront: {
            compare: "equal",
            passOp: "decrement-clamp"
        },
        stencilBack: {
            compare: "equal",
            passOp: "decrement-clamp"
        }
    };
    Ji[Ce.MASK_ACTIVE] = {
        stencilWriteMask: 0,
        stencilFront: {
            compare: "equal",
            passOp: "keep"
        },
        stencilBack: {
            compare: "equal",
            passOp: "keep"
        }
    };
    Ji[Ce.INVERSE_MASK_ACTIVE] = {
        stencilWriteMask: 0,
        stencilFront: {
            compare: "not-equal",
            passOp: "replace"
        },
        stencilBack: {
            compare: "not-equal",
            passOp: "replace"
        }
    };
    class Dm {
        constructor(t){
            this._stencilCache = {
                enabled: !1,
                stencilReference: 0,
                stencilMode: Ce.NONE
            }, this._renderTargetStencilState = Object.create(null), t.renderTarget.onRenderTargetChange.add(this);
        }
        contextChange(t) {
            this._gl = t, this._comparisonFuncMapping = {
                always: t.ALWAYS,
                never: t.NEVER,
                equal: t.EQUAL,
                "not-equal": t.NOTEQUAL,
                less: t.LESS,
                "less-equal": t.LEQUAL,
                greater: t.GREATER,
                "greater-equal": t.GEQUAL
            }, this._stencilOpsMapping = {
                keep: t.KEEP,
                zero: t.ZERO,
                replace: t.REPLACE,
                invert: t.INVERT,
                "increment-clamp": t.INCR,
                "decrement-clamp": t.DECR,
                "increment-wrap": t.INCR_WRAP,
                "decrement-wrap": t.DECR_WRAP
            }, this.resetState();
        }
        onRenderTargetChange(t) {
            if (this._activeRenderTarget === t) return;
            this._activeRenderTarget = t;
            let e = this._renderTargetStencilState[t.uid];
            e || (e = this._renderTargetStencilState[t.uid] = {
                stencilMode: Ce.DISABLED,
                stencilReference: 0
            }), this.setStencilMode(e.stencilMode, e.stencilReference);
        }
        resetState() {
            this._stencilCache.enabled = !1, this._stencilCache.stencilMode = Ce.NONE, this._stencilCache.stencilReference = 0;
        }
        setStencilMode(t, e) {
            const n = this._renderTargetStencilState[this._activeRenderTarget.uid], s = this._gl, r = Ji[t], a = this._stencilCache;
            if (n.stencilMode = t, n.stencilReference = e, t === Ce.DISABLED) {
                this._stencilCache.enabled && (this._stencilCache.enabled = !1, s.disable(s.STENCIL_TEST));
                return;
            }
            this._stencilCache.enabled || (this._stencilCache.enabled = !0, s.enable(s.STENCIL_TEST)), (t !== a.stencilMode || a.stencilReference !== e) && (a.stencilMode = t, a.stencilReference = e, s.stencilFunc(this._comparisonFuncMapping[r.stencilBack.compare], e, 255), s.stencilOp(s.KEEP, s.KEEP, this._stencilOpsMapping[r.stencilBack.passOp]));
        }
    }
    Dm.extension = {
        type: [
            st.WebGLSystem
        ],
        name: "stencil"
    };
    class JA {
        constructor(t){
            this._syncFunctionHash = Object.create(null), this._adaptor = t, this._systemCheck();
        }
        _systemCheck() {
            if (!Xp()) throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
        }
        ensureUniformGroup(t) {
            const e = this.getUniformGroupData(t);
            t.buffer || (t.buffer = new ji({
                data: new Float32Array(e.layout.size / 4),
                usage: Se.UNIFORM | Se.COPY_DST
            }));
        }
        getUniformGroupData(t) {
            return this._syncFunctionHash[t._signature] || this._initUniformGroup(t);
        }
        _initUniformGroup(t) {
            const e = t._signature;
            let n = this._syncFunctionHash[e];
            if (!n) {
                const s = Object.keys(t.uniformStructures).map((o)=>t.uniformStructures[o]), r = this._adaptor.createUboElements(s), a = this._generateUboSync(r.uboElements);
                n = this._syncFunctionHash[e] = {
                    layout: r,
                    syncFunction: a
                };
            }
            return this._syncFunctionHash[e];
        }
        _generateUboSync(t) {
            return this._adaptor.generateUboSync(t);
        }
        syncUniformGroup(t, e, n) {
            const s = this.getUniformGroupData(t);
            t.buffer || (t.buffer = new ji({
                data: new Float32Array(s.layout.size / 4),
                usage: Se.UNIFORM | Se.COPY_DST
            }));
            let r = null;
            return e || (e = t.buffer.data, r = t.buffer.dataInt32), n || (n = 0), s.syncFunction(t.uniforms, e, r, n), !0;
        }
        updateUniformGroup(t) {
            if (t.isStatic && !t._dirtyId) return !1;
            t._dirtyId = 0;
            const e = this.syncUniformGroup(t);
            return t.buffer.update(), e;
        }
        destroy() {
            this._syncFunctionHash = null;
        }
    }
    const Lm = {
        f32: 4,
        i32: 4,
        "vec2<f32>": 8,
        "vec3<f32>": 12,
        "vec4<f32>": 16,
        "vec2<i32>": 8,
        "vec3<i32>": 12,
        "vec4<i32>": 16,
        "mat2x2<f32>": 16 * 2,
        "mat3x3<f32>": 16 * 3,
        "mat4x4<f32>": 16 * 4
    };
    function QA(i) {
        const t = i.map((r)=>({
                data: r,
                offset: 0,
                size: 0
            })), e = 16;
        let n = 0, s = 0;
        for(let r = 0; r < t.length; r++){
            const a = t[r];
            if (n = Lm[a.data.type], !n) throw new Error(`Unknown type ${a.data.type}`);
            a.data.size > 1 && (n = Math.max(n, e) * a.data.size);
            const o = n === 12 ? 16 : n;
            a.size = n;
            const c = s % e;
            c > 0 && e - c < o ? s += (e - c) % 16 : s += (n - c % n) % n, a.offset = s, s += n;
        }
        return s = Math.ceil(s / 16) * 16, {
            uboElements: t,
            size: s
        };
    }
    const zi = [
        {
            type: "mat3x3<f32>",
            test: (i)=>i.value.a !== void 0,
            ubo: `
            var matrix = uv[name].toArray(true);
            data[offset] = matrix[0];
            data[offset + 1] = matrix[1];
            data[offset + 2] = matrix[2];
            data[offset + 4] = matrix[3];
            data[offset + 5] = matrix[4];
            data[offset + 6] = matrix[5];
            data[offset + 8] = matrix[6];
            data[offset + 9] = matrix[7];
            data[offset + 10] = matrix[8];
        `,
            uniform: `
            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));
        `
        },
        {
            type: "vec4<f32>",
            test: (i)=>i.type === "vec4<f32>" && i.size === 1 && i.value.width !== void 0,
            ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
            data[offset + 2] = v.width;
            data[offset + 3] = v.height;
        `,
            uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {
                cv[0] = v.x;
                cv[1] = v.y;
                cv[2] = v.width;
                cv[3] = v.height;
                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);
            }
        `
        },
        {
            type: "vec2<f32>",
            test: (i)=>i.type === "vec2<f32>" && i.size === 1 && i.value.x !== void 0,
            ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
        `,
            uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y) {
                cv[0] = v.x;
                cv[1] = v.y;
                gl.uniform2f(ud[name].location, v.x, v.y);
            }
        `
        },
        {
            type: "vec4<f32>",
            test: (i)=>i.type === "vec4<f32>" && i.size === 1 && i.value.red !== void 0,
            ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
            data[offset + 3] = v.alpha;
        `,
            uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                cv[3] = v.alpha;
                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);
            }
        `
        },
        {
            type: "vec3<f32>",
            test: (i)=>i.type === "vec3<f32>" && i.size === 1 && i.value.red !== void 0,
            ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
        `,
            uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);
            }
        `
        }
    ];
    function tw(i, t, e, n) {
        const s = [
            `
        var v = null;
        var v2 = null;
        var t = 0;
        var index = 0;
        var name = null;
        var arrayOffset = null;
    `
        ];
        let r = 0;
        for(let o = 0; o < i.length; o++){
            const c = i[o], l = c.data.name;
            let h = !1, u = 0;
            for(let d = 0; d < zi.length; d++)if (zi[d].test(c.data)) {
                u = c.offset / 4, s.push(`name = "${l}";`, `offset += ${u - r};`, zi[d][t] || zi[d].ubo), h = !0;
                break;
            }
            if (!h) if (c.data.size > 1) u = c.offset / 4, s.push(e(c, u - r));
            else {
                const d = n[c.data.type];
                u = c.offset / 4, s.push(`
                    v = uv.${l};
                    offset += ${u - r};
                    ${d};
                `);
            }
            r = u;
        }
        const a = s.join(`
`);
        return new Function("uv", "data", "dataInt32", "offset", a);
    }
    function _s(i, t) {
        return `
        for (let i = 0; i < ${i * t}; i++) {
            data[offset + (((i / ${i})|0) * 4) + (i % ${i})] = v[i];
        }
    `;
    }
    const Um = {
        f32: `
        data[offset] = v;`,
        i32: `
        dataInt32[offset] = v;`,
        "vec2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];`,
        "vec3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];`,
        "vec4<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];`,
        "vec2<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];`,
        "vec3<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];`,
        "vec4<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];
        dataInt32[offset + 3] = v[3];`,
        "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 4] = v[2];
        data[offset + 5] = v[3];`,
        "mat3x3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];
        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];`,
        "mat4x4<f32>": `
        for (let i = 0; i < 16; i++) {
            data[offset + i] = v[i];
        }`,
        "mat3x2<f32>": _s(3, 2),
        "mat4x2<f32>": _s(4, 2),
        "mat2x3<f32>": _s(2, 3),
        "mat4x3<f32>": _s(4, 3),
        "mat2x4<f32>": _s(2, 4),
        "mat3x4<f32>": _s(3, 4)
    };
    ({
        ...Um
    });
    function ew(i, t) {
        const e = Math.max(Lm[i.data.type] / 16, 1), n = i.data.value.length / i.data.size, s = (4 - n % 4) % 4, r = i.data.type.indexOf("i32") >= 0 ? "dataInt32" : "data";
        return `
        v = uv.${i.data.name};
        offset += ${t};

        arrayOffset = offset;

        t = 0;

        for(var i=0; i < ${i.data.size * e}; i++)
        {
            for(var j = 0; j < ${n}; j++)
            {
                ${r}[arrayOffset++] = v[t++];
            }
            ${s !== 0 ? `arrayOffset += ${s};` : ""}
        }
    `;
    }
    function nw(i) {
        return tw(i, "uboStd40", ew, Um);
    }
    class Nm extends JA {
        constructor(){
            super({
                createUboElements: QA,
                generateUboSync: nw
            });
        }
    }
    Nm.extension = {
        type: [
            st.WebGLSystem
        ],
        name: "ubo"
    };
    class iw {
        constructor(){
            this._clearColorCache = [
                0,
                0,
                0,
                0
            ], this._viewPortCache = new fe;
        }
        init(t, e) {
            this._renderer = t, this._renderTargetSystem = e, t.runners.contextChange.add(this);
        }
        contextChange() {
            this._clearColorCache = [
                0,
                0,
                0,
                0
            ], this._viewPortCache = new fe;
        }
        copyToTexture(t, e, n, s, r) {
            const a = this._renderTargetSystem, o = this._renderer, c = a.getGpuRenderTarget(t), l = o.gl;
            return this.finishRenderPass(t), l.bindFramebuffer(l.FRAMEBUFFER, c.resolveTargetFramebuffer), o.texture.bind(e, 0), l.copyTexSubImage2D(l.TEXTURE_2D, 0, r.x, r.y, n.x, n.y, s.width, s.height), e;
        }
        startRenderPass(t, e = !0, n, s) {
            const r = this._renderTargetSystem, a = t.colorTexture, o = r.getGpuRenderTarget(t);
            let c = s.y;
            t.isRoot && (c = a.pixelHeight - s.height), t.colorTextures.forEach((u)=>{
                this._renderer.texture.unbind(u);
            });
            const l = this._renderer.gl;
            l.bindFramebuffer(l.FRAMEBUFFER, o.framebuffer);
            const h = this._viewPortCache;
            (h.x !== s.x || h.y !== c || h.width !== s.width || h.height !== s.height) && (h.x = s.x, h.y = c, h.width = s.width, h.height = s.height, l.viewport(s.x, c, s.width, s.height)), !o.depthStencilRenderBuffer && (t.stencil || t.depth) && this._initStencil(o), this.clear(t, e, n);
        }
        finishRenderPass(t) {
            const n = this._renderTargetSystem.getGpuRenderTarget(t);
            if (!n.msaa) return;
            const s = this._renderer.gl;
            s.bindFramebuffer(s.FRAMEBUFFER, n.resolveTargetFramebuffer), s.bindFramebuffer(s.READ_FRAMEBUFFER, n.framebuffer), s.blitFramebuffer(0, 0, n.width, n.height, 0, 0, n.width, n.height, s.COLOR_BUFFER_BIT, s.NEAREST), s.bindFramebuffer(s.FRAMEBUFFER, n.framebuffer);
        }
        initGpuRenderTarget(t) {
            const n = this._renderer.gl, s = new ZA, r = t.colorTexture;
            return xi.test(r.resource) ? (this._renderer.context.ensureCanvasSize(t.colorTexture.resource), s.framebuffer = null, s) : (this._initColor(t, s), n.bindFramebuffer(n.FRAMEBUFFER, null), s);
        }
        destroyGpuRenderTarget(t) {
            const e = this._renderer.gl;
            t.framebuffer && (e.deleteFramebuffer(t.framebuffer), t.framebuffer = null), t.resolveTargetFramebuffer && (e.deleteFramebuffer(t.resolveTargetFramebuffer), t.resolveTargetFramebuffer = null), t.depthStencilRenderBuffer && (e.deleteRenderbuffer(t.depthStencilRenderBuffer), t.depthStencilRenderBuffer = null), t.msaaRenderBuffer.forEach((n)=>{
                e.deleteRenderbuffer(n);
            }), t.msaaRenderBuffer = null;
        }
        clear(t, e, n) {
            if (!e) return;
            const s = this._renderTargetSystem;
            typeof e == "boolean" && (e = e ? vi.ALL : vi.NONE);
            const r = this._renderer.gl;
            if (e & vi.COLOR) {
                n ?? (n = s.defaultClearColor);
                const a = this._clearColorCache, o = n;
                (a[0] !== o[0] || a[1] !== o[1] || a[2] !== o[2] || a[3] !== o[3]) && (a[0] = o[0], a[1] = o[1], a[2] = o[2], a[3] = o[3], r.clearColor(o[0], o[1], o[2], o[3]));
            }
            r.clear(e);
        }
        resizeGpuRenderTarget(t) {
            if (t.isRoot) return;
            const n = this._renderTargetSystem.getGpuRenderTarget(t);
            this._resizeColor(t, n), (t.stencil || t.depth) && this._resizeStencil(n);
        }
        _initColor(t, e) {
            const n = this._renderer, s = n.gl, r = s.createFramebuffer();
            if (e.resolveTargetFramebuffer = r, s.bindFramebuffer(s.FRAMEBUFFER, r), e.width = t.colorTexture.source.pixelWidth, e.height = t.colorTexture.source.pixelHeight, t.colorTextures.forEach((a, o)=>{
                const c = a.source;
                c.antialias && (n.context.supports.msaa ? e.msaa = !0 : _e("[RenderTexture] Antialiasing on textures is not supported in WebGL1")), n.texture.bindSource(c, 0);
                const h = n.texture.getGlSource(c).texture;
                s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + o, 3553, h, 0);
            }), e.msaa) {
                const a = s.createFramebuffer();
                e.framebuffer = a, s.bindFramebuffer(s.FRAMEBUFFER, a), t.colorTextures.forEach((o, c)=>{
                    const l = s.createRenderbuffer();
                    e.msaaRenderBuffer[c] = l;
                });
            } else e.framebuffer = r;
            this._resizeColor(t, e);
        }
        _resizeColor(t, e) {
            const n = t.colorTexture.source;
            if (e.width = n.pixelWidth, e.height = n.pixelHeight, t.colorTextures.forEach((s, r)=>{
                r !== 0 && s.source.resize(n.width, n.height, n._resolution);
            }), e.msaa) {
                const s = this._renderer, r = s.gl, a = e.framebuffer;
                r.bindFramebuffer(r.FRAMEBUFFER, a), t.colorTextures.forEach((o, c)=>{
                    const l = o.source;
                    s.texture.bindSource(l, 0);
                    const u = s.texture.getGlSource(l).internalFormat, d = e.msaaRenderBuffer[c];
                    r.bindRenderbuffer(r.RENDERBUFFER, d), r.renderbufferStorageMultisample(r.RENDERBUFFER, 4, u, l.pixelWidth, l.pixelHeight), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + c, r.RENDERBUFFER, d);
                });
            }
        }
        _initStencil(t) {
            if (t.framebuffer === null) return;
            const e = this._renderer.gl, n = e.createRenderbuffer();
            t.depthStencilRenderBuffer = n, e.bindRenderbuffer(e.RENDERBUFFER, n), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.RENDERBUFFER, n), this._resizeStencil(t);
        }
        _resizeStencil(t) {
            const e = this._renderer.gl;
            e.bindRenderbuffer(e.RENDERBUFFER, t.depthStencilRenderBuffer), t.msaa ? e.renderbufferStorageMultisample(e.RENDERBUFFER, 4, e.DEPTH24_STENCIL8, t.width, t.height) : e.renderbufferStorage(e.RENDERBUFFER, this._renderer.context.webGLVersion === 2 ? e.DEPTH24_STENCIL8 : e.DEPTH_STENCIL, t.width, t.height);
        }
        prerender(t) {
            const e = t.colorTexture.resource;
            this._renderer.context.multiView && xi.test(e) && this._renderer.context.ensureCanvasSize(e);
        }
        postrender(t) {
            if (this._renderer.context.multiView && xi.test(t.colorTexture.resource)) {
                const e = this._renderer.context.canvas, n = t.colorTexture;
                n.context2D.drawImage(e, 0, n.pixelHeight - e.height);
            }
        }
    }
    function sw(i, t, e, n, s, r) {
        const a = r ? 1 : -1;
        return i.identity(), i.a = 1 / n * 2, i.d = a * (1 / s * 2), i.tx = -1 - t * i.a, i.ty = -a - e * i.d, i;
    }
    const cr = new Map;
    function Bm(i, t) {
        if (!cr.has(i)) {
            const e = new Ot({
                source: new xi({
                    resource: i,
                    ...t
                })
            }), n = ()=>{
                cr.get(i) === e && cr.delete(i);
            };
            e.once("destroy", n), e.source.once("destroy", n), cr.set(i, e);
        }
        return cr.get(i);
    }
    function rw(i) {
        const t = i.colorTexture.source.resource;
        return globalThis.HTMLCanvasElement && t instanceof HTMLCanvasElement && document.body.contains(t);
    }
    const Fm = class Om {
        constructor(t = {}){
            if (this.uid = pe("renderTarget"), this.colorTextures = [], this.dirtyId = 0, this.isRoot = !1, this._size = new Float32Array(2), this._managedColorTextures = !1, t = {
                ...Om.defaultOptions,
                ...t
            }, this.stencil = t.stencil, this.depth = t.depth, this.isRoot = t.isRoot, typeof t.colorTextures == "number") {
                this._managedColorTextures = !0;
                for(let e = 0; e < t.colorTextures; e++)this.colorTextures.push(new Ne({
                    width: t.width,
                    height: t.height,
                    resolution: t.resolution,
                    antialias: t.antialias
                }));
            } else {
                this.colorTextures = [
                    ...t.colorTextures.map((n)=>n.source)
                ];
                const e = this.colorTexture.source;
                this.resize(e.width, e.height, e._resolution);
            }
            this.colorTexture.source.on("resize", this.onSourceResize, this), (t.depthStencilTexture || this.stencil) && (t.depthStencilTexture instanceof Ot || t.depthStencilTexture instanceof Ne ? this.depthStencilTexture = t.depthStencilTexture.source : this.ensureDepthStencilTexture());
        }
        get size() {
            const t = this._size;
            return t[0] = this.pixelWidth, t[1] = this.pixelHeight, t;
        }
        get width() {
            return this.colorTexture.source.width;
        }
        get height() {
            return this.colorTexture.source.height;
        }
        get pixelWidth() {
            return this.colorTexture.source.pixelWidth;
        }
        get pixelHeight() {
            return this.colorTexture.source.pixelHeight;
        }
        get resolution() {
            return this.colorTexture.source._resolution;
        }
        get colorTexture() {
            return this.colorTextures[0];
        }
        onSourceResize(t) {
            this.resize(t.width, t.height, t._resolution, !0);
        }
        ensureDepthStencilTexture() {
            this.depthStencilTexture || (this.depthStencilTexture = new Ne({
                width: this.width,
                height: this.height,
                resolution: this.resolution,
                format: "depth24plus-stencil8",
                autoGenerateMipmaps: !1,
                antialias: !1,
                mipLevelCount: 1
            }));
        }
        resize(t, e, n = this.resolution, s = !1) {
            this.dirtyId++, this.colorTextures.forEach((r, a)=>{
                s && a === 0 || r.source.resize(t, e, n);
            }), this.depthStencilTexture && this.depthStencilTexture.source.resize(t, e, n);
        }
        destroy() {
            this.colorTexture.source.off("resize", this.onSourceResize, this), this._managedColorTextures && this.colorTextures.forEach((t)=>{
                t.destroy();
            }), this.depthStencilTexture && (this.depthStencilTexture.destroy(), delete this.depthStencilTexture);
        }
    };
    Fm.defaultOptions = {
        width: 0,
        height: 0,
        resolution: 1,
        colorTextures: 1,
        stencil: !1,
        depth: !1,
        antialias: !1,
        isRoot: !1
    };
    let Dl = Fm;
    class aw {
        constructor(t){
            this.rootViewPort = new fe, this.viewport = new fe, this.onRenderTargetChange = new Yp("onRenderTargetChange"), this.projectionMatrix = new Ft, this.defaultClearColor = [
                0,
                0,
                0,
                0
            ], this._renderSurfaceToRenderTargetHash = new Map, this._gpuRenderTargetHash = Object.create(null), this._renderTargetStack = [], this._renderer = t, t.renderableGC.addManagedHash(this, "_gpuRenderTargetHash");
        }
        finishRenderPass() {
            this.adaptor.finishRenderPass(this.renderTarget);
        }
        renderStart({ target: t, clear: e, clearColor: n, frame: s }) {
            this._renderTargetStack.length = 0, this.push(t, e, n, s), this.rootViewPort.copyFrom(this.viewport), this.rootRenderTarget = this.renderTarget, this.renderingToScreen = rw(this.rootRenderTarget), this.adaptor.prerender?.(this.rootRenderTarget);
        }
        postrender() {
            this.adaptor.postrender?.(this.rootRenderTarget);
        }
        bind(t, e = !0, n, s) {
            const r = this.getRenderTarget(t), a = this.renderTarget !== r;
            this.renderTarget = r, this.renderSurface = t;
            const o = this.getGpuRenderTarget(r);
            (r.pixelWidth !== o.width || r.pixelHeight !== o.height) && (this.adaptor.resizeGpuRenderTarget(r), o.width = r.pixelWidth, o.height = r.pixelHeight);
            const c = r.colorTexture, l = this.viewport, h = c.pixelWidth, u = c.pixelHeight;
            if (!s && t instanceof Ot && (s = t.frame), s) {
                const d = c._resolution;
                l.x = s.x * d + .5 | 0, l.y = s.y * d + .5 | 0, l.width = s.width * d + .5 | 0, l.height = s.height * d + .5 | 0;
            } else l.x = 0, l.y = 0, l.width = h, l.height = u;
            return sw(this.projectionMatrix, 0, 0, l.width / c.resolution, l.height / c.resolution, !r.isRoot), this.adaptor.startRenderPass(r, e, n, l), a && this.onRenderTargetChange.emit(r), r;
        }
        clear(t, e = vi.ALL, n) {
            e && (t && (t = this.getRenderTarget(t)), this.adaptor.clear(t || this.renderTarget, e, n, this.viewport));
        }
        contextChange() {
            this._gpuRenderTargetHash = Object.create(null);
        }
        push(t, e = vi.ALL, n, s) {
            const r = this.bind(t, e, n, s);
            return this._renderTargetStack.push({
                renderTarget: r,
                frame: s
            }), r;
        }
        pop() {
            this._renderTargetStack.pop();
            const t = this._renderTargetStack[this._renderTargetStack.length - 1];
            this.bind(t.renderTarget, !1, null, t.frame);
        }
        getRenderTarget(t) {
            return t.isTexture && (t = t.source), this._renderSurfaceToRenderTargetHash.get(t) ?? this._initRenderTarget(t);
        }
        copyToTexture(t, e, n, s, r) {
            n.x < 0 && (s.width += n.x, r.x -= n.x, n.x = 0), n.y < 0 && (s.height += n.y, r.y -= n.y, n.y = 0);
            const { pixelWidth: a, pixelHeight: o } = t;
            return s.width = Math.min(s.width, a - n.x), s.height = Math.min(s.height, o - n.y), this.adaptor.copyToTexture(t, e, n, s, r);
        }
        ensureDepthStencil() {
            this.renderTarget.stencil || (this.renderTarget.stencil = !0, this.adaptor.startRenderPass(this.renderTarget, !1, null, this.viewport));
        }
        destroy() {
            this._renderer = null, this._renderSurfaceToRenderTargetHash.forEach((t, e)=>{
                t !== e && t.destroy();
            }), this._renderSurfaceToRenderTargetHash.clear(), this._gpuRenderTargetHash = Object.create(null);
        }
        _initRenderTarget(t) {
            let e = null;
            return xi.test(t) && (t = Bm(t).source), t instanceof Dl ? e = t : t instanceof Ne && (e = new Dl({
                colorTextures: [
                    t
                ]
            }), xi.test(t.source.resource) && (e.isRoot = !0), t.once("destroy", ()=>{
                e.destroy(), this._renderSurfaceToRenderTargetHash.delete(t);
                const n = this._gpuRenderTargetHash[e.uid];
                n && (this._gpuRenderTargetHash[e.uid] = null, this.adaptor.destroyGpuRenderTarget(n));
            })), this._renderSurfaceToRenderTargetHash.set(t, e), e;
        }
        getGpuRenderTarget(t) {
            return this._gpuRenderTargetHash[t.uid] || (this._gpuRenderTargetHash[t.uid] = this.adaptor.initGpuRenderTarget(t));
        }
        resetState() {
            this.renderTarget = null, this.renderSurface = null;
        }
    }
    class km extends aw {
        constructor(t){
            super(t), this.adaptor = new iw, this.adaptor.init(t, this);
        }
    }
    km.extension = {
        type: [
            st.WebGLSystem
        ],
        name: "renderTarget"
    };
    class Gm extends In {
        constructor({ buffer: t, offset: e, size: n }){
            super(), this.uid = pe("buffer"), this._resourceType = "bufferResource", this._touched = 0, this._resourceId = pe("resource"), this._bufferResource = !0, this.destroyed = !1, this.buffer = t, this.offset = e | 0, this.size = n, this.buffer.on("change", this.onBufferChange, this);
        }
        onBufferChange() {
            this._resourceId = pe("resource"), this.emit("change", this);
        }
        destroy(t = !1) {
            this.destroyed = !0, t && this.buffer.destroy(), this.emit("change", this), this.buffer = null;
        }
    }
    function ow(i, t) {
        const e = [], n = [
            `
        var g = s.groups;
        var sS = r.shader;
        var p = s.glProgram;
        var ugS = r.uniformGroup;
        var resources;
    `
        ];
        let s = !1, r = 0;
        const a = t._getProgramData(i.glProgram);
        for(const c in i.groups){
            const l = i.groups[c];
            e.push(`
            resources = g[${c}].resources;
        `);
            for(const h in l.resources){
                const u = l.resources[h];
                if (u instanceof Ki) if (u.ubo) {
                    const d = i._uniformBindMap[c][Number(h)];
                    e.push(`
                        sS.bindUniformBlock(
                            resources[${h}],
                            '${d}',
                            ${i.glProgram._uniformBlockData[d].index}
                        );
                    `);
                } else e.push(`
                        ugS.updateUniformGroup(resources[${h}], p, sD);
                    `);
                else if (u instanceof Gm) {
                    const d = i._uniformBindMap[c][Number(h)];
                    e.push(`
                    sS.bindUniformBlock(
                        resources[${h}],
                        '${d}',
                        ${i.glProgram._uniformBlockData[d].index}
                    );
                `);
                } else if (u instanceof Ne) {
                    const d = i._uniformBindMap[c][h], f = a.uniformData[d];
                    f && (s || (s = !0, n.push(`
                        var tS = r.texture;
                        `)), t._gl.uniform1i(f.location, r), e.push(`
                        tS.bind(resources[${h}], ${r});
                    `), r++);
                }
            }
        }
        const o = [
            ...n,
            ...e
        ].join(`
`);
        return new Function("r", "s", "sD", o);
    }
    class cw {
        constructor(t, e){
            this.program = t, this.uniformData = e, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBlockBindings = {};
        }
        destroy() {
            this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBlockBindings = null, this.program = null;
        }
    }
    function uf(i, t, e) {
        const n = i.createShader(t);
        return i.shaderSource(n, e), i.compileShader(n), n;
    }
    function gc(i) {
        const t = new Array(i);
        for(let e = 0; e < t.length; e++)t[e] = !1;
        return t;
    }
    function Hm(i, t) {
        switch(i){
            case "float":
                return 0;
            case "vec2":
                return new Float32Array(2 * t);
            case "vec3":
                return new Float32Array(3 * t);
            case "vec4":
                return new Float32Array(4 * t);
            case "int":
            case "uint":
            case "sampler2D":
            case "sampler2DArray":
                return 0;
            case "ivec2":
                return new Int32Array(2 * t);
            case "ivec3":
                return new Int32Array(3 * t);
            case "ivec4":
                return new Int32Array(4 * t);
            case "uvec2":
                return new Uint32Array(2 * t);
            case "uvec3":
                return new Uint32Array(3 * t);
            case "uvec4":
                return new Uint32Array(4 * t);
            case "bool":
                return !1;
            case "bvec2":
                return gc(2 * t);
            case "bvec3":
                return gc(3 * t);
            case "bvec4":
                return gc(4 * t);
            case "mat2":
                return new Float32Array([
                    1,
                    0,
                    0,
                    1
                ]);
            case "mat3":
                return new Float32Array([
                    1,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    1
                ]);
            case "mat4":
                return new Float32Array([
                    1,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    1
                ]);
        }
        return null;
    }
    let Sa = null;
    const df = {
        FLOAT: "float",
        FLOAT_VEC2: "vec2",
        FLOAT_VEC3: "vec3",
        FLOAT_VEC4: "vec4",
        INT: "int",
        INT_VEC2: "ivec2",
        INT_VEC3: "ivec3",
        INT_VEC4: "ivec4",
        UNSIGNED_INT: "uint",
        UNSIGNED_INT_VEC2: "uvec2",
        UNSIGNED_INT_VEC3: "uvec3",
        UNSIGNED_INT_VEC4: "uvec4",
        BOOL: "bool",
        BOOL_VEC2: "bvec2",
        BOOL_VEC3: "bvec3",
        BOOL_VEC4: "bvec4",
        FLOAT_MAT2: "mat2",
        FLOAT_MAT3: "mat3",
        FLOAT_MAT4: "mat4",
        SAMPLER_2D: "sampler2D",
        INT_SAMPLER_2D: "sampler2D",
        UNSIGNED_INT_SAMPLER_2D: "sampler2D",
        SAMPLER_CUBE: "samplerCube",
        INT_SAMPLER_CUBE: "samplerCube",
        UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
        SAMPLER_2D_ARRAY: "sampler2DArray",
        INT_SAMPLER_2D_ARRAY: "sampler2DArray",
        UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
    }, lw = {
        float: "float32",
        vec2: "float32x2",
        vec3: "float32x3",
        vec4: "float32x4",
        int: "sint32",
        ivec2: "sint32x2",
        ivec3: "sint32x3",
        ivec4: "sint32x4",
        uint: "uint32",
        uvec2: "uint32x2",
        uvec3: "uint32x3",
        uvec4: "uint32x4",
        bool: "uint32",
        bvec2: "uint32x2",
        bvec3: "uint32x3",
        bvec4: "uint32x4"
    };
    function zm(i, t) {
        if (!Sa) {
            const e = Object.keys(df);
            Sa = {};
            for(let n = 0; n < e.length; ++n){
                const s = e[n];
                Sa[i[s]] = df[s];
            }
        }
        return Sa[t];
    }
    function hw(i, t) {
        const e = zm(i, t);
        return lw[e] || "float32";
    }
    function uw(i, t, e = !1) {
        const n = {}, s = t.getProgramParameter(i, t.ACTIVE_ATTRIBUTES);
        for(let a = 0; a < s; a++){
            const o = t.getActiveAttrib(i, a);
            if (o.name.startsWith("gl_")) continue;
            const c = hw(t, o.type);
            n[o.name] = {
                location: 0,
                format: c,
                stride: Dr(c).stride,
                offset: 0,
                instance: !1,
                start: 0
            };
        }
        const r = Object.keys(n);
        if (e) {
            r.sort((a, o)=>a > o ? 1 : -1);
            for(let a = 0; a < r.length; a++)n[r[a]].location = a, t.bindAttribLocation(i, a, r[a]);
            t.linkProgram(i);
        } else for(let a = 0; a < r.length; a++)n[r[a]].location = t.getAttribLocation(i, r[a]);
        return n;
    }
    function dw(i, t) {
        if (!t.ACTIVE_UNIFORM_BLOCKS) return {};
        const e = {}, n = t.getProgramParameter(i, t.ACTIVE_UNIFORM_BLOCKS);
        for(let s = 0; s < n; s++){
            const r = t.getActiveUniformBlockName(i, s), a = t.getUniformBlockIndex(i, r), o = t.getActiveUniformBlockParameter(i, s, t.UNIFORM_BLOCK_DATA_SIZE);
            e[r] = {
                name: r,
                index: a,
                size: o
            };
        }
        return e;
    }
    function fw(i, t) {
        const e = {}, n = t.getProgramParameter(i, t.ACTIVE_UNIFORMS);
        for(let s = 0; s < n; s++){
            const r = t.getActiveUniform(i, s), a = r.name.replace(/\[.*?\]$/, ""), o = !!r.name.match(/\[.*?\]$/), c = zm(t, r.type);
            e[a] = {
                name: a,
                index: s,
                type: c,
                size: r.size,
                isArray: o,
                value: Hm(c, r.size)
            };
        }
        return e;
    }
    function ff(i, t) {
        const e = i.getShaderSource(t).split(`
`).map((l, h)=>`${h}: ${l}`), n = i.getShaderInfoLog(t), s = n.split(`
`), r = {}, a = s.map((l)=>parseFloat(l.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter((l)=>l && !r[l] ? (r[l] = !0, !0) : !1), o = [
            ""
        ];
        a.forEach((l)=>{
            e[l - 1] = `%c${e[l - 1]}%c`, o.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
        });
        const c = e.join(`
`);
        o[0] = c, console.error(n), console.groupCollapsed("click to view full shader code"), console.warn(...o), console.groupEnd();
    }
    function pw(i, t, e, n) {
        i.getProgramParameter(t, i.LINK_STATUS) || (i.getShaderParameter(e, i.COMPILE_STATUS) || ff(i, e), i.getShaderParameter(n, i.COMPILE_STATUS) || ff(i, n), console.error("PixiJS Error: Could not initialize shader."), i.getProgramInfoLog(t) !== "" && console.warn("PixiJS Warning: gl.getProgramInfoLog()", i.getProgramInfoLog(t)));
    }
    function mw(i, t) {
        const e = uf(i, i.VERTEX_SHADER, t.vertex), n = uf(i, i.FRAGMENT_SHADER, t.fragment), s = i.createProgram();
        i.attachShader(s, e), i.attachShader(s, n);
        const r = t.transformFeedbackVaryings;
        r && (typeof i.transformFeedbackVaryings != "function" ? _e("TransformFeedback is not supported but TransformFeedbackVaryings are given.") : i.transformFeedbackVaryings(s, r.names, r.bufferMode === "separate" ? i.SEPARATE_ATTRIBS : i.INTERLEAVED_ATTRIBS)), i.linkProgram(s), i.getProgramParameter(s, i.LINK_STATUS) || pw(i, s, e, n), t._attributeData = uw(s, i, !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(t.vertex)), t._uniformData = fw(s, i), t._uniformBlockData = dw(s, i), i.deleteShader(e), i.deleteShader(n);
        const a = {};
        for(const c in t._uniformData){
            const l = t._uniformData[c];
            a[c] = {
                location: i.getUniformLocation(s, c),
                value: Hm(l.type, l.size)
            };
        }
        return new cw(s, a);
    }
    const Ma = {
        textureCount: 0,
        blockIndex: 0
    };
    class Vm {
        constructor(t){
            this._activeProgram = null, this._programDataHash = Object.create(null), this._shaderSyncFunctions = Object.create(null), this._renderer = t, this._renderer.renderableGC.addManagedHash(this, "_programDataHash");
        }
        contextChange(t) {
            this._gl = t, this._programDataHash = Object.create(null), this._shaderSyncFunctions = Object.create(null), this._activeProgram = null, this.maxTextures = Ja();
        }
        bind(t, e) {
            if (this._setProgram(t.glProgram), e) return;
            Ma.textureCount = 0, Ma.blockIndex = 0;
            let n = this._shaderSyncFunctions[t.glProgram._key];
            n || (n = this._shaderSyncFunctions[t.glProgram._key] = this._generateShaderSync(t, this)), this._renderer.buffer.nextBindBase(!!t.glProgram.transformFeedbackVaryings), n(this._renderer, t, Ma);
        }
        updateUniformGroup(t) {
            this._renderer.uniformGroup.updateUniformGroup(t, this._activeProgram, Ma);
        }
        bindUniformBlock(t, e, n = 0) {
            const s = this._renderer.buffer, r = this._getProgramData(this._activeProgram), a = t._bufferResource;
            a || this._renderer.ubo.updateUniformGroup(t);
            const o = t.buffer, c = s.updateBuffer(o), l = s.freeLocationForBufferBase(c);
            if (a) {
                const { offset: u, size: d } = t;
                u === 0 && d === o.data.byteLength ? s.bindBufferBase(c, l) : s.bindBufferRange(c, l, u);
            } else s.getLastBindBaseLocation(c) !== l && s.bindBufferBase(c, l);
            const h = this._activeProgram._uniformBlockData[e].index;
            r.uniformBlockBindings[n] !== l && (r.uniformBlockBindings[n] = l, this._renderer.gl.uniformBlockBinding(r.program, h, l));
        }
        _setProgram(t) {
            if (this._activeProgram === t) return;
            this._activeProgram = t;
            const e = this._getProgramData(t);
            this._gl.useProgram(e.program);
        }
        _getProgramData(t) {
            return this._programDataHash[t._key] || this._createProgramData(t);
        }
        _createProgramData(t) {
            const e = t._key;
            return this._programDataHash[e] = mw(this._gl, t), this._programDataHash[e];
        }
        destroy() {
            for (const t of Object.keys(this._programDataHash))this._programDataHash[t].destroy(), this._programDataHash[t] = null;
            this._programDataHash = null;
        }
        _generateShaderSync(t, e) {
            return ow(t, e);
        }
        resetState() {
            this._activeProgram = null;
        }
    }
    Vm.extension = {
        type: [
            st.WebGLSystem
        ],
        name: "shader"
    };
    const _w = {
        f32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1f(location, v);
        }`,
        "vec2<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2f(location, v[0], v[1]);
        }`,
        "vec3<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3f(location, v[0], v[1], v[2]);
        }`,
        "vec4<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4f(location, v[0], v[1], v[2], v[3]);
        }`,
        i32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
        "vec2<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
        "vec3<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
        "vec4<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
        u32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1ui(location, v);
        }`,
        "vec2<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2ui(location, v[0], v[1]);
        }`,
        "vec3<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3ui(location, v[0], v[1], v[2]);
        }`,
        "vec4<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
        }`,
        bool: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
        "vec2<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
        "vec3<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
        "vec4<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
        "mat2x2<f32>": "gl.uniformMatrix2fv(location, false, v);",
        "mat3x3<f32>": "gl.uniformMatrix3fv(location, false, v);",
        "mat4x4<f32>": "gl.uniformMatrix4fv(location, false, v);"
    }, gw = {
        f32: "gl.uniform1fv(location, v);",
        "vec2<f32>": "gl.uniform2fv(location, v);",
        "vec3<f32>": "gl.uniform3fv(location, v);",
        "vec4<f32>": "gl.uniform4fv(location, v);",
        "mat2x2<f32>": "gl.uniformMatrix2fv(location, false, v);",
        "mat3x3<f32>": "gl.uniformMatrix3fv(location, false, v);",
        "mat4x4<f32>": "gl.uniformMatrix4fv(location, false, v);",
        i32: "gl.uniform1iv(location, v);",
        "vec2<i32>": "gl.uniform2iv(location, v);",
        "vec3<i32>": "gl.uniform3iv(location, v);",
        "vec4<i32>": "gl.uniform4iv(location, v);",
        u32: "gl.uniform1iv(location, v);",
        "vec2<u32>": "gl.uniform2iv(location, v);",
        "vec3<u32>": "gl.uniform3iv(location, v);",
        "vec4<u32>": "gl.uniform4iv(location, v);",
        bool: "gl.uniform1iv(location, v);",
        "vec2<bool>": "gl.uniform2iv(location, v);",
        "vec3<bool>": "gl.uniform3iv(location, v);",
        "vec4<bool>": "gl.uniform4iv(location, v);"
    };
    function xw(i, t) {
        const e = [
            `
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
        var name = null;
    `
        ];
        for(const n in i.uniforms){
            if (!t[n]) {
                i.uniforms[n] instanceof Ki ? i.uniforms[n].ubo ? e.push(`
                        renderer.shader.bindUniformBlock(uv.${n}, "${n}");
                    `) : e.push(`
                        renderer.shader.updateUniformGroup(uv.${n});
                    `) : i.uniforms[n] instanceof Gm && e.push(`
                        renderer.shader.bindBufferResource(uv.${n}, "${n}");
                    `);
                continue;
            }
            const s = i.uniformStructures[n];
            let r = !1;
            for(let a = 0; a < zi.length; a++){
                const o = zi[a];
                if (s.type === o.type && o.test(s)) {
                    e.push(`name = "${n}";`, zi[a].uniform), r = !0;
                    break;
                }
            }
            if (!r) {
                const o = (s.size === 1 ? _w : gw)[s.type].replace("location", `ud["${n}"].location`);
                e.push(`
            cu = ud["${n}"];
            cv = cu.value;
            v = uv["${n}"];
            ${o};`);
            }
        }
        return new Function("ud", "uv", "renderer", "syncData", e.join(`
`));
    }
    class Wm {
        constructor(t){
            this._cache = {}, this._uniformGroupSyncHash = {}, this._renderer = t, this.gl = null, this._cache = {};
        }
        contextChange(t) {
            this.gl = t;
        }
        updateUniformGroup(t, e, n) {
            const s = this._renderer.shader._getProgramData(e);
            (!t.isStatic || t._dirtyId !== s.uniformDirtyGroups[t.uid]) && (s.uniformDirtyGroups[t.uid] = t._dirtyId, this._getUniformSyncFunction(t, e)(s.uniformData, t.uniforms, this._renderer, n));
        }
        _getUniformSyncFunction(t, e) {
            return this._uniformGroupSyncHash[t._signature]?.[e._key] || this._createUniformSyncFunction(t, e);
        }
        _createUniformSyncFunction(t, e) {
            const n = this._uniformGroupSyncHash[t._signature] || (this._uniformGroupSyncHash[t._signature] = {}), s = this._getSignature(t, e._uniformData, "u");
            return this._cache[s] || (this._cache[s] = this._generateUniformsSync(t, e._uniformData)), n[e._key] = this._cache[s], n[e._key];
        }
        _generateUniformsSync(t, e) {
            return xw(t, e);
        }
        _getSignature(t, e, n) {
            const s = t.uniforms, r = [
                `${n}-`
            ];
            for(const a in s)r.push(a), e[a] && r.push(e[a].type);
            return r.join("-");
        }
        destroy() {
            this._renderer = null, this._cache = null;
        }
    }
    Wm.extension = {
        type: [
            st.WebGLSystem
        ],
        name: "uniformGroup"
    };
    function vw(i) {
        const t = {};
        if (t.normal = [
            i.ONE,
            i.ONE_MINUS_SRC_ALPHA
        ], t.add = [
            i.ONE,
            i.ONE
        ], t.multiply = [
            i.DST_COLOR,
            i.ONE_MINUS_SRC_ALPHA,
            i.ONE,
            i.ONE_MINUS_SRC_ALPHA
        ], t.screen = [
            i.ONE,
            i.ONE_MINUS_SRC_COLOR,
            i.ONE,
            i.ONE_MINUS_SRC_ALPHA
        ], t.none = [
            0,
            0
        ], t["normal-npm"] = [
            i.SRC_ALPHA,
            i.ONE_MINUS_SRC_ALPHA,
            i.ONE,
            i.ONE_MINUS_SRC_ALPHA
        ], t["add-npm"] = [
            i.SRC_ALPHA,
            i.ONE,
            i.ONE,
            i.ONE
        ], t["screen-npm"] = [
            i.SRC_ALPHA,
            i.ONE_MINUS_SRC_COLOR,
            i.ONE,
            i.ONE_MINUS_SRC_ALPHA
        ], t.erase = [
            i.ZERO,
            i.ONE_MINUS_SRC_ALPHA
        ], !(i instanceof $e.get().getWebGLRenderingContext())) t.min = [
            i.ONE,
            i.ONE,
            i.ONE,
            i.ONE,
            i.MIN,
            i.MIN
        ], t.max = [
            i.ONE,
            i.ONE,
            i.ONE,
            i.ONE,
            i.MAX,
            i.MAX
        ];
        else {
            const n = i.getExtension("EXT_blend_minmax");
            n && (t.min = [
                i.ONE,
                i.ONE,
                i.ONE,
                i.ONE,
                n.MIN_EXT,
                n.MIN_EXT
            ], t.max = [
                i.ONE,
                i.ONE,
                i.ONE,
                i.ONE,
                n.MAX_EXT,
                n.MAX_EXT
            ]);
        }
        return t;
    }
    const yw = 0, bw = 1, Sw = 2, Mw = 3, Tw = 4, Ew = 5, Xm = class Ll {
        constructor(t){
            this._invertFrontFace = !1, this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = "none", this._blendEq = !1, this.map = [], this.map[yw] = this.setBlend, this.map[bw] = this.setOffset, this.map[Sw] = this.setCullFace, this.map[Mw] = this.setDepthTest, this.map[Tw] = this.setFrontFace, this.map[Ew] = this.setDepthMask, this.checks = [], this.defaultState = Fr.for2d(), t.renderTarget.onRenderTargetChange.add(this);
        }
        onRenderTargetChange(t) {
            this._invertFrontFace = !t.isRoot, this._cullFace ? this.setFrontFace(this._frontFace) : this._frontFaceDirty = !0;
        }
        contextChange(t) {
            this.gl = t, this.blendModesMap = vw(t), this.resetState();
        }
        set(t) {
            if (t || (t = this.defaultState), this.stateId !== t.data) {
                let e = this.stateId ^ t.data, n = 0;
                for(; e;)e & 1 && this.map[n].call(this, !!(t.data & 1 << n)), e >>= 1, n++;
                this.stateId = t.data;
            }
            for(let e = 0; e < this.checks.length; e++)this.checks[e](this, t);
        }
        forceState(t) {
            t || (t = this.defaultState);
            for(let e = 0; e < this.map.length; e++)this.map[e].call(this, !!(t.data & 1 << e));
            for(let e = 0; e < this.checks.length; e++)this.checks[e](this, t);
            this.stateId = t.data;
        }
        setBlend(t) {
            this._updateCheck(Ll._checkBlendMode, t), this.gl[t ? "enable" : "disable"](this.gl.BLEND);
        }
        setOffset(t) {
            this._updateCheck(Ll._checkPolygonOffset, t), this.gl[t ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
        }
        setDepthTest(t) {
            this.gl[t ? "enable" : "disable"](this.gl.DEPTH_TEST);
        }
        setDepthMask(t) {
            this.gl.depthMask(t);
        }
        setCullFace(t) {
            this._cullFace = t, this.gl[t ? "enable" : "disable"](this.gl.CULL_FACE), this._cullFace && this._frontFaceDirty && this.setFrontFace(this._frontFace);
        }
        setFrontFace(t) {
            this._frontFace = t, this._frontFaceDirty = !1;
            const e = this._invertFrontFace ? !t : t;
            this._glFrontFace !== e && (this._glFrontFace = e, this.gl.frontFace(this.gl[e ? "CW" : "CCW"]));
        }
        setBlendMode(t) {
            if (this.blendModesMap[t] || (t = "normal"), t === this.blendMode) return;
            this.blendMode = t;
            const e = this.blendModesMap[t], n = this.gl;
            e.length === 2 ? n.blendFunc(e[0], e[1]) : n.blendFuncSeparate(e[0], e[1], e[2], e[3]), e.length === 6 ? (this._blendEq = !0, n.blendEquationSeparate(e[4], e[5])) : this._blendEq && (this._blendEq = !1, n.blendEquationSeparate(n.FUNC_ADD, n.FUNC_ADD));
        }
        setPolygonOffset(t, e) {
            this.gl.polygonOffset(t, e);
        }
        resetState() {
            this._glFrontFace = !1, this._frontFace = !1, this._cullFace = !1, this._frontFaceDirty = !1, this._invertFrontFace = !1, this.gl.frontFace(this.gl.CCW), this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1), this.forceState(this.defaultState), this._blendEq = !0, this.blendMode = "", this.setBlendMode("normal");
        }
        _updateCheck(t, e) {
            const n = this.checks.indexOf(t);
            e && n === -1 ? this.checks.push(t) : !e && n !== -1 && this.checks.splice(n, 1);
        }
        static _checkBlendMode(t, e) {
            t.setBlendMode(e.blendMode);
        }
        static _checkPolygonOffset(t, e) {
            t.setPolygonOffset(1, e.polygonOffset);
        }
        destroy() {
            this.gl = null, this.checks.length = 0;
        }
    };
    Xm.extension = {
        type: [
            st.WebGLSystem
        ],
        name: "state"
    };
    let Aw = Xm;
    class ww {
        constructor(t){
            this.target = wm.TEXTURE_2D, this.texture = t, this.width = -1, this.height = -1, this.type = te.UNSIGNED_BYTE, this.internalFormat = Il.RGBA, this.format = Il.RGBA, this.samplerType = 0;
        }
    }
    const Rw = {
        id: "buffer",
        upload (i, t, e) {
            t.width === i.width || t.height === i.height ? e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, i.width, i.height, t.format, t.type, i.resource) : e.texImage2D(t.target, 0, t.internalFormat, i.width, i.height, 0, t.format, t.type, i.resource), t.width = i.width, t.height = i.height;
        }
    }, Cw = {
        "bc1-rgba-unorm": !0,
        "bc1-rgba-unorm-srgb": !0,
        "bc2-rgba-unorm": !0,
        "bc2-rgba-unorm-srgb": !0,
        "bc3-rgba-unorm": !0,
        "bc3-rgba-unorm-srgb": !0,
        "bc4-r-unorm": !0,
        "bc4-r-snorm": !0,
        "bc5-rg-unorm": !0,
        "bc5-rg-snorm": !0,
        "bc6h-rgb-ufloat": !0,
        "bc6h-rgb-float": !0,
        "bc7-rgba-unorm": !0,
        "bc7-rgba-unorm-srgb": !0,
        "etc2-rgb8unorm": !0,
        "etc2-rgb8unorm-srgb": !0,
        "etc2-rgb8a1unorm": !0,
        "etc2-rgb8a1unorm-srgb": !0,
        "etc2-rgba8unorm": !0,
        "etc2-rgba8unorm-srgb": !0,
        "eac-r11unorm": !0,
        "eac-r11snorm": !0,
        "eac-rg11unorm": !0,
        "eac-rg11snorm": !0,
        "astc-4x4-unorm": !0,
        "astc-4x4-unorm-srgb": !0,
        "astc-5x4-unorm": !0,
        "astc-5x4-unorm-srgb": !0,
        "astc-5x5-unorm": !0,
        "astc-5x5-unorm-srgb": !0,
        "astc-6x5-unorm": !0,
        "astc-6x5-unorm-srgb": !0,
        "astc-6x6-unorm": !0,
        "astc-6x6-unorm-srgb": !0,
        "astc-8x5-unorm": !0,
        "astc-8x5-unorm-srgb": !0,
        "astc-8x6-unorm": !0,
        "astc-8x6-unorm-srgb": !0,
        "astc-8x8-unorm": !0,
        "astc-8x8-unorm-srgb": !0,
        "astc-10x5-unorm": !0,
        "astc-10x5-unorm-srgb": !0,
        "astc-10x6-unorm": !0,
        "astc-10x6-unorm-srgb": !0,
        "astc-10x8-unorm": !0,
        "astc-10x8-unorm-srgb": !0,
        "astc-10x10-unorm": !0,
        "astc-10x10-unorm-srgb": !0,
        "astc-12x10-unorm": !0,
        "astc-12x10-unorm-srgb": !0,
        "astc-12x12-unorm": !0,
        "astc-12x12-unorm-srgb": !0
    }, Pw = {
        id: "compressed",
        upload (i, t, e) {
            e.pixelStorei(e.UNPACK_ALIGNMENT, 4);
            let n = i.pixelWidth, s = i.pixelHeight;
            const r = !!Cw[i.format];
            for(let a = 0; a < i.resource.length; a++){
                const o = i.resource[a];
                r ? e.compressedTexImage2D(e.TEXTURE_2D, a, t.internalFormat, n, s, 0, o) : e.texImage2D(e.TEXTURE_2D, a, t.internalFormat, n, s, 0, t.format, t.type, o), n = Math.max(n >> 1, 1), s = Math.max(s >> 1, 1);
            }
        }
    }, Ym = {
        id: "image",
        upload (i, t, e, n) {
            const s = t.width, r = t.height, a = i.pixelWidth, o = i.pixelHeight, c = i.resourceWidth, l = i.resourceHeight;
            c < a || l < o ? ((s !== a || r !== o) && e.texImage2D(t.target, 0, t.internalFormat, a, o, 0, t.format, t.type, null), n === 2 ? e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, c, l, t.format, t.type, i.resource) : e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, t.format, t.type, i.resource)) : s === a && r === o ? e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, t.format, t.type, i.resource) : n === 2 ? e.texImage2D(t.target, 0, t.internalFormat, a, o, 0, t.format, t.type, i.resource) : e.texImage2D(t.target, 0, t.internalFormat, t.format, t.type, i.resource), t.width = a, t.height = o;
        }
    }, Iw = {
        id: "video",
        upload (i, t, e, n) {
            if (!i.isValid) {
                e.texImage2D(t.target, 0, t.internalFormat, 1, 1, 0, t.format, t.type, null);
                return;
            }
            Ym.upload(i, t, e, n);
        }
    }, pf = {
        linear: 9729,
        nearest: 9728
    }, Dw = {
        linear: {
            linear: 9987,
            nearest: 9985
        },
        nearest: {
            linear: 9986,
            nearest: 9984
        }
    }, xc = {
        "clamp-to-edge": 33071,
        repeat: 10497,
        "mirror-repeat": 33648
    }, Lw = {
        never: 512,
        less: 513,
        equal: 514,
        "less-equal": 515,
        greater: 516,
        "not-equal": 517,
        "greater-equal": 518,
        always: 519
    };
    function mf(i, t, e, n, s, r, a, o) {
        const c = r;
        if (!o || i.addressModeU !== "repeat" || i.addressModeV !== "repeat" || i.addressModeW !== "repeat") {
            const l = xc[a ? "clamp-to-edge" : i.addressModeU], h = xc[a ? "clamp-to-edge" : i.addressModeV], u = xc[a ? "clamp-to-edge" : i.addressModeW];
            t[s](c, t.TEXTURE_WRAP_S, l), t[s](c, t.TEXTURE_WRAP_T, h), t.TEXTURE_WRAP_R && t[s](c, t.TEXTURE_WRAP_R, u);
        }
        if ((!o || i.magFilter !== "linear") && t[s](c, t.TEXTURE_MAG_FILTER, pf[i.magFilter]), e) {
            if (!o || i.mipmapFilter !== "linear") {
                const l = Dw[i.minFilter][i.mipmapFilter];
                t[s](c, t.TEXTURE_MIN_FILTER, l);
            }
        } else t[s](c, t.TEXTURE_MIN_FILTER, pf[i.minFilter]);
        if (n && i.maxAnisotropy > 1) {
            const l = Math.min(i.maxAnisotropy, t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
            t[s](c, n.TEXTURE_MAX_ANISOTROPY_EXT, l);
        }
        i.compare && t[s](c, t.TEXTURE_COMPARE_FUNC, Lw[i.compare]);
    }
    function Uw(i) {
        return {
            r8unorm: i.RED,
            r8snorm: i.RED,
            r8uint: i.RED,
            r8sint: i.RED,
            r16uint: i.RED,
            r16sint: i.RED,
            r16float: i.RED,
            rg8unorm: i.RG,
            rg8snorm: i.RG,
            rg8uint: i.RG,
            rg8sint: i.RG,
            r32uint: i.RED,
            r32sint: i.RED,
            r32float: i.RED,
            rg16uint: i.RG,
            rg16sint: i.RG,
            rg16float: i.RG,
            rgba8unorm: i.RGBA,
            "rgba8unorm-srgb": i.RGBA,
            rgba8snorm: i.RGBA,
            rgba8uint: i.RGBA,
            rgba8sint: i.RGBA,
            bgra8unorm: i.RGBA,
            "bgra8unorm-srgb": i.RGBA,
            rgb9e5ufloat: i.RGB,
            rgb10a2unorm: i.RGBA,
            rg11b10ufloat: i.RGB,
            rg32uint: i.RG,
            rg32sint: i.RG,
            rg32float: i.RG,
            rgba16uint: i.RGBA,
            rgba16sint: i.RGBA,
            rgba16float: i.RGBA,
            rgba32uint: i.RGBA,
            rgba32sint: i.RGBA,
            rgba32float: i.RGBA,
            stencil8: i.STENCIL_INDEX8,
            depth16unorm: i.DEPTH_COMPONENT,
            depth24plus: i.DEPTH_COMPONENT,
            "depth24plus-stencil8": i.DEPTH_STENCIL,
            depth32float: i.DEPTH_COMPONENT,
            "depth32float-stencil8": i.DEPTH_STENCIL
        };
    }
    function Nw(i, t) {
        let e = {}, n = i.RGBA;
        return i instanceof $e.get().getWebGLRenderingContext() ? t.srgb && (e = {
            "rgba8unorm-srgb": t.srgb.SRGB8_ALPHA8_EXT,
            "bgra8unorm-srgb": t.srgb.SRGB8_ALPHA8_EXT
        }) : (e = {
            "rgba8unorm-srgb": i.SRGB8_ALPHA8,
            "bgra8unorm-srgb": i.SRGB8_ALPHA8
        }, n = i.RGBA8), {
            r8unorm: i.R8,
            r8snorm: i.R8_SNORM,
            r8uint: i.R8UI,
            r8sint: i.R8I,
            r16uint: i.R16UI,
            r16sint: i.R16I,
            r16float: i.R16F,
            rg8unorm: i.RG8,
            rg8snorm: i.RG8_SNORM,
            rg8uint: i.RG8UI,
            rg8sint: i.RG8I,
            r32uint: i.R32UI,
            r32sint: i.R32I,
            r32float: i.R32F,
            rg16uint: i.RG16UI,
            rg16sint: i.RG16I,
            rg16float: i.RG16F,
            rgba8unorm: i.RGBA,
            ...e,
            rgba8snorm: i.RGBA8_SNORM,
            rgba8uint: i.RGBA8UI,
            rgba8sint: i.RGBA8I,
            bgra8unorm: n,
            rgb9e5ufloat: i.RGB9_E5,
            rgb10a2unorm: i.RGB10_A2,
            rg11b10ufloat: i.R11F_G11F_B10F,
            rg32uint: i.RG32UI,
            rg32sint: i.RG32I,
            rg32float: i.RG32F,
            rgba16uint: i.RGBA16UI,
            rgba16sint: i.RGBA16I,
            rgba16float: i.RGBA16F,
            rgba32uint: i.RGBA32UI,
            rgba32sint: i.RGBA32I,
            rgba32float: i.RGBA32F,
            stencil8: i.STENCIL_INDEX8,
            depth16unorm: i.DEPTH_COMPONENT16,
            depth24plus: i.DEPTH_COMPONENT24,
            "depth24plus-stencil8": i.DEPTH24_STENCIL8,
            depth32float: i.DEPTH_COMPONENT32F,
            "depth32float-stencil8": i.DEPTH32F_STENCIL8,
            ...t.s3tc ? {
                "bc1-rgba-unorm": t.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,
                "bc2-rgba-unorm": t.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,
                "bc3-rgba-unorm": t.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT
            } : {},
            ...t.s3tc_sRGB ? {
                "bc1-rgba-unorm-srgb": t.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
                "bc2-rgba-unorm-srgb": t.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
                "bc3-rgba-unorm-srgb": t.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
            } : {},
            ...t.rgtc ? {
                "bc4-r-unorm": t.rgtc.COMPRESSED_RED_RGTC1_EXT,
                "bc4-r-snorm": t.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,
                "bc5-rg-unorm": t.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,
                "bc5-rg-snorm": t.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
            } : {},
            ...t.bptc ? {
                "bc6h-rgb-float": t.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,
                "bc6h-rgb-ufloat": t.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,
                "bc7-rgba-unorm": t.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,
                "bc7-rgba-unorm-srgb": t.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            } : {},
            ...t.etc ? {
                "etc2-rgb8unorm": t.etc.COMPRESSED_RGB8_ETC2,
                "etc2-rgb8unorm-srgb": t.etc.COMPRESSED_SRGB8_ETC2,
                "etc2-rgb8a1unorm": t.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
                "etc2-rgb8a1unorm-srgb": t.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,
                "etc2-rgba8unorm": t.etc.COMPRESSED_RGBA8_ETC2_EAC,
                "etc2-rgba8unorm-srgb": t.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,
                "eac-r11unorm": t.etc.COMPRESSED_R11_EAC,
                "eac-rg11unorm": t.etc.COMPRESSED_SIGNED_RG11_EAC
            } : {},
            ...t.astc ? {
                "astc-4x4-unorm": t.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,
                "astc-4x4-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,
                "astc-5x4-unorm": t.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,
                "astc-5x4-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,
                "astc-5x5-unorm": t.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,
                "astc-5x5-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,
                "astc-6x5-unorm": t.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,
                "astc-6x5-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,
                "astc-6x6-unorm": t.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,
                "astc-6x6-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,
                "astc-8x5-unorm": t.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,
                "astc-8x5-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,
                "astc-8x6-unorm": t.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,
                "astc-8x6-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,
                "astc-8x8-unorm": t.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,
                "astc-8x8-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,
                "astc-10x5-unorm": t.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,
                "astc-10x5-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,
                "astc-10x6-unorm": t.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,
                "astc-10x6-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,
                "astc-10x8-unorm": t.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,
                "astc-10x8-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,
                "astc-10x10-unorm": t.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,
                "astc-10x10-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,
                "astc-12x10-unorm": t.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,
                "astc-12x10-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,
                "astc-12x12-unorm": t.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,
                "astc-12x12-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            } : {}
        };
    }
    function Bw(i) {
        return {
            r8unorm: i.UNSIGNED_BYTE,
            r8snorm: i.BYTE,
            r8uint: i.UNSIGNED_BYTE,
            r8sint: i.BYTE,
            r16uint: i.UNSIGNED_SHORT,
            r16sint: i.SHORT,
            r16float: i.HALF_FLOAT,
            rg8unorm: i.UNSIGNED_BYTE,
            rg8snorm: i.BYTE,
            rg8uint: i.UNSIGNED_BYTE,
            rg8sint: i.BYTE,
            r32uint: i.UNSIGNED_INT,
            r32sint: i.INT,
            r32float: i.FLOAT,
            rg16uint: i.UNSIGNED_SHORT,
            rg16sint: i.SHORT,
            rg16float: i.HALF_FLOAT,
            rgba8unorm: i.UNSIGNED_BYTE,
            "rgba8unorm-srgb": i.UNSIGNED_BYTE,
            rgba8snorm: i.BYTE,
            rgba8uint: i.UNSIGNED_BYTE,
            rgba8sint: i.BYTE,
            bgra8unorm: i.UNSIGNED_BYTE,
            "bgra8unorm-srgb": i.UNSIGNED_BYTE,
            rgb9e5ufloat: i.UNSIGNED_INT_5_9_9_9_REV,
            rgb10a2unorm: i.UNSIGNED_INT_2_10_10_10_REV,
            rg11b10ufloat: i.UNSIGNED_INT_10F_11F_11F_REV,
            rg32uint: i.UNSIGNED_INT,
            rg32sint: i.INT,
            rg32float: i.FLOAT,
            rgba16uint: i.UNSIGNED_SHORT,
            rgba16sint: i.SHORT,
            rgba16float: i.HALF_FLOAT,
            rgba32uint: i.UNSIGNED_INT,
            rgba32sint: i.INT,
            rgba32float: i.FLOAT,
            stencil8: i.UNSIGNED_BYTE,
            depth16unorm: i.UNSIGNED_SHORT,
            depth24plus: i.UNSIGNED_INT,
            "depth24plus-stencil8": i.UNSIGNED_INT_24_8,
            depth32float: i.FLOAT,
            "depth32float-stencil8": i.FLOAT_32_UNSIGNED_INT_24_8_REV
        };
    }
    const Fw = 4;
    class qm {
        constructor(t){
            this.managedTextures = [], this._glTextures = Object.create(null), this._glSamplers = Object.create(null), this._boundTextures = [], this._activeTextureLocation = -1, this._boundSamplers = Object.create(null), this._uploads = {
                image: Ym,
                buffer: Rw,
                video: Iw,
                compressed: Pw
            }, this._premultiplyAlpha = !1, this._useSeparateSamplers = !1, this._renderer = t, this._renderer.renderableGC.addManagedHash(this, "_glTextures"), this._renderer.renderableGC.addManagedHash(this, "_glSamplers");
        }
        contextChange(t) {
            this._gl = t, this._mapFormatToInternalFormat || (this._mapFormatToInternalFormat = Nw(t, this._renderer.context.extensions), this._mapFormatToType = Bw(t), this._mapFormatToFormat = Uw(t)), this._glTextures = Object.create(null), this._glSamplers = Object.create(null), this._boundSamplers = Object.create(null), this._premultiplyAlpha = !1;
            for(let e = 0; e < 16; e++)this.bind(Ot.EMPTY, e);
        }
        initSource(t) {
            this.bind(t);
        }
        bind(t, e = 0) {
            const n = t.source;
            t ? (this.bindSource(n, e), this._useSeparateSamplers && this._bindSampler(n.style, e)) : (this.bindSource(null, e), this._useSeparateSamplers && this._bindSampler(null, e));
        }
        bindSource(t, e = 0) {
            const n = this._gl;
            if (t._touched = this._renderer.textureGC.count, this._boundTextures[e] !== t) {
                this._boundTextures[e] = t, this._activateLocation(e), t || (t = Ot.EMPTY.source);
                const s = this.getGlSource(t);
                n.bindTexture(s.target, s.texture);
            }
        }
        _bindSampler(t, e = 0) {
            const n = this._gl;
            if (!t) {
                this._boundSamplers[e] = null, n.bindSampler(e, null);
                return;
            }
            const s = this._getGlSampler(t);
            this._boundSamplers[e] !== s && (this._boundSamplers[e] = s, n.bindSampler(e, s));
        }
        unbind(t) {
            const e = t.source, n = this._boundTextures, s = this._gl;
            for(let r = 0; r < n.length; r++)if (n[r] === e) {
                this._activateLocation(r);
                const a = this.getGlSource(e);
                s.bindTexture(a.target, null), n[r] = null;
            }
        }
        _activateLocation(t) {
            this._activeTextureLocation !== t && (this._activeTextureLocation = t, this._gl.activeTexture(this._gl.TEXTURE0 + t));
        }
        _initSource(t) {
            const e = this._gl, n = new ww(e.createTexture());
            if (n.type = this._mapFormatToType[t.format], n.internalFormat = this._mapFormatToInternalFormat[t.format], n.format = this._mapFormatToFormat[t.format], t.autoGenerateMipmaps && (this._renderer.context.supports.nonPowOf2mipmaps || t.isPowerOfTwo)) {
                const s = Math.max(t.width, t.height);
                t.mipLevelCount = Math.floor(Math.log2(s)) + 1;
            }
            return this._glTextures[t.uid] = n, this.managedTextures.includes(t) || (t.on("update", this.onSourceUpdate, this), t.on("resize", this.onSourceUpdate, this), t.on("styleChange", this.onStyleChange, this), t.on("destroy", this.onSourceDestroy, this), t.on("unload", this.onSourceUnload, this), t.on("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.push(t)), this.onSourceUpdate(t), this.updateStyle(t, !1), n;
        }
        onStyleChange(t) {
            this.updateStyle(t, !1);
        }
        updateStyle(t, e) {
            const n = this._gl, s = this.getGlSource(t);
            n.bindTexture(n.TEXTURE_2D, s.texture), this._boundTextures[this._activeTextureLocation] = t, mf(t.style, n, t.mipLevelCount > 1, this._renderer.context.extensions.anisotropicFiltering, "texParameteri", n.TEXTURE_2D, !this._renderer.context.supports.nonPowOf2wrapping && !t.isPowerOfTwo, e);
        }
        onSourceUnload(t) {
            const e = this._glTextures[t.uid];
            e && (this.unbind(t), this._glTextures[t.uid] = null, this._gl.deleteTexture(e.texture));
        }
        onSourceUpdate(t) {
            const e = this._gl, n = this.getGlSource(t);
            e.bindTexture(e.TEXTURE_2D, n.texture), this._boundTextures[this._activeTextureLocation] = t;
            const s = t.alphaMode === "premultiply-alpha-on-upload";
            this._premultiplyAlpha !== s && (this._premultiplyAlpha = s, e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, s)), this._uploads[t.uploadMethodId] ? this._uploads[t.uploadMethodId].upload(t, n, e, this._renderer.context.webGLVersion) : e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, t.pixelWidth, t.pixelHeight, 0, e.RGBA, e.UNSIGNED_BYTE, null), t.autoGenerateMipmaps && t.mipLevelCount > 1 && this.onUpdateMipmaps(t, !1);
        }
        onUpdateMipmaps(t, e = !0) {
            e && this.bindSource(t, 0);
            const n = this.getGlSource(t);
            this._gl.generateMipmap(n.target);
        }
        onSourceDestroy(t) {
            t.off("destroy", this.onSourceDestroy, this), t.off("update", this.onSourceUpdate, this), t.off("resize", this.onSourceUpdate, this), t.off("unload", this.onSourceUnload, this), t.off("styleChange", this.onStyleChange, this), t.off("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.splice(this.managedTextures.indexOf(t), 1), this.onSourceUnload(t);
        }
        _initSampler(t) {
            const e = this._gl, n = this._gl.createSampler();
            return this._glSamplers[t._resourceId] = n, mf(t, e, this._boundTextures[this._activeTextureLocation].mipLevelCount > 1, this._renderer.context.extensions.anisotropicFiltering, "samplerParameteri", n, !1, !0), this._glSamplers[t._resourceId];
        }
        _getGlSampler(t) {
            return this._glSamplers[t._resourceId] || this._initSampler(t);
        }
        getGlSource(t) {
            return this._glTextures[t.uid] || this._initSource(t);
        }
        generateCanvas(t) {
            const { pixels: e, width: n, height: s } = this.getPixels(t), r = $e.get().createCanvas();
            r.width = n, r.height = s;
            const a = r.getContext("2d");
            if (a) {
                const o = a.createImageData(n, s);
                o.data.set(e), a.putImageData(o, 0, 0);
            }
            return r;
        }
        getPixels(t) {
            const e = t.source.resolution, n = t.frame, s = Math.max(Math.round(n.width * e), 1), r = Math.max(Math.round(n.height * e), 1), a = new Uint8Array(Fw * s * r), o = this._renderer, c = o.renderTarget.getRenderTarget(t), l = o.renderTarget.getGpuRenderTarget(c), h = o.gl;
            return h.bindFramebuffer(h.FRAMEBUFFER, l.resolveTargetFramebuffer), h.readPixels(Math.round(n.x * e), Math.round(n.y * e), s, r, h.RGBA, h.UNSIGNED_BYTE, a), {
                pixels: new Uint8ClampedArray(a.buffer),
                width: s,
                height: r
            };
        }
        destroy() {
            this.managedTextures.slice().forEach((t)=>this.onSourceDestroy(t)), this.managedTextures = null, this._renderer = null;
        }
        resetState() {
            this._activeTextureLocation = -1, this._boundTextures.fill(Ot.EMPTY.source), this._boundSamplers = Object.create(null);
            const t = this._gl;
            this._premultiplyAlpha = !1, t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._premultiplyAlpha);
        }
    }
    qm.extension = {
        type: [
            st.WebGLSystem
        ],
        name: "texture"
    };
    class jm {
        init() {
            const t = new Ki({
                uColor: {
                    value: new Float32Array([
                        1,
                        1,
                        1,
                        1
                    ]),
                    type: "vec4<f32>"
                },
                uTransformMatrix: {
                    value: new Ft,
                    type: "mat3x3<f32>"
                },
                uRound: {
                    value: 0,
                    type: "f32"
                }
            }), e = Ja(), n = gh({
                name: "graphics",
                bits: [
                    im,
                    sm(e),
                    bm,
                    xh
                ]
            });
            this.shader = new Zi({
                glProgram: n,
                resources: {
                    localUniforms: t,
                    batchSamplers: rm(e)
                }
            });
        }
        execute(t, e) {
            const n = e.context, s = n.customShader || this.shader, r = t.renderer, a = r.graphicsContext, { batcher: o, instructions: c } = a.getContextRenderData(n);
            s.groups[0] = r.globalUniforms.bindGroup, r.state.set(t.state), r.shader.bind(s), r.geometry.bind(o.geometry, s.glProgram);
            const l = c.instructions;
            for(let h = 0; h < c.instructionSize; h++){
                const u = l[h];
                if (u.size) {
                    for(let d = 0; d < u.textures.count; d++)r.texture.bind(u.textures.textures[d], d);
                    r.geometry.draw(u.topology, u.size, u.start);
                }
            }
        }
        destroy() {
            this.shader.destroy(!0), this.shader = null;
        }
    }
    jm.extension = {
        type: [
            st.WebGLPipesAdaptor
        ],
        name: "graphics"
    };
    class $m {
        init() {
            const t = gh({
                name: "mesh",
                bits: [
                    bm,
                    GA,
                    xh
                ]
            });
            this._shader = new Zi({
                glProgram: t,
                resources: {
                    uTexture: Ot.EMPTY.source,
                    textureUniforms: {
                        uTextureMatrix: {
                            type: "mat3x3<f32>",
                            value: new Ft
                        }
                    }
                }
            });
        }
        execute(t, e) {
            const n = t.renderer;
            let s = e._shader;
            if (s) {
                if (!s.glProgram) {
                    _e("Mesh shader has no glProgram", e.shader);
                    return;
                }
            } else {
                s = this._shader;
                const r = e.texture, a = r.source;
                s.resources.uTexture = a, s.resources.uSampler = a.style, s.resources.textureUniforms.uniforms.uTextureMatrix = r.textureMatrix.mapCoord;
            }
            s.groups[100] = n.globalUniforms.bindGroup, s.groups[101] = t.localUniformsBindGroup, n.encoder.draw({
                geometry: e._geometry,
                shader: s,
                state: e.state
            });
        }
        destroy() {
            this._shader.destroy(!0), this._shader = null;
        }
    }
    $m.extension = {
        type: [
            st.WebGLPipesAdaptor
        ],
        name: "mesh"
    };
    class Km {
        constructor(t){
            this._renderer = t;
        }
        updateRenderable() {}
        destroyRenderable() {}
        validateRenderable() {
            return !1;
        }
        addRenderable(t, e) {
            this._renderer.renderPipes.batch.break(e), e.add(t);
        }
        execute(t) {
            t.isRenderable && t.render(this._renderer);
        }
        destroy() {
            this._renderer = null;
        }
    }
    Km.extension = {
        type: [
            st.WebGLPipes,
            st.WebGPUPipes,
            st.CanvasPipes
        ],
        name: "customRender"
    };
    Zm = class {
        constructor(){
            this.batcherName = "default", this.topology = "triangle-list", this.attributeSize = 4, this.indexSize = 6, this.packAsQuad = !0, this.roundPixels = 0, this._attributeStart = 0, this._batcher = null, this._batch = null;
        }
        get blendMode() {
            return this.renderable.groupBlendMode;
        }
        get color() {
            return this.renderable.groupColorAlpha;
        }
        reset() {
            this.renderable = null, this.texture = null, this._batcher = null, this._batch = null, this.bounds = null;
        }
    };
    function Ul(i, t) {
        const e = i.instructionSet, n = e.instructions;
        for(let s = 0; s < e.instructionSize; s++){
            const r = n[s];
            t[r.renderPipeId].execute(r);
        }
    }
    const Ow = new Ft;
    class Jm {
        constructor(t){
            this._renderer = t;
        }
        addRenderGroup(t, e) {
            t.isCachedAsTexture ? this._addRenderableCacheAsTexture(t, e) : this._addRenderableDirect(t, e);
        }
        execute(t) {
            t.isRenderable && (t.isCachedAsTexture ? this._executeCacheAsTexture(t) : this._executeDirect(t));
        }
        destroy() {
            this._renderer = null;
        }
        _addRenderableDirect(t, e) {
            this._renderer.renderPipes.batch.break(e), t._batchableRenderGroup && (Ge.return(t._batchableRenderGroup), t._batchableRenderGroup = null), e.add(t);
        }
        _addRenderableCacheAsTexture(t, e) {
            const n = t._batchableRenderGroup ?? (t._batchableRenderGroup = Ge.get(Zm));
            n.renderable = t.root, n.transform = t.root.relativeGroupTransform, n.texture = t.texture, n.bounds = t._textureBounds, e.add(t), this._renderer.renderPipes.batch.addToBatch(n, e);
        }
        _executeCacheAsTexture(t) {
            if (t.textureNeedsUpdate) {
                t.textureNeedsUpdate = !1;
                const e = Ow.identity().translate(-t._textureBounds.x, -t._textureBounds.y);
                this._renderer.renderTarget.push(t.texture, !0, null, t.texture.frame), this._renderer.globalUniforms.push({
                    worldTransformMatrix: e,
                    worldColor: 4294967295
                }), Ul(t, this._renderer.renderPipes), this._renderer.renderTarget.finishRenderPass(), this._renderer.renderTarget.pop(), this._renderer.globalUniforms.pop();
            }
            t._batchableRenderGroup._batcher.updateElement(t._batchableRenderGroup), t._batchableRenderGroup._batcher.geometry.buffers[0].update();
        }
        _executeDirect(t) {
            this._renderer.globalUniforms.push({
                worldTransformMatrix: t.inverseParentTextureTransform,
                worldColor: t.worldColorAlpha
            }), Ul(t, this._renderer.renderPipes), this._renderer.globalUniforms.pop();
        }
    }
    Jm.extension = {
        type: [
            st.WebGLPipes,
            st.WebGPUPipes,
            st.CanvasPipes
        ],
        name: "renderGroup"
    };
    function Nl(i, t) {
        t || (t = 0);
        for(let e = t; e < i.length && i[e]; e++)i[e] = null;
    }
    const kw = new mn, _f = xr | Wa | lh;
    function Qm(i, t = !1) {
        Gw(i);
        const e = i.childrenToUpdate, n = i.updateTick++;
        for(const s in e){
            const r = Number(s), a = e[s], o = a.list, c = a.index;
            for(let l = 0; l < c; l++){
                const h = o[l];
                h.parentRenderGroup === i && h.relativeRenderGroupDepth === r && t_(h, n, 0);
            }
            Nl(o, c), a.index = 0;
        }
        if (t) for(let s = 0; s < i.renderGroupChildren.length; s++)Qm(i.renderGroupChildren[s], t);
    }
    function Gw(i) {
        const t = i.root;
        let e;
        if (i.renderGroupParent) {
            const n = i.renderGroupParent;
            i.worldTransform.appendFrom(t.relativeGroupTransform, n.worldTransform), i.worldColor = Va(t.groupColor, n.worldColor), e = t.groupAlpha * n.worldAlpha;
        } else i.worldTransform.copyFrom(t.localTransform), i.worldColor = t.localColor, e = t.localAlpha;
        e = e < 0 ? 0 : e > 1 ? 1 : e, i.worldAlpha = e, i.worldColorAlpha = i.worldColor + ((e * 255 | 0) << 24);
    }
    function t_(i, t, e) {
        if (t === i.updateTick) return;
        i.updateTick = t, i.didChange = !1;
        const n = i.localTransform;
        i.updateLocalTransform();
        const s = i.parent;
        if (s && !s.renderGroup ? (e |= i._updateFlags, i.relativeGroupTransform.appendFrom(n, s.relativeGroupTransform), e & _f && gf(i, s, e)) : (e = i._updateFlags, i.relativeGroupTransform.copyFrom(n), e & _f && gf(i, kw, e)), !i.renderGroup) {
            const r = i.children, a = r.length;
            for(let l = 0; l < a; l++)t_(r[l], t, e);
            const o = i.parentRenderGroup, c = i;
            c.renderPipeId && !o.structureDidChange && o.updateRenderable(c);
        }
    }
    function gf(i, t, e) {
        if (e & Wa) {
            i.groupColor = Va(i.localColor, t.groupColor);
            let n = i.localAlpha * t.groupAlpha;
            n = n < 0 ? 0 : n > 1 ? 1 : n, i.groupAlpha = n, i.groupColorAlpha = i.groupColor + ((n * 255 | 0) << 24);
        }
        e & lh && (i.groupBlendMode = i.localBlendMode === "inherit" ? t.groupBlendMode : i.localBlendMode), e & xr && (i.globalDisplayStatus = i.localDisplayStatus & t.globalDisplayStatus), i._updateFlags = 0;
    }
    function Hw(i, t) {
        const { list: e, index: n } = i.childrenRenderablesToUpdate;
        let s = !1;
        for(let r = 0; r < n; r++){
            const a = e[r];
            if (s = t[a.renderPipeId].validateRenderable(a), s) break;
        }
        return i.structureDidChange = s, s;
    }
    const zw = new Ft;
    class e_ {
        constructor(t){
            this._renderer = t;
        }
        render({ container: t, transform: e }) {
            const n = t.parent, s = t.renderGroup.renderGroupParent;
            t.parent = null, t.renderGroup.renderGroupParent = null;
            const r = this._renderer;
            let a = zw;
            e && (a = a.copyFrom(t.renderGroup.localTransform), t.renderGroup.localTransform.copyFrom(e));
            const o = r.renderPipes;
            this._updateCachedRenderGroups(t.renderGroup, null), this._updateRenderGroups(t.renderGroup), r.globalUniforms.start({
                worldTransformMatrix: e ? t.renderGroup.localTransform : t.renderGroup.worldTransform,
                worldColor: t.renderGroup.worldColorAlpha
            }), Ul(t.renderGroup, o), o.uniformBatch && o.uniformBatch.renderEnd(), e && t.renderGroup.localTransform.copyFrom(a), t.parent = n, t.renderGroup.renderGroupParent = s;
        }
        destroy() {
            this._renderer = null;
        }
        _updateCachedRenderGroups(t, e) {
            if (t.isCachedAsTexture) {
                if (!t.updateCacheTexture) return;
                e = t;
            }
            t._parentCacheAsTextureRenderGroup = e;
            for(let n = t.renderGroupChildren.length - 1; n >= 0; n--)this._updateCachedRenderGroups(t.renderGroupChildren[n], e);
            if (t.invalidateMatrices(), t.isCachedAsTexture) {
                if (t.textureNeedsUpdate) {
                    const n = t.root.getLocalBounds();
                    n.ceil();
                    const s = t.texture;
                    t.texture && ws.returnTexture(t.texture);
                    const r = this._renderer, a = t.textureOptions.resolution || r.view.resolution, o = t.textureOptions.antialias ?? r.view.antialias;
                    t.texture = ws.getOptimalTexture(n.width, n.height, a, o), t._textureBounds || (t._textureBounds = new en), t._textureBounds.copyFrom(n), s !== t.texture && t.renderGroupParent && (t.renderGroupParent.structureDidChange = !0);
                }
            } else t.texture && (ws.returnTexture(t.texture), t.texture = null);
        }
        _updateRenderGroups(t) {
            const e = this._renderer, n = e.renderPipes;
            if (t.runOnRender(e), t.instructionSet.renderPipes = n, t.structureDidChange ? Nl(t.childrenRenderablesToUpdate.list, 0) : Hw(t, n), Qm(t), t.structureDidChange ? (t.structureDidChange = !1, this._buildInstructions(t, e)) : this._updateRenderables(t), t.childrenRenderablesToUpdate.index = 0, e.renderPipes.batch.upload(t.instructionSet), !(t.isCachedAsTexture && !t.textureNeedsUpdate)) for(let s = 0; s < t.renderGroupChildren.length; s++)this._updateRenderGroups(t.renderGroupChildren[s]);
        }
        _updateRenderables(t) {
            const { list: e, index: n } = t.childrenRenderablesToUpdate;
            for(let s = 0; s < n; s++){
                const r = e[s];
                r.didViewUpdate && t.updateRenderable(r);
            }
            Nl(e, n);
        }
        _buildInstructions(t, e) {
            const n = t.root, s = t.instructionSet;
            s.reset();
            const r = e.renderPipes ? e : e.batch.renderer, a = r.renderPipes;
            a.batch.buildStart(s), a.blendMode.buildStart(), a.colorMask.buildStart(), n.sortableChildren && n.sortChildren(), n.collectRenderablesWithEffects(s, r, null), a.batch.buildEnd(s), a.blendMode.buildEnd(s);
        }
    }
    e_.extension = {
        type: [
            st.WebGLSystem,
            st.WebGPUSystem,
            st.CanvasSystem
        ],
        name: "renderGroup"
    };
    class n_ {
        constructor(t){
            this._gpuSpriteHash = Object.create(null), this._destroyRenderableBound = this.destroyRenderable.bind(this), this._renderer = t, this._renderer.renderableGC.addManagedHash(this, "_gpuSpriteHash");
        }
        addRenderable(t, e) {
            const n = this._getGpuSprite(t);
            t.didViewUpdate && this._updateBatchableSprite(t, n), this._renderer.renderPipes.batch.addToBatch(n, e);
        }
        updateRenderable(t) {
            const e = this._gpuSpriteHash[t.uid];
            t.didViewUpdate && this._updateBatchableSprite(t, e), e._batcher.updateElement(e);
        }
        validateRenderable(t) {
            const e = this._getGpuSprite(t);
            return !e._batcher.checkAndUpdateTexture(e, t._texture);
        }
        destroyRenderable(t) {
            const e = this._gpuSpriteHash[t.uid];
            Ge.return(e), this._gpuSpriteHash[t.uid] = null, t.off("destroyed", this._destroyRenderableBound);
        }
        _updateBatchableSprite(t, e) {
            e.bounds = t.visualBounds, e.texture = t._texture;
        }
        _getGpuSprite(t) {
            return this._gpuSpriteHash[t.uid] || this._initGPUSprite(t);
        }
        _initGPUSprite(t) {
            const e = Ge.get(Zm);
            return e.renderable = t, e.transform = t.groupTransform, e.texture = t._texture, e.bounds = t.visualBounds, e.roundPixels = this._renderer._roundPixels | t._roundPixels, this._gpuSpriteHash[t.uid] = e, t.on("destroyed", this._destroyRenderableBound), e;
        }
        destroy() {
            for(const t in this._gpuSpriteHash)Ge.return(this._gpuSpriteHash[t]);
            this._gpuSpriteHash = null, this._renderer = null;
        }
    }
    n_.extension = {
        type: [
            st.WebGLPipes,
            st.WebGPUPipes,
            st.CanvasPipes
        ],
        name: "sprite"
    };
    const Ah = class i_ {
        constructor(){
            this.clearBeforeRender = !0, this._backgroundColor = new Pe(0), this.color = this._backgroundColor, this.alpha = 1;
        }
        init(t) {
            t = {
                ...i_.defaultOptions,
                ...t
            }, this.clearBeforeRender = t.clearBeforeRender, this.color = t.background || t.backgroundColor || this._backgroundColor, this.alpha = t.backgroundAlpha, this._backgroundColor.setAlpha(t.backgroundAlpha);
        }
        get color() {
            return this._backgroundColor;
        }
        set color(t) {
            this._backgroundColor.setValue(t);
        }
        get alpha() {
            return this._backgroundColor.alpha;
        }
        set alpha(t) {
            this._backgroundColor.setAlpha(t);
        }
        get colorRgba() {
            return this._backgroundColor.toArray();
        }
        destroy() {}
    };
    Ah.extension = {
        type: [
            st.WebGLSystem,
            st.WebGPUSystem,
            st.CanvasSystem
        ],
        name: "background",
        priority: 0
    };
    Ah.defaultOptions = {
        backgroundAlpha: 1,
        backgroundColor: 0,
        clearBeforeRender: !0
    };
    let Vw = Ah;
    const Mr = {};
    Be.handle(st.BlendMode, (i)=>{
        if (!i.name) throw new Error("BlendMode extension must have a name property");
        Mr[i.name] = i.ref;
    }, (i)=>{
        delete Mr[i.name];
    });
    class s_ {
        constructor(t){
            this._isAdvanced = !1, this._filterHash = Object.create(null), this._renderer = t, this._renderer.runners.prerender.add(this);
        }
        prerender() {
            this._activeBlendMode = "normal", this._isAdvanced = !1;
        }
        setBlendMode(t, e, n) {
            if (this._activeBlendMode === e) {
                this._isAdvanced && this._renderableList.push(t);
                return;
            }
            this._activeBlendMode = e, this._isAdvanced && this._endAdvancedBlendMode(n), this._isAdvanced = !!Mr[e], this._isAdvanced && (this._beginAdvancedBlendMode(n), this._renderableList.push(t));
        }
        _beginAdvancedBlendMode(t) {
            this._renderer.renderPipes.batch.break(t);
            const e = this._activeBlendMode;
            if (!Mr[e]) {
                _e(`Unable to assign BlendMode: '${e}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);
                return;
            }
            let n = this._filterHash[e];
            n || (n = this._filterHash[e] = new za, n.filters = [
                new Mr[e]
            ]);
            const s = {
                renderPipeId: "filter",
                action: "pushFilter",
                renderables: [],
                filterEffect: n,
                canBundle: !1
            };
            this._renderableList = s.renderables, t.add(s);
        }
        _endAdvancedBlendMode(t) {
            this._renderableList = null, this._renderer.renderPipes.batch.break(t), t.add({
                renderPipeId: "filter",
                action: "popFilter",
                canBundle: !1
            });
        }
        buildStart() {
            this._isAdvanced = !1;
        }
        buildEnd(t) {
            this._isAdvanced && this._endAdvancedBlendMode(t);
        }
        destroy() {
            this._renderer = null, this._renderableList = null;
            for(const t in this._filterHash)this._filterHash[t].destroy();
            this._filterHash = null;
        }
    }
    s_.extension = {
        type: [
            st.WebGLPipes,
            st.WebGPUPipes,
            st.CanvasPipes
        ],
        name: "blendMode"
    };
    const vc = {
        png: "image/png",
        jpg: "image/jpeg",
        webp: "image/webp"
    }, wh = class r_ {
        constructor(t){
            this._renderer = t;
        }
        _normalizeOptions(t, e = {}) {
            return t instanceof mn || t instanceof Ot ? {
                target: t,
                ...e
            } : {
                ...e,
                ...t
            };
        }
        async image(t) {
            const e = new Image;
            return e.src = await this.base64(t), e;
        }
        async base64(t) {
            t = this._normalizeOptions(t, r_.defaultImageOptions);
            const { format: e, quality: n } = t, s = this.canvas(t);
            if (s.toBlob !== void 0) return new Promise((r, a)=>{
                s.toBlob((o)=>{
                    if (!o) {
                        a(new Error("ICanvas.toBlob failed!"));
                        return;
                    }
                    const c = new FileReader;
                    c.onload = ()=>r(c.result), c.onerror = a, c.readAsDataURL(o);
                }, vc[e], n);
            });
            if (s.toDataURL !== void 0) return s.toDataURL(vc[e], n);
            if (s.convertToBlob !== void 0) {
                const r = await s.convertToBlob({
                    type: vc[e],
                    quality: n
                });
                return new Promise((a, o)=>{
                    const c = new FileReader;
                    c.onload = ()=>a(c.result), c.onerror = o, c.readAsDataURL(r);
                });
            }
            throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");
        }
        canvas(t) {
            t = this._normalizeOptions(t);
            const e = t.target, n = this._renderer;
            if (e instanceof Ot) return n.texture.generateCanvas(e);
            const s = n.textureGenerator.generateTexture(t), r = n.texture.generateCanvas(s);
            return s.destroy(!0), r;
        }
        pixels(t) {
            t = this._normalizeOptions(t);
            const e = t.target, n = this._renderer, s = e instanceof Ot ? e : n.textureGenerator.generateTexture(t), r = n.texture.getPixels(s);
            return e instanceof mn && s.destroy(!0), r;
        }
        texture(t) {
            return t = this._normalizeOptions(t), t.target instanceof Ot ? t.target : this._renderer.textureGenerator.generateTexture(t);
        }
        download(t) {
            t = this._normalizeOptions(t);
            const e = this.canvas(t), n = document.createElement("a");
            n.download = t.filename ?? "image.png", n.href = e.toDataURL("image/png"), document.body.appendChild(n), n.click(), document.body.removeChild(n);
        }
        log(t) {
            const e = t.width ?? 200;
            t = this._normalizeOptions(t);
            const n = this.canvas(t), s = n.toDataURL();
            console.log(`[Pixi Texture] ${n.width}px ${n.height}px`);
            const r = [
                "font-size: 1px;",
                `padding: ${e}px 300px;`,
                `background: url(${s}) no-repeat;`,
                "background-size: contain;"
            ].join(" ");
            console.log("%c ", r);
        }
        destroy() {
            this._renderer = null;
        }
    };
    wh.extension = {
        type: [
            st.WebGLSystem,
            st.WebGPUSystem
        ],
        name: "extract"
    };
    wh.defaultImageOptions = {
        format: "png",
        quality: 1
    };
    let Ww = wh;
    class Rh extends Ot {
        static create(t) {
            return new Rh({
                source: new Ne(t)
            });
        }
        resize(t, e, n) {
            return this.source.resize(t, e, n), this;
        }
    }
    const Xw = new fe, Yw = new en, qw = [
        0,
        0,
        0,
        0
    ];
    class a_ {
        constructor(t){
            this._renderer = t;
        }
        generateTexture(t) {
            t instanceof mn && (t = {
                target: t,
                frame: void 0,
                textureSourceOptions: {},
                resolution: void 0
            });
            const e = t.resolution || this._renderer.resolution, n = t.antialias || this._renderer.view.antialias, s = t.target;
            let r = t.clearColor;
            r ? r = Array.isArray(r) && r.length === 4 ? r : Pe.shared.setValue(r).toArray() : r = qw;
            const a = t.frame?.copyTo(Xw) || ch(s, Yw).rectangle;
            a.width = Math.max(a.width, 1 / e) | 0, a.height = Math.max(a.height, 1 / e) | 0;
            const o = Rh.create({
                ...t.textureSourceOptions,
                width: a.width,
                height: a.height,
                resolution: e,
                antialias: n
            }), c = Ft.shared.translate(-a.x, -a.y);
            return this._renderer.render({
                container: s,
                transform: c,
                target: o,
                clearColor: r
            }), o.source.updateMipmaps(), o;
        }
        destroy() {
            this._renderer = null;
        }
    }
    a_.extension = {
        type: [
            st.WebGLSystem,
            st.WebGPUSystem
        ],
        name: "textureGenerator"
    };
    jw = function(i, t, e) {
        const n = (i >> 24 & 255) / 255;
        t[e++] = (i & 255) / 255 * n, t[e++] = (i >> 8 & 255) / 255 * n, t[e++] = (i >> 16 & 255) / 255 * n, t[e++] = n;
    };
    class o_ {
        constructor(t){
            this._stackIndex = 0, this._globalUniformDataStack = [], this._uniformsPool = [], this._activeUniforms = [], this._bindGroupPool = [], this._activeBindGroups = [], this._renderer = t;
        }
        reset() {
            this._stackIndex = 0;
            for(let t = 0; t < this._activeUniforms.length; t++)this._uniformsPool.push(this._activeUniforms[t]);
            for(let t = 0; t < this._activeBindGroups.length; t++)this._bindGroupPool.push(this._activeBindGroups[t]);
            this._activeUniforms.length = 0, this._activeBindGroups.length = 0;
        }
        start(t) {
            this.reset(), this.push(t);
        }
        bind({ size: t, projectionMatrix: e, worldTransformMatrix: n, worldColor: s, offset: r }) {
            const a = this._renderer.renderTarget.renderTarget, o = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {
                worldTransformMatrix: new Ft,
                worldColor: 4294967295,
                offset: new Ue
            }, c = {
                projectionMatrix: e || this._renderer.renderTarget.projectionMatrix,
                resolution: t || a.size,
                worldTransformMatrix: n || o.worldTransformMatrix,
                worldColor: s || o.worldColor,
                offset: r || o.offset,
                bindGroup: null
            }, l = this._uniformsPool.pop() || this._createUniforms();
            this._activeUniforms.push(l);
            const h = l.uniforms;
            h.uProjectionMatrix = c.projectionMatrix, h.uResolution = c.resolution, h.uWorldTransformMatrix.copyFrom(c.worldTransformMatrix), h.uWorldTransformMatrix.tx -= c.offset.x, h.uWorldTransformMatrix.ty -= c.offset.y, jw(c.worldColor, h.uWorldColorAlpha, 0), l.update();
            let u;
            this._renderer.renderPipes.uniformBatch ? u = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(l, !1) : (u = this._bindGroupPool.pop() || new vr, this._activeBindGroups.push(u), u.setResource(l, 0)), c.bindGroup = u, this._currentGlobalUniformData = c;
        }
        push(t) {
            this.bind(t), this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;
        }
        pop() {
            this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1], this._renderer.type === Yi.WEBGL && this._currentGlobalUniformData.bindGroup.resources[0].update();
        }
        get bindGroup() {
            return this._currentGlobalUniformData.bindGroup;
        }
        get globalUniformData() {
            return this._currentGlobalUniformData;
        }
        get uniformGroup() {
            return this._currentGlobalUniformData.bindGroup.resources[0];
        }
        _createUniforms() {
            return new Ki({
                uProjectionMatrix: {
                    value: new Ft,
                    type: "mat3x3<f32>"
                },
                uWorldTransformMatrix: {
                    value: new Ft,
                    type: "mat3x3<f32>"
                },
                uWorldColorAlpha: {
                    value: new Float32Array(4),
                    type: "vec4<f32>"
                },
                uResolution: {
                    value: [
                        0,
                        0
                    ],
                    type: "vec2<f32>"
                }
            }, {
                isStatic: !0
            });
        }
        destroy() {
            this._renderer = null;
        }
    }
    o_.extension = {
        type: [
            st.WebGLSystem,
            st.WebGPUSystem,
            st.CanvasSystem
        ],
        name: "globalUniforms"
    };
    let $w = 1;
    class c_ {
        constructor(){
            this._tasks = [], this._offset = 0;
        }
        init() {
            Ms.system.add(this._update, this);
        }
        repeat(t, e, n = !0) {
            const s = $w++;
            let r = 0;
            return n && (this._offset += 1e3, r = this._offset), this._tasks.push({
                func: t,
                duration: e,
                start: performance.now(),
                offset: r,
                last: performance.now(),
                repeat: !0,
                id: s
            }), s;
        }
        cancel(t) {
            for(let e = 0; e < this._tasks.length; e++)if (this._tasks[e].id === t) {
                this._tasks.splice(e, 1);
                return;
            }
        }
        _update() {
            const t = performance.now();
            for(let e = 0; e < this._tasks.length; e++){
                const n = this._tasks[e];
                if (t - n.offset - n.last >= n.duration) {
                    const s = t - n.start;
                    n.func(s), n.last = t;
                }
            }
        }
        destroy() {
            Ms.system.remove(this._update, this), this._tasks.length = 0;
        }
    }
    c_.extension = {
        type: [
            st.WebGLSystem,
            st.WebGPUSystem,
            st.CanvasSystem
        ],
        name: "scheduler",
        priority: 0
    };
    let xf = !1;
    function Kw(i) {
        if (!xf) {
            if ($e.get().getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
                const t = [
                    `%c  %c  %c  %c  %c PixiJS %c v${Tl} (${i}) http://www.pixijs.com/

`,
                    "background: #E72264; padding:5px 0;",
                    "background: #6CA2EA; padding:5px 0;",
                    "background: #B5D33D; padding:5px 0;",
                    "background: #FED23F; padding:5px 0;",
                    "color: #FFFFFF; background: #E72264; padding:5px 0;",
                    "color: #E72264; background: #FFFFFF; padding:5px 0;"
                ];
                globalThis.console.log(...t);
            } else globalThis.console && globalThis.console.log(`PixiJS ${Tl} - ${i} - http://www.pixijs.com/`);
            xf = !0;
        }
    }
    class Ch {
        constructor(t){
            this._renderer = t;
        }
        init(t) {
            if (t.hello) {
                let e = this._renderer.name;
                this._renderer.type === Yi.WEBGL && (e += ` ${this._renderer.context.webGLVersion}`), Kw(e);
            }
        }
    }
    Ch.extension = {
        type: [
            st.WebGLSystem,
            st.WebGPUSystem,
            st.CanvasSystem
        ],
        name: "hello",
        priority: -2
    };
    Ch.defaultOptions = {
        hello: !1
    };
    function Zw(i) {
        let t = !1;
        for(const n in i)if (i[n] == null) {
            t = !0;
            break;
        }
        if (!t) return i;
        const e = Object.create(null);
        for(const n in i){
            const s = i[n];
            s && (e[n] = s);
        }
        return e;
    }
    function Jw(i) {
        let t = 0;
        for(let e = 0; e < i.length; e++)i[e] == null ? t++ : i[e - t] = i[e];
        return i.length -= t, i;
    }
    let Qw = 0;
    const Ph = class l_ {
        constructor(t){
            this._managedRenderables = [], this._managedHashes = [], this._managedArrays = [], this._renderer = t;
        }
        init(t) {
            t = {
                ...l_.defaultOptions,
                ...t
            }, this.maxUnusedTime = t.renderableGCMaxUnusedTime, this._frequency = t.renderableGCFrequency, this.enabled = t.renderableGCActive;
        }
        get enabled() {
            return !!this._handler;
        }
        set enabled(t) {
            this.enabled !== t && (t ? (this._handler = this._renderer.scheduler.repeat(()=>this.run(), this._frequency, !1), this._hashHandler = this._renderer.scheduler.repeat(()=>{
                for (const e of this._managedHashes)e.context[e.hash] = Zw(e.context[e.hash]);
            }, this._frequency), this._arrayHandler = this._renderer.scheduler.repeat(()=>{
                for (const e of this._managedArrays)Jw(e.context[e.hash]);
            }, this._frequency)) : (this._renderer.scheduler.cancel(this._handler), this._renderer.scheduler.cancel(this._hashHandler), this._renderer.scheduler.cancel(this._arrayHandler)));
        }
        addManagedHash(t, e) {
            this._managedHashes.push({
                context: t,
                hash: e
            });
        }
        addManagedArray(t, e) {
            this._managedArrays.push({
                context: t,
                hash: e
            });
        }
        prerender({ container: t }) {
            this._now = performance.now(), t.renderGroup.gcTick = Qw++, this._updateInstructionGCTick(t.renderGroup, t.renderGroup.gcTick);
        }
        addRenderable(t) {
            this.enabled && (t._lastUsed === -1 && (this._managedRenderables.push(t), t.once("destroyed", this._removeRenderable, this)), t._lastUsed = this._now);
        }
        run() {
            const t = this._now, e = this._managedRenderables, n = this._renderer.renderPipes;
            let s = 0;
            for(let r = 0; r < e.length; r++){
                const a = e[r];
                if (a === null) {
                    s++;
                    continue;
                }
                const o = a.renderGroup ?? a.parentRenderGroup, c = o?.instructionSet?.gcTick ?? -1;
                if ((o?.gcTick ?? 0) === c && (a._lastUsed = t), t - a._lastUsed > this.maxUnusedTime) {
                    if (!a.destroyed) {
                        const l = n;
                        o && (o.structureDidChange = !0), l[a.renderPipeId].destroyRenderable(a);
                    }
                    a._lastUsed = -1, s++, a.off("destroyed", this._removeRenderable, this);
                } else e[r - s] = a;
            }
            e.length -= s;
        }
        destroy() {
            this.enabled = !1, this._renderer = null, this._managedRenderables.length = 0, this._managedHashes.length = 0, this._managedArrays.length = 0;
        }
        _removeRenderable(t) {
            const e = this._managedRenderables.indexOf(t);
            e >= 0 && (t.off("destroyed", this._removeRenderable, this), this._managedRenderables[e] = null);
        }
        _updateInstructionGCTick(t, e) {
            t.instructionSet.gcTick = e;
            for (const n of t.renderGroupChildren)this._updateInstructionGCTick(n, e);
        }
    };
    Ph.extension = {
        type: [
            st.WebGLSystem,
            st.WebGPUSystem
        ],
        name: "renderableGC",
        priority: 0
    };
    Ph.defaultOptions = {
        renderableGCActive: !0,
        renderableGCMaxUnusedTime: 6e4,
        renderableGCFrequency: 3e4
    };
    let t1 = Ph;
    const Ih = class h_ {
        constructor(t){
            this._renderer = t, this.count = 0, this.checkCount = 0;
        }
        init(t) {
            t = {
                ...h_.defaultOptions,
                ...t
            }, this.checkCountMax = t.textureGCCheckCountMax, this.maxIdle = t.textureGCAMaxIdle ?? t.textureGCMaxIdle, this.active = t.textureGCActive;
        }
        postrender() {
            this._renderer.renderingToScreen && (this.count++, this.active && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())));
        }
        run() {
            const t = this._renderer.texture.managedTextures;
            for(let e = 0; e < t.length; e++){
                const n = t[e];
                n.autoGarbageCollect && n.resource && n._touched > -1 && this.count - n._touched > this.maxIdle && (n._touched = -1, n.unload());
            }
        }
        destroy() {
            this._renderer = null;
        }
    };
    Ih.extension = {
        type: [
            st.WebGLSystem,
            st.WebGPUSystem
        ],
        name: "textureGC"
    };
    Ih.defaultOptions = {
        textureGCActive: !0,
        textureGCAMaxIdle: null,
        textureGCMaxIdle: 60 * 60,
        textureGCCheckCountMax: 600
    };
    let e1 = Ih;
    const Dh = class u_ {
        get autoDensity() {
            return this.texture.source.autoDensity;
        }
        set autoDensity(t) {
            this.texture.source.autoDensity = t;
        }
        get resolution() {
            return this.texture.source._resolution;
        }
        set resolution(t) {
            this.texture.source.resize(this.texture.source.width, this.texture.source.height, t);
        }
        init(t) {
            t = {
                ...u_.defaultOptions,
                ...t
            }, t.view && (ue(be, "ViewSystem.view has been renamed to ViewSystem.canvas"), t.canvas = t.view), this.screen = new fe(0, 0, t.width, t.height), this.canvas = t.canvas || $e.get().createCanvas(), this.antialias = !!t.antialias, this.texture = Bm(this.canvas, t), this.renderTarget = new Dl({
                colorTextures: [
                    this.texture
                ],
                depth: !!t.depth,
                isRoot: !0
            }), this.texture.source.transparent = t.backgroundAlpha < 1, this.resolution = t.resolution;
        }
        resize(t, e, n) {
            this.texture.source.resize(t, e, n), this.screen.width = this.texture.frame.width, this.screen.height = this.texture.frame.height;
        }
        destroy(t = !1) {
            (typeof t == "boolean" ? t : !!t?.removeView) && this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);
        }
    };
    Dh.extension = {
        type: [
            st.WebGLSystem,
            st.WebGPUSystem,
            st.CanvasSystem
        ],
        name: "view",
        priority: 0
    };
    Dh.defaultOptions = {
        width: 800,
        height: 600,
        autoDensity: !1,
        antialias: !1
    };
    let n1 = Dh;
    const i1 = [
        Vw,
        o_,
        Ch,
        n1,
        e_,
        e1,
        a_,
        Ww,
        $p,
        t1,
        c_
    ], s1 = [
        s_,
        ym,
        n_,
        Jm,
        Sm,
        Tm,
        Mm,
        Km
    ], r1 = [
        ...i1,
        Nm,
        KA,
        WA,
        Em,
        qm,
        km,
        Rm,
        Wm,
        Vm,
        Im,
        Aw,
        Dm,
        Pm
    ], a1 = [
        ...s1
    ], o1 = [
        xm,
        $m,
        jm
    ], d_ = [], f_ = [], p_ = [];
    Be.handleByNamedList(st.WebGLSystem, d_);
    Be.handleByNamedList(st.WebGLPipes, f_);
    Be.handleByNamedList(st.WebGLPipesAdaptor, p_);
    Be.add(...r1, ...a1, ...o1);
    class c1 extends VT {
        constructor(){
            const t = {
                name: "webgl",
                type: Yi.WEBGL,
                systems: d_,
                renderPipes: f_,
                renderPipeAdaptors: p_
            };
            super(t);
        }
    }
    Be.add(_M, gM);
    class Xe {
        static _instance = new Xe;
        _width;
        _height;
        _threeRenderer;
        _pixiRenderer;
        _camera3D;
        static get instance() {
            return this._instance;
        }
        get width() {
            return this._width;
        }
        get height() {
            return this._height;
        }
        get camera3D() {
            return this._camera3D;
        }
        constructor(){
            const t = document.getElementById("main");
            if (!t) throw new Error("Canvas element not found");
            this._width = window.innerWidth, this._height = window.innerHeight, this._threeRenderer = new LS({
                canvas: t,
                antialias: !0,
                stencil: !0
            }), this._pixiRenderer = new c1, this._camera3D = new We(60, this._width / this._height, .1, 1e3);
        }
        async init() {
            this._threeRenderer.setSize(this._width, this._height), this._threeRenderer.setClearColor(14540253, 1), this._threeRenderer.shadowMap.enabled = !0, await this._pixiRenderer.init({
                canvas: this._threeRenderer.domElement,
                context: this._threeRenderer.getContext(),
                width: this._width,
                height: this._height,
                clearBeforeRender: !1
            });
        }
        render(t) {
            this._threeRenderer.resetState(), this._threeRenderer.render(t.scene3D, this._camera3D), this._pixiRenderer.resetState(), this._pixiRenderer.render(t.container2D);
        }
        resize(t, e) {
            this._width = t, this._height = e, this._threeRenderer.setSize(this._width, this._height), this._pixiRenderer.resize(this._width, this._height), this._camera3D.aspect = this._width / this._height, this._camera3D.updateProjectionMatrix();
        }
    }
    class m_ {
        _model;
        _animationMixer;
        _animationIndex = 0;
        _animationLoopStyle = il;
        _collider;
        _moveX = 0;
        _moveY = 0;
        _moveSpeed = 2;
        static animationNames = [
            "Attack",
            "Brag",
            "Defend",
            "Hit",
            "Idle"
        ];
        constructor(){
            this._model = Xi.instance.getModel("ninja");
            const t = Xi.instance.getTexture("ninja");
            this._model.scene.traverse((e)=>{
                e instanceof Le && (e.material.map = t, e.material.needsUpdate = !0, e.material.side = dn, e.material.castShadow = !0, e.material.receiveShadow = !0);
            }), this._animationMixer = new Kx(this._model.scene), this._animationIndex = this._model.animations.length - 1, this._collider = new Cn;
        }
        get model() {
            return this._model;
        }
        get collider() {
            return this._collider;
        }
        get animationMixer() {
            return this._animationMixer;
        }
        setAnimation(t, e = il) {
            t >= 0 && t < this._model.animations.length && (this._animationIndex = t, this._animationLoopStyle = e, this._animationMixer.stopAllAction(), this._animationMixer.clipAction(this._model.animations[this._animationIndex]).play().setLoop(this._animationLoopStyle, 1 / 0));
        }
        moveLeft() {
            this._moveX = -this._moveSpeed, this._model.scene.rotation.y = Math.PI * 1.5;
        }
        moveRight() {
            this._moveX = this._moveSpeed, this._model.scene.rotation.y = Math.PI * .5;
        }
        moveUp() {
            this._moveY = this._moveSpeed, this._model.scene.rotation.y = Math.PI;
        }
        moveDown() {
            this._moveY = -this._moveSpeed, this._model.scene.rotation.y = 0;
        }
        stopMovement() {
            this._moveX = 0, this._moveY = 0;
        }
        checkCollisions(t) {
            const e = this._model.scene.position.z;
            this._model.scene.position.z = 0, this._collider.setFromObject(this._model.scene), this._collider.expandByScalar(this._collider.getSize(new k).length() * .05);
            let n = !1;
            return t.forEach((s)=>{
                new Cn().setFromObject(s).intersectsBox(this._collider) && (n = !0);
            }), this._model.scene.position.z = e, n;
        }
        update(t) {
            (this._moveX != 0 || this._moveY != 0) && (this._model.scene.position.x += this._moveX * t, this._model.scene.position.y += this._moveY * t, Xe.instance.camera3D.position.x = this._model.scene.position.x, Xe.instance.camera3D.position.y = this._model.scene.position.y);
        }
    }
    class __ {
        _scene3D = new rx;
        _container2D = new mn;
        get scene3D() {
            return this._scene3D;
        }
        get container2D() {
            return this._container2D;
        }
        load() {}
        unload() {
            this.scene3D.clear(), this.container2D.removeChildren();
        }
        update(t) {}
        resize(t, e) {}
    }
    class Sn {
        static _instance = new Sn;
        _scenes = new Map;
        _currentScene = null;
        constructor(){}
        static get instance() {
            return this._instance;
        }
        addScene(t, e) {
            this._scenes.set(t, e);
        }
        getScene(t) {
            return this._scenes.get(t);
        }
        switchToScene(t) {
            const e = this._scenes.get(t);
            if (!e) throw new Error(`Scene ${t} not found`);
            this._currentScene && this._currentScene.unload(), this._currentScene = e, this._currentScene.load();
        }
        get currentScene() {
            if (!this._currentScene) throw new Error("No current scene set");
            return this._currentScene;
        }
    }
    class l1 extends __ {
        _width;
        _height;
        _player;
        constructor(){
            super(), this._width = Xe.instance.width, this._height = Xe.instance.height, this._player = new m_;
        }
        get player() {
            return this._player;
        }
        async load() {
            super.load(), await this.load3D(), await this.load2D();
        }
        async load3D() {
            const t = this._player.model.scene;
            t.position.set(0, 0, 0), t.scale.set(1, 1, 1), this._player.setAnimation(this._player.model.animations.length - 1);
            const e = new zs(4, 4), n = new Us({
                color: 5795445,
                side: dn,
                emissive: 5795445
            }), s = new Le(e, n);
            s.rotation.x = Math.PI * .5, s.position.y = t.position.y, s.receiveShadow = !0;
            const r = Xe.instance.camera3D;
            r.position.x = t.position.x, r.position.y = t.position.y + 1, r.position.z = 4.5;
            const a = new Ql(16777215, 1);
            a.position.set(1, 3, 1), a.castShadow = !0, this.scene3D.add(t, s), this.scene3D.add(new Qf, a);
        }
        async load2D() {
            const t = this._width * .5, e = this._height * .1, n = (this._width - t) * .5, s = 10, r = 10, a = "DarkOrange", o = new ni().roundRect(n, r, t, e, s).fill(a);
            this.container2D.addChild(o);
            const c = "MediumBlue", l = new Sr({
                text: "Animations",
                style: {
                    fontFamily: "Arial",
                    fontSize: o.height * .25,
                    fill: c
                }
            });
            l.x = n + (t - l.width) * .5, l.y = (r + o.height * .5 - l.height) * .5, this.container2D.addChild(l);
            const h = 15657173, u = 11897088, d = 5, f = o.width / d;
            let _ = n + f * .5;
            for(let m = 0; m < d; m++){
                const x = new ni().circle(_, o.height * .75, o.height * .2).fill("Gold");
                x.interactive = !0, x.eventMode = "static", x.on("pointerdown", ()=>{
                    x.tint = u, console.log("Button clicked!", m), this._player.setAnimation(m);
                }), x.on("pointerup", ()=>{
                    x.tint = h;
                }), x.on("pointerover", ()=>{
                    x.tint = h;
                }), x.on("pointerout", ()=>{
                    x.tint = 16777215;
                }), this.container2D.addChild(x);
                const y = new Sr({
                    text: `${m + 1}`,
                    style: {
                        fontFamily: "Arial",
                        fontSize: x.height * .5,
                        fill: c
                    }
                });
                y.x = _ - y.width * .5, y.y = o.height * .75 - y.height * .5, this.container2D.addChild(y), _ += f;
            }
            const g = new ni().ellipse(0, 0, o.width * .25, o.height * .5).fill(a);
            g.alpha = .5, g.x = n + o.width * .5, g.y = o.y + o.height + r * 2 + g.height * .5, this.container2D.addChild(g);
            const p = new Sr({
                text: "Play Maze",
                style: {
                    fontFamily: "Arial",
                    fontSize: o.height * .25,
                    fill: c,
                    align: "center"
                }
            });
            p.x = l.x, p.y = g.y - p.height * .5, this.container2D.addChild(p), g.interactive = !0, g.eventMode = "static", g.on("pointerdown", ()=>{
                g.tint = u, console.log("Play Maze"), Sn.instance.switchToScene("maze");
            }), g.on("pointerup", ()=>{
                g.tint = h;
            }), g.on("pointerover", ()=>{
                g.tint = h;
            }), g.on("pointerout", ()=>{
                g.tint = 16777215;
            });
        }
        update(t) {
            this._player.model.scene.rotation.y += t * .5, this._player.animationMixer.update(t), this._player.update(t);
        }
        resize(t, e) {
            this._width = t, this._height = e, this.container2D.width = this._width * .5;
        }
    }
    class h1 extends __ {
        _player;
        _walls = [];
        _width;
        _height;
        _exitX = 0;
        _exitY = 0;
        _levelCompleted = !1;
        _nextButton = new mn;
        constructor(){
            super(), this._width = Xe.instance.width, this._height = Xe.instance.height, this._player = new m_;
        }
        async load() {
            this._levelCompleted = !1, await this.load2D(), await this.load3D();
        }
        async load3D() {
            const t = this._player.model.scene;
            t.position.set(1, 1, .7), t.scale.set(.45, .45, .45), t.rotation.y = 0, this._player.collider.setFromObject(t);
            const e = this._player.collider.getCenter(new k);
            t.position.x = e.x, t.position.y = e.y, this._player.setAnimation(this._player.model.animations.length - 1);
            const n = new Ql(16777215, 1);
            n.position.set(1, 3, 1), this.scene3D.add(t, new Qf, n), this.addTiles3D(), Xe.instance.camera3D.position.set(t.position.x, t.position.y, 10);
        }
        addTiles3D() {
            const t = [
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    1,
                    0,
                    1,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    1,
                    0,
                    1,
                    1,
                    0,
                    1,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    0,
                    1,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    0
                ],
                [
                    1,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    0,
                    1,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    0
                ],
                [
                    1,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    1,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    1,
                    0,
                    0,
                    0,
                    1,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ]
            ];
            this._exitX = 16, this._exitY = 5;
            const e = new zs(1, 1), n = new Us({
                map: Xi.instance.getTexture("ground")
            }), s = new Hs(1, 1, 1), r = new Us({
                map: Xi.instance.getTexture("wall")
            }), a = new Le(s, r), o = new Le(e, n);
            for(let c = 0; c < t.length; c++)for(let l = 0; l < t[c].length; l++){
                const h = l, u = t.length - 1 - c;
                if (t[c][l] == 1) {
                    const d = a.clone();
                    d.position.set(h, u, 0), this._walls.push(d), this.scene3D.add(d);
                } else o.position.set(h, u, 0), this.scene3D.add(o.clone());
            }
        }
        async load2D() {
            const t = "DarkOrange", e = new ni().rect(0, 0, this._width, Math.min(30, this._height * .1)).fill(t);
            e.interactive = !0, e.eventMode = "static", e.on("pointerdown", ()=>{
                console.log("Box clicked");
            });
            const n = Xe.instance.width, s = Xe.instance.height, r = new ni().rect(0, 0, n, s).fill(t);
            r.alpha = 0, r.interactive = !0, r.eventMode = "static", r.on("pointerdown", (g)=>{
                const p = g.global.x - n * .5, m = g.global.y - s * .5;
                Math.abs(p) >= Math.abs(m) ? p > 0 ? this._player.moveRight() : this._player.moveLeft() : m > 0 ? this._player.moveDown() : this._player.moveUp();
            }), r.on("pointerup", ()=>{
                this._player.stopMovement();
            });
            const a = new Sr({
                text: "Ninja Maze Game",
                style: {
                    fontFamily: "Arial",
                    fontSize: e.height * .5,
                    fill: "MediumBlue"
                }
            });
            a.x = (this._width - a.width) * .5, a.y = e.y + e.height * .5 - a.height * .5, this.container2D.addChild(r, e, a);
            const o = this._width * .25, c = this._height * .1, l = (this._width - o) * .5, h = (this._height * .25 - c) * .5, u = new ni().roundRect(l, h, o, c, 10).fill("DarkOrange"), d = 15657173, f = 11897088;
            u.interactive = !0, u.eventMode = "static", u.on("pointerdown", ()=>{
                u.tint = f, console.log("Button clicked"), Sn.instance.switchToScene("intro");
            }), u.on("pointerup", ()=>{
                u.tint = d;
            }), u.on("pointerover", ()=>{
                u.tint = d;
            }), u.on("pointerout", ()=>{
                u.tint = 16777215;
            });
            const _ = new Sr({
                text: "Go Back",
                style: {
                    fontFamily: "Arial",
                    fontSize: c * .5,
                    fill: "MediumBlue"
                }
            });
            _.x = (this._width - _.width) * .5, _.y = h + (u.height - _.height) * .5, this._nextButton.addChild(u, _), this._nextButton.visible = !1, this.container2D.addChild(this._nextButton);
        }
        update(t) {
            if (this._player.animationMixer.update(t), this._levelCompleted) return;
            const e = this._player.model.scene.position.clone();
            if (this._player.update(t), this._player.checkCollisions(this._walls)) {
                this._player.model.scene.position.copy(e);
                return;
            }
            Math.abs(this._player.model.scene.position.x - this._exitX) < .1 && Math.abs(this._player.model.scene.position.y - this._exitY) < .5 && (console.log("Exit reached"), this._levelCompleted = !0, this._player.setAnimation(1), this._nextButton.visible = !0);
        }
        resize(t, e) {
            this._width = t, this._height = e, this.container2D.width = this._width * .5;
        }
    }
    (async ()=>{
        await Xe.instance.init(), await Xi.instance.loadAsync(), Sn.instance.addScene("intro", new l1), Sn.instance.addScene("maze", new h1), Sn.instance.switchToScene("intro"), Sn.instance.currentScene.load();
        const i = new Fx;
        function t() {
            Sn.instance.currentScene.update(i.getDelta()), Xe.instance.render(Sn.instance.currentScene), requestAnimationFrame(t);
        }
        t();
        function e(n, s) {
            Xe.instance.resize(n, s), Sn.instance.currentScene.resize(n, s);
        }
        window.addEventListener("resize", ()=>{
            e(window.innerWidth, window.innerHeight);
        });
    })();
})();
export { im as $, Zi as A, vr as B, mn as C, $e as D, st as E, fh as F, tm as G, Br as H, Xa as I, qs as J, RM as K, AE as L, Ft as M, _c as N, DE as O, Ue as P, gh as Q, fe as R, Fr as S, Ms as T, xl as U, Bd as V, bm as W, xh as X, Ja as Y, wE as Z, PE as _, In as a, sm as a0, rm as a1, ni as a2, CM as a3, Zm as a4, dm as a5, Ot as b, Pe as c, ue as d, Be as e, qi as f, LA as g, UA as h, Pl as i, xs as j, Ki as k, ws as l, Yi as m, hd as n, en as o, ji as p, Se as q, zM as r, RA as s, jw as t, Ge as u, be as v, _e as w, lm as x, Od as y, Dr as z, __tla };
