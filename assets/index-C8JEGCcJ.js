const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./browserAll-naxp-0GG.js","./webworkerAll-Dv38b-0_.js"])))=>i.map(i=>d[i]);
let rm, Ki, gr, wn, jt, se, ph, nm, Br, Ya, Ws, PM, RE, Fe, vc, UE, Lt, xh, ft, Fr, Ss, yl, Od, Mm, vh, eo, CE, DE, Cn, am, om, ja, IM, Qm, pm, Oe, Pt, ut, Nt, Yi, NA, BA, Dl, gs, $i, As, Xi, dd, en, qi, St, WM, PA, Kw, Gt, bt, _t, um, Gd, Pr;
let __tla = (async ()=>{
    (function() {
        const e = document.createElement("link").relList;
        if (e && e.supports && e.supports("modulepreload")) return;
        for (const s of document.querySelectorAll('link[rel="modulepreload"]'))n(s);
        new MutationObserver((s)=>{
            for (const r of s)if (r.type === "childList") for (const a of r.addedNodes)a.tagName === "LINK" && a.rel === "modulepreload" && n(a);
        }).observe(document, {
            childList: !0,
            subtree: !0
        });
        function t(s) {
            const r = {};
            return s.integrity && (r.integrity = s.integrity), s.referrerPolicy && (r.referrerPolicy = s.referrerPolicy), s.crossOrigin === "use-credentials" ? r.credentials = "include" : s.crossOrigin === "anonymous" ? r.credentials = "omit" : r.credentials = "same-origin", r;
        }
        function n(s) {
            if (s.ep) return;
            s.ep = !0;
            const r = t(s);
            fetch(s.href, r);
        }
    })();
    const Ol = "175", T_ = 0, zh = 1, E_ = 2, bf = 1, A_ = 2, jn = 3, ti = 0, Jt = 1, Un = 2, pi = 0, Ms = 1, Vh = 2, Wh = 3, Xh = 4, w_ = 5, Ni = 100, R_ = 101, C_ = 102, P_ = 103, I_ = 104, D_ = 200, L_ = 201, U_ = 202, N_ = 203, Mc = 204, Tc = 205, B_ = 206, F_ = 207, O_ = 208, k_ = 209, G_ = 210, H_ = 211, z_ = 212, V_ = 213, W_ = 214, Ec = 0, Ac = 1, wc = 2, ws = 3, Rc = 4, Cc = 5, Pc = 6, Ic = 7, Sf = 0, X_ = 1, Y_ = 2, mi = 0, q_ = 1, j_ = 2, $_ = 3, K_ = 4, Z_ = 5, J_ = 6, Q_ = 7, Yh = "attached", eg = "detached", Mf = 300, Rs = 301, Cs = 302, Dc = 303, Lc = 304, $a = 306, Ps = 1e3, ui = 1001, Fa = 1002, Yt = 1003, Tf = 1004, ar = 1005, an = 1006, Ta = 1007, Kn = 1008, ni = 1009, Ef = 1010, Af = 1011, br = 1012, kl = 1013, zi = 1014, Mn = 1015, Lr = 1016, Gl = 1017, Hl = 1018, Sr = 1020, wf = 35902, Rf = 1021, Cf = 1022, un = 1023, Pf = 1024, If = 1025, Mr = 1026, Tr = 1027, zl = 1028, Vl = 1029, Df = 1030, Wl = 1031, Xl = 1033, Ea = 33776, Aa = 33777, wa = 33778, Ra = 33779, Uc = 35840, Nc = 35841, Bc = 35842, Fc = 35843, Oc = 36196, kc = 37492, Gc = 37496, Hc = 37808, zc = 37809, Vc = 37810, Wc = 37811, Xc = 37812, Yc = 37813, qc = 37814, jc = 37815, $c = 37816, Kc = 37817, Zc = 37818, Jc = 37819, Qc = 37820, el = 37821, Ca = 36492, tl = 36494, nl = 36495, Lf = 36283, il = 36284, sl = 36285, rl = 36286, or = 2200, Pa = 2201, tg = 2202, Er = 2300, Ar = 2301, so = 2302, vs = 2400, ys = 2401, Oa = 2402, Yl = 2500, ng = 2501, ig = 0, Uf = 1, al = 2, sg = 3200, rg = 3201, Nf = 0, ag = 1, hi = "", Dt = "srgb", $t = "srgb-linear", ka = "linear", ct = "srgb", Qi = 7680, qh = 519, og = 512, cg = 513, lg = 514, Bf = 515, hg = 516, ug = 517, dg = 518, fg = 519, ol = 35044, jh = "300 es", Zn = 2e3, Ga = 2001;
    class ji {
        addEventListener(e, t) {
            this._listeners === void 0 && (this._listeners = {});
            const n = this._listeners;
            n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
        }
        hasEventListener(e, t) {
            const n = this._listeners;
            return n === void 0 ? !1 : n[e] !== void 0 && n[e].indexOf(t) !== -1;
        }
        removeEventListener(e, t) {
            const n = this._listeners;
            if (n === void 0) return;
            const s = n[e];
            if (s !== void 0) {
                const r = s.indexOf(t);
                r !== -1 && s.splice(r, 1);
            }
        }
        dispatchEvent(e) {
            const t = this._listeners;
            if (t === void 0) return;
            const n = t[e.type];
            if (n !== void 0) {
                e.target = this;
                const s = n.slice(0);
                for(let r = 0, a = s.length; r < a; r++)s[r].call(this, e);
                e.target = null;
            }
        }
    }
    const Ft = [
        "00",
        "01",
        "02",
        "03",
        "04",
        "05",
        "06",
        "07",
        "08",
        "09",
        "0a",
        "0b",
        "0c",
        "0d",
        "0e",
        "0f",
        "10",
        "11",
        "12",
        "13",
        "14",
        "15",
        "16",
        "17",
        "18",
        "19",
        "1a",
        "1b",
        "1c",
        "1d",
        "1e",
        "1f",
        "20",
        "21",
        "22",
        "23",
        "24",
        "25",
        "26",
        "27",
        "28",
        "29",
        "2a",
        "2b",
        "2c",
        "2d",
        "2e",
        "2f",
        "30",
        "31",
        "32",
        "33",
        "34",
        "35",
        "36",
        "37",
        "38",
        "39",
        "3a",
        "3b",
        "3c",
        "3d",
        "3e",
        "3f",
        "40",
        "41",
        "42",
        "43",
        "44",
        "45",
        "46",
        "47",
        "48",
        "49",
        "4a",
        "4b",
        "4c",
        "4d",
        "4e",
        "4f",
        "50",
        "51",
        "52",
        "53",
        "54",
        "55",
        "56",
        "57",
        "58",
        "59",
        "5a",
        "5b",
        "5c",
        "5d",
        "5e",
        "5f",
        "60",
        "61",
        "62",
        "63",
        "64",
        "65",
        "66",
        "67",
        "68",
        "69",
        "6a",
        "6b",
        "6c",
        "6d",
        "6e",
        "6f",
        "70",
        "71",
        "72",
        "73",
        "74",
        "75",
        "76",
        "77",
        "78",
        "79",
        "7a",
        "7b",
        "7c",
        "7d",
        "7e",
        "7f",
        "80",
        "81",
        "82",
        "83",
        "84",
        "85",
        "86",
        "87",
        "88",
        "89",
        "8a",
        "8b",
        "8c",
        "8d",
        "8e",
        "8f",
        "90",
        "91",
        "92",
        "93",
        "94",
        "95",
        "96",
        "97",
        "98",
        "99",
        "9a",
        "9b",
        "9c",
        "9d",
        "9e",
        "9f",
        "a0",
        "a1",
        "a2",
        "a3",
        "a4",
        "a5",
        "a6",
        "a7",
        "a8",
        "a9",
        "aa",
        "ab",
        "ac",
        "ad",
        "ae",
        "af",
        "b0",
        "b1",
        "b2",
        "b3",
        "b4",
        "b5",
        "b6",
        "b7",
        "b8",
        "b9",
        "ba",
        "bb",
        "bc",
        "bd",
        "be",
        "bf",
        "c0",
        "c1",
        "c2",
        "c3",
        "c4",
        "c5",
        "c6",
        "c7",
        "c8",
        "c9",
        "ca",
        "cb",
        "cc",
        "cd",
        "ce",
        "cf",
        "d0",
        "d1",
        "d2",
        "d3",
        "d4",
        "d5",
        "d6",
        "d7",
        "d8",
        "d9",
        "da",
        "db",
        "dc",
        "dd",
        "de",
        "df",
        "e0",
        "e1",
        "e2",
        "e3",
        "e4",
        "e5",
        "e6",
        "e7",
        "e8",
        "e9",
        "ea",
        "eb",
        "ec",
        "ed",
        "ee",
        "ef",
        "f0",
        "f1",
        "f2",
        "f3",
        "f4",
        "f5",
        "f6",
        "f7",
        "f8",
        "f9",
        "fa",
        "fb",
        "fc",
        "fd",
        "fe",
        "ff"
    ];
    let $h = 1234567;
    const dr = Math.PI / 180, Is = 180 / Math.PI;
    function Tn() {
        const i = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0;
        return (Ft[i & 255] + Ft[i >> 8 & 255] + Ft[i >> 16 & 255] + Ft[i >> 24 & 255] + "-" + Ft[e & 255] + Ft[e >> 8 & 255] + "-" + Ft[e >> 16 & 15 | 64] + Ft[e >> 24 & 255] + "-" + Ft[t & 63 | 128] + Ft[t >> 8 & 255] + "-" + Ft[t >> 16 & 255] + Ft[t >> 24 & 255] + Ft[n & 255] + Ft[n >> 8 & 255] + Ft[n >> 16 & 255] + Ft[n >> 24 & 255]).toLowerCase();
    }
    function Ye(i, e, t) {
        return Math.max(e, Math.min(t, i));
    }
    function ql(i, e) {
        return (i % e + e) % e;
    }
    function pg(i, e, t, n, s) {
        return n + (i - e) * (s - n) / (t - e);
    }
    function mg(i, e, t) {
        return i !== e ? (t - i) / (e - i) : 0;
    }
    function fr(i, e, t) {
        return (1 - t) * i + t * e;
    }
    function _g(i, e, t, n) {
        return fr(i, e, 1 - Math.exp(-t * n));
    }
    function gg(i, e = 1) {
        return e - Math.abs(ql(i, e * 2) - e);
    }
    function xg(i, e, t) {
        return i <= e ? 0 : i >= t ? 1 : (i = (i - e) / (t - e), i * i * (3 - 2 * i));
    }
    function vg(i, e, t) {
        return i <= e ? 0 : i >= t ? 1 : (i = (i - e) / (t - e), i * i * i * (i * (i * 6 - 15) + 10));
    }
    function yg(i, e) {
        return i + Math.floor(Math.random() * (e - i + 1));
    }
    function bg(i, e) {
        return i + Math.random() * (e - i);
    }
    function Sg(i) {
        return i * (.5 - Math.random());
    }
    function Mg(i) {
        i !== void 0 && ($h = i);
        let e = $h += 1831565813;
        return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
    }
    function Tg(i) {
        return i * dr;
    }
    function Eg(i) {
        return i * Is;
    }
    function Ag(i) {
        return (i & i - 1) === 0 && i !== 0;
    }
    function wg(i) {
        return Math.pow(2, Math.ceil(Math.log(i) / Math.LN2));
    }
    function Rg(i) {
        return Math.pow(2, Math.floor(Math.log(i) / Math.LN2));
    }
    function Cg(i, e, t, n, s) {
        const r = Math.cos, a = Math.sin, o = r(t / 2), c = a(t / 2), l = r((e + n) / 2), h = a((e + n) / 2), u = r((e - n) / 2), d = a((e - n) / 2), f = r((n - e) / 2), _ = a((n - e) / 2);
        switch(s){
            case "XYX":
                i.set(o * h, c * u, c * d, o * l);
                break;
            case "YZY":
                i.set(c * d, o * h, c * u, o * l);
                break;
            case "ZXZ":
                i.set(c * u, c * d, o * h, o * l);
                break;
            case "XZX":
                i.set(o * h, c * _, c * f, o * l);
                break;
            case "YXY":
                i.set(c * f, o * h, c * _, o * l);
                break;
            case "ZYZ":
                i.set(c * _, c * f, o * h, o * l);
                break;
            default:
                console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + s);
        }
    }
    function bn(i, e) {
        switch(e.constructor){
            case Float32Array:
                return i;
            case Uint32Array:
                return i / 4294967295;
            case Uint16Array:
                return i / 65535;
            case Uint8Array:
                return i / 255;
            case Int32Array:
                return Math.max(i / 2147483647, -1);
            case Int16Array:
                return Math.max(i / 32767, -1);
            case Int8Array:
                return Math.max(i / 127, -1);
            default:
                throw new Error("Invalid component type.");
        }
    }
    function ot(i, e) {
        switch(e.constructor){
            case Float32Array:
                return i;
            case Uint32Array:
                return Math.round(i * 4294967295);
            case Uint16Array:
                return Math.round(i * 65535);
            case Uint8Array:
                return Math.round(i * 255);
            case Int32Array:
                return Math.round(i * 2147483647);
            case Int16Array:
                return Math.round(i * 32767);
            case Int8Array:
                return Math.round(i * 127);
            default:
                throw new Error("Invalid component type.");
        }
    }
    const Pg = {
        DEG2RAD: dr,
        RAD2DEG: Is,
        generateUUID: Tn,
        clamp: Ye,
        euclideanModulo: ql,
        mapLinear: pg,
        inverseLerp: mg,
        lerp: fr,
        damp: _g,
        pingpong: gg,
        smoothstep: xg,
        smootherstep: vg,
        randInt: yg,
        randFloat: bg,
        randFloatSpread: Sg,
        seededRandom: Mg,
        degToRad: Tg,
        radToDeg: Eg,
        isPowerOfTwo: Ag,
        ceilPowerOfTwo: wg,
        floorPowerOfTwo: Rg,
        setQuaternionFromProperEuler: Cg,
        normalize: ot,
        denormalize: bn
    };
    class Ke {
        constructor(e = 0, t = 0){
            Ke.prototype.isVector2 = !0, this.x = e, this.y = t;
        }
        get width() {
            return this.x;
        }
        set width(e) {
            this.x = e;
        }
        get height() {
            return this.y;
        }
        set height(e) {
            this.y = e;
        }
        set(e, t) {
            return this.x = e, this.y = t, this;
        }
        setScalar(e) {
            return this.x = e, this.y = e, this;
        }
        setX(e) {
            return this.x = e, this;
        }
        setY(e) {
            return this.y = e, this;
        }
        setComponent(e, t) {
            switch(e){
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e);
            }
            return this;
        }
        getComponent(e) {
            switch(e){
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error("index is out of range: " + e);
            }
        }
        clone() {
            return new this.constructor(this.x, this.y);
        }
        copy(e) {
            return this.x = e.x, this.y = e.y, this;
        }
        add(e) {
            return this.x += e.x, this.y += e.y, this;
        }
        addScalar(e) {
            return this.x += e, this.y += e, this;
        }
        addVectors(e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this;
        }
        addScaledVector(e, t) {
            return this.x += e.x * t, this.y += e.y * t, this;
        }
        sub(e) {
            return this.x -= e.x, this.y -= e.y, this;
        }
        subScalar(e) {
            return this.x -= e, this.y -= e, this;
        }
        subVectors(e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this;
        }
        multiply(e) {
            return this.x *= e.x, this.y *= e.y, this;
        }
        multiplyScalar(e) {
            return this.x *= e, this.y *= e, this;
        }
        divide(e) {
            return this.x /= e.x, this.y /= e.y, this;
        }
        divideScalar(e) {
            return this.multiplyScalar(1 / e);
        }
        applyMatrix3(e) {
            const t = this.x, n = this.y, s = e.elements;
            return this.x = s[0] * t + s[3] * n + s[6], this.y = s[1] * t + s[4] * n + s[7], this;
        }
        min(e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
        }
        max(e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
        }
        clamp(e, t) {
            return this.x = Ye(this.x, e.x, t.x), this.y = Ye(this.y, e.y, t.y), this;
        }
        clampScalar(e, t) {
            return this.x = Ye(this.x, e, t), this.y = Ye(this.y, e, t), this;
        }
        clampLength(e, t) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Ye(n, e, t));
        }
        floor() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
        }
        ceil() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
        }
        round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        }
        roundToZero() {
            return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
        }
        negate() {
            return this.x = -this.x, this.y = -this.y, this;
        }
        dot(e) {
            return this.x * e.x + this.y * e.y;
        }
        cross(e) {
            return this.x * e.y - this.y * e.x;
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y;
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
            return this.divideScalar(this.length() || 1);
        }
        angle() {
            return Math.atan2(-this.y, -this.x) + Math.PI;
        }
        angleTo(e) {
            const t = Math.sqrt(this.lengthSq() * e.lengthSq());
            if (t === 0) return Math.PI / 2;
            const n = this.dot(e) / t;
            return Math.acos(Ye(n, -1, 1));
        }
        distanceTo(e) {
            return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
            const t = this.x - e.x, n = this.y - e.y;
            return t * t + n * n;
        }
        manhattanDistanceTo(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
        }
        setLength(e) {
            return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
        }
        lerpVectors(e, t, n) {
            return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this;
        }
        equals(e) {
            return e.x === this.x && e.y === this.y;
        }
        fromArray(e, t = 0) {
            return this.x = e[t], this.y = e[t + 1], this;
        }
        toArray(e = [], t = 0) {
            return e[t] = this.x, e[t + 1] = this.y, e;
        }
        fromBufferAttribute(e, t) {
            return this.x = e.getX(t), this.y = e.getY(t), this;
        }
        rotateAround(e, t) {
            const n = Math.cos(t), s = Math.sin(t), r = this.x - e.x, a = this.y - e.y;
            return this.x = r * n - a * s + e.x, this.y = r * s + a * n + e.y, this;
        }
        random() {
            return this.x = Math.random(), this.y = Math.random(), this;
        }
        *[Symbol.iterator]() {
            yield this.x, yield this.y;
        }
    }
    class Ge {
        constructor(e, t, n, s, r, a, o, c, l){
            Ge.prototype.isMatrix3 = !0, this.elements = [
                1,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                1
            ], e !== void 0 && this.set(e, t, n, s, r, a, o, c, l);
        }
        set(e, t, n, s, r, a, o, c, l) {
            const h = this.elements;
            return h[0] = e, h[1] = s, h[2] = o, h[3] = t, h[4] = r, h[5] = c, h[6] = n, h[7] = a, h[8] = l, this;
        }
        identity() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
        }
        copy(e) {
            const t = this.elements, n = e.elements;
            return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this;
        }
        extractBasis(e, t, n) {
            return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
        }
        setFromMatrix4(e) {
            const t = e.elements;
            return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this;
        }
        multiply(e) {
            return this.multiplyMatrices(this, e);
        }
        premultiply(e) {
            return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
            const n = e.elements, s = t.elements, r = this.elements, a = n[0], o = n[3], c = n[6], l = n[1], h = n[4], u = n[7], d = n[2], f = n[5], _ = n[8], g = s[0], p = s[3], m = s[6], v = s[1], y = s[4], x = s[7], I = s[2], w = s[5], R = s[8];
            return r[0] = a * g + o * v + c * I, r[3] = a * p + o * y + c * w, r[6] = a * m + o * x + c * R, r[1] = l * g + h * v + u * I, r[4] = l * p + h * y + u * w, r[7] = l * m + h * x + u * R, r[2] = d * g + f * v + _ * I, r[5] = d * p + f * y + _ * w, r[8] = d * m + f * x + _ * R, this;
        }
        multiplyScalar(e) {
            const t = this.elements;
            return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
        }
        determinant() {
            const e = this.elements, t = e[0], n = e[1], s = e[2], r = e[3], a = e[4], o = e[5], c = e[6], l = e[7], h = e[8];
            return t * a * h - t * o * l - n * r * h + n * o * c + s * r * l - s * a * c;
        }
        invert() {
            const e = this.elements, t = e[0], n = e[1], s = e[2], r = e[3], a = e[4], o = e[5], c = e[6], l = e[7], h = e[8], u = h * a - o * l, d = o * c - h * r, f = l * r - a * c, _ = t * u + n * d + s * f;
            if (_ === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
            const g = 1 / _;
            return e[0] = u * g, e[1] = (s * l - h * n) * g, e[2] = (o * n - s * a) * g, e[3] = d * g, e[4] = (h * t - s * c) * g, e[5] = (s * r - o * t) * g, e[6] = f * g, e[7] = (n * c - l * t) * g, e[8] = (a * t - n * r) * g, this;
        }
        transpose() {
            let e;
            const t = this.elements;
            return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
        }
        getNormalMatrix(e) {
            return this.setFromMatrix4(e).invert().transpose();
        }
        transposeIntoArray(e) {
            const t = this.elements;
            return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
        }
        setUvTransform(e, t, n, s, r, a, o) {
            const c = Math.cos(r), l = Math.sin(r);
            return this.set(n * c, n * l, -n * (c * a + l * o) + a + e, -s * l, s * c, -s * (-l * a + c * o) + o + t, 0, 0, 1), this;
        }
        scale(e, t) {
            return this.premultiply(ro.makeScale(e, t)), this;
        }
        rotate(e) {
            return this.premultiply(ro.makeRotation(-e)), this;
        }
        translate(e, t) {
            return this.premultiply(ro.makeTranslation(e, t)), this;
        }
        makeTranslation(e, t) {
            return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1), this;
        }
        makeRotation(e) {
            const t = Math.cos(e), n = Math.sin(e);
            return this.set(t, -n, 0, n, t, 0, 0, 0, 1), this;
        }
        makeScale(e, t) {
            return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
        }
        equals(e) {
            const t = this.elements, n = e.elements;
            for(let s = 0; s < 9; s++)if (t[s] !== n[s]) return !1;
            return !0;
        }
        fromArray(e, t = 0) {
            for(let n = 0; n < 9; n++)this.elements[n] = e[n + t];
            return this;
        }
        toArray(e = [], t = 0) {
            const n = this.elements;
            return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e;
        }
        clone() {
            return new this.constructor().fromArray(this.elements);
        }
    }
    const ro = new Ge;
    function Ff(i) {
        for(let e = i.length - 1; e >= 0; --e)if (i[e] >= 65535) return !0;
        return !1;
    }
    function wr(i) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", i);
    }
    function Ig() {
        const i = wr("canvas");
        return i.style.display = "block", i;
    }
    const Kh = {};
    function Ia(i) {
        i in Kh || (Kh[i] = !0, console.warn(i));
    }
    function Dg(i, e, t) {
        return new Promise(function(n, s) {
            function r() {
                switch(i.clientWaitSync(e, i.SYNC_FLUSH_COMMANDS_BIT, 0)){
                    case i.WAIT_FAILED:
                        s();
                        break;
                    case i.TIMEOUT_EXPIRED:
                        setTimeout(r, t);
                        break;
                    default:
                        n();
                }
            }
            setTimeout(r, t);
        });
    }
    function Lg(i) {
        const e = i.elements;
        e[2] = .5 * e[2] + .5 * e[3], e[6] = .5 * e[6] + .5 * e[7], e[10] = .5 * e[10] + .5 * e[11], e[14] = .5 * e[14] + .5 * e[15];
    }
    function Ug(i) {
        const e = i.elements;
        e[11] === -1 ? (e[10] = -e[10] - 1, e[14] = -e[14]) : (e[10] = -e[10], e[14] = -e[14] + 1);
    }
    const Zh = new Ge().set(.4123908, .3575843, .1804808, .212639, .7151687, .0721923, .0193308, .1191948, .9505322), Jh = new Ge().set(3.2409699, -1.5373832, -.4986108, -.9692436, 1.8759675, .0415551, .0556301, -.203977, 1.0569715);
    function Ng() {
        const i = {
            enabled: !0,
            workingColorSpace: $t,
            spaces: {},
            convert: function(s, r, a) {
                return this.enabled === !1 || r === a || !r || !a || (this.spaces[r].transfer === ct && (s.r = Jn(s.r), s.g = Jn(s.g), s.b = Jn(s.b)), this.spaces[r].primaries !== this.spaces[a].primaries && (s.applyMatrix3(this.spaces[r].toXYZ), s.applyMatrix3(this.spaces[a].fromXYZ)), this.spaces[a].transfer === ct && (s.r = Ts(s.r), s.g = Ts(s.g), s.b = Ts(s.b))), s;
            },
            fromWorkingColorSpace: function(s, r) {
                return this.convert(s, this.workingColorSpace, r);
            },
            toWorkingColorSpace: function(s, r) {
                return this.convert(s, r, this.workingColorSpace);
            },
            getPrimaries: function(s) {
                return this.spaces[s].primaries;
            },
            getTransfer: function(s) {
                return s === hi ? ka : this.spaces[s].transfer;
            },
            getLuminanceCoefficients: function(s, r = this.workingColorSpace) {
                return s.fromArray(this.spaces[r].luminanceCoefficients);
            },
            define: function(s) {
                Object.assign(this.spaces, s);
            },
            _getMatrix: function(s, r, a) {
                return s.copy(this.spaces[r].toXYZ).multiply(this.spaces[a].fromXYZ);
            },
            _getDrawingBufferColorSpace: function(s) {
                return this.spaces[s].outputColorSpaceConfig.drawingBufferColorSpace;
            },
            _getUnpackColorSpace: function(s = this.workingColorSpace) {
                return this.spaces[s].workingColorSpaceConfig.unpackColorSpace;
            }
        }, e = [
            .64,
            .33,
            .3,
            .6,
            .15,
            .06
        ], t = [
            .2126,
            .7152,
            .0722
        ], n = [
            .3127,
            .329
        ];
        return i.define({
            [$t]: {
                primaries: e,
                whitePoint: n,
                transfer: ka,
                toXYZ: Zh,
                fromXYZ: Jh,
                luminanceCoefficients: t,
                workingColorSpaceConfig: {
                    unpackColorSpace: Dt
                },
                outputColorSpaceConfig: {
                    drawingBufferColorSpace: Dt
                }
            },
            [Dt]: {
                primaries: e,
                whitePoint: n,
                transfer: ct,
                toXYZ: Zh,
                fromXYZ: Jh,
                luminanceCoefficients: t,
                outputColorSpaceConfig: {
                    drawingBufferColorSpace: Dt
                }
            }
        }), i;
    }
    const $e = Ng();
    function Jn(i) {
        return i < .04045 ? i * .0773993808 : Math.pow(i * .9478672986 + .0521327014, 2.4);
    }
    function Ts(i) {
        return i < .0031308 ? i * 12.92 : 1.055 * Math.pow(i, .41666) - .055;
    }
    let es;
    class Bg {
        static getDataURL(e, t = "image/png") {
            if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
            let n;
            if (e instanceof HTMLCanvasElement) n = e;
            else {
                es === void 0 && (es = wr("canvas")), es.width = e.width, es.height = e.height;
                const s = es.getContext("2d");
                e instanceof ImageData ? s.putImageData(e, 0, 0) : s.drawImage(e, 0, 0, e.width, e.height), n = es;
            }
            return n.toDataURL(t);
        }
        static sRGBToLinear(e) {
            if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
                const t = wr("canvas");
                t.width = e.width, t.height = e.height;
                const n = t.getContext("2d");
                n.drawImage(e, 0, 0, e.width, e.height);
                const s = n.getImageData(0, 0, e.width, e.height), r = s.data;
                for(let a = 0; a < r.length; a++)r[a] = Jn(r[a] / 255) * 255;
                return n.putImageData(s, 0, 0), t;
            } else if (e.data) {
                const t = e.data.slice(0);
                for(let n = 0; n < t.length; n++)t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[n] = Math.floor(Jn(t[n] / 255) * 255) : t[n] = Jn(t[n]);
                return {
                    data: t,
                    width: e.width,
                    height: e.height
                };
            } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
        }
    }
    let Fg = 0;
    class jl {
        constructor(e = null){
            this.isSource = !0, Object.defineProperty(this, "id", {
                value: Fg++
            }), this.uuid = Tn(), this.data = e, this.dataReady = !0, this.version = 0;
        }
        set needsUpdate(e) {
            e === !0 && this.version++;
        }
        toJSON(e) {
            const t = e === void 0 || typeof e == "string";
            if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
            const n = {
                uuid: this.uuid,
                url: ""
            }, s = this.data;
            if (s !== null) {
                let r;
                if (Array.isArray(s)) {
                    r = [];
                    for(let a = 0, o = s.length; a < o; a++)s[a].isDataTexture ? r.push(ao(s[a].image)) : r.push(ao(s[a]));
                } else r = ao(s);
                n.url = r;
            }
            return t || (e.images[this.uuid] = n), n;
        }
    }
    function ao(i) {
        return typeof HTMLImageElement < "u" && i instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && i instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && i instanceof ImageBitmap ? Bg.getDataURL(i) : i.data ? {
            data: Array.from(i.data),
            width: i.width,
            height: i.height,
            type: i.data.constructor.name
        } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
    }
    let Og = 0, Qt = class Da extends ji {
        constructor(e = Da.DEFAULT_IMAGE, t = Da.DEFAULT_MAPPING, n = ui, s = ui, r = an, a = Kn, o = un, c = ni, l = Da.DEFAULT_ANISOTROPY, h = hi){
            super(), this.isTexture = !0, Object.defineProperty(this, "id", {
                value: Og++
            }), this.uuid = Tn(), this.name = "", this.source = new jl(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = n, this.wrapT = s, this.magFilter = r, this.minFilter = a, this.anisotropy = l, this.format = o, this.internalFormat = null, this.type = c, this.offset = new Ke(0, 0), this.repeat = new Ke(1, 1), this.center = new Ke(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Ge, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = h, this.userData = {}, this.version = 0, this.onUpdate = null, this.renderTarget = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0;
        }
        get image() {
            return this.source.data;
        }
        set image(e = null) {
            this.source.data = e;
        }
        updateMatrix() {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
        }
        clone() {
            return new this.constructor().copy(this);
        }
        copy(e) {
            return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.renderTarget = e.renderTarget, this.isRenderTargetTexture = e.isRenderTargetTexture, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
        }
        toJSON(e) {
            const t = e === void 0 || typeof e == "string";
            if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
            const n = {
                metadata: {
                    version: 4.6,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                image: this.source.toJSON(e).uuid,
                mapping: this.mapping,
                channel: this.channel,
                repeat: [
                    this.repeat.x,
                    this.repeat.y
                ],
                offset: [
                    this.offset.x,
                    this.offset.y
                ],
                center: [
                    this.center.x,
                    this.center.y
                ],
                rotation: this.rotation,
                wrap: [
                    this.wrapS,
                    this.wrapT
                ],
                format: this.format,
                internalFormat: this.internalFormat,
                type: this.type,
                colorSpace: this.colorSpace,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY,
                generateMipmaps: this.generateMipmaps,
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment
            };
            return Object.keys(this.userData).length > 0 && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n;
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            });
        }
        transformUv(e) {
            if (this.mapping !== Mf) return e;
            if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch(this.wrapS){
                case Ps:
                    e.x = e.x - Math.floor(e.x);
                    break;
                case ui:
                    e.x = e.x < 0 ? 0 : 1;
                    break;
                case Fa:
                    Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                    break;
            }
            if (e.y < 0 || e.y > 1) switch(this.wrapT){
                case Ps:
                    e.y = e.y - Math.floor(e.y);
                    break;
                case ui:
                    e.y = e.y < 0 ? 0 : 1;
                    break;
                case Fa:
                    Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                    break;
            }
            return this.flipY && (e.y = 1 - e.y), e;
        }
        set needsUpdate(e) {
            e === !0 && (this.version++, this.source.needsUpdate = !0);
        }
        set needsPMREMUpdate(e) {
            e === !0 && this.pmremVersion++;
        }
    };
    Qt.DEFAULT_IMAGE = null;
    Qt.DEFAULT_MAPPING = Mf;
    Qt.DEFAULT_ANISOTROPY = 1;
    class nt {
        constructor(e = 0, t = 0, n = 0, s = 1){
            nt.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = n, this.w = s;
        }
        get width() {
            return this.z;
        }
        set width(e) {
            this.z = e;
        }
        get height() {
            return this.w;
        }
        set height(e) {
            this.w = e;
        }
        set(e, t, n, s) {
            return this.x = e, this.y = t, this.z = n, this.w = s, this;
        }
        setScalar(e) {
            return this.x = e, this.y = e, this.z = e, this.w = e, this;
        }
        setX(e) {
            return this.x = e, this;
        }
        setY(e) {
            return this.y = e, this;
        }
        setZ(e) {
            return this.z = e, this;
        }
        setW(e) {
            return this.w = e, this;
        }
        setComponent(e, t) {
            switch(e){
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                case 3:
                    this.w = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e);
            }
            return this;
        }
        getComponent(e) {
            switch(e){
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error("index is out of range: " + e);
            }
        }
        clone() {
            return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(e) {
            return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
        }
        add(e) {
            return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
        }
        addScalar(e) {
            return this.x += e, this.y += e, this.z += e, this.w += e, this;
        }
        addVectors(e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
        }
        addScaledVector(e, t) {
            return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
        }
        sub(e) {
            return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
        }
        subScalar(e) {
            return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
        }
        subVectors(e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
        }
        multiply(e) {
            return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
        }
        multiplyScalar(e) {
            return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
        }
        applyMatrix4(e) {
            const t = this.x, n = this.y, s = this.z, r = this.w, a = e.elements;
            return this.x = a[0] * t + a[4] * n + a[8] * s + a[12] * r, this.y = a[1] * t + a[5] * n + a[9] * s + a[13] * r, this.z = a[2] * t + a[6] * n + a[10] * s + a[14] * r, this.w = a[3] * t + a[7] * n + a[11] * s + a[15] * r, this;
        }
        divide(e) {
            return this.x /= e.x, this.y /= e.y, this.z /= e.z, this.w /= e.w, this;
        }
        divideScalar(e) {
            return this.multiplyScalar(1 / e);
        }
        setAxisAngleFromQuaternion(e) {
            this.w = 2 * Math.acos(e.w);
            const t = Math.sqrt(1 - e.w * e.w);
            return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
        }
        setAxisAngleFromRotationMatrix(e) {
            let t, n, s, r;
            const c = e.elements, l = c[0], h = c[4], u = c[8], d = c[1], f = c[5], _ = c[9], g = c[2], p = c[6], m = c[10];
            if (Math.abs(h - d) < .01 && Math.abs(u - g) < .01 && Math.abs(_ - p) < .01) {
                if (Math.abs(h + d) < .1 && Math.abs(u + g) < .1 && Math.abs(_ + p) < .1 && Math.abs(l + f + m - 3) < .1) return this.set(1, 0, 0, 0), this;
                t = Math.PI;
                const y = (l + 1) / 2, x = (f + 1) / 2, I = (m + 1) / 2, w = (h + d) / 4, R = (u + g) / 4, N = (_ + p) / 4;
                return y > x && y > I ? y < .01 ? (n = 0, s = .707106781, r = .707106781) : (n = Math.sqrt(y), s = w / n, r = R / n) : x > I ? x < .01 ? (n = .707106781, s = 0, r = .707106781) : (s = Math.sqrt(x), n = w / s, r = N / s) : I < .01 ? (n = .707106781, s = .707106781, r = 0) : (r = Math.sqrt(I), n = R / r, s = N / r), this.set(n, s, r, t), this;
            }
            let v = Math.sqrt((p - _) * (p - _) + (u - g) * (u - g) + (d - h) * (d - h));
            return Math.abs(v) < .001 && (v = 1), this.x = (p - _) / v, this.y = (u - g) / v, this.z = (d - h) / v, this.w = Math.acos((l + f + m - 1) / 2), this;
        }
        setFromMatrixPosition(e) {
            const t = e.elements;
            return this.x = t[12], this.y = t[13], this.z = t[14], this.w = t[15], this;
        }
        min(e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
        }
        max(e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
        }
        clamp(e, t) {
            return this.x = Ye(this.x, e.x, t.x), this.y = Ye(this.y, e.y, t.y), this.z = Ye(this.z, e.z, t.z), this.w = Ye(this.w, e.w, t.w), this;
        }
        clampScalar(e, t) {
            return this.x = Ye(this.x, e, t), this.y = Ye(this.y, e, t), this.z = Ye(this.z, e, t), this.w = Ye(this.w, e, t), this;
        }
        clampLength(e, t) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Ye(n, e, t));
        }
        floor() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
        }
        ceil() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
        }
        round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
        }
        roundToZero() {
            return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
        }
        negate() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
        }
        dot(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
        }
        normalize() {
            return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
            return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
        }
        lerpVectors(e, t, n) {
            return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this;
        }
        equals(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
        }
        fromArray(e, t = 0) {
            return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
        }
        toArray(e = [], t = 0) {
            return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
        }
        fromBufferAttribute(e, t) {
            return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
        }
        random() {
            return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
        }
        *[Symbol.iterator]() {
            yield this.x, yield this.y, yield this.z, yield this.w;
        }
    }
    let kg = class extends ji {
        constructor(e = 1, t = 1, n = {}){
            super(), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new nt(0, 0, e, t), this.scissorTest = !1, this.viewport = new nt(0, 0, e, t);
            const s = {
                width: e,
                height: t,
                depth: 1
            };
            n = Object.assign({
                generateMipmaps: !1,
                internalFormat: null,
                minFilter: an,
                depthBuffer: !0,
                stencilBuffer: !1,
                resolveDepthBuffer: !0,
                resolveStencilBuffer: !0,
                depthTexture: null,
                samples: 0,
                count: 1
            }, n);
            const r = new Qt(s, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace);
            r.flipY = !1, r.generateMipmaps = n.generateMipmaps, r.internalFormat = n.internalFormat, this.textures = [];
            const a = n.count;
            for(let o = 0; o < a; o++)this.textures[o] = r.clone(), this.textures[o].isRenderTargetTexture = !0, this.textures[o].renderTarget = this;
            this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.resolveDepthBuffer = n.resolveDepthBuffer, this.resolveStencilBuffer = n.resolveStencilBuffer, this._depthTexture = n.depthTexture, this.samples = n.samples;
        }
        get texture() {
            return this.textures[0];
        }
        set texture(e) {
            this.textures[0] = e;
        }
        set depthTexture(e) {
            this._depthTexture !== null && (this._depthTexture.renderTarget = null), e !== null && (e.renderTarget = this), this._depthTexture = e;
        }
        get depthTexture() {
            return this._depthTexture;
        }
        setSize(e, t, n = 1) {
            if (this.width !== e || this.height !== t || this.depth !== n) {
                this.width = e, this.height = t, this.depth = n;
                for(let s = 0, r = this.textures.length; s < r; s++)this.textures[s].image.width = e, this.textures[s].image.height = t, this.textures[s].image.depth = n;
                this.dispose();
            }
            this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
        }
        clone() {
            return new this.constructor().copy(this);
        }
        copy(e) {
            this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
            for(let t = 0, n = e.textures.length; t < n; t++){
                this.textures[t] = e.textures[t].clone(), this.textures[t].isRenderTargetTexture = !0, this.textures[t].renderTarget = this;
                const s = Object.assign({}, e.textures[t].image);
                this.textures[t].source = new jl(s);
            }
            return this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            });
        }
    };
    class Vi extends kg {
        constructor(e = 1, t = 1, n = {}){
            super(e, t, n), this.isWebGLRenderTarget = !0;
        }
    }
    class Of extends Qt {
        constructor(e = null, t = 1, n = 1, s = 1){
            super(null), this.isDataArrayTexture = !0, this.image = {
                data: e,
                width: t,
                height: n,
                depth: s
            }, this.magFilter = Yt, this.minFilter = Yt, this.wrapR = ui, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = new Set;
        }
        addLayerUpdate(e) {
            this.layerUpdates.add(e);
        }
        clearLayerUpdates() {
            this.layerUpdates.clear();
        }
    }
    class Gg extends Qt {
        constructor(e = null, t = 1, n = 1, s = 1){
            super(null), this.isData3DTexture = !0, this.image = {
                data: e,
                width: t,
                height: n,
                depth: s
            }, this.magFilter = Yt, this.minFilter = Yt, this.wrapR = ui, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
        }
    }
    class En {
        constructor(e = 0, t = 0, n = 0, s = 1){
            this.isQuaternion = !0, this._x = e, this._y = t, this._z = n, this._w = s;
        }
        static slerpFlat(e, t, n, s, r, a, o) {
            let c = n[s + 0], l = n[s + 1], h = n[s + 2], u = n[s + 3];
            const d = r[a + 0], f = r[a + 1], _ = r[a + 2], g = r[a + 3];
            if (o === 0) {
                e[t + 0] = c, e[t + 1] = l, e[t + 2] = h, e[t + 3] = u;
                return;
            }
            if (o === 1) {
                e[t + 0] = d, e[t + 1] = f, e[t + 2] = _, e[t + 3] = g;
                return;
            }
            if (u !== g || c !== d || l !== f || h !== _) {
                let p = 1 - o;
                const m = c * d + l * f + h * _ + u * g, v = m >= 0 ? 1 : -1, y = 1 - m * m;
                if (y > Number.EPSILON) {
                    const I = Math.sqrt(y), w = Math.atan2(I, m * v);
                    p = Math.sin(p * w) / I, o = Math.sin(o * w) / I;
                }
                const x = o * v;
                if (c = c * p + d * x, l = l * p + f * x, h = h * p + _ * x, u = u * p + g * x, p === 1 - o) {
                    const I = 1 / Math.sqrt(c * c + l * l + h * h + u * u);
                    c *= I, l *= I, h *= I, u *= I;
                }
            }
            e[t] = c, e[t + 1] = l, e[t + 2] = h, e[t + 3] = u;
        }
        static multiplyQuaternionsFlat(e, t, n, s, r, a) {
            const o = n[s], c = n[s + 1], l = n[s + 2], h = n[s + 3], u = r[a], d = r[a + 1], f = r[a + 2], _ = r[a + 3];
            return e[t] = o * _ + h * u + c * f - l * d, e[t + 1] = c * _ + h * d + l * u - o * f, e[t + 2] = l * _ + h * f + o * d - c * u, e[t + 3] = h * _ - o * u - c * d - l * f, e;
        }
        get x() {
            return this._x;
        }
        set x(e) {
            this._x = e, this._onChangeCallback();
        }
        get y() {
            return this._y;
        }
        set y(e) {
            this._y = e, this._onChangeCallback();
        }
        get z() {
            return this._z;
        }
        set z(e) {
            this._z = e, this._onChangeCallback();
        }
        get w() {
            return this._w;
        }
        set w(e) {
            this._w = e, this._onChangeCallback();
        }
        set(e, t, n, s) {
            return this._x = e, this._y = t, this._z = n, this._w = s, this._onChangeCallback(), this;
        }
        clone() {
            return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(e) {
            return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
        }
        setFromEuler(e, t = !0) {
            const n = e._x, s = e._y, r = e._z, a = e._order, o = Math.cos, c = Math.sin, l = o(n / 2), h = o(s / 2), u = o(r / 2), d = c(n / 2), f = c(s / 2), _ = c(r / 2);
            switch(a){
                case "XYZ":
                    this._x = d * h * u + l * f * _, this._y = l * f * u - d * h * _, this._z = l * h * _ + d * f * u, this._w = l * h * u - d * f * _;
                    break;
                case "YXZ":
                    this._x = d * h * u + l * f * _, this._y = l * f * u - d * h * _, this._z = l * h * _ - d * f * u, this._w = l * h * u + d * f * _;
                    break;
                case "ZXY":
                    this._x = d * h * u - l * f * _, this._y = l * f * u + d * h * _, this._z = l * h * _ + d * f * u, this._w = l * h * u - d * f * _;
                    break;
                case "ZYX":
                    this._x = d * h * u - l * f * _, this._y = l * f * u + d * h * _, this._z = l * h * _ - d * f * u, this._w = l * h * u + d * f * _;
                    break;
                case "YZX":
                    this._x = d * h * u + l * f * _, this._y = l * f * u + d * h * _, this._z = l * h * _ - d * f * u, this._w = l * h * u - d * f * _;
                    break;
                case "XZY":
                    this._x = d * h * u - l * f * _, this._y = l * f * u - d * h * _, this._z = l * h * _ + d * f * u, this._w = l * h * u + d * f * _;
                    break;
                default:
                    console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a);
            }
            return t === !0 && this._onChangeCallback(), this;
        }
        setFromAxisAngle(e, t) {
            const n = t / 2, s = Math.sin(n);
            return this._x = e.x * s, this._y = e.y * s, this._z = e.z * s, this._w = Math.cos(n), this._onChangeCallback(), this;
        }
        setFromRotationMatrix(e) {
            const t = e.elements, n = t[0], s = t[4], r = t[8], a = t[1], o = t[5], c = t[9], l = t[2], h = t[6], u = t[10], d = n + o + u;
            if (d > 0) {
                const f = .5 / Math.sqrt(d + 1);
                this._w = .25 / f, this._x = (h - c) * f, this._y = (r - l) * f, this._z = (a - s) * f;
            } else if (n > o && n > u) {
                const f = 2 * Math.sqrt(1 + n - o - u);
                this._w = (h - c) / f, this._x = .25 * f, this._y = (s + a) / f, this._z = (r + l) / f;
            } else if (o > u) {
                const f = 2 * Math.sqrt(1 + o - n - u);
                this._w = (r - l) / f, this._x = (s + a) / f, this._y = .25 * f, this._z = (c + h) / f;
            } else {
                const f = 2 * Math.sqrt(1 + u - n - o);
                this._w = (a - s) / f, this._x = (r + l) / f, this._y = (c + h) / f, this._z = .25 * f;
            }
            return this._onChangeCallback(), this;
        }
        setFromUnitVectors(e, t) {
            let n = e.dot(t) + 1;
            return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize();
        }
        angleTo(e) {
            return 2 * Math.acos(Math.abs(Ye(this.dot(e), -1, 1)));
        }
        rotateTowards(e, t) {
            const n = this.angleTo(e);
            if (n === 0) return this;
            const s = Math.min(1, t / n);
            return this.slerp(e, s), this;
        }
        identity() {
            return this.set(0, 0, 0, 1);
        }
        invert() {
            return this.conjugate();
        }
        conjugate() {
            return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
        }
        dot(e) {
            return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
        }
        lengthSq() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
        }
        length() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
        }
        normalize() {
            let e = this.length();
            return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
        }
        multiply(e) {
            return this.multiplyQuaternions(this, e);
        }
        premultiply(e) {
            return this.multiplyQuaternions(e, this);
        }
        multiplyQuaternions(e, t) {
            const n = e._x, s = e._y, r = e._z, a = e._w, o = t._x, c = t._y, l = t._z, h = t._w;
            return this._x = n * h + a * o + s * l - r * c, this._y = s * h + a * c + r * o - n * l, this._z = r * h + a * l + n * c - s * o, this._w = a * h - n * o - s * c - r * l, this._onChangeCallback(), this;
        }
        slerp(e, t) {
            if (t === 0) return this;
            if (t === 1) return this.copy(e);
            const n = this._x, s = this._y, r = this._z, a = this._w;
            let o = a * e._w + n * e._x + s * e._y + r * e._z;
            if (o < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e), o >= 1) return this._w = a, this._x = n, this._y = s, this._z = r, this;
            const c = 1 - o * o;
            if (c <= Number.EPSILON) {
                const f = 1 - t;
                return this._w = f * a + t * this._w, this._x = f * n + t * this._x, this._y = f * s + t * this._y, this._z = f * r + t * this._z, this.normalize(), this;
            }
            const l = Math.sqrt(c), h = Math.atan2(l, o), u = Math.sin((1 - t) * h) / l, d = Math.sin(t * h) / l;
            return this._w = a * u + this._w * d, this._x = n * u + this._x * d, this._y = s * u + this._y * d, this._z = r * u + this._z * d, this._onChangeCallback(), this;
        }
        slerpQuaternions(e, t, n) {
            return this.copy(e).slerp(t, n);
        }
        random() {
            const e = 2 * Math.PI * Math.random(), t = 2 * Math.PI * Math.random(), n = Math.random(), s = Math.sqrt(1 - n), r = Math.sqrt(n);
            return this.set(s * Math.sin(e), s * Math.cos(e), r * Math.sin(t), r * Math.cos(t));
        }
        equals(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
        }
        fromArray(e, t = 0) {
            return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
        }
        toArray(e = [], t = 0) {
            return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
        }
        fromBufferAttribute(e, t) {
            return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this;
        }
        toJSON() {
            return this.toArray();
        }
        _onChange(e) {
            return this._onChangeCallback = e, this;
        }
        _onChangeCallback() {}
        *[Symbol.iterator]() {
            yield this._x, yield this._y, yield this._z, yield this._w;
        }
    }
    class k {
        constructor(e = 0, t = 0, n = 0){
            k.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = n;
        }
        set(e, t, n) {
            return n === void 0 && (n = this.z), this.x = e, this.y = t, this.z = n, this;
        }
        setScalar(e) {
            return this.x = e, this.y = e, this.z = e, this;
        }
        setX(e) {
            return this.x = e, this;
        }
        setY(e) {
            return this.y = e, this;
        }
        setZ(e) {
            return this.z = e, this;
        }
        setComponent(e, t) {
            switch(e){
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e);
            }
            return this;
        }
        getComponent(e) {
            switch(e){
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error("index is out of range: " + e);
            }
        }
        clone() {
            return new this.constructor(this.x, this.y, this.z);
        }
        copy(e) {
            return this.x = e.x, this.y = e.y, this.z = e.z, this;
        }
        add(e) {
            return this.x += e.x, this.y += e.y, this.z += e.z, this;
        }
        addScalar(e) {
            return this.x += e, this.y += e, this.z += e, this;
        }
        addVectors(e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
        }
        addScaledVector(e, t) {
            return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
        }
        sub(e) {
            return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
        }
        subScalar(e) {
            return this.x -= e, this.y -= e, this.z -= e, this;
        }
        subVectors(e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
        }
        multiply(e) {
            return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
        }
        multiplyScalar(e) {
            return this.x *= e, this.y *= e, this.z *= e, this;
        }
        multiplyVectors(e, t) {
            return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
        }
        applyEuler(e) {
            return this.applyQuaternion(Qh.setFromEuler(e));
        }
        applyAxisAngle(e, t) {
            return this.applyQuaternion(Qh.setFromAxisAngle(e, t));
        }
        applyMatrix3(e) {
            const t = this.x, n = this.y, s = this.z, r = e.elements;
            return this.x = r[0] * t + r[3] * n + r[6] * s, this.y = r[1] * t + r[4] * n + r[7] * s, this.z = r[2] * t + r[5] * n + r[8] * s, this;
        }
        applyNormalMatrix(e) {
            return this.applyMatrix3(e).normalize();
        }
        applyMatrix4(e) {
            const t = this.x, n = this.y, s = this.z, r = e.elements, a = 1 / (r[3] * t + r[7] * n + r[11] * s + r[15]);
            return this.x = (r[0] * t + r[4] * n + r[8] * s + r[12]) * a, this.y = (r[1] * t + r[5] * n + r[9] * s + r[13]) * a, this.z = (r[2] * t + r[6] * n + r[10] * s + r[14]) * a, this;
        }
        applyQuaternion(e) {
            const t = this.x, n = this.y, s = this.z, r = e.x, a = e.y, o = e.z, c = e.w, l = 2 * (a * s - o * n), h = 2 * (o * t - r * s), u = 2 * (r * n - a * t);
            return this.x = t + c * l + a * u - o * h, this.y = n + c * h + o * l - r * u, this.z = s + c * u + r * h - a * l, this;
        }
        project(e) {
            return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
        }
        unproject(e) {
            return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
        }
        transformDirection(e) {
            const t = this.x, n = this.y, s = this.z, r = e.elements;
            return this.x = r[0] * t + r[4] * n + r[8] * s, this.y = r[1] * t + r[5] * n + r[9] * s, this.z = r[2] * t + r[6] * n + r[10] * s, this.normalize();
        }
        divide(e) {
            return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
        }
        divideScalar(e) {
            return this.multiplyScalar(1 / e);
        }
        min(e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
        }
        max(e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
        }
        clamp(e, t) {
            return this.x = Ye(this.x, e.x, t.x), this.y = Ye(this.y, e.y, t.y), this.z = Ye(this.z, e.z, t.z), this;
        }
        clampScalar(e, t) {
            return this.x = Ye(this.x, e, t), this.y = Ye(this.y, e, t), this.z = Ye(this.z, e, t), this;
        }
        clampLength(e, t) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Ye(n, e, t));
        }
        floor() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
        }
        ceil() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
        }
        round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
        }
        roundToZero() {
            return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
        }
        negate() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
        }
        dot(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z;
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
            return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
            return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
        }
        lerpVectors(e, t, n) {
            return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this;
        }
        cross(e) {
            return this.crossVectors(this, e);
        }
        crossVectors(e, t) {
            const n = e.x, s = e.y, r = e.z, a = t.x, o = t.y, c = t.z;
            return this.x = s * c - r * o, this.y = r * a - n * c, this.z = n * o - s * a, this;
        }
        projectOnVector(e) {
            const t = e.lengthSq();
            if (t === 0) return this.set(0, 0, 0);
            const n = e.dot(this) / t;
            return this.copy(e).multiplyScalar(n);
        }
        projectOnPlane(e) {
            return oo.copy(this).projectOnVector(e), this.sub(oo);
        }
        reflect(e) {
            return this.sub(oo.copy(e).multiplyScalar(2 * this.dot(e)));
        }
        angleTo(e) {
            const t = Math.sqrt(this.lengthSq() * e.lengthSq());
            if (t === 0) return Math.PI / 2;
            const n = this.dot(e) / t;
            return Math.acos(Ye(n, -1, 1));
        }
        distanceTo(e) {
            return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
            const t = this.x - e.x, n = this.y - e.y, s = this.z - e.z;
            return t * t + n * n + s * s;
        }
        manhattanDistanceTo(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
        }
        setFromSpherical(e) {
            return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
        }
        setFromSphericalCoords(e, t, n) {
            const s = Math.sin(t) * e;
            return this.x = s * Math.sin(n), this.y = Math.cos(t) * e, this.z = s * Math.cos(n), this;
        }
        setFromCylindrical(e) {
            return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
        }
        setFromCylindricalCoords(e, t, n) {
            return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this;
        }
        setFromMatrixPosition(e) {
            const t = e.elements;
            return this.x = t[12], this.y = t[13], this.z = t[14], this;
        }
        setFromMatrixScale(e) {
            const t = this.setFromMatrixColumn(e, 0).length(), n = this.setFromMatrixColumn(e, 1).length(), s = this.setFromMatrixColumn(e, 2).length();
            return this.x = t, this.y = n, this.z = s, this;
        }
        setFromMatrixColumn(e, t) {
            return this.fromArray(e.elements, t * 4);
        }
        setFromMatrix3Column(e, t) {
            return this.fromArray(e.elements, t * 3);
        }
        setFromEuler(e) {
            return this.x = e._x, this.y = e._y, this.z = e._z, this;
        }
        setFromColor(e) {
            return this.x = e.r, this.y = e.g, this.z = e.b, this;
        }
        equals(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z;
        }
        fromArray(e, t = 0) {
            return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
        }
        toArray(e = [], t = 0) {
            return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
        }
        fromBufferAttribute(e, t) {
            return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
        }
        random() {
            return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
        }
        randomDirection() {
            const e = Math.random() * Math.PI * 2, t = Math.random() * 2 - 1, n = Math.sqrt(1 - t * t);
            return this.x = n * Math.cos(e), this.y = t, this.z = n * Math.sin(e), this;
        }
        *[Symbol.iterator]() {
            yield this.x, yield this.y, yield this.z;
        }
    }
    const oo = new k, Qh = new En;
    class fn {
        constructor(e = new k(1 / 0, 1 / 0, 1 / 0), t = new k(-1 / 0, -1 / 0, -1 / 0)){
            this.isBox3 = !0, this.min = e, this.max = t;
        }
        set(e, t) {
            return this.min.copy(e), this.max.copy(t), this;
        }
        setFromArray(e) {
            this.makeEmpty();
            for(let t = 0, n = e.length; t < n; t += 3)this.expandByPoint(_n.fromArray(e, t));
            return this;
        }
        setFromBufferAttribute(e) {
            this.makeEmpty();
            for(let t = 0, n = e.count; t < n; t++)this.expandByPoint(_n.fromBufferAttribute(e, t));
            return this;
        }
        setFromPoints(e) {
            this.makeEmpty();
            for(let t = 0, n = e.length; t < n; t++)this.expandByPoint(e[t]);
            return this;
        }
        setFromCenterAndSize(e, t) {
            const n = _n.copy(t).multiplyScalar(.5);
            return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
        }
        setFromObject(e, t = !1) {
            return this.makeEmpty(), this.expandByObject(e, t);
        }
        clone() {
            return new this.constructor().copy(this);
        }
        copy(e) {
            return this.min.copy(e.min), this.max.copy(e.max), this;
        }
        makeEmpty() {
            return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
        }
        isEmpty() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
        }
        getCenter(e) {
            return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5);
        }
        getSize(e) {
            return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
        }
        expandByPoint(e) {
            return this.min.min(e), this.max.max(e), this;
        }
        expandByVector(e) {
            return this.min.sub(e), this.max.add(e), this;
        }
        expandByScalar(e) {
            return this.min.addScalar(-e), this.max.addScalar(e), this;
        }
        expandByObject(e, t = !1) {
            e.updateWorldMatrix(!1, !1);
            const n = e.geometry;
            if (n !== void 0) {
                const r = n.getAttribute("position");
                if (t === !0 && r !== void 0 && e.isInstancedMesh !== !0) for(let a = 0, o = r.count; a < o; a++)e.isMesh === !0 ? e.getVertexPosition(a, _n) : _n.fromBufferAttribute(r, a), _n.applyMatrix4(e.matrixWorld), this.expandByPoint(_n);
                else e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), Gr.copy(e.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(), Gr.copy(n.boundingBox)), Gr.applyMatrix4(e.matrixWorld), this.union(Gr);
            }
            const s = e.children;
            for(let r = 0, a = s.length; r < a; r++)this.expandByObject(s[r], t);
            return this;
        }
        containsPoint(e) {
            return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z;
        }
        containsBox(e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
        }
        getParameter(e, t) {
            return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z));
        }
        intersectsBox(e) {
            return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z;
        }
        intersectsSphere(e) {
            return this.clampPoint(e.center, _n), _n.distanceToSquared(e.center) <= e.radius * e.radius;
        }
        intersectsPlane(e) {
            let t, n;
            return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant;
        }
        intersectsTriangle(e) {
            if (this.isEmpty()) return !1;
            this.getCenter(Ys), Hr.subVectors(this.max, Ys), ts.subVectors(e.a, Ys), ns.subVectors(e.b, Ys), is.subVectors(e.c, Ys), ii.subVectors(ns, ts), si.subVectors(is, ns), bi.subVectors(ts, is);
            let t = [
                0,
                -ii.z,
                ii.y,
                0,
                -si.z,
                si.y,
                0,
                -bi.z,
                bi.y,
                ii.z,
                0,
                -ii.x,
                si.z,
                0,
                -si.x,
                bi.z,
                0,
                -bi.x,
                -ii.y,
                ii.x,
                0,
                -si.y,
                si.x,
                0,
                -bi.y,
                bi.x,
                0
            ];
            return !co(t, ts, ns, is, Hr) || (t = [
                1,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                1
            ], !co(t, ts, ns, is, Hr)) ? !1 : (zr.crossVectors(ii, si), t = [
                zr.x,
                zr.y,
                zr.z
            ], co(t, ts, ns, is, Hr));
        }
        clampPoint(e, t) {
            return t.copy(e).clamp(this.min, this.max);
        }
        distanceToPoint(e) {
            return this.clampPoint(e, _n).distanceTo(e);
        }
        getBoundingSphere(e) {
            return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(_n).length() * .5), e;
        }
        intersect(e) {
            return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
        }
        union(e) {
            return this.min.min(e.min), this.max.max(e.max), this;
        }
        applyMatrix4(e) {
            return this.isEmpty() ? this : (Hn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Hn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Hn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Hn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Hn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Hn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Hn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Hn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Hn), this);
        }
        translate(e) {
            return this.min.add(e), this.max.add(e), this;
        }
        equals(e) {
            return e.min.equals(this.min) && e.max.equals(this.max);
        }
    }
    const Hn = [
        new k,
        new k,
        new k,
        new k,
        new k,
        new k,
        new k,
        new k
    ], _n = new k, Gr = new fn, ts = new k, ns = new k, is = new k, ii = new k, si = new k, bi = new k, Ys = new k, Hr = new k, zr = new k, Si = new k;
    function co(i, e, t, n, s) {
        for(let r = 0, a = i.length - 3; r <= a; r += 3){
            Si.fromArray(i, r);
            const o = s.x * Math.abs(Si.x) + s.y * Math.abs(Si.y) + s.z * Math.abs(Si.z), c = e.dot(Si), l = t.dot(Si), h = n.dot(Si);
            if (Math.max(-Math.max(c, l, h), Math.min(c, l, h)) > o) return !1;
        }
        return !0;
    }
    const Hg = new fn, qs = new k, lo = new k;
    class Fn {
        constructor(e = new k, t = -1){
            this.isSphere = !0, this.center = e, this.radius = t;
        }
        set(e, t) {
            return this.center.copy(e), this.radius = t, this;
        }
        setFromPoints(e, t) {
            const n = this.center;
            t !== void 0 ? n.copy(t) : Hg.setFromPoints(e).getCenter(n);
            let s = 0;
            for(let r = 0, a = e.length; r < a; r++)s = Math.max(s, n.distanceToSquared(e[r]));
            return this.radius = Math.sqrt(s), this;
        }
        copy(e) {
            return this.center.copy(e.center), this.radius = e.radius, this;
        }
        isEmpty() {
            return this.radius < 0;
        }
        makeEmpty() {
            return this.center.set(0, 0, 0), this.radius = -1, this;
        }
        containsPoint(e) {
            return e.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(e) {
            return e.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(e) {
            const t = this.radius + e.radius;
            return e.center.distanceToSquared(this.center) <= t * t;
        }
        intersectsBox(e) {
            return e.intersectsSphere(this);
        }
        intersectsPlane(e) {
            return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(e, t) {
            const n = this.center.distanceToSquared(e);
            return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
        }
        getBoundingBox(e) {
            return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
        }
        applyMatrix4(e) {
            return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
        }
        translate(e) {
            return this.center.add(e), this;
        }
        expandByPoint(e) {
            if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this;
            qs.subVectors(e, this.center);
            const t = qs.lengthSq();
            if (t > this.radius * this.radius) {
                const n = Math.sqrt(t), s = (n - this.radius) * .5;
                this.center.addScaledVector(qs, s / n), this.radius += s;
            }
            return this;
        }
        union(e) {
            return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (lo.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(qs.copy(e.center).add(lo)), this.expandByPoint(qs.copy(e.center).sub(lo))), this);
        }
        equals(e) {
            return e.center.equals(this.center) && e.radius === this.radius;
        }
        clone() {
            return new this.constructor().copy(this);
        }
    }
    const zn = new k, ho = new k, Vr = new k, ri = new k, uo = new k, Wr = new k, fo = new k;
    class Ka {
        constructor(e = new k, t = new k(0, 0, -1)){
            this.origin = e, this.direction = t;
        }
        set(e, t) {
            return this.origin.copy(e), this.direction.copy(t), this;
        }
        copy(e) {
            return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
        }
        at(e, t) {
            return t.copy(this.origin).addScaledVector(this.direction, e);
        }
        lookAt(e) {
            return this.direction.copy(e).sub(this.origin).normalize(), this;
        }
        recast(e) {
            return this.origin.copy(this.at(e, zn)), this;
        }
        closestPointToPoint(e, t) {
            t.subVectors(e, this.origin);
            const n = t.dot(this.direction);
            return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n);
        }
        distanceToPoint(e) {
            return Math.sqrt(this.distanceSqToPoint(e));
        }
        distanceSqToPoint(e) {
            const t = zn.subVectors(e, this.origin).dot(this.direction);
            return t < 0 ? this.origin.distanceToSquared(e) : (zn.copy(this.origin).addScaledVector(this.direction, t), zn.distanceToSquared(e));
        }
        distanceSqToSegment(e, t, n, s) {
            ho.copy(e).add(t).multiplyScalar(.5), Vr.copy(t).sub(e).normalize(), ri.copy(this.origin).sub(ho);
            const r = e.distanceTo(t) * .5, a = -this.direction.dot(Vr), o = ri.dot(this.direction), c = -ri.dot(Vr), l = ri.lengthSq(), h = Math.abs(1 - a * a);
            let u, d, f, _;
            if (h > 0) if (u = a * c - o, d = a * o - c, _ = r * h, u >= 0) if (d >= -_) if (d <= _) {
                const g = 1 / h;
                u *= g, d *= g, f = u * (u + a * d + 2 * o) + d * (a * u + d + 2 * c) + l;
            } else d = r, u = Math.max(0, -(a * d + o)), f = -u * u + d * (d + 2 * c) + l;
            else d = -r, u = Math.max(0, -(a * d + o)), f = -u * u + d * (d + 2 * c) + l;
            else d <= -_ ? (u = Math.max(0, -(-a * r + o)), d = u > 0 ? -r : Math.min(Math.max(-r, -c), r), f = -u * u + d * (d + 2 * c) + l) : d <= _ ? (u = 0, d = Math.min(Math.max(-r, -c), r), f = d * (d + 2 * c) + l) : (u = Math.max(0, -(a * r + o)), d = u > 0 ? r : Math.min(Math.max(-r, -c), r), f = -u * u + d * (d + 2 * c) + l);
            else d = a > 0 ? -r : r, u = Math.max(0, -(a * d + o)), f = -u * u + d * (d + 2 * c) + l;
            return n && n.copy(this.origin).addScaledVector(this.direction, u), s && s.copy(ho).addScaledVector(Vr, d), f;
        }
        intersectSphere(e, t) {
            zn.subVectors(e.center, this.origin);
            const n = zn.dot(this.direction), s = zn.dot(zn) - n * n, r = e.radius * e.radius;
            if (s > r) return null;
            const a = Math.sqrt(r - s), o = n - a, c = n + a;
            return c < 0 ? null : o < 0 ? this.at(c, t) : this.at(o, t);
        }
        intersectsSphere(e) {
            return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
        }
        distanceToPlane(e) {
            const t = e.normal.dot(this.direction);
            if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
            const n = -(this.origin.dot(e.normal) + e.constant) / t;
            return n >= 0 ? n : null;
        }
        intersectPlane(e, t) {
            const n = this.distanceToPlane(e);
            return n === null ? null : this.at(n, t);
        }
        intersectsPlane(e) {
            const t = e.distanceToPoint(this.origin);
            return t === 0 || e.normal.dot(this.direction) * t < 0;
        }
        intersectBox(e, t) {
            let n, s, r, a, o, c;
            const l = 1 / this.direction.x, h = 1 / this.direction.y, u = 1 / this.direction.z, d = this.origin;
            return l >= 0 ? (n = (e.min.x - d.x) * l, s = (e.max.x - d.x) * l) : (n = (e.max.x - d.x) * l, s = (e.min.x - d.x) * l), h >= 0 ? (r = (e.min.y - d.y) * h, a = (e.max.y - d.y) * h) : (r = (e.max.y - d.y) * h, a = (e.min.y - d.y) * h), n > a || r > s || ((r > n || isNaN(n)) && (n = r), (a < s || isNaN(s)) && (s = a), u >= 0 ? (o = (e.min.z - d.z) * u, c = (e.max.z - d.z) * u) : (o = (e.max.z - d.z) * u, c = (e.min.z - d.z) * u), n > c || o > s) || ((o > n || n !== n) && (n = o), (c < s || s !== s) && (s = c), s < 0) ? null : this.at(n >= 0 ? n : s, t);
        }
        intersectsBox(e) {
            return this.intersectBox(e, zn) !== null;
        }
        intersectTriangle(e, t, n, s, r) {
            uo.subVectors(t, e), Wr.subVectors(n, e), fo.crossVectors(uo, Wr);
            let a = this.direction.dot(fo), o;
            if (a > 0) {
                if (s) return null;
                o = 1;
            } else if (a < 0) o = -1, a = -a;
            else return null;
            ri.subVectors(this.origin, e);
            const c = o * this.direction.dot(Wr.crossVectors(ri, Wr));
            if (c < 0) return null;
            const l = o * this.direction.dot(uo.cross(ri));
            if (l < 0 || c + l > a) return null;
            const h = -o * ri.dot(fo);
            return h < 0 ? null : this.at(h / a, r);
        }
        applyMatrix4(e) {
            return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
        }
        equals(e) {
            return e.origin.equals(this.origin) && e.direction.equals(this.direction);
        }
        clone() {
            return new this.constructor().copy(this);
        }
    }
    class He {
        constructor(e, t, n, s, r, a, o, c, l, h, u, d, f, _, g, p){
            He.prototype.isMatrix4 = !0, this.elements = [
                1,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                1
            ], e !== void 0 && this.set(e, t, n, s, r, a, o, c, l, h, u, d, f, _, g, p);
        }
        set(e, t, n, s, r, a, o, c, l, h, u, d, f, _, g, p) {
            const m = this.elements;
            return m[0] = e, m[4] = t, m[8] = n, m[12] = s, m[1] = r, m[5] = a, m[9] = o, m[13] = c, m[2] = l, m[6] = h, m[10] = u, m[14] = d, m[3] = f, m[7] = _, m[11] = g, m[15] = p, this;
        }
        identity() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        clone() {
            return new He().fromArray(this.elements);
        }
        copy(e) {
            const t = this.elements, n = e.elements;
            return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this;
        }
        copyPosition(e) {
            const t = this.elements, n = e.elements;
            return t[12] = n[12], t[13] = n[13], t[14] = n[14], this;
        }
        setFromMatrix3(e) {
            const t = e.elements;
            return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this;
        }
        extractBasis(e, t, n) {
            return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
        }
        makeBasis(e, t, n) {
            return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this;
        }
        extractRotation(e) {
            const t = this.elements, n = e.elements, s = 1 / ss.setFromMatrixColumn(e, 0).length(), r = 1 / ss.setFromMatrixColumn(e, 1).length(), a = 1 / ss.setFromMatrixColumn(e, 2).length();
            return t[0] = n[0] * s, t[1] = n[1] * s, t[2] = n[2] * s, t[3] = 0, t[4] = n[4] * r, t[5] = n[5] * r, t[6] = n[6] * r, t[7] = 0, t[8] = n[8] * a, t[9] = n[9] * a, t[10] = n[10] * a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
        }
        makeRotationFromEuler(e) {
            const t = this.elements, n = e.x, s = e.y, r = e.z, a = Math.cos(n), o = Math.sin(n), c = Math.cos(s), l = Math.sin(s), h = Math.cos(r), u = Math.sin(r);
            if (e.order === "XYZ") {
                const d = a * h, f = a * u, _ = o * h, g = o * u;
                t[0] = c * h, t[4] = -c * u, t[8] = l, t[1] = f + _ * l, t[5] = d - g * l, t[9] = -o * c, t[2] = g - d * l, t[6] = _ + f * l, t[10] = a * c;
            } else if (e.order === "YXZ") {
                const d = c * h, f = c * u, _ = l * h, g = l * u;
                t[0] = d + g * o, t[4] = _ * o - f, t[8] = a * l, t[1] = a * u, t[5] = a * h, t[9] = -o, t[2] = f * o - _, t[6] = g + d * o, t[10] = a * c;
            } else if (e.order === "ZXY") {
                const d = c * h, f = c * u, _ = l * h, g = l * u;
                t[0] = d - g * o, t[4] = -a * u, t[8] = _ + f * o, t[1] = f + _ * o, t[5] = a * h, t[9] = g - d * o, t[2] = -a * l, t[6] = o, t[10] = a * c;
            } else if (e.order === "ZYX") {
                const d = a * h, f = a * u, _ = o * h, g = o * u;
                t[0] = c * h, t[4] = _ * l - f, t[8] = d * l + g, t[1] = c * u, t[5] = g * l + d, t[9] = f * l - _, t[2] = -l, t[6] = o * c, t[10] = a * c;
            } else if (e.order === "YZX") {
                const d = a * c, f = a * l, _ = o * c, g = o * l;
                t[0] = c * h, t[4] = g - d * u, t[8] = _ * u + f, t[1] = u, t[5] = a * h, t[9] = -o * h, t[2] = -l * h, t[6] = f * u + _, t[10] = d - g * u;
            } else if (e.order === "XZY") {
                const d = a * c, f = a * l, _ = o * c, g = o * l;
                t[0] = c * h, t[4] = -u, t[8] = l * h, t[1] = d * u + g, t[5] = a * h, t[9] = f * u - _, t[2] = _ * u - f, t[6] = o * h, t[10] = g * u + d;
            }
            return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
        }
        makeRotationFromQuaternion(e) {
            return this.compose(zg, e, Vg);
        }
        lookAt(e, t, n) {
            const s = this.elements;
            return nn.subVectors(e, t), nn.lengthSq() === 0 && (nn.z = 1), nn.normalize(), ai.crossVectors(n, nn), ai.lengthSq() === 0 && (Math.abs(n.z) === 1 ? nn.x += 1e-4 : nn.z += 1e-4, nn.normalize(), ai.crossVectors(n, nn)), ai.normalize(), Xr.crossVectors(nn, ai), s[0] = ai.x, s[4] = Xr.x, s[8] = nn.x, s[1] = ai.y, s[5] = Xr.y, s[9] = nn.y, s[2] = ai.z, s[6] = Xr.z, s[10] = nn.z, this;
        }
        multiply(e) {
            return this.multiplyMatrices(this, e);
        }
        premultiply(e) {
            return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
            const n = e.elements, s = t.elements, r = this.elements, a = n[0], o = n[4], c = n[8], l = n[12], h = n[1], u = n[5], d = n[9], f = n[13], _ = n[2], g = n[6], p = n[10], m = n[14], v = n[3], y = n[7], x = n[11], I = n[15], w = s[0], R = s[4], N = s[8], E = s[12], S = s[1], D = s[5], j = s[9], z = s[13], K = s[2], ne = s[6], b = s[10], C = s[14], A = s[3], U = s[7], B = s[11], V = s[15];
            return r[0] = a * w + o * S + c * K + l * A, r[4] = a * R + o * D + c * ne + l * U, r[8] = a * N + o * j + c * b + l * B, r[12] = a * E + o * z + c * C + l * V, r[1] = h * w + u * S + d * K + f * A, r[5] = h * R + u * D + d * ne + f * U, r[9] = h * N + u * j + d * b + f * B, r[13] = h * E + u * z + d * C + f * V, r[2] = _ * w + g * S + p * K + m * A, r[6] = _ * R + g * D + p * ne + m * U, r[10] = _ * N + g * j + p * b + m * B, r[14] = _ * E + g * z + p * C + m * V, r[3] = v * w + y * S + x * K + I * A, r[7] = v * R + y * D + x * ne + I * U, r[11] = v * N + y * j + x * b + I * B, r[15] = v * E + y * z + x * C + I * V, this;
        }
        multiplyScalar(e) {
            const t = this.elements;
            return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
        }
        determinant() {
            const e = this.elements, t = e[0], n = e[4], s = e[8], r = e[12], a = e[1], o = e[5], c = e[9], l = e[13], h = e[2], u = e[6], d = e[10], f = e[14], _ = e[3], g = e[7], p = e[11], m = e[15];
            return _ * (+r * c * u - s * l * u - r * o * d + n * l * d + s * o * f - n * c * f) + g * (+t * c * f - t * l * d + r * a * d - s * a * f + s * l * h - r * c * h) + p * (+t * l * u - t * o * f - r * a * u + n * a * f + r * o * h - n * l * h) + m * (-s * o * h - t * c * u + t * o * d + s * a * u - n * a * d + n * c * h);
        }
        transpose() {
            const e = this.elements;
            let t;
            return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
        }
        setPosition(e, t, n) {
            const s = this.elements;
            return e.isVector3 ? (s[12] = e.x, s[13] = e.y, s[14] = e.z) : (s[12] = e, s[13] = t, s[14] = n), this;
        }
        invert() {
            const e = this.elements, t = e[0], n = e[1], s = e[2], r = e[3], a = e[4], o = e[5], c = e[6], l = e[7], h = e[8], u = e[9], d = e[10], f = e[11], _ = e[12], g = e[13], p = e[14], m = e[15], v = u * p * l - g * d * l + g * c * f - o * p * f - u * c * m + o * d * m, y = _ * d * l - h * p * l - _ * c * f + a * p * f + h * c * m - a * d * m, x = h * g * l - _ * u * l + _ * o * f - a * g * f - h * o * m + a * u * m, I = _ * u * c - h * g * c - _ * o * d + a * g * d + h * o * p - a * u * p, w = t * v + n * y + s * x + r * I;
            if (w === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            const R = 1 / w;
            return e[0] = v * R, e[1] = (g * d * r - u * p * r - g * s * f + n * p * f + u * s * m - n * d * m) * R, e[2] = (o * p * r - g * c * r + g * s * l - n * p * l - o * s * m + n * c * m) * R, e[3] = (u * c * r - o * d * r - u * s * l + n * d * l + o * s * f - n * c * f) * R, e[4] = y * R, e[5] = (h * p * r - _ * d * r + _ * s * f - t * p * f - h * s * m + t * d * m) * R, e[6] = (_ * c * r - a * p * r - _ * s * l + t * p * l + a * s * m - t * c * m) * R, e[7] = (a * d * r - h * c * r + h * s * l - t * d * l - a * s * f + t * c * f) * R, e[8] = x * R, e[9] = (_ * u * r - h * g * r - _ * n * f + t * g * f + h * n * m - t * u * m) * R, e[10] = (a * g * r - _ * o * r + _ * n * l - t * g * l - a * n * m + t * o * m) * R, e[11] = (h * o * r - a * u * r - h * n * l + t * u * l + a * n * f - t * o * f) * R, e[12] = I * R, e[13] = (h * g * s - _ * u * s + _ * n * d - t * g * d - h * n * p + t * u * p) * R, e[14] = (_ * o * s - a * g * s - _ * n * c + t * g * c + a * n * p - t * o * p) * R, e[15] = (a * u * s - h * o * s + h * n * c - t * u * c - a * n * d + t * o * d) * R, this;
        }
        scale(e) {
            const t = this.elements, n = e.x, s = e.y, r = e.z;
            return t[0] *= n, t[4] *= s, t[8] *= r, t[1] *= n, t[5] *= s, t[9] *= r, t[2] *= n, t[6] *= s, t[10] *= r, t[3] *= n, t[7] *= s, t[11] *= r, this;
        }
        getMaxScaleOnAxis() {
            const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], s = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
            return Math.sqrt(Math.max(t, n, s));
        }
        makeTranslation(e, t, n) {
            return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this;
        }
        makeRotationX(e) {
            const t = Math.cos(e), n = Math.sin(e);
            return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this;
        }
        makeRotationY(e) {
            const t = Math.cos(e), n = Math.sin(e);
            return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this;
        }
        makeRotationZ(e) {
            const t = Math.cos(e), n = Math.sin(e);
            return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        makeRotationAxis(e, t) {
            const n = Math.cos(t), s = Math.sin(t), r = 1 - n, a = e.x, o = e.y, c = e.z, l = r * a, h = r * o;
            return this.set(l * a + n, l * o - s * c, l * c + s * o, 0, l * o + s * c, h * o + n, h * c - s * a, 0, l * c - s * o, h * c + s * a, r * c * c + n, 0, 0, 0, 0, 1), this;
        }
        makeScale(e, t, n) {
            return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
        }
        makeShear(e, t, n, s, r, a) {
            return this.set(1, n, r, 0, e, 1, a, 0, t, s, 1, 0, 0, 0, 0, 1), this;
        }
        compose(e, t, n) {
            const s = this.elements, r = t._x, a = t._y, o = t._z, c = t._w, l = r + r, h = a + a, u = o + o, d = r * l, f = r * h, _ = r * u, g = a * h, p = a * u, m = o * u, v = c * l, y = c * h, x = c * u, I = n.x, w = n.y, R = n.z;
            return s[0] = (1 - (g + m)) * I, s[1] = (f + x) * I, s[2] = (_ - y) * I, s[3] = 0, s[4] = (f - x) * w, s[5] = (1 - (d + m)) * w, s[6] = (p + v) * w, s[7] = 0, s[8] = (_ + y) * R, s[9] = (p - v) * R, s[10] = (1 - (d + g)) * R, s[11] = 0, s[12] = e.x, s[13] = e.y, s[14] = e.z, s[15] = 1, this;
        }
        decompose(e, t, n) {
            const s = this.elements;
            let r = ss.set(s[0], s[1], s[2]).length();
            const a = ss.set(s[4], s[5], s[6]).length(), o = ss.set(s[8], s[9], s[10]).length();
            this.determinant() < 0 && (r = -r), e.x = s[12], e.y = s[13], e.z = s[14], gn.copy(this);
            const l = 1 / r, h = 1 / a, u = 1 / o;
            return gn.elements[0] *= l, gn.elements[1] *= l, gn.elements[2] *= l, gn.elements[4] *= h, gn.elements[5] *= h, gn.elements[6] *= h, gn.elements[8] *= u, gn.elements[9] *= u, gn.elements[10] *= u, t.setFromRotationMatrix(gn), n.x = r, n.y = a, n.z = o, this;
        }
        makePerspective(e, t, n, s, r, a, o = Zn) {
            const c = this.elements, l = 2 * r / (t - e), h = 2 * r / (n - s), u = (t + e) / (t - e), d = (n + s) / (n - s);
            let f, _;
            if (o === Zn) f = -(a + r) / (a - r), _ = -2 * a * r / (a - r);
            else if (o === Ga) f = -a / (a - r), _ = -a * r / (a - r);
            else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + o);
            return c[0] = l, c[4] = 0, c[8] = u, c[12] = 0, c[1] = 0, c[5] = h, c[9] = d, c[13] = 0, c[2] = 0, c[6] = 0, c[10] = f, c[14] = _, c[3] = 0, c[7] = 0, c[11] = -1, c[15] = 0, this;
        }
        makeOrthographic(e, t, n, s, r, a, o = Zn) {
            const c = this.elements, l = 1 / (t - e), h = 1 / (n - s), u = 1 / (a - r), d = (t + e) * l, f = (n + s) * h;
            let _, g;
            if (o === Zn) _ = (a + r) * u, g = -2 * u;
            else if (o === Ga) _ = r * u, g = -1 * u;
            else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + o);
            return c[0] = 2 * l, c[4] = 0, c[8] = 0, c[12] = -d, c[1] = 0, c[5] = 2 * h, c[9] = 0, c[13] = -f, c[2] = 0, c[6] = 0, c[10] = g, c[14] = -_, c[3] = 0, c[7] = 0, c[11] = 0, c[15] = 1, this;
        }
        equals(e) {
            const t = this.elements, n = e.elements;
            for(let s = 0; s < 16; s++)if (t[s] !== n[s]) return !1;
            return !0;
        }
        fromArray(e, t = 0) {
            for(let n = 0; n < 16; n++)this.elements[n] = e[n + t];
            return this;
        }
        toArray(e = [], t = 0) {
            const n = this.elements;
            return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e;
        }
    }
    const ss = new k, gn = new He, zg = new k(0, 0, 0), Vg = new k(1, 1, 1), ai = new k, Xr = new k, nn = new k, eu = new He, tu = new En;
    class Bn {
        constructor(e = 0, t = 0, n = 0, s = Bn.DEFAULT_ORDER){
            this.isEuler = !0, this._x = e, this._y = t, this._z = n, this._order = s;
        }
        get x() {
            return this._x;
        }
        set x(e) {
            this._x = e, this._onChangeCallback();
        }
        get y() {
            return this._y;
        }
        set y(e) {
            this._y = e, this._onChangeCallback();
        }
        get z() {
            return this._z;
        }
        set z(e) {
            this._z = e, this._onChangeCallback();
        }
        get order() {
            return this._order;
        }
        set order(e) {
            this._order = e, this._onChangeCallback();
        }
        set(e, t, n, s = this._order) {
            return this._x = e, this._y = t, this._z = n, this._order = s, this._onChangeCallback(), this;
        }
        clone() {
            return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(e) {
            return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
        }
        setFromRotationMatrix(e, t = this._order, n = !0) {
            const s = e.elements, r = s[0], a = s[4], o = s[8], c = s[1], l = s[5], h = s[9], u = s[2], d = s[6], f = s[10];
            switch(t){
                case "XYZ":
                    this._y = Math.asin(Ye(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-h, f), this._z = Math.atan2(-a, r)) : (this._x = Math.atan2(d, l), this._z = 0);
                    break;
                case "YXZ":
                    this._x = Math.asin(-Ye(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(o, f), this._z = Math.atan2(c, l)) : (this._y = Math.atan2(-u, r), this._z = 0);
                    break;
                case "ZXY":
                    this._x = Math.asin(Ye(d, -1, 1)), Math.abs(d) < .9999999 ? (this._y = Math.atan2(-u, f), this._z = Math.atan2(-a, l)) : (this._y = 0, this._z = Math.atan2(c, r));
                    break;
                case "ZYX":
                    this._y = Math.asin(-Ye(u, -1, 1)), Math.abs(u) < .9999999 ? (this._x = Math.atan2(d, f), this._z = Math.atan2(c, r)) : (this._x = 0, this._z = Math.atan2(-a, l));
                    break;
                case "YZX":
                    this._z = Math.asin(Ye(c, -1, 1)), Math.abs(c) < .9999999 ? (this._x = Math.atan2(-h, l), this._y = Math.atan2(-u, r)) : (this._x = 0, this._y = Math.atan2(o, f));
                    break;
                case "XZY":
                    this._z = Math.asin(-Ye(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(d, l), this._y = Math.atan2(o, r)) : (this._x = Math.atan2(-h, f), this._y = 0);
                    break;
                default:
                    console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
            }
            return this._order = t, n === !0 && this._onChangeCallback(), this;
        }
        setFromQuaternion(e, t, n) {
            return eu.makeRotationFromQuaternion(e), this.setFromRotationMatrix(eu, t, n);
        }
        setFromVector3(e, t = this._order) {
            return this.set(e.x, e.y, e.z, t);
        }
        reorder(e) {
            return tu.setFromEuler(this), this.setFromQuaternion(tu, e);
        }
        equals(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
        }
        fromArray(e) {
            return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
        }
        toArray(e = [], t = 0) {
            return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
        }
        _onChange(e) {
            return this._onChangeCallback = e, this;
        }
        _onChangeCallback() {}
        *[Symbol.iterator]() {
            yield this._x, yield this._y, yield this._z, yield this._order;
        }
    }
    Bn.DEFAULT_ORDER = "XYZ";
    class kf {
        constructor(){
            this.mask = 1;
        }
        set(e) {
            this.mask = (1 << e | 0) >>> 0;
        }
        enable(e) {
            this.mask |= 1 << e | 0;
        }
        enableAll() {
            this.mask = -1;
        }
        toggle(e) {
            this.mask ^= 1 << e | 0;
        }
        disable(e) {
            this.mask &= ~(1 << e | 0);
        }
        disableAll() {
            this.mask = 0;
        }
        test(e) {
            return (this.mask & e.mask) !== 0;
        }
        isEnabled(e) {
            return (this.mask & (1 << e | 0)) !== 0;
        }
    }
    let Wg = 0;
    const nu = new k, rs = new En, Vn = new He, Yr = new k, js = new k, Xg = new k, Yg = new En, iu = new k(1, 0, 0), su = new k(0, 1, 0), ru = new k(0, 0, 1), au = {
        type: "added"
    }, qg = {
        type: "removed"
    }, as = {
        type: "childadded",
        child: null
    }, po = {
        type: "childremoved",
        child: null
    };
    class gt extends ji {
        constructor(){
            super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
                value: Wg++
            }), this.uuid = Tn(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = gt.DEFAULT_UP.clone();
            const e = new k, t = new Bn, n = new En, s = new k(1, 1, 1);
            function r() {
                n.setFromEuler(t, !1);
            }
            function a() {
                t.setFromQuaternion(n, void 0, !1);
            }
            t._onChange(r), n._onChange(a), Object.defineProperties(this, {
                position: {
                    configurable: !0,
                    enumerable: !0,
                    value: e
                },
                rotation: {
                    configurable: !0,
                    enumerable: !0,
                    value: t
                },
                quaternion: {
                    configurable: !0,
                    enumerable: !0,
                    value: n
                },
                scale: {
                    configurable: !0,
                    enumerable: !0,
                    value: s
                },
                modelViewMatrix: {
                    value: new He
                },
                normalMatrix: {
                    value: new Ge
                }
            }), this.matrix = new He, this.matrixWorld = new He, this.matrixAutoUpdate = gt.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = gt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new kf, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.customDepthMaterial = void 0, this.customDistanceMaterial = void 0, this.userData = {};
        }
        onBeforeShadow() {}
        onAfterShadow() {}
        onBeforeRender() {}
        onAfterRender() {}
        applyMatrix4(e) {
            this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
        }
        applyQuaternion(e) {
            return this.quaternion.premultiply(e), this;
        }
        setRotationFromAxisAngle(e, t) {
            this.quaternion.setFromAxisAngle(e, t);
        }
        setRotationFromEuler(e) {
            this.quaternion.setFromEuler(e, !0);
        }
        setRotationFromMatrix(e) {
            this.quaternion.setFromRotationMatrix(e);
        }
        setRotationFromQuaternion(e) {
            this.quaternion.copy(e);
        }
        rotateOnAxis(e, t) {
            return rs.setFromAxisAngle(e, t), this.quaternion.multiply(rs), this;
        }
        rotateOnWorldAxis(e, t) {
            return rs.setFromAxisAngle(e, t), this.quaternion.premultiply(rs), this;
        }
        rotateX(e) {
            return this.rotateOnAxis(iu, e);
        }
        rotateY(e) {
            return this.rotateOnAxis(su, e);
        }
        rotateZ(e) {
            return this.rotateOnAxis(ru, e);
        }
        translateOnAxis(e, t) {
            return nu.copy(e).applyQuaternion(this.quaternion), this.position.add(nu.multiplyScalar(t)), this;
        }
        translateX(e) {
            return this.translateOnAxis(iu, e);
        }
        translateY(e) {
            return this.translateOnAxis(su, e);
        }
        translateZ(e) {
            return this.translateOnAxis(ru, e);
        }
        localToWorld(e) {
            return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
        }
        worldToLocal(e) {
            return this.updateWorldMatrix(!0, !1), e.applyMatrix4(Vn.copy(this.matrixWorld).invert());
        }
        lookAt(e, t, n) {
            e.isVector3 ? Yr.copy(e) : Yr.set(e, t, n);
            const s = this.parent;
            this.updateWorldMatrix(!0, !1), js.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Vn.lookAt(js, Yr, this.up) : Vn.lookAt(Yr, js, this.up), this.quaternion.setFromRotationMatrix(Vn), s && (Vn.extractRotation(s.matrixWorld), rs.setFromRotationMatrix(Vn), this.quaternion.premultiply(rs.invert()));
        }
        add(e) {
            if (arguments.length > 1) {
                for(let t = 0; t < arguments.length; t++)this.add(arguments[t]);
                return this;
            }
            return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(au), as.child = e, this.dispatchEvent(as), as.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
        }
        remove(e) {
            if (arguments.length > 1) {
                for(let n = 0; n < arguments.length; n++)this.remove(arguments[n]);
                return this;
            }
            const t = this.children.indexOf(e);
            return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(qg), po.child = e, this.dispatchEvent(po), po.child = null), this;
        }
        removeFromParent() {
            const e = this.parent;
            return e !== null && e.remove(this), this;
        }
        clear() {
            return this.remove(...this.children);
        }
        attach(e) {
            return this.updateWorldMatrix(!0, !1), Vn.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), Vn.multiply(e.parent.matrixWorld)), e.applyMatrix4(Vn), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(au), as.child = e, this.dispatchEvent(as), as.child = null, this;
        }
        getObjectById(e) {
            return this.getObjectByProperty("id", e);
        }
        getObjectByName(e) {
            return this.getObjectByProperty("name", e);
        }
        getObjectByProperty(e, t) {
            if (this[e] === t) return this;
            for(let n = 0, s = this.children.length; n < s; n++){
                const a = this.children[n].getObjectByProperty(e, t);
                if (a !== void 0) return a;
            }
        }
        getObjectsByProperty(e, t, n = []) {
            this[e] === t && n.push(this);
            const s = this.children;
            for(let r = 0, a = s.length; r < a; r++)s[r].getObjectsByProperty(e, t, n);
            return n;
        }
        getWorldPosition(e) {
            return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
        }
        getWorldQuaternion(e) {
            return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(js, e, Xg), e;
        }
        getWorldScale(e) {
            return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(js, Yg, e), e;
        }
        getWorldDirection(e) {
            this.updateWorldMatrix(!0, !1);
            const t = this.matrixWorld.elements;
            return e.set(t[8], t[9], t[10]).normalize();
        }
        raycast() {}
        traverse(e) {
            e(this);
            const t = this.children;
            for(let n = 0, s = t.length; n < s; n++)t[n].traverse(e);
        }
        traverseVisible(e) {
            if (this.visible === !1) return;
            e(this);
            const t = this.children;
            for(let n = 0, s = t.length; n < s; n++)t[n].traverseVisible(e);
        }
        traverseAncestors(e) {
            const t = this.parent;
            t !== null && (e(t), t.traverseAncestors(e));
        }
        updateMatrix() {
            this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
        }
        updateMatrixWorld(e) {
            this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, e = !0);
            const t = this.children;
            for(let n = 0, s = t.length; n < s; n++)t[n].updateMatrixWorld(e);
        }
        updateWorldMatrix(e, t) {
            const n = this.parent;
            if (e === !0 && n !== null && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), t === !0) {
                const s = this.children;
                for(let r = 0, a = s.length; r < a; r++)s[r].updateWorldMatrix(!1, !0);
            }
        }
        toJSON(e) {
            const t = e === void 0 || typeof e == "string", n = {};
            t && (e = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {},
                skeletons: {},
                animations: {},
                nodes: {}
            }, n.metadata = {
                version: 4.6,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            const s = {};
            s.uuid = this.uuid, s.type = this.type, this.name !== "" && (s.name = this.name), this.castShadow === !0 && (s.castShadow = !0), this.receiveShadow === !0 && (s.receiveShadow = !0), this.visible === !1 && (s.visible = !1), this.frustumCulled === !1 && (s.frustumCulled = !1), this.renderOrder !== 0 && (s.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (s.userData = this.userData), s.layers = this.layers.mask, s.matrix = this.matrix.toArray(), s.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (s.matrixAutoUpdate = !1), this.isInstancedMesh && (s.type = "InstancedMesh", s.count = this.count, s.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (s.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (s.type = "BatchedMesh", s.perObjectFrustumCulled = this.perObjectFrustumCulled, s.sortObjects = this.sortObjects, s.drawRanges = this._drawRanges, s.reservedRanges = this._reservedRanges, s.visibility = this._visibility, s.active = this._active, s.bounds = this._bounds.map((o)=>({
                    boxInitialized: o.boxInitialized,
                    boxMin: o.box.min.toArray(),
                    boxMax: o.box.max.toArray(),
                    sphereInitialized: o.sphereInitialized,
                    sphereRadius: o.sphere.radius,
                    sphereCenter: o.sphere.center.toArray()
                })), s.maxInstanceCount = this._maxInstanceCount, s.maxVertexCount = this._maxVertexCount, s.maxIndexCount = this._maxIndexCount, s.geometryInitialized = this._geometryInitialized, s.geometryCount = this._geometryCount, s.matricesTexture = this._matricesTexture.toJSON(e), this._colorsTexture !== null && (s.colorsTexture = this._colorsTexture.toJSON(e)), this.boundingSphere !== null && (s.boundingSphere = {
                center: s.boundingSphere.center.toArray(),
                radius: s.boundingSphere.radius
            }), this.boundingBox !== null && (s.boundingBox = {
                min: s.boundingBox.min.toArray(),
                max: s.boundingBox.max.toArray()
            }));
            function r(o, c) {
                return o[c.uuid] === void 0 && (o[c.uuid] = c.toJSON(e)), c.uuid;
            }
            if (this.isScene) this.background && (this.background.isColor ? s.background = this.background.toJSON() : this.background.isTexture && (s.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (s.environment = this.environment.toJSON(e).uuid);
            else if (this.isMesh || this.isLine || this.isPoints) {
                s.geometry = r(e.geometries, this.geometry);
                const o = this.geometry.parameters;
                if (o !== void 0 && o.shapes !== void 0) {
                    const c = o.shapes;
                    if (Array.isArray(c)) for(let l = 0, h = c.length; l < h; l++){
                        const u = c[l];
                        r(e.shapes, u);
                    }
                    else r(e.shapes, c);
                }
            }
            if (this.isSkinnedMesh && (s.bindMode = this.bindMode, s.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (r(e.skeletons, this.skeleton), s.skeleton = this.skeleton.uuid)), this.material !== void 0) if (Array.isArray(this.material)) {
                const o = [];
                for(let c = 0, l = this.material.length; c < l; c++)o.push(r(e.materials, this.material[c]));
                s.material = o;
            } else s.material = r(e.materials, this.material);
            if (this.children.length > 0) {
                s.children = [];
                for(let o = 0; o < this.children.length; o++)s.children.push(this.children[o].toJSON(e).object);
            }
            if (this.animations.length > 0) {
                s.animations = [];
                for(let o = 0; o < this.animations.length; o++){
                    const c = this.animations[o];
                    s.animations.push(r(e.animations, c));
                }
            }
            if (t) {
                const o = a(e.geometries), c = a(e.materials), l = a(e.textures), h = a(e.images), u = a(e.shapes), d = a(e.skeletons), f = a(e.animations), _ = a(e.nodes);
                o.length > 0 && (n.geometries = o), c.length > 0 && (n.materials = c), l.length > 0 && (n.textures = l), h.length > 0 && (n.images = h), u.length > 0 && (n.shapes = u), d.length > 0 && (n.skeletons = d), f.length > 0 && (n.animations = f), _.length > 0 && (n.nodes = _);
            }
            return n.object = s, n;
            function a(o) {
                const c = [];
                for(const l in o){
                    const h = o[l];
                    delete h.metadata, c.push(h);
                }
                return c;
            }
        }
        clone(e) {
            return new this.constructor().copy(this, e);
        }
        copy(e, t = !0) {
            if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0) for(let n = 0; n < e.children.length; n++){
                const s = e.children[n];
                this.add(s.clone());
            }
            return this;
        }
    }
    gt.DEFAULT_UP = new k(0, 1, 0);
    gt.DEFAULT_MATRIX_AUTO_UPDATE = !0;
    gt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
    const xn = new k, Wn = new k, mo = new k, Xn = new k, os = new k, cs = new k, ou = new k, _o = new k, go = new k, xo = new k, vo = new nt, yo = new nt, bo = new nt;
    class Sn {
        constructor(e = new k, t = new k, n = new k){
            this.a = e, this.b = t, this.c = n;
        }
        static getNormal(e, t, n, s) {
            s.subVectors(n, t), xn.subVectors(e, t), s.cross(xn);
            const r = s.lengthSq();
            return r > 0 ? s.multiplyScalar(1 / Math.sqrt(r)) : s.set(0, 0, 0);
        }
        static getBarycoord(e, t, n, s, r) {
            xn.subVectors(s, t), Wn.subVectors(n, t), mo.subVectors(e, t);
            const a = xn.dot(xn), o = xn.dot(Wn), c = xn.dot(mo), l = Wn.dot(Wn), h = Wn.dot(mo), u = a * l - o * o;
            if (u === 0) return r.set(0, 0, 0), null;
            const d = 1 / u, f = (l * c - o * h) * d, _ = (a * h - o * c) * d;
            return r.set(1 - f - _, _, f);
        }
        static containsPoint(e, t, n, s) {
            return this.getBarycoord(e, t, n, s, Xn) === null ? !1 : Xn.x >= 0 && Xn.y >= 0 && Xn.x + Xn.y <= 1;
        }
        static getInterpolation(e, t, n, s, r, a, o, c) {
            return this.getBarycoord(e, t, n, s, Xn) === null ? (c.x = 0, c.y = 0, "z" in c && (c.z = 0), "w" in c && (c.w = 0), null) : (c.setScalar(0), c.addScaledVector(r, Xn.x), c.addScaledVector(a, Xn.y), c.addScaledVector(o, Xn.z), c);
        }
        static getInterpolatedAttribute(e, t, n, s, r, a) {
            return vo.setScalar(0), yo.setScalar(0), bo.setScalar(0), vo.fromBufferAttribute(e, t), yo.fromBufferAttribute(e, n), bo.fromBufferAttribute(e, s), a.setScalar(0), a.addScaledVector(vo, r.x), a.addScaledVector(yo, r.y), a.addScaledVector(bo, r.z), a;
        }
        static isFrontFacing(e, t, n, s) {
            return xn.subVectors(n, t), Wn.subVectors(e, t), xn.cross(Wn).dot(s) < 0;
        }
        set(e, t, n) {
            return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
        }
        setFromPointsAndIndices(e, t, n, s) {
            return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[s]), this;
        }
        setFromAttributeAndIndices(e, t, n, s) {
            return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, s), this;
        }
        clone() {
            return new this.constructor().copy(this);
        }
        copy(e) {
            return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
        }
        getArea() {
            return xn.subVectors(this.c, this.b), Wn.subVectors(this.a, this.b), xn.cross(Wn).length() * .5;
        }
        getMidpoint(e) {
            return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
        }
        getNormal(e) {
            return Sn.getNormal(this.a, this.b, this.c, e);
        }
        getPlane(e) {
            return e.setFromCoplanarPoints(this.a, this.b, this.c);
        }
        getBarycoord(e, t) {
            return Sn.getBarycoord(e, this.a, this.b, this.c, t);
        }
        getInterpolation(e, t, n, s, r) {
            return Sn.getInterpolation(e, this.a, this.b, this.c, t, n, s, r);
        }
        containsPoint(e) {
            return Sn.containsPoint(e, this.a, this.b, this.c);
        }
        isFrontFacing(e) {
            return Sn.isFrontFacing(this.a, this.b, this.c, e);
        }
        intersectsBox(e) {
            return e.intersectsTriangle(this);
        }
        closestPointToPoint(e, t) {
            const n = this.a, s = this.b, r = this.c;
            let a, o;
            os.subVectors(s, n), cs.subVectors(r, n), _o.subVectors(e, n);
            const c = os.dot(_o), l = cs.dot(_o);
            if (c <= 0 && l <= 0) return t.copy(n);
            go.subVectors(e, s);
            const h = os.dot(go), u = cs.dot(go);
            if (h >= 0 && u <= h) return t.copy(s);
            const d = c * u - h * l;
            if (d <= 0 && c >= 0 && h <= 0) return a = c / (c - h), t.copy(n).addScaledVector(os, a);
            xo.subVectors(e, r);
            const f = os.dot(xo), _ = cs.dot(xo);
            if (_ >= 0 && f <= _) return t.copy(r);
            const g = f * l - c * _;
            if (g <= 0 && l >= 0 && _ <= 0) return o = l / (l - _), t.copy(n).addScaledVector(cs, o);
            const p = h * _ - f * u;
            if (p <= 0 && u - h >= 0 && f - _ >= 0) return ou.subVectors(r, s), o = (u - h) / (u - h + (f - _)), t.copy(s).addScaledVector(ou, o);
            const m = 1 / (p + g + d);
            return a = g * m, o = d * m, t.copy(n).addScaledVector(os, a).addScaledVector(cs, o);
        }
        equals(e) {
            return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
        }
    }
    const Gf = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    }, oi = {
        h: 0,
        s: 0,
        l: 0
    }, qr = {
        h: 0,
        s: 0,
        l: 0
    };
    function So(i, e, t) {
        return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? i + (e - i) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? i + (e - i) * 6 * (2 / 3 - t) : i;
    }
    let Be = class {
        constructor(e, t, n){
            return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, n);
        }
        set(e, t, n) {
            if (t === void 0 && n === void 0) {
                const s = e;
                s && s.isColor ? this.copy(s) : typeof s == "number" ? this.setHex(s) : typeof s == "string" && this.setStyle(s);
            } else this.setRGB(e, t, n);
            return this;
        }
        setScalar(e) {
            return this.r = e, this.g = e, this.b = e, this;
        }
        setHex(e, t = Dt) {
            return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, $e.toWorkingColorSpace(this, t), this;
        }
        setRGB(e, t, n, s = $e.workingColorSpace) {
            return this.r = e, this.g = t, this.b = n, $e.toWorkingColorSpace(this, s), this;
        }
        setHSL(e, t, n, s = $e.workingColorSpace) {
            if (e = ql(e, 1), t = Ye(t, 0, 1), n = Ye(n, 0, 1), t === 0) this.r = this.g = this.b = n;
            else {
                const r = n <= .5 ? n * (1 + t) : n + t - n * t, a = 2 * n - r;
                this.r = So(a, r, e + 1 / 3), this.g = So(a, r, e), this.b = So(a, r, e - 1 / 3);
            }
            return $e.toWorkingColorSpace(this, s), this;
        }
        setStyle(e, t = Dt) {
            function n(r) {
                r !== void 0 && parseFloat(r) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
            }
            let s;
            if (s = /^(\w+)\(([^\)]*)\)/.exec(e)) {
                let r;
                const a = s[1], o = s[2];
                switch(a){
                    case "rgb":
                    case "rgba":
                        if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return n(r[4]), this.setRGB(Math.min(255, parseInt(r[1], 10)) / 255, Math.min(255, parseInt(r[2], 10)) / 255, Math.min(255, parseInt(r[3], 10)) / 255, t);
                        if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return n(r[4]), this.setRGB(Math.min(100, parseInt(r[1], 10)) / 100, Math.min(100, parseInt(r[2], 10)) / 100, Math.min(100, parseInt(r[3], 10)) / 100, t);
                        break;
                    case "hsl":
                    case "hsla":
                        if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return n(r[4]), this.setHSL(parseFloat(r[1]) / 360, parseFloat(r[2]) / 100, parseFloat(r[3]) / 100, t);
                        break;
                    default:
                        console.warn("THREE.Color: Unknown color model " + e);
                }
            } else if (s = /^\#([A-Fa-f\d]+)$/.exec(e)) {
                const r = s[1], a = r.length;
                if (a === 3) return this.setRGB(parseInt(r.charAt(0), 16) / 15, parseInt(r.charAt(1), 16) / 15, parseInt(r.charAt(2), 16) / 15, t);
                if (a === 6) return this.setHex(parseInt(r, 16), t);
                console.warn("THREE.Color: Invalid hex color " + e);
            } else if (e && e.length > 0) return this.setColorName(e, t);
            return this;
        }
        setColorName(e, t = Dt) {
            const n = Gf[e.toLowerCase()];
            return n !== void 0 ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this;
        }
        clone() {
            return new this.constructor(this.r, this.g, this.b);
        }
        copy(e) {
            return this.r = e.r, this.g = e.g, this.b = e.b, this;
        }
        copySRGBToLinear(e) {
            return this.r = Jn(e.r), this.g = Jn(e.g), this.b = Jn(e.b), this;
        }
        copyLinearToSRGB(e) {
            return this.r = Ts(e.r), this.g = Ts(e.g), this.b = Ts(e.b), this;
        }
        convertSRGBToLinear() {
            return this.copySRGBToLinear(this), this;
        }
        convertLinearToSRGB() {
            return this.copyLinearToSRGB(this), this;
        }
        getHex(e = Dt) {
            return $e.fromWorkingColorSpace(Ot.copy(this), e), Math.round(Ye(Ot.r * 255, 0, 255)) * 65536 + Math.round(Ye(Ot.g * 255, 0, 255)) * 256 + Math.round(Ye(Ot.b * 255, 0, 255));
        }
        getHexString(e = Dt) {
            return ("000000" + this.getHex(e).toString(16)).slice(-6);
        }
        getHSL(e, t = $e.workingColorSpace) {
            $e.fromWorkingColorSpace(Ot.copy(this), t);
            const n = Ot.r, s = Ot.g, r = Ot.b, a = Math.max(n, s, r), o = Math.min(n, s, r);
            let c, l;
            const h = (o + a) / 2;
            if (o === a) c = 0, l = 0;
            else {
                const u = a - o;
                switch(l = h <= .5 ? u / (a + o) : u / (2 - a - o), a){
                    case n:
                        c = (s - r) / u + (s < r ? 6 : 0);
                        break;
                    case s:
                        c = (r - n) / u + 2;
                        break;
                    case r:
                        c = (n - s) / u + 4;
                        break;
                }
                c /= 6;
            }
            return e.h = c, e.s = l, e.l = h, e;
        }
        getRGB(e, t = $e.workingColorSpace) {
            return $e.fromWorkingColorSpace(Ot.copy(this), t), e.r = Ot.r, e.g = Ot.g, e.b = Ot.b, e;
        }
        getStyle(e = Dt) {
            $e.fromWorkingColorSpace(Ot.copy(this), e);
            const t = Ot.r, n = Ot.g, s = Ot.b;
            return e !== Dt ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${s.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(s * 255)})`;
        }
        offsetHSL(e, t, n) {
            return this.getHSL(oi), this.setHSL(oi.h + e, oi.s + t, oi.l + n);
        }
        add(e) {
            return this.r += e.r, this.g += e.g, this.b += e.b, this;
        }
        addColors(e, t) {
            return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
        }
        addScalar(e) {
            return this.r += e, this.g += e, this.b += e, this;
        }
        sub(e) {
            return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
        }
        multiply(e) {
            return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
        }
        multiplyScalar(e) {
            return this.r *= e, this.g *= e, this.b *= e, this;
        }
        lerp(e, t) {
            return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
        }
        lerpColors(e, t, n) {
            return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this;
        }
        lerpHSL(e, t) {
            this.getHSL(oi), e.getHSL(qr);
            const n = fr(oi.h, qr.h, t), s = fr(oi.s, qr.s, t), r = fr(oi.l, qr.l, t);
            return this.setHSL(n, s, r), this;
        }
        setFromVector3(e) {
            return this.r = e.x, this.g = e.y, this.b = e.z, this;
        }
        applyMatrix3(e) {
            const t = this.r, n = this.g, s = this.b, r = e.elements;
            return this.r = r[0] * t + r[3] * n + r[6] * s, this.g = r[1] * t + r[4] * n + r[7] * s, this.b = r[2] * t + r[5] * n + r[8] * s, this;
        }
        equals(e) {
            return e.r === this.r && e.g === this.g && e.b === this.b;
        }
        fromArray(e, t = 0) {
            return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
        }
        toArray(e = [], t = 0) {
            return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
        }
        fromBufferAttribute(e, t) {
            return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
        }
        toJSON() {
            return this.getHex();
        }
        *[Symbol.iterator]() {
            yield this.r, yield this.g, yield this.b;
        }
    };
    const Ot = new Be;
    Be.NAMES = Gf;
    let jg = 0;
    class Nn extends ji {
        constructor(){
            super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
                value: jg++
            }), this.uuid = Tn(), this.name = "", this.type = "Material", this.blending = Ms, this.side = ti, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = Mc, this.blendDst = Tc, this.blendEquation = Ni, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Be(0, 0, 0), this.blendAlpha = 0, this.depthFunc = ws, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = qh, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Qi, this.stencilZFail = Qi, this.stencilZPass = Qi, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.allowOverride = !0, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
        }
        get alphaTest() {
            return this._alphaTest;
        }
        set alphaTest(e) {
            this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
        }
        onBeforeRender() {}
        onBeforeCompile() {}
        customProgramCacheKey() {
            return this.onBeforeCompile.toString();
        }
        setValues(e) {
            if (e !== void 0) for(const t in e){
                const n = e[t];
                if (n === void 0) {
                    console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
                    continue;
                }
                const s = this[t];
                if (s === void 0) {
                    console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
                    continue;
                }
                s && s.isColor ? s.set(n) : s && s.isVector3 && n && n.isVector3 ? s.copy(n) : this[t] = n;
            }
        }
        toJSON(e) {
            const t = e === void 0 || typeof e == "string";
            t && (e = {
                textures: {},
                images: {}
            });
            const n = {
                metadata: {
                    version: 4.6,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };
            n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (n.dispersion = this.dispersion), this.iridescence !== void 0 && (n.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapRotation !== void 0 && (n.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== Ms && (n.blending = this.blending), this.side !== ti && (n.side = this.side), this.vertexColors === !0 && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = !0), this.blendSrc !== Mc && (n.blendSrc = this.blendSrc), this.blendDst !== Tc && (n.blendDst = this.blendDst), this.blendEquation !== Ni && (n.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha), this.depthFunc !== ws && (n.depthFunc = this.depthFunc), this.depthTest === !1 && (n.depthTest = this.depthTest), this.depthWrite === !1 && (n.depthWrite = this.depthWrite), this.colorWrite === !1 && (n.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== qh && (n.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (n.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== Qi && (n.stencilFail = this.stencilFail), this.stencilZFail !== Qi && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== Qi && (n.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaHash === !0 && (n.alphaHash = !0), this.alphaToCoverage === !0 && (n.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0), this.forceSinglePass === !0 && (n.forceSinglePass = !0), this.wireframe === !0 && (n.wireframe = !0), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (n.flatShading = !0), this.visible === !1 && (n.visible = !1), this.toneMapped === !1 && (n.toneMapped = !1), this.fog === !1 && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData);
            function s(r) {
                const a = [];
                for(const o in r){
                    const c = r[o];
                    delete c.metadata, a.push(c);
                }
                return a;
            }
            if (t) {
                const r = s(e.textures), a = s(e.images);
                r.length > 0 && (n.textures = r), a.length > 0 && (n.images = a);
            }
            return n;
        }
        clone() {
            return new this.constructor().copy(this);
        }
        copy(e) {
            this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
            const t = e.clippingPlanes;
            let n = null;
            if (t !== null) {
                const s = t.length;
                n = new Array(s);
                for(let r = 0; r !== s; ++r)n[r] = t[r].clone();
            }
            return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            });
        }
        set needsUpdate(e) {
            e === !0 && this.version++;
        }
        onBuild() {
            console.warn("Material: onBuild() has been removed.");
        }
    }
    class Fi extends Nn {
        constructor(e){
            super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Be(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Bn, this.combine = Sf, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
        }
        copy(e) {
            return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
        }
    }
    const Tt = new k, jr = new Ke;
    let $g = 0;
    class qt {
        constructor(e, t, n = !1){
            if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.isBufferAttribute = !0, Object.defineProperty(this, "id", {
                value: $g++
            }), this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = n, this.usage = ol, this.updateRanges = [], this.gpuType = Mn, this.version = 0;
        }
        onUploadCallback() {}
        set needsUpdate(e) {
            e === !0 && this.version++;
        }
        setUsage(e) {
            return this.usage = e, this;
        }
        addUpdateRange(e, t) {
            this.updateRanges.push({
                start: e,
                count: t
            });
        }
        clearUpdateRanges() {
            this.updateRanges.length = 0;
        }
        copy(e) {
            return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
        }
        copyAt(e, t, n) {
            e *= this.itemSize, n *= t.itemSize;
            for(let s = 0, r = this.itemSize; s < r; s++)this.array[e + s] = t.array[n + s];
            return this;
        }
        copyArray(e) {
            return this.array.set(e), this;
        }
        applyMatrix3(e) {
            if (this.itemSize === 2) for(let t = 0, n = this.count; t < n; t++)jr.fromBufferAttribute(this, t), jr.applyMatrix3(e), this.setXY(t, jr.x, jr.y);
            else if (this.itemSize === 3) for(let t = 0, n = this.count; t < n; t++)Tt.fromBufferAttribute(this, t), Tt.applyMatrix3(e), this.setXYZ(t, Tt.x, Tt.y, Tt.z);
            return this;
        }
        applyMatrix4(e) {
            for(let t = 0, n = this.count; t < n; t++)Tt.fromBufferAttribute(this, t), Tt.applyMatrix4(e), this.setXYZ(t, Tt.x, Tt.y, Tt.z);
            return this;
        }
        applyNormalMatrix(e) {
            for(let t = 0, n = this.count; t < n; t++)Tt.fromBufferAttribute(this, t), Tt.applyNormalMatrix(e), this.setXYZ(t, Tt.x, Tt.y, Tt.z);
            return this;
        }
        transformDirection(e) {
            for(let t = 0, n = this.count; t < n; t++)Tt.fromBufferAttribute(this, t), Tt.transformDirection(e), this.setXYZ(t, Tt.x, Tt.y, Tt.z);
            return this;
        }
        set(e, t = 0) {
            return this.array.set(e, t), this;
        }
        getComponent(e, t) {
            let n = this.array[e * this.itemSize + t];
            return this.normalized && (n = bn(n, this.array)), n;
        }
        setComponent(e, t, n) {
            return this.normalized && (n = ot(n, this.array)), this.array[e * this.itemSize + t] = n, this;
        }
        getX(e) {
            let t = this.array[e * this.itemSize];
            return this.normalized && (t = bn(t, this.array)), t;
        }
        setX(e, t) {
            return this.normalized && (t = ot(t, this.array)), this.array[e * this.itemSize] = t, this;
        }
        getY(e) {
            let t = this.array[e * this.itemSize + 1];
            return this.normalized && (t = bn(t, this.array)), t;
        }
        setY(e, t) {
            return this.normalized && (t = ot(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
        }
        getZ(e) {
            let t = this.array[e * this.itemSize + 2];
            return this.normalized && (t = bn(t, this.array)), t;
        }
        setZ(e, t) {
            return this.normalized && (t = ot(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
        }
        getW(e) {
            let t = this.array[e * this.itemSize + 3];
            return this.normalized && (t = bn(t, this.array)), t;
        }
        setW(e, t) {
            return this.normalized && (t = ot(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
        }
        setXY(e, t, n) {
            return e *= this.itemSize, this.normalized && (t = ot(t, this.array), n = ot(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this;
        }
        setXYZ(e, t, n, s) {
            return e *= this.itemSize, this.normalized && (t = ot(t, this.array), n = ot(n, this.array), s = ot(s, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = s, this;
        }
        setXYZW(e, t, n, s, r) {
            return e *= this.itemSize, this.normalized && (t = ot(t, this.array), n = ot(n, this.array), s = ot(s, this.array), r = ot(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = s, this.array[e + 3] = r, this;
        }
        onUpload(e) {
            return this.onUploadCallback = e, this;
        }
        clone() {
            return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
            const e = {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: Array.from(this.array),
                normalized: this.normalized
            };
            return this.name !== "" && (e.name = this.name), this.usage !== ol && (e.usage = this.usage), e;
        }
    }
    class Hf extends qt {
        constructor(e, t, n){
            super(new Uint16Array(e), t, n);
        }
    }
    class zf extends qt {
        constructor(e, t, n){
            super(new Uint32Array(e), t, n);
        }
    }
    class Qn extends qt {
        constructor(e, t, n){
            super(new Float32Array(e), t, n);
        }
    }
    let Kg = 0;
    const ln = new He, Mo = new gt, ls = new k, sn = new fn, $s = new fn, wt = new k;
    class On extends ji {
        constructor(){
            super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
                value: Kg++
            }), this.uuid = Tn(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                start: 0,
                count: 1 / 0
            }, this.userData = {};
        }
        getIndex() {
            return this.index;
        }
        setIndex(e) {
            return Array.isArray(e) ? this.index = new (Ff(e) ? zf : Hf)(e, 1) : this.index = e, this;
        }
        setIndirect(e) {
            return this.indirect = e, this;
        }
        getIndirect() {
            return this.indirect;
        }
        getAttribute(e) {
            return this.attributes[e];
        }
        setAttribute(e, t) {
            return this.attributes[e] = t, this;
        }
        deleteAttribute(e) {
            return delete this.attributes[e], this;
        }
        hasAttribute(e) {
            return this.attributes[e] !== void 0;
        }
        addGroup(e, t, n = 0) {
            this.groups.push({
                start: e,
                count: t,
                materialIndex: n
            });
        }
        clearGroups() {
            this.groups = [];
        }
        setDrawRange(e, t) {
            this.drawRange.start = e, this.drawRange.count = t;
        }
        applyMatrix4(e) {
            const t = this.attributes.position;
            t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
            const n = this.attributes.normal;
            if (n !== void 0) {
                const r = new Ge().getNormalMatrix(e);
                n.applyNormalMatrix(r), n.needsUpdate = !0;
            }
            const s = this.attributes.tangent;
            return s !== void 0 && (s.transformDirection(e), s.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
        }
        applyQuaternion(e) {
            return ln.makeRotationFromQuaternion(e), this.applyMatrix4(ln), this;
        }
        rotateX(e) {
            return ln.makeRotationX(e), this.applyMatrix4(ln), this;
        }
        rotateY(e) {
            return ln.makeRotationY(e), this.applyMatrix4(ln), this;
        }
        rotateZ(e) {
            return ln.makeRotationZ(e), this.applyMatrix4(ln), this;
        }
        translate(e, t, n) {
            return ln.makeTranslation(e, t, n), this.applyMatrix4(ln), this;
        }
        scale(e, t, n) {
            return ln.makeScale(e, t, n), this.applyMatrix4(ln), this;
        }
        lookAt(e) {
            return Mo.lookAt(e), Mo.updateMatrix(), this.applyMatrix4(Mo.matrix), this;
        }
        center() {
            return this.computeBoundingBox(), this.boundingBox.getCenter(ls).negate(), this.translate(ls.x, ls.y, ls.z), this;
        }
        setFromPoints(e) {
            const t = this.getAttribute("position");
            if (t === void 0) {
                const n = [];
                for(let s = 0, r = e.length; s < r; s++){
                    const a = e[s];
                    n.push(a.x, a.y, a.z || 0);
                }
                this.setAttribute("position", new Qn(n, 3));
            } else {
                const n = Math.min(e.length, t.count);
                for(let s = 0; s < n; s++){
                    const r = e[s];
                    t.setXYZ(s, r.x, r.y, r.z || 0);
                }
                e.length > t.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), t.needsUpdate = !0;
            }
            return this;
        }
        computeBoundingBox() {
            this.boundingBox === null && (this.boundingBox = new fn);
            const e = this.attributes.position, t = this.morphAttributes.position;
            if (e && e.isGLBufferAttribute) {
                console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(new k(-1 / 0, -1 / 0, -1 / 0), new k(1 / 0, 1 / 0, 1 / 0));
                return;
            }
            if (e !== void 0) {
                if (this.boundingBox.setFromBufferAttribute(e), t) for(let n = 0, s = t.length; n < s; n++){
                    const r = t[n];
                    sn.setFromBufferAttribute(r), this.morphTargetsRelative ? (wt.addVectors(this.boundingBox.min, sn.min), this.boundingBox.expandByPoint(wt), wt.addVectors(this.boundingBox.max, sn.max), this.boundingBox.expandByPoint(wt)) : (this.boundingBox.expandByPoint(sn.min), this.boundingBox.expandByPoint(sn.max));
                }
            } else this.boundingBox.makeEmpty();
            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
        }
        computeBoundingSphere() {
            this.boundingSphere === null && (this.boundingSphere = new Fn);
            const e = this.attributes.position, t = this.morphAttributes.position;
            if (e && e.isGLBufferAttribute) {
                console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new k, 1 / 0);
                return;
            }
            if (e) {
                const n = this.boundingSphere.center;
                if (sn.setFromBufferAttribute(e), t) for(let r = 0, a = t.length; r < a; r++){
                    const o = t[r];
                    $s.setFromBufferAttribute(o), this.morphTargetsRelative ? (wt.addVectors(sn.min, $s.min), sn.expandByPoint(wt), wt.addVectors(sn.max, $s.max), sn.expandByPoint(wt)) : (sn.expandByPoint($s.min), sn.expandByPoint($s.max));
                }
                sn.getCenter(n);
                let s = 0;
                for(let r = 0, a = e.count; r < a; r++)wt.fromBufferAttribute(e, r), s = Math.max(s, n.distanceToSquared(wt));
                if (t) for(let r = 0, a = t.length; r < a; r++){
                    const o = t[r], c = this.morphTargetsRelative;
                    for(let l = 0, h = o.count; l < h; l++)wt.fromBufferAttribute(o, l), c && (ls.fromBufferAttribute(e, l), wt.add(ls)), s = Math.max(s, n.distanceToSquared(wt));
                }
                this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
            }
        }
        computeTangents() {
            const e = this.index, t = this.attributes;
            if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
                console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                return;
            }
            const n = t.position, s = t.normal, r = t.uv;
            this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new qt(new Float32Array(4 * n.count), 4));
            const a = this.getAttribute("tangent"), o = [], c = [];
            for(let N = 0; N < n.count; N++)o[N] = new k, c[N] = new k;
            const l = new k, h = new k, u = new k, d = new Ke, f = new Ke, _ = new Ke, g = new k, p = new k;
            function m(N, E, S) {
                l.fromBufferAttribute(n, N), h.fromBufferAttribute(n, E), u.fromBufferAttribute(n, S), d.fromBufferAttribute(r, N), f.fromBufferAttribute(r, E), _.fromBufferAttribute(r, S), h.sub(l), u.sub(l), f.sub(d), _.sub(d);
                const D = 1 / (f.x * _.y - _.x * f.y);
                isFinite(D) && (g.copy(h).multiplyScalar(_.y).addScaledVector(u, -f.y).multiplyScalar(D), p.copy(u).multiplyScalar(f.x).addScaledVector(h, -_.x).multiplyScalar(D), o[N].add(g), o[E].add(g), o[S].add(g), c[N].add(p), c[E].add(p), c[S].add(p));
            }
            let v = this.groups;
            v.length === 0 && (v = [
                {
                    start: 0,
                    count: e.count
                }
            ]);
            for(let N = 0, E = v.length; N < E; ++N){
                const S = v[N], D = S.start, j = S.count;
                for(let z = D, K = D + j; z < K; z += 3)m(e.getX(z + 0), e.getX(z + 1), e.getX(z + 2));
            }
            const y = new k, x = new k, I = new k, w = new k;
            function R(N) {
                I.fromBufferAttribute(s, N), w.copy(I);
                const E = o[N];
                y.copy(E), y.sub(I.multiplyScalar(I.dot(E))).normalize(), x.crossVectors(w, E);
                const D = x.dot(c[N]) < 0 ? -1 : 1;
                a.setXYZW(N, y.x, y.y, y.z, D);
            }
            for(let N = 0, E = v.length; N < E; ++N){
                const S = v[N], D = S.start, j = S.count;
                for(let z = D, K = D + j; z < K; z += 3)R(e.getX(z + 0)), R(e.getX(z + 1)), R(e.getX(z + 2));
            }
        }
        computeVertexNormals() {
            const e = this.index, t = this.getAttribute("position");
            if (t !== void 0) {
                let n = this.getAttribute("normal");
                if (n === void 0) n = new qt(new Float32Array(t.count * 3), 3), this.setAttribute("normal", n);
                else for(let d = 0, f = n.count; d < f; d++)n.setXYZ(d, 0, 0, 0);
                const s = new k, r = new k, a = new k, o = new k, c = new k, l = new k, h = new k, u = new k;
                if (e) for(let d = 0, f = e.count; d < f; d += 3){
                    const _ = e.getX(d + 0), g = e.getX(d + 1), p = e.getX(d + 2);
                    s.fromBufferAttribute(t, _), r.fromBufferAttribute(t, g), a.fromBufferAttribute(t, p), h.subVectors(a, r), u.subVectors(s, r), h.cross(u), o.fromBufferAttribute(n, _), c.fromBufferAttribute(n, g), l.fromBufferAttribute(n, p), o.add(h), c.add(h), l.add(h), n.setXYZ(_, o.x, o.y, o.z), n.setXYZ(g, c.x, c.y, c.z), n.setXYZ(p, l.x, l.y, l.z);
                }
                else for(let d = 0, f = t.count; d < f; d += 3)s.fromBufferAttribute(t, d + 0), r.fromBufferAttribute(t, d + 1), a.fromBufferAttribute(t, d + 2), h.subVectors(a, r), u.subVectors(s, r), h.cross(u), n.setXYZ(d + 0, h.x, h.y, h.z), n.setXYZ(d + 1, h.x, h.y, h.z), n.setXYZ(d + 2, h.x, h.y, h.z);
                this.normalizeNormals(), n.needsUpdate = !0;
            }
        }
        normalizeNormals() {
            const e = this.attributes.normal;
            for(let t = 0, n = e.count; t < n; t++)wt.fromBufferAttribute(e, t), wt.normalize(), e.setXYZ(t, wt.x, wt.y, wt.z);
        }
        toNonIndexed() {
            function e(o, c) {
                const l = o.array, h = o.itemSize, u = o.normalized, d = new l.constructor(c.length * h);
                let f = 0, _ = 0;
                for(let g = 0, p = c.length; g < p; g++){
                    o.isInterleavedBufferAttribute ? f = c[g] * o.data.stride + o.offset : f = c[g] * h;
                    for(let m = 0; m < h; m++)d[_++] = l[f++];
                }
                return new qt(d, h, u);
            }
            if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
            const t = new On, n = this.index.array, s = this.attributes;
            for(const o in s){
                const c = s[o], l = e(c, n);
                t.setAttribute(o, l);
            }
            const r = this.morphAttributes;
            for(const o in r){
                const c = [], l = r[o];
                for(let h = 0, u = l.length; h < u; h++){
                    const d = l[h], f = e(d, n);
                    c.push(f);
                }
                t.morphAttributes[o] = c;
            }
            t.morphTargetsRelative = this.morphTargetsRelative;
            const a = this.groups;
            for(let o = 0, c = a.length; o < c; o++){
                const l = a[o];
                t.addGroup(l.start, l.count, l.materialIndex);
            }
            return t;
        }
        toJSON() {
            const e = {
                metadata: {
                    version: 4.6,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
                const c = this.parameters;
                for(const l in c)c[l] !== void 0 && (e[l] = c[l]);
                return e;
            }
            e.data = {
                attributes: {}
            };
            const t = this.index;
            t !== null && (e.data.index = {
                type: t.array.constructor.name,
                array: Array.prototype.slice.call(t.array)
            });
            const n = this.attributes;
            for(const c in n){
                const l = n[c];
                e.data.attributes[c] = l.toJSON(e.data);
            }
            const s = {};
            let r = !1;
            for(const c in this.morphAttributes){
                const l = this.morphAttributes[c], h = [];
                for(let u = 0, d = l.length; u < d; u++){
                    const f = l[u];
                    h.push(f.toJSON(e.data));
                }
                h.length > 0 && (s[c] = h, r = !0);
            }
            r && (e.data.morphAttributes = s, e.data.morphTargetsRelative = this.morphTargetsRelative);
            const a = this.groups;
            a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
            const o = this.boundingSphere;
            return o !== null && (e.data.boundingSphere = {
                center: o.center.toArray(),
                radius: o.radius
            }), e;
        }
        clone() {
            return new this.constructor().copy(this);
        }
        copy(e) {
            this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
            const t = {};
            this.name = e.name;
            const n = e.index;
            n !== null && this.setIndex(n.clone());
            const s = e.attributes;
            for(const l in s){
                const h = s[l];
                this.setAttribute(l, h.clone(t));
            }
            const r = e.morphAttributes;
            for(const l in r){
                const h = [], u = r[l];
                for(let d = 0, f = u.length; d < f; d++)h.push(u[d].clone(t));
                this.morphAttributes[l] = h;
            }
            this.morphTargetsRelative = e.morphTargetsRelative;
            const a = e.groups;
            for(let l = 0, h = a.length; l < h; l++){
                const u = a[l];
                this.addGroup(u.start, u.count, u.materialIndex);
            }
            const o = e.boundingBox;
            o !== null && (this.boundingBox = o.clone());
            const c = e.boundingSphere;
            return c !== null && (this.boundingSphere = c.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            });
        }
    }
    const cu = new He, Mi = new Ka, $r = new Fn, lu = new k, Kr = new k, Zr = new k, Jr = new k, To = new k, Qr = new k, hu = new k, ea = new k;
    class kt extends gt {
        constructor(e = new On, t = new Fi){
            super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets();
        }
        copy(e, t) {
            return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
        }
        updateMorphTargets() {
            const t = this.geometry.morphAttributes, n = Object.keys(t);
            if (n.length > 0) {
                const s = t[n[0]];
                if (s !== void 0) {
                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                    for(let r = 0, a = s.length; r < a; r++){
                        const o = s[r].name || String(r);
                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = r;
                    }
                }
            }
        }
        getVertexPosition(e, t) {
            const n = this.geometry, s = n.attributes.position, r = n.morphAttributes.position, a = n.morphTargetsRelative;
            t.fromBufferAttribute(s, e);
            const o = this.morphTargetInfluences;
            if (r && o) {
                Qr.set(0, 0, 0);
                for(let c = 0, l = r.length; c < l; c++){
                    const h = o[c], u = r[c];
                    h !== 0 && (To.fromBufferAttribute(u, e), a ? Qr.addScaledVector(To, h) : Qr.addScaledVector(To.sub(t), h));
                }
                t.add(Qr);
            }
            return t;
        }
        raycast(e, t) {
            const n = this.geometry, s = this.material, r = this.matrixWorld;
            s !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(), $r.copy(n.boundingSphere), $r.applyMatrix4(r), Mi.copy(e.ray).recast(e.near), !($r.containsPoint(Mi.origin) === !1 && (Mi.intersectSphere($r, lu) === null || Mi.origin.distanceToSquared(lu) > (e.far - e.near) ** 2)) && (cu.copy(r).invert(), Mi.copy(e.ray).applyMatrix4(cu), !(n.boundingBox !== null && Mi.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(e, t, Mi)));
        }
        _computeIntersections(e, t, n) {
            let s;
            const r = this.geometry, a = this.material, o = r.index, c = r.attributes.position, l = r.attributes.uv, h = r.attributes.uv1, u = r.attributes.normal, d = r.groups, f = r.drawRange;
            if (o !== null) if (Array.isArray(a)) for(let _ = 0, g = d.length; _ < g; _++){
                const p = d[_], m = a[p.materialIndex], v = Math.max(p.start, f.start), y = Math.min(o.count, Math.min(p.start + p.count, f.start + f.count));
                for(let x = v, I = y; x < I; x += 3){
                    const w = o.getX(x), R = o.getX(x + 1), N = o.getX(x + 2);
                    s = ta(this, m, e, n, l, h, u, w, R, N), s && (s.faceIndex = Math.floor(x / 3), s.face.materialIndex = p.materialIndex, t.push(s));
                }
            }
            else {
                const _ = Math.max(0, f.start), g = Math.min(o.count, f.start + f.count);
                for(let p = _, m = g; p < m; p += 3){
                    const v = o.getX(p), y = o.getX(p + 1), x = o.getX(p + 2);
                    s = ta(this, a, e, n, l, h, u, v, y, x), s && (s.faceIndex = Math.floor(p / 3), t.push(s));
                }
            }
            else if (c !== void 0) if (Array.isArray(a)) for(let _ = 0, g = d.length; _ < g; _++){
                const p = d[_], m = a[p.materialIndex], v = Math.max(p.start, f.start), y = Math.min(c.count, Math.min(p.start + p.count, f.start + f.count));
                for(let x = v, I = y; x < I; x += 3){
                    const w = x, R = x + 1, N = x + 2;
                    s = ta(this, m, e, n, l, h, u, w, R, N), s && (s.faceIndex = Math.floor(x / 3), s.face.materialIndex = p.materialIndex, t.push(s));
                }
            }
            else {
                const _ = Math.max(0, f.start), g = Math.min(c.count, f.start + f.count);
                for(let p = _, m = g; p < m; p += 3){
                    const v = p, y = p + 1, x = p + 2;
                    s = ta(this, a, e, n, l, h, u, v, y, x), s && (s.faceIndex = Math.floor(p / 3), t.push(s));
                }
            }
        }
    }
    function Zg(i, e, t, n, s, r, a, o) {
        let c;
        if (e.side === Jt ? c = n.intersectTriangle(a, r, s, !0, o) : c = n.intersectTriangle(s, r, a, e.side === ti, o), c === null) return null;
        ea.copy(o), ea.applyMatrix4(i.matrixWorld);
        const l = t.ray.origin.distanceTo(ea);
        return l < t.near || l > t.far ? null : {
            distance: l,
            point: ea.clone(),
            object: i
        };
    }
    function ta(i, e, t, n, s, r, a, o, c, l) {
        i.getVertexPosition(o, Kr), i.getVertexPosition(c, Zr), i.getVertexPosition(l, Jr);
        const h = Zg(i, e, t, n, Kr, Zr, Jr, hu);
        if (h) {
            const u = new k;
            Sn.getBarycoord(hu, Kr, Zr, Jr, u), s && (h.uv = Sn.getInterpolatedAttribute(s, o, c, l, u, new Ke)), r && (h.uv1 = Sn.getInterpolatedAttribute(r, o, c, l, u, new Ke)), a && (h.normal = Sn.getInterpolatedAttribute(a, o, c, l, u, new k), h.normal.dot(n.direction) > 0 && h.normal.multiplyScalar(-1));
            const d = {
                a: o,
                b: c,
                c: l,
                normal: new k,
                materialIndex: 0
            };
            Sn.getNormal(Kr, Zr, Jr, d.normal), h.face = d, h.barycoord = u;
        }
        return h;
    }
    class ks extends On {
        constructor(e = 1, t = 1, n = 1, s = 1, r = 1, a = 1){
            super(), this.type = "BoxGeometry", this.parameters = {
                width: e,
                height: t,
                depth: n,
                widthSegments: s,
                heightSegments: r,
                depthSegments: a
            };
            const o = this;
            s = Math.floor(s), r = Math.floor(r), a = Math.floor(a);
            const c = [], l = [], h = [], u = [];
            let d = 0, f = 0;
            _("z", "y", "x", -1, -1, n, t, e, a, r, 0), _("z", "y", "x", 1, -1, n, t, -e, a, r, 1), _("x", "z", "y", 1, 1, e, n, t, s, a, 2), _("x", "z", "y", 1, -1, e, n, -t, s, a, 3), _("x", "y", "z", 1, -1, e, t, n, s, r, 4), _("x", "y", "z", -1, -1, e, t, -n, s, r, 5), this.setIndex(c), this.setAttribute("position", new Qn(l, 3)), this.setAttribute("normal", new Qn(h, 3)), this.setAttribute("uv", new Qn(u, 2));
            function _(g, p, m, v, y, x, I, w, R, N, E) {
                const S = x / R, D = I / N, j = x / 2, z = I / 2, K = w / 2, ne = R + 1, b = N + 1;
                let C = 0, A = 0;
                const U = new k;
                for(let B = 0; B < b; B++){
                    const V = B * D - z;
                    for(let q = 0; q < ne; q++){
                        const te = q * S - j;
                        U[g] = te * v, U[p] = V * y, U[m] = K, l.push(U.x, U.y, U.z), U[g] = 0, U[p] = 0, U[m] = w > 0 ? 1 : -1, h.push(U.x, U.y, U.z), u.push(q / R), u.push(1 - B / N), C += 1;
                    }
                }
                for(let B = 0; B < N; B++)for(let V = 0; V < R; V++){
                    const q = d + V + ne * B, te = d + V + ne * (B + 1), H = d + (V + 1) + ne * (B + 1), $ = d + (V + 1) + ne * B;
                    c.push(q, te, $), c.push(te, H, $), A += 6;
                }
                o.addGroup(f, A, E), f += A, d += C;
            }
        }
        copy(e) {
            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
        }
        static fromJSON(e) {
            return new ks(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
        }
    }
    function Ds(i) {
        const e = {};
        for(const t in i){
            e[t] = {};
            for(const n in i[t]){
                const s = i[t][n];
                s && (s.isColor || s.isMatrix3 || s.isMatrix4 || s.isVector2 || s.isVector3 || s.isVector4 || s.isTexture || s.isQuaternion) ? s.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][n] = null) : e[t][n] = s.clone() : Array.isArray(s) ? e[t][n] = s.slice() : e[t][n] = s;
            }
        }
        return e;
    }
    function Vt(i) {
        const e = {};
        for(let t = 0; t < i.length; t++){
            const n = Ds(i[t]);
            for(const s in n)e[s] = n[s];
        }
        return e;
    }
    function Jg(i) {
        const e = [];
        for(let t = 0; t < i.length; t++)e.push(i[t].clone());
        return e;
    }
    function Vf(i) {
        const e = i.getRenderTarget();
        return e === null ? i.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : $e.workingColorSpace;
    }
    const Qg = {
        clone: Ds,
        merge: Vt
    };
    var ex = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, tx = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
    class xi extends Nn {
        constructor(e){
            super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = ex, this.fragmentShader = tx, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
                clipCullDistance: !1,
                multiDraw: !1
            }, this.defaultAttributeValues = {
                color: [
                    1,
                    1,
                    1
                ],
                uv: [
                    0,
                    0
                ],
                uv1: [
                    0,
                    0
                ]
            }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e);
        }
        copy(e) {
            return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Ds(e.uniforms), this.uniformsGroups = Jg(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
        }
        toJSON(e) {
            const t = super.toJSON(e);
            t.glslVersion = this.glslVersion, t.uniforms = {};
            for(const s in this.uniforms){
                const a = this.uniforms[s].value;
                a && a.isTexture ? t.uniforms[s] = {
                    type: "t",
                    value: a.toJSON(e).uuid
                } : a && a.isColor ? t.uniforms[s] = {
                    type: "c",
                    value: a.getHex()
                } : a && a.isVector2 ? t.uniforms[s] = {
                    type: "v2",
                    value: a.toArray()
                } : a && a.isVector3 ? t.uniforms[s] = {
                    type: "v3",
                    value: a.toArray()
                } : a && a.isVector4 ? t.uniforms[s] = {
                    type: "v4",
                    value: a.toArray()
                } : a && a.isMatrix3 ? t.uniforms[s] = {
                    type: "m3",
                    value: a.toArray()
                } : a && a.isMatrix4 ? t.uniforms[s] = {
                    type: "m4",
                    value: a.toArray()
                } : t.uniforms[s] = {
                    value: a
                };
            }
            Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
            const n = {};
            for(const s in this.extensions)this.extensions[s] === !0 && (n[s] = !0);
            return Object.keys(n).length > 0 && (t.extensions = n), t;
        }
    }
    class Wf extends gt {
        constructor(){
            super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new He, this.projectionMatrix = new He, this.projectionMatrixInverse = new He, this.coordinateSystem = Zn;
        }
        copy(e, t) {
            return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
        }
        getWorldDirection(e) {
            return super.getWorldDirection(e).negate();
        }
        updateMatrixWorld(e) {
            super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        updateWorldMatrix(e, t) {
            super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        clone() {
            return new this.constructor().copy(this);
        }
    }
    const ci = new k, uu = new Ke, du = new Ke;
    class Wt extends Wf {
        constructor(e = 50, t = 1, n = .1, s = 2e3){
            super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = s, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
        }
        copy(e, t) {
            return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
        }
        setFocalLength(e) {
            const t = .5 * this.getFilmHeight() / e;
            this.fov = Is * 2 * Math.atan(t), this.updateProjectionMatrix();
        }
        getFocalLength() {
            const e = Math.tan(dr * .5 * this.fov);
            return .5 * this.getFilmHeight() / e;
        }
        getEffectiveFOV() {
            return Is * 2 * Math.atan(Math.tan(dr * .5 * this.fov) / this.zoom);
        }
        getFilmWidth() {
            return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
            return this.filmGauge / Math.max(this.aspect, 1);
        }
        getViewBounds(e, t, n) {
            ci.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse), t.set(ci.x, ci.y).multiplyScalar(-e / ci.z), ci.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse), n.set(ci.x, ci.y).multiplyScalar(-e / ci.z);
        }
        getViewSize(e, t) {
            return this.getViewBounds(e, uu, du), t.subVectors(du, uu);
        }
        setViewOffset(e, t, n, s, r, a) {
            this.aspect = e / t, this.view === null && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = s, this.view.width = r, this.view.height = a, this.updateProjectionMatrix();
        }
        clearViewOffset() {
            this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
            const e = this.near;
            let t = e * Math.tan(dr * .5 * this.fov) / this.zoom, n = 2 * t, s = this.aspect * n, r = -.5 * s;
            const a = this.view;
            if (this.view !== null && this.view.enabled) {
                const c = a.fullWidth, l = a.fullHeight;
                r += a.offsetX * s / c, t -= a.offsetY * n / l, s *= a.width / c, n *= a.height / l;
            }
            const o = this.filmOffset;
            o !== 0 && (r += e * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + s, t, t - n, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
        }
    }
    const hs = -90, us = 1;
    class nx extends gt {
        constructor(e, t, n){
            super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0;
            const s = new Wt(hs, us, e, t);
            s.layers = this.layers, this.add(s);
            const r = new Wt(hs, us, e, t);
            r.layers = this.layers, this.add(r);
            const a = new Wt(hs, us, e, t);
            a.layers = this.layers, this.add(a);
            const o = new Wt(hs, us, e, t);
            o.layers = this.layers, this.add(o);
            const c = new Wt(hs, us, e, t);
            c.layers = this.layers, this.add(c);
            const l = new Wt(hs, us, e, t);
            l.layers = this.layers, this.add(l);
        }
        updateCoordinateSystem() {
            const e = this.coordinateSystem, t = this.children.concat(), [n, s, r, a, o, c] = t;
            for (const l of t)this.remove(l);
            if (e === Zn) n.up.set(0, 1, 0), n.lookAt(1, 0, 0), s.up.set(0, 1, 0), s.lookAt(-1, 0, 0), r.up.set(0, 0, -1), r.lookAt(0, 1, 0), a.up.set(0, 0, 1), a.lookAt(0, -1, 0), o.up.set(0, 1, 0), o.lookAt(0, 0, 1), c.up.set(0, 1, 0), c.lookAt(0, 0, -1);
            else if (e === Ga) n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), s.up.set(0, -1, 0), s.lookAt(1, 0, 0), r.up.set(0, 0, 1), r.lookAt(0, 1, 0), a.up.set(0, 0, -1), a.lookAt(0, -1, 0), o.up.set(0, -1, 0), o.lookAt(0, 0, 1), c.up.set(0, -1, 0), c.lookAt(0, 0, -1);
            else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
            for (const l of t)this.add(l), l.updateMatrixWorld();
        }
        update(e, t) {
            this.parent === null && this.updateMatrixWorld();
            const { renderTarget: n, activeMipmapLevel: s } = this;
            this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
            const [r, a, o, c, l, h] = this.children, u = e.getRenderTarget(), d = e.getActiveCubeFace(), f = e.getActiveMipmapLevel(), _ = e.xr.enabled;
            e.xr.enabled = !1;
            const g = n.texture.generateMipmaps;
            n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0, s), e.render(t, r), e.setRenderTarget(n, 1, s), e.render(t, a), e.setRenderTarget(n, 2, s), e.render(t, o), e.setRenderTarget(n, 3, s), e.render(t, c), e.setRenderTarget(n, 4, s), e.render(t, l), n.texture.generateMipmaps = g, e.setRenderTarget(n, 5, s), e.render(t, h), e.setRenderTarget(u, d, f), e.xr.enabled = _, n.texture.needsPMREMUpdate = !0;
        }
    }
    class Xf extends Qt {
        constructor(e = [], t = Rs, n, s, r, a, o, c, l, h){
            super(e, t, n, s, r, a, o, c, l, h), this.isCubeTexture = !0, this.flipY = !1;
        }
        get images() {
            return this.image;
        }
        set images(e) {
            this.image = e;
        }
    }
    class ix extends Vi {
        constructor(e = 1, t = {}){
            super(e, e, t), this.isWebGLCubeRenderTarget = !0;
            const n = {
                width: e,
                height: e,
                depth: 1
            }, s = [
                n,
                n,
                n,
                n,
                n,
                n
            ];
            this.texture = new Xf(s, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : an;
        }
        fromEquirectangularTexture(e, t) {
            this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
            const n = {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
                fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
            }, s = new ks(5, 5, 5), r = new xi({
                name: "CubemapFromEquirect",
                uniforms: Ds(n.uniforms),
                vertexShader: n.vertexShader,
                fragmentShader: n.fragmentShader,
                side: Jt,
                blending: pi
            });
            r.uniforms.tEquirect.value = t;
            const a = new kt(s, r), o = t.minFilter;
            return t.minFilter === Kn && (t.minFilter = an), new nx(1, 10, this).update(e, a), t.minFilter = o, a.geometry.dispose(), a.material.dispose(), this;
        }
        clear(e, t = !0, n = !0, s = !0) {
            const r = e.getRenderTarget();
            for(let a = 0; a < 6; a++)e.setRenderTarget(this, a), e.clear(t, n, s);
            e.setRenderTarget(r);
        }
    }
    class Oi extends gt {
        constructor(){
            super(), this.isGroup = !0, this.type = "Group";
        }
    }
    const sx = {
        type: "move"
    };
    class Eo {
        constructor(){
            this._targetRay = null, this._grip = null, this._hand = null;
        }
        getHandSpace() {
            return this._hand === null && (this._hand = new Oi, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
                pinching: !1
            }), this._hand;
        }
        getTargetRaySpace() {
            return this._targetRay === null && (this._targetRay = new Oi, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new k, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new k), this._targetRay;
        }
        getGripSpace() {
            return this._grip === null && (this._grip = new Oi, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new k, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new k), this._grip;
        }
        dispatchEvent(e) {
            return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
        }
        connect(e) {
            if (e && e.hand) {
                const t = this._hand;
                if (t) for (const n of e.hand.values())this._getHandJoint(t, n);
            }
            return this.dispatchEvent({
                type: "connected",
                data: e
            }), this;
        }
        disconnect(e) {
            return this.dispatchEvent({
                type: "disconnected",
                data: e
            }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
        }
        update(e, t, n) {
            let s = null, r = null, a = null;
            const o = this._targetRay, c = this._grip, l = this._hand;
            if (e && t.session.visibilityState !== "visible-blurred") {
                if (l && e.hand) {
                    a = !0;
                    for (const g of e.hand.values()){
                        const p = t.getJointPose(g, n), m = this._getHandJoint(l, g);
                        p !== null && (m.matrix.fromArray(p.transform.matrix), m.matrix.decompose(m.position, m.rotation, m.scale), m.matrixWorldNeedsUpdate = !0, m.jointRadius = p.radius), m.visible = p !== null;
                    }
                    const h = l.joints["index-finger-tip"], u = l.joints["thumb-tip"], d = h.position.distanceTo(u.position), f = .02, _ = .005;
                    l.inputState.pinching && d > f + _ ? (l.inputState.pinching = !1, this.dispatchEvent({
                        type: "pinchend",
                        handedness: e.handedness,
                        target: this
                    })) : !l.inputState.pinching && d <= f - _ && (l.inputState.pinching = !0, this.dispatchEvent({
                        type: "pinchstart",
                        handedness: e.handedness,
                        target: this
                    }));
                } else c !== null && e.gripSpace && (r = t.getPose(e.gripSpace, n), r !== null && (c.matrix.fromArray(r.transform.matrix), c.matrix.decompose(c.position, c.rotation, c.scale), c.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (c.hasLinearVelocity = !0, c.linearVelocity.copy(r.linearVelocity)) : c.hasLinearVelocity = !1, r.angularVelocity ? (c.hasAngularVelocity = !0, c.angularVelocity.copy(r.angularVelocity)) : c.hasAngularVelocity = !1));
                o !== null && (s = t.getPose(e.targetRaySpace, n), s === null && r !== null && (s = r), s !== null && (o.matrix.fromArray(s.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.matrixWorldNeedsUpdate = !0, s.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(s.linearVelocity)) : o.hasLinearVelocity = !1, s.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(s.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent(sx)));
            }
            return o !== null && (o.visible = s !== null), c !== null && (c.visible = r !== null), l !== null && (l.visible = a !== null), this;
        }
        _getHandJoint(e, t) {
            if (e.joints[t.jointName] === void 0) {
                const n = new Oi;
                n.matrixAutoUpdate = !1, n.visible = !1, e.joints[t.jointName] = n, e.add(n);
            }
            return e.joints[t.jointName];
        }
    }
    class rx extends gt {
        constructor(){
            super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new Bn, this.environmentIntensity = 1, this.environmentRotation = new Bn, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                detail: this
            }));
        }
        copy(e, t) {
            return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity), t.object.environmentRotation = this.environmentRotation.toArray(), t;
        }
    }
    class ax {
        constructor(e, t){
            this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = ol, this.updateRanges = [], this.version = 0, this.uuid = Tn();
        }
        onUploadCallback() {}
        set needsUpdate(e) {
            e === !0 && this.version++;
        }
        setUsage(e) {
            return this.usage = e, this;
        }
        addUpdateRange(e, t) {
            this.updateRanges.push({
                start: e,
                count: t
            });
        }
        clearUpdateRanges() {
            this.updateRanges.length = 0;
        }
        copy(e) {
            return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
        }
        copyAt(e, t, n) {
            e *= this.stride, n *= t.stride;
            for(let s = 0, r = this.stride; s < r; s++)this.array[e + s] = t.array[n + s];
            return this;
        }
        set(e, t = 0) {
            return this.array.set(e, t), this;
        }
        clone(e) {
            e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Tn()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
            const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), n = new this.constructor(t, this.stride);
            return n.setUsage(this.usage), n;
        }
        onUpload(e) {
            return this.onUploadCallback = e, this;
        }
        toJSON(e) {
            return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Tn()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
                uuid: this.uuid,
                buffer: this.array.buffer._uuid,
                type: this.array.constructor.name,
                stride: this.stride
            };
        }
    }
    const zt = new k;
    class $l {
        constructor(e, t, n, s = !1){
            this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = s;
        }
        get count() {
            return this.data.count;
        }
        get array() {
            return this.data.array;
        }
        set needsUpdate(e) {
            this.data.needsUpdate = e;
        }
        applyMatrix4(e) {
            for(let t = 0, n = this.data.count; t < n; t++)zt.fromBufferAttribute(this, t), zt.applyMatrix4(e), this.setXYZ(t, zt.x, zt.y, zt.z);
            return this;
        }
        applyNormalMatrix(e) {
            for(let t = 0, n = this.count; t < n; t++)zt.fromBufferAttribute(this, t), zt.applyNormalMatrix(e), this.setXYZ(t, zt.x, zt.y, zt.z);
            return this;
        }
        transformDirection(e) {
            for(let t = 0, n = this.count; t < n; t++)zt.fromBufferAttribute(this, t), zt.transformDirection(e), this.setXYZ(t, zt.x, zt.y, zt.z);
            return this;
        }
        getComponent(e, t) {
            let n = this.array[e * this.data.stride + this.offset + t];
            return this.normalized && (n = bn(n, this.array)), n;
        }
        setComponent(e, t, n) {
            return this.normalized && (n = ot(n, this.array)), this.data.array[e * this.data.stride + this.offset + t] = n, this;
        }
        setX(e, t) {
            return this.normalized && (t = ot(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this;
        }
        setY(e, t) {
            return this.normalized && (t = ot(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this;
        }
        setZ(e, t) {
            return this.normalized && (t = ot(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this;
        }
        setW(e, t) {
            return this.normalized && (t = ot(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this;
        }
        getX(e) {
            let t = this.data.array[e * this.data.stride + this.offset];
            return this.normalized && (t = bn(t, this.array)), t;
        }
        getY(e) {
            let t = this.data.array[e * this.data.stride + this.offset + 1];
            return this.normalized && (t = bn(t, this.array)), t;
        }
        getZ(e) {
            let t = this.data.array[e * this.data.stride + this.offset + 2];
            return this.normalized && (t = bn(t, this.array)), t;
        }
        getW(e) {
            let t = this.data.array[e * this.data.stride + this.offset + 3];
            return this.normalized && (t = bn(t, this.array)), t;
        }
        setXY(e, t, n) {
            return e = e * this.data.stride + this.offset, this.normalized && (t = ot(t, this.array), n = ot(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this;
        }
        setXYZ(e, t, n, s) {
            return e = e * this.data.stride + this.offset, this.normalized && (t = ot(t, this.array), n = ot(n, this.array), s = ot(s, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = s, this;
        }
        setXYZW(e, t, n, s, r) {
            return e = e * this.data.stride + this.offset, this.normalized && (t = ot(t, this.array), n = ot(n, this.array), s = ot(s, this.array), r = ot(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = s, this.data.array[e + 3] = r, this;
        }
        clone(e) {
            if (e === void 0) {
                console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
                const t = [];
                for(let n = 0; n < this.count; n++){
                    const s = n * this.data.stride + this.offset;
                    for(let r = 0; r < this.itemSize; r++)t.push(this.data.array[s + r]);
                }
                return new qt(new this.array.constructor(t), this.itemSize, this.normalized);
            } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new $l(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
        }
        toJSON(e) {
            if (e === void 0) {
                console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
                const t = [];
                for(let n = 0; n < this.count; n++){
                    const s = n * this.data.stride + this.offset;
                    for(let r = 0; r < this.itemSize; r++)t.push(this.data.array[s + r]);
                }
                return {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: t,
                    normalized: this.normalized
                };
            } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            };
        }
    }
    const fu = new k, pu = new nt, mu = new nt, ox = new k, _u = new He, na = new k, Ao = new Fn, gu = new He, wo = new Ka;
    class cx extends kt {
        constructor(e, t){
            super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = Yh, this.bindMatrix = new He, this.bindMatrixInverse = new He, this.boundingBox = null, this.boundingSphere = null;
        }
        computeBoundingBox() {
            const e = this.geometry;
            this.boundingBox === null && (this.boundingBox = new fn), this.boundingBox.makeEmpty();
            const t = e.getAttribute("position");
            for(let n = 0; n < t.count; n++)this.getVertexPosition(n, na), this.boundingBox.expandByPoint(na);
        }
        computeBoundingSphere() {
            const e = this.geometry;
            this.boundingSphere === null && (this.boundingSphere = new Fn), this.boundingSphere.makeEmpty();
            const t = e.getAttribute("position");
            for(let n = 0; n < t.count; n++)this.getVertexPosition(n, na), this.boundingSphere.expandByPoint(na);
        }
        copy(e, t) {
            return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
        }
        raycast(e, t) {
            const n = this.material, s = this.matrixWorld;
            n !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), Ao.copy(this.boundingSphere), Ao.applyMatrix4(s), e.ray.intersectsSphere(Ao) !== !1 && (gu.copy(s).invert(), wo.copy(e.ray).applyMatrix4(gu), !(this.boundingBox !== null && wo.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, wo)));
        }
        getVertexPosition(e, t) {
            return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
        }
        bind(e, t) {
            this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
        }
        pose() {
            this.skeleton.pose();
        }
        normalizeSkinWeights() {
            const e = new nt, t = this.geometry.attributes.skinWeight;
            for(let n = 0, s = t.count; n < s; n++){
                e.fromBufferAttribute(t, n);
                const r = 1 / e.manhattanLength();
                r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w);
            }
        }
        updateMatrixWorld(e) {
            super.updateMatrixWorld(e), this.bindMode === Yh ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === eg ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
        }
        applyBoneTransform(e, t) {
            const n = this.skeleton, s = this.geometry;
            pu.fromBufferAttribute(s.attributes.skinIndex, e), mu.fromBufferAttribute(s.attributes.skinWeight, e), fu.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
            for(let r = 0; r < 4; r++){
                const a = mu.getComponent(r);
                if (a !== 0) {
                    const o = pu.getComponent(r);
                    _u.multiplyMatrices(n.bones[o].matrixWorld, n.boneInverses[o]), t.addScaledVector(ox.copy(fu).applyMatrix4(_u), a);
                }
            }
            return t.applyMatrix4(this.bindMatrixInverse);
        }
    }
    class Yf extends gt {
        constructor(){
            super(), this.isBone = !0, this.type = "Bone";
        }
    }
    class qf extends Qt {
        constructor(e = null, t = 1, n = 1, s, r, a, o, c, l = Yt, h = Yt, u, d){
            super(null, a, o, c, l, h, s, r, u, d), this.isDataTexture = !0, this.image = {
                data: e,
                width: t,
                height: n
            }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
        }
    }
    const xu = new He, lx = new He;
    class Kl {
        constructor(e = [], t = []){
            this.uuid = Tn(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.init();
        }
        init() {
            const e = this.bones, t = this.boneInverses;
            if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0) this.calculateInverses();
            else if (e.length !== t.length) {
                console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
                for(let n = 0, s = this.bones.length; n < s; n++)this.boneInverses.push(new He);
            }
        }
        calculateInverses() {
            this.boneInverses.length = 0;
            for(let e = 0, t = this.bones.length; e < t; e++){
                const n = new He;
                this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(n);
            }
        }
        pose() {
            for(let e = 0, t = this.bones.length; e < t; e++){
                const n = this.bones[e];
                n && n.matrixWorld.copy(this.boneInverses[e]).invert();
            }
            for(let e = 0, t = this.bones.length; e < t; e++){
                const n = this.bones[e];
                n && (n.parent && n.parent.isBone ? (n.matrix.copy(n.parent.matrixWorld).invert(), n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld), n.matrix.decompose(n.position, n.quaternion, n.scale));
            }
        }
        update() {
            const e = this.bones, t = this.boneInverses, n = this.boneMatrices, s = this.boneTexture;
            for(let r = 0, a = e.length; r < a; r++){
                const o = e[r] ? e[r].matrixWorld : lx;
                xu.multiplyMatrices(o, t[r]), xu.toArray(n, r * 16);
            }
            s !== null && (s.needsUpdate = !0);
        }
        clone() {
            return new Kl(this.bones, this.boneInverses);
        }
        computeBoneTexture() {
            let e = Math.sqrt(this.bones.length * 4);
            e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
            const t = new Float32Array(e * e * 4);
            t.set(this.boneMatrices);
            const n = new qf(t, e, e, un, Mn);
            return n.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = n, this;
        }
        getBoneByName(e) {
            for(let t = 0, n = this.bones.length; t < n; t++){
                const s = this.bones[t];
                if (s.name === e) return s;
            }
        }
        dispose() {
            this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
        }
        fromJSON(e, t) {
            this.uuid = e.uuid;
            for(let n = 0, s = e.bones.length; n < s; n++){
                const r = e.bones[n];
                let a = t[r];
                a === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", r), a = new Yf), this.bones.push(a), this.boneInverses.push(new He().fromArray(e.boneInverses[n]));
            }
            return this.init(), this;
        }
        toJSON() {
            const e = {
                metadata: {
                    version: 4.6,
                    type: "Skeleton",
                    generator: "Skeleton.toJSON"
                },
                bones: [],
                boneInverses: []
            };
            e.uuid = this.uuid;
            const t = this.bones, n = this.boneInverses;
            for(let s = 0, r = t.length; s < r; s++){
                const a = t[s];
                e.bones.push(a.uuid);
                const o = n[s];
                e.boneInverses.push(o.toArray());
            }
            return e;
        }
    }
    class cl extends qt {
        constructor(e, t, n, s = 1){
            super(e, t, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = s;
        }
        copy(e) {
            return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
        }
        toJSON() {
            const e = super.toJSON();
            return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
        }
    }
    const ds = new He, vu = new He, ia = [], yu = new fn, hx = new He, Ks = new kt, Zs = new Fn;
    class ux extends kt {
        constructor(e, t, n){
            super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new cl(new Float32Array(n * 16), 16), this.instanceColor = null, this.morphTexture = null, this.count = n, this.boundingBox = null, this.boundingSphere = null;
            for(let s = 0; s < n; s++)this.setMatrixAt(s, hx);
        }
        computeBoundingBox() {
            const e = this.geometry, t = this.count;
            this.boundingBox === null && (this.boundingBox = new fn), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
            for(let n = 0; n < t; n++)this.getMatrixAt(n, ds), yu.copy(e.boundingBox).applyMatrix4(ds), this.boundingBox.union(yu);
        }
        computeBoundingSphere() {
            const e = this.geometry, t = this.count;
            this.boundingSphere === null && (this.boundingSphere = new Fn), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
            for(let n = 0; n < t; n++)this.getMatrixAt(n, ds), Zs.copy(e.boundingSphere).applyMatrix4(ds), this.boundingSphere.union(Zs);
        }
        copy(e, t) {
            return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
        }
        getColorAt(e, t) {
            t.fromArray(this.instanceColor.array, e * 3);
        }
        getMatrixAt(e, t) {
            t.fromArray(this.instanceMatrix.array, e * 16);
        }
        getMorphAt(e, t) {
            const n = t.morphTargetInfluences, s = this.morphTexture.source.data.data, r = n.length + 1, a = e * r + 1;
            for(let o = 0; o < n.length; o++)n[o] = s[a + o];
        }
        raycast(e, t) {
            const n = this.matrixWorld, s = this.count;
            if (Ks.geometry = this.geometry, Ks.material = this.material, Ks.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), Zs.copy(this.boundingSphere), Zs.applyMatrix4(n), e.ray.intersectsSphere(Zs) !== !1)) for(let r = 0; r < s; r++){
                this.getMatrixAt(r, ds), vu.multiplyMatrices(n, ds), Ks.matrixWorld = vu, Ks.raycast(e, ia);
                for(let a = 0, o = ia.length; a < o; a++){
                    const c = ia[a];
                    c.instanceId = r, c.object = this, t.push(c);
                }
                ia.length = 0;
            }
        }
        setColorAt(e, t) {
            this.instanceColor === null && (this.instanceColor = new cl(new Float32Array(this.instanceMatrix.count * 3).fill(1), 3)), t.toArray(this.instanceColor.array, e * 3);
        }
        setMatrixAt(e, t) {
            t.toArray(this.instanceMatrix.array, e * 16);
        }
        setMorphAt(e, t) {
            const n = t.morphTargetInfluences, s = n.length + 1;
            this.morphTexture === null && (this.morphTexture = new qf(new Float32Array(s * this.count), s, this.count, zl, Mn));
            const r = this.morphTexture.source.data.data;
            let a = 0;
            for(let l = 0; l < n.length; l++)a += n[l];
            const o = this.geometry.morphTargetsRelative ? 1 : 1 - a, c = s * e;
            r[c] = o, r.set(n, c + 1);
        }
        updateMorphTargets() {}
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            }), this.morphTexture !== null && (this.morphTexture.dispose(), this.morphTexture = null);
        }
    }
    const Ro = new k, dx = new k, fx = new Ge;
    class Ci {
        constructor(e = new k(1, 0, 0), t = 0){
            this.isPlane = !0, this.normal = e, this.constant = t;
        }
        set(e, t) {
            return this.normal.copy(e), this.constant = t, this;
        }
        setComponents(e, t, n, s) {
            return this.normal.set(e, t, n), this.constant = s, this;
        }
        setFromNormalAndCoplanarPoint(e, t) {
            return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
        }
        setFromCoplanarPoints(e, t, n) {
            const s = Ro.subVectors(n, t).cross(dx.subVectors(e, t)).normalize();
            return this.setFromNormalAndCoplanarPoint(s, e), this;
        }
        copy(e) {
            return this.normal.copy(e.normal), this.constant = e.constant, this;
        }
        normalize() {
            const e = 1 / this.normal.length();
            return this.normal.multiplyScalar(e), this.constant *= e, this;
        }
        negate() {
            return this.constant *= -1, this.normal.negate(), this;
        }
        distanceToPoint(e) {
            return this.normal.dot(e) + this.constant;
        }
        distanceToSphere(e) {
            return this.distanceToPoint(e.center) - e.radius;
        }
        projectPoint(e, t) {
            return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
        }
        intersectLine(e, t) {
            const n = e.delta(Ro), s = this.normal.dot(n);
            if (s === 0) return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
            const r = -(e.start.dot(this.normal) + this.constant) / s;
            return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(n, r);
        }
        intersectsLine(e) {
            const t = this.distanceToPoint(e.start), n = this.distanceToPoint(e.end);
            return t < 0 && n > 0 || n < 0 && t > 0;
        }
        intersectsBox(e) {
            return e.intersectsPlane(this);
        }
        intersectsSphere(e) {
            return e.intersectsPlane(this);
        }
        coplanarPoint(e) {
            return e.copy(this.normal).multiplyScalar(-this.constant);
        }
        applyMatrix4(e, t) {
            const n = t || fx.getNormalMatrix(e), s = this.coplanarPoint(Ro).applyMatrix4(e), r = this.normal.applyMatrix3(n).normalize();
            return this.constant = -s.dot(r), this;
        }
        translate(e) {
            return this.constant -= e.dot(this.normal), this;
        }
        equals(e) {
            return e.normal.equals(this.normal) && e.constant === this.constant;
        }
        clone() {
            return new this.constructor().copy(this);
        }
    }
    const Ti = new Fn, sa = new k;
    class Zl {
        constructor(e = new Ci, t = new Ci, n = new Ci, s = new Ci, r = new Ci, a = new Ci){
            this.planes = [
                e,
                t,
                n,
                s,
                r,
                a
            ];
        }
        set(e, t, n, s, r, a) {
            const o = this.planes;
            return o[0].copy(e), o[1].copy(t), o[2].copy(n), o[3].copy(s), o[4].copy(r), o[5].copy(a), this;
        }
        copy(e) {
            const t = this.planes;
            for(let n = 0; n < 6; n++)t[n].copy(e.planes[n]);
            return this;
        }
        setFromProjectionMatrix(e, t = Zn) {
            const n = this.planes, s = e.elements, r = s[0], a = s[1], o = s[2], c = s[3], l = s[4], h = s[5], u = s[6], d = s[7], f = s[8], _ = s[9], g = s[10], p = s[11], m = s[12], v = s[13], y = s[14], x = s[15];
            if (n[0].setComponents(c - r, d - l, p - f, x - m).normalize(), n[1].setComponents(c + r, d + l, p + f, x + m).normalize(), n[2].setComponents(c + a, d + h, p + _, x + v).normalize(), n[3].setComponents(c - a, d - h, p - _, x - v).normalize(), n[4].setComponents(c - o, d - u, p - g, x - y).normalize(), t === Zn) n[5].setComponents(c + o, d + u, p + g, x + y).normalize();
            else if (t === Ga) n[5].setComponents(o, u, g, y).normalize();
            else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
            return this;
        }
        intersectsObject(e) {
            if (e.boundingSphere !== void 0) e.boundingSphere === null && e.computeBoundingSphere(), Ti.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
            else {
                const t = e.geometry;
                t.boundingSphere === null && t.computeBoundingSphere(), Ti.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
            }
            return this.intersectsSphere(Ti);
        }
        intersectsSprite(e) {
            return Ti.center.set(0, 0, 0), Ti.radius = .7071067811865476, Ti.applyMatrix4(e.matrixWorld), this.intersectsSphere(Ti);
        }
        intersectsSphere(e) {
            const t = this.planes, n = e.center, s = -e.radius;
            for(let r = 0; r < 6; r++)if (t[r].distanceToPoint(n) < s) return !1;
            return !0;
        }
        intersectsBox(e) {
            const t = this.planes;
            for(let n = 0; n < 6; n++){
                const s = t[n];
                if (sa.x = s.normal.x > 0 ? e.max.x : e.min.x, sa.y = s.normal.y > 0 ? e.max.y : e.min.y, sa.z = s.normal.z > 0 ? e.max.z : e.min.z, s.distanceToPoint(sa) < 0) return !1;
            }
            return !0;
        }
        containsPoint(e) {
            const t = this.planes;
            for(let n = 0; n < 6; n++)if (t[n].distanceToPoint(e) < 0) return !1;
            return !0;
        }
        clone() {
            return new this.constructor().copy(this);
        }
    }
    class jf extends Nn {
        constructor(e){
            super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new Be(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
        }
        copy(e) {
            return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
        }
    }
    const Ha = new k, za = new k, bu = new He, Js = new Ka, ra = new Fn, Co = new k, Su = new k;
    class Jl extends gt {
        constructor(e = new On, t = new jf){
            super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets();
        }
        copy(e, t) {
            return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
        }
        computeLineDistances() {
            const e = this.geometry;
            if (e.index === null) {
                const t = e.attributes.position, n = [
                    0
                ];
                for(let s = 1, r = t.count; s < r; s++)Ha.fromBufferAttribute(t, s - 1), za.fromBufferAttribute(t, s), n[s] = n[s - 1], n[s] += Ha.distanceTo(za);
                e.setAttribute("lineDistance", new Qn(n, 1));
            } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            return this;
        }
        raycast(e, t) {
            const n = this.geometry, s = this.matrixWorld, r = e.params.Line.threshold, a = n.drawRange;
            if (n.boundingSphere === null && n.computeBoundingSphere(), ra.copy(n.boundingSphere), ra.applyMatrix4(s), ra.radius += r, e.ray.intersectsSphere(ra) === !1) return;
            bu.copy(s).invert(), Js.copy(e.ray).applyMatrix4(bu);
            const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), c = o * o, l = this.isLineSegments ? 2 : 1, h = n.index, d = n.attributes.position;
            if (h !== null) {
                const f = Math.max(0, a.start), _ = Math.min(h.count, a.start + a.count);
                for(let g = f, p = _ - 1; g < p; g += l){
                    const m = h.getX(g), v = h.getX(g + 1), y = aa(this, e, Js, c, m, v, g);
                    y && t.push(y);
                }
                if (this.isLineLoop) {
                    const g = h.getX(_ - 1), p = h.getX(f), m = aa(this, e, Js, c, g, p, _ - 1);
                    m && t.push(m);
                }
            } else {
                const f = Math.max(0, a.start), _ = Math.min(d.count, a.start + a.count);
                for(let g = f, p = _ - 1; g < p; g += l){
                    const m = aa(this, e, Js, c, g, g + 1, g);
                    m && t.push(m);
                }
                if (this.isLineLoop) {
                    const g = aa(this, e, Js, c, _ - 1, f, _ - 1);
                    g && t.push(g);
                }
            }
        }
        updateMorphTargets() {
            const t = this.geometry.morphAttributes, n = Object.keys(t);
            if (n.length > 0) {
                const s = t[n[0]];
                if (s !== void 0) {
                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                    for(let r = 0, a = s.length; r < a; r++){
                        const o = s[r].name || String(r);
                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = r;
                    }
                }
            }
        }
    }
    function aa(i, e, t, n, s, r, a) {
        const o = i.geometry.attributes.position;
        if (Ha.fromBufferAttribute(o, s), za.fromBufferAttribute(o, r), t.distanceSqToSegment(Ha, za, Co, Su) > n) return;
        Co.applyMatrix4(i.matrixWorld);
        const l = e.ray.origin.distanceTo(Co);
        if (!(l < e.near || l > e.far)) return {
            distance: l,
            point: Su.clone().applyMatrix4(i.matrixWorld),
            index: a,
            face: null,
            faceIndex: null,
            barycoord: null,
            object: i
        };
    }
    const Mu = new k, Tu = new k;
    class px extends Jl {
        constructor(e, t){
            super(e, t), this.isLineSegments = !0, this.type = "LineSegments";
        }
        computeLineDistances() {
            const e = this.geometry;
            if (e.index === null) {
                const t = e.attributes.position, n = [];
                for(let s = 0, r = t.count; s < r; s += 2)Mu.fromBufferAttribute(t, s), Tu.fromBufferAttribute(t, s + 1), n[s] = s === 0 ? 0 : n[s - 1], n[s + 1] = n[s] + Mu.distanceTo(Tu);
                e.setAttribute("lineDistance", new Qn(n, 1));
            } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            return this;
        }
    }
    class mx extends Jl {
        constructor(e, t){
            super(e, t), this.isLineLoop = !0, this.type = "LineLoop";
        }
    }
    class $f extends Nn {
        constructor(e){
            super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new Be(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e);
        }
        copy(e) {
            return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
        }
    }
    const Eu = new He, ll = new Ka, oa = new Fn, ca = new k;
    class _x extends gt {
        constructor(e = new On, t = new $f){
            super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets();
        }
        copy(e, t) {
            return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
        }
        raycast(e, t) {
            const n = this.geometry, s = this.matrixWorld, r = e.params.Points.threshold, a = n.drawRange;
            if (n.boundingSphere === null && n.computeBoundingSphere(), oa.copy(n.boundingSphere), oa.applyMatrix4(s), oa.radius += r, e.ray.intersectsSphere(oa) === !1) return;
            Eu.copy(s).invert(), ll.copy(e.ray).applyMatrix4(Eu);
            const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), c = o * o, l = n.index, u = n.attributes.position;
            if (l !== null) {
                const d = Math.max(0, a.start), f = Math.min(l.count, a.start + a.count);
                for(let _ = d, g = f; _ < g; _++){
                    const p = l.getX(_);
                    ca.fromBufferAttribute(u, p), Au(ca, p, c, s, e, t, this);
                }
            } else {
                const d = Math.max(0, a.start), f = Math.min(u.count, a.start + a.count);
                for(let _ = d, g = f; _ < g; _++)ca.fromBufferAttribute(u, _), Au(ca, _, c, s, e, t, this);
            }
        }
        updateMorphTargets() {
            const t = this.geometry.morphAttributes, n = Object.keys(t);
            if (n.length > 0) {
                const s = t[n[0]];
                if (s !== void 0) {
                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                    for(let r = 0, a = s.length; r < a; r++){
                        const o = s[r].name || String(r);
                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = r;
                    }
                }
            }
        }
    }
    function Au(i, e, t, n, s, r, a) {
        const o = ll.distanceSqToPoint(i);
        if (o < t) {
            const c = new k;
            ll.closestPointToPoint(i, c), c.applyMatrix4(n);
            const l = s.ray.origin.distanceTo(c);
            if (l < s.near || l > s.far) return;
            r.push({
                distance: l,
                distanceToRay: Math.sqrt(o),
                point: c,
                index: e,
                face: null,
                faceIndex: null,
                barycoord: null,
                object: a
            });
        }
    }
    class Kf extends Qt {
        constructor(e, t, n = zi, s, r, a, o = Yt, c = Yt, l, h = Mr){
            if (h !== Mr && h !== Tr) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
            super(null, s, r, a, o, c, h, n, l), this.isDepthTexture = !0, this.image = {
                width: e,
                height: t
            }, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
        }
        copy(e) {
            return super.copy(e), this.source = new jl(Object.assign({}, e.image)), this.compareFunction = e.compareFunction, this;
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t;
        }
    }
    class Ur extends On {
        constructor(e = 1, t = 1, n = 1, s = 1){
            super(), this.type = "PlaneGeometry", this.parameters = {
                width: e,
                height: t,
                widthSegments: n,
                heightSegments: s
            };
            const r = e / 2, a = t / 2, o = Math.floor(n), c = Math.floor(s), l = o + 1, h = c + 1, u = e / o, d = t / c, f = [], _ = [], g = [], p = [];
            for(let m = 0; m < h; m++){
                const v = m * d - a;
                for(let y = 0; y < l; y++){
                    const x = y * u - r;
                    _.push(x, -v, 0), g.push(0, 0, 1), p.push(y / o), p.push(1 - m / c);
                }
            }
            for(let m = 0; m < c; m++)for(let v = 0; v < o; v++){
                const y = v + l * m, x = v + l * (m + 1), I = v + 1 + l * (m + 1), w = v + 1 + l * m;
                f.push(y, x, w), f.push(x, I, w);
            }
            this.setIndex(f), this.setAttribute("position", new Qn(_, 3)), this.setAttribute("normal", new Qn(g, 3)), this.setAttribute("uv", new Qn(p, 2));
        }
        copy(e) {
            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
        }
        static fromJSON(e) {
            return new Ur(e.width, e.height, e.widthSegments, e.heightSegments);
        }
    }
    class Rr extends Nn {
        constructor(e){
            super(), this.isMeshStandardMaterial = !0, this.type = "MeshStandardMaterial", this.defines = {
                STANDARD: ""
            }, this.color = new Be(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Be(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Nf, this.normalScale = new Ke(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Bn, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
        }
        copy(e) {
            return super.copy(e), this.defines = {
                STANDARD: ""
            }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
        }
    }
    class kn extends Rr {
        constructor(e){
            super(), this.isMeshPhysicalMaterial = !0, this.defines = {
                STANDARD: "",
                PHYSICAL: ""
            }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Ke(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
                get: function() {
                    return Ye(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
                },
                set: function(t) {
                    this.ior = (1 + .4 * t) / (1 - .4 * t);
                }
            }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [
                100,
                400
            ], this.iridescenceThicknessMap = null, this.sheenColor = new Be(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Be(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Be(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e);
        }
        get anisotropy() {
            return this._anisotropy;
        }
        set anisotropy(e) {
            this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e;
        }
        get clearcoat() {
            return this._clearcoat;
        }
        set clearcoat(e) {
            this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
        }
        get iridescence() {
            return this._iridescence;
        }
        set iridescence(e) {
            this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
        }
        get dispersion() {
            return this._dispersion;
        }
        set dispersion(e) {
            this._dispersion > 0 != e > 0 && this.version++, this._dispersion = e;
        }
        get sheen() {
            return this._sheen;
        }
        set sheen(e) {
            this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
        }
        get transmission() {
            return this._transmission;
        }
        set transmission(e) {
            this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
        }
        copy(e) {
            return super.copy(e), this.defines = {
                STANDARD: "",
                PHYSICAL: ""
            }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.dispersion = e.dispersion, this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [
                ...e.iridescenceThicknessRange
            ], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
        }
    }
    class gx extends Nn {
        constructor(e){
            super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = sg, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
        }
        copy(e) {
            return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
        }
    }
    class xx extends Nn {
        constructor(e){
            super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
        }
        copy(e) {
            return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
        }
    }
    function la(i, e) {
        return !i || i.constructor === e ? i : typeof e.BYTES_PER_ELEMENT == "number" ? new e(i) : Array.prototype.slice.call(i);
    }
    function vx(i) {
        return ArrayBuffer.isView(i) && !(i instanceof DataView);
    }
    function yx(i) {
        function e(s, r) {
            return i[s] - i[r];
        }
        const t = i.length, n = new Array(t);
        for(let s = 0; s !== t; ++s)n[s] = s;
        return n.sort(e), n;
    }
    function wu(i, e, t) {
        const n = i.length, s = new i.constructor(n);
        for(let r = 0, a = 0; a !== n; ++r){
            const o = t[r] * e;
            for(let c = 0; c !== e; ++c)s[a++] = i[o + c];
        }
        return s;
    }
    function Zf(i, e, t, n) {
        let s = 1, r = i[0];
        for(; r !== void 0 && r[n] === void 0;)r = i[s++];
        if (r === void 0) return;
        let a = r[n];
        if (a !== void 0) if (Array.isArray(a)) do a = r[n], a !== void 0 && (e.push(r.time), t.push(...a)), r = i[s++];
        while (r !== void 0);
        else if (a.toArray !== void 0) do a = r[n], a !== void 0 && (e.push(r.time), a.toArray(t, t.length)), r = i[s++];
        while (r !== void 0);
        else do a = r[n], a !== void 0 && (e.push(r.time), t.push(a)), r = i[s++];
        while (r !== void 0);
    }
    class Nr {
        constructor(e, t, n, s){
            this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = s !== void 0 ? s : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {};
        }
        evaluate(e) {
            const t = this.parameterPositions;
            let n = this._cachedIndex, s = t[n], r = t[n - 1];
            e: {
                t: {
                    let a;
                    n: {
                        i: if (!(e < s)) {
                            for(let o = n + 2;;){
                                if (s === void 0) {
                                    if (e < r) break i;
                                    return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
                                }
                                if (n === o) break;
                                if (r = s, s = t[++n], e < s) break t;
                            }
                            a = t.length;
                            break n;
                        }
                        if (!(e >= r)) {
                            const o = t[1];
                            e < o && (n = 2, r = o);
                            for(let c = n - 2;;){
                                if (r === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
                                if (n === c) break;
                                if (s = r, r = t[--n - 1], e >= r) break t;
                            }
                            a = n, n = 0;
                            break n;
                        }
                        break e;
                    }
                    for(; n < a;){
                        const o = n + a >>> 1;
                        e < t[o] ? a = o : n = o + 1;
                    }
                    if (s = t[n], r = t[n - 1], r === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
                    if (s === void 0) return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
                }
                this._cachedIndex = n, this.intervalChanged_(n, r, s);
            }
            return this.interpolate_(n, r, e, s);
        }
        getSettings_() {
            return this.settings || this.DefaultSettings_;
        }
        copySampleValue_(e) {
            const t = this.resultBuffer, n = this.sampleValues, s = this.valueSize, r = e * s;
            for(let a = 0; a !== s; ++a)t[a] = n[r + a];
            return t;
        }
        interpolate_() {
            throw new Error("call to abstract method");
        }
        intervalChanged_() {}
    }
    class bx extends Nr {
        constructor(e, t, n, s){
            super(e, t, n, s), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
                endingStart: vs,
                endingEnd: vs
            };
        }
        intervalChanged_(e, t, n) {
            const s = this.parameterPositions;
            let r = e - 2, a = e + 1, o = s[r], c = s[a];
            if (o === void 0) switch(this.getSettings_().endingStart){
                case ys:
                    r = e, o = 2 * t - n;
                    break;
                case Oa:
                    r = s.length - 2, o = t + s[r] - s[r + 1];
                    break;
                default:
                    r = e, o = n;
            }
            if (c === void 0) switch(this.getSettings_().endingEnd){
                case ys:
                    a = e, c = 2 * n - t;
                    break;
                case Oa:
                    a = 1, c = n + s[1] - s[0];
                    break;
                default:
                    a = e - 1, c = t;
            }
            const l = (n - t) * .5, h = this.valueSize;
            this._weightPrev = l / (t - o), this._weightNext = l / (c - n), this._offsetPrev = r * h, this._offsetNext = a * h;
        }
        interpolate_(e, t, n, s) {
            const r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, c = e * o, l = c - o, h = this._offsetPrev, u = this._offsetNext, d = this._weightPrev, f = this._weightNext, _ = (n - t) / (s - t), g = _ * _, p = g * _, m = -d * p + 2 * d * g - d * _, v = (1 + d) * p + (-1.5 - 2 * d) * g + (-.5 + d) * _ + 1, y = (-1 - f) * p + (1.5 + f) * g + .5 * _, x = f * p - f * g;
            for(let I = 0; I !== o; ++I)r[I] = m * a[h + I] + v * a[l + I] + y * a[c + I] + x * a[u + I];
            return r;
        }
    }
    class Jf extends Nr {
        constructor(e, t, n, s){
            super(e, t, n, s);
        }
        interpolate_(e, t, n, s) {
            const r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, c = e * o, l = c - o, h = (n - t) / (s - t), u = 1 - h;
            for(let d = 0; d !== o; ++d)r[d] = a[l + d] * u + a[c + d] * h;
            return r;
        }
    }
    class Sx extends Nr {
        constructor(e, t, n, s){
            super(e, t, n, s);
        }
        interpolate_(e) {
            return this.copySampleValue_(e - 1);
        }
    }
    class Rn {
        constructor(e, t, n, s){
            if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
            if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
            this.name = e, this.times = la(t, this.TimeBufferType), this.values = la(n, this.ValueBufferType), this.setInterpolation(s || this.DefaultInterpolation);
        }
        static toJSON(e) {
            const t = e.constructor;
            let n;
            if (t.toJSON !== this.toJSON) n = t.toJSON(e);
            else {
                n = {
                    name: e.name,
                    times: la(e.times, Array),
                    values: la(e.values, Array)
                };
                const s = e.getInterpolation();
                s !== e.DefaultInterpolation && (n.interpolation = s);
            }
            return n.type = e.ValueTypeName, n;
        }
        InterpolantFactoryMethodDiscrete(e) {
            return new Sx(this.times, this.values, this.getValueSize(), e);
        }
        InterpolantFactoryMethodLinear(e) {
            return new Jf(this.times, this.values, this.getValueSize(), e);
        }
        InterpolantFactoryMethodSmooth(e) {
            return new bx(this.times, this.values, this.getValueSize(), e);
        }
        setInterpolation(e) {
            let t;
            switch(e){
                case Er:
                    t = this.InterpolantFactoryMethodDiscrete;
                    break;
                case Ar:
                    t = this.InterpolantFactoryMethodLinear;
                    break;
                case so:
                    t = this.InterpolantFactoryMethodSmooth;
                    break;
            }
            if (t === void 0) {
                const n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                if (this.createInterpolant === void 0) if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
                else throw new Error(n);
                return console.warn("THREE.KeyframeTrack:", n), this;
            }
            return this.createInterpolant = t, this;
        }
        getInterpolation() {
            switch(this.createInterpolant){
                case this.InterpolantFactoryMethodDiscrete:
                    return Er;
                case this.InterpolantFactoryMethodLinear:
                    return Ar;
                case this.InterpolantFactoryMethodSmooth:
                    return so;
            }
        }
        getValueSize() {
            return this.values.length / this.times.length;
        }
        shift(e) {
            if (e !== 0) {
                const t = this.times;
                for(let n = 0, s = t.length; n !== s; ++n)t[n] += e;
            }
            return this;
        }
        scale(e) {
            if (e !== 1) {
                const t = this.times;
                for(let n = 0, s = t.length; n !== s; ++n)t[n] *= e;
            }
            return this;
        }
        trim(e, t) {
            const n = this.times, s = n.length;
            let r = 0, a = s - 1;
            for(; r !== s && n[r] < e;)++r;
            for(; a !== -1 && n[a] > t;)--a;
            if (++a, r !== 0 || a !== s) {
                r >= a && (a = Math.max(a, 1), r = a - 1);
                const o = this.getValueSize();
                this.times = n.slice(r, a), this.values = this.values.slice(r * o, a * o);
            }
            return this;
        }
        validate() {
            let e = !0;
            const t = this.getValueSize();
            t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
            const n = this.times, s = this.values, r = n.length;
            r === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
            let a = null;
            for(let o = 0; o !== r; o++){
                const c = n[o];
                if (typeof c == "number" && isNaN(c)) {
                    console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, c), e = !1;
                    break;
                }
                if (a !== null && a > c) {
                    console.error("THREE.KeyframeTrack: Out of order keys.", this, o, c, a), e = !1;
                    break;
                }
                a = c;
            }
            if (s !== void 0 && vx(s)) for(let o = 0, c = s.length; o !== c; ++o){
                const l = s[o];
                if (isNaN(l)) {
                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, l), e = !1;
                    break;
                }
            }
            return e;
        }
        optimize() {
            const e = this.times.slice(), t = this.values.slice(), n = this.getValueSize(), s = this.getInterpolation() === so, r = e.length - 1;
            let a = 1;
            for(let o = 1; o < r; ++o){
                let c = !1;
                const l = e[o], h = e[o + 1];
                if (l !== h && (o !== 1 || l !== e[0])) if (s) c = !0;
                else {
                    const u = o * n, d = u - n, f = u + n;
                    for(let _ = 0; _ !== n; ++_){
                        const g = t[u + _];
                        if (g !== t[d + _] || g !== t[f + _]) {
                            c = !0;
                            break;
                        }
                    }
                }
                if (c) {
                    if (o !== a) {
                        e[a] = e[o];
                        const u = o * n, d = a * n;
                        for(let f = 0; f !== n; ++f)t[d + f] = t[u + f];
                    }
                    ++a;
                }
            }
            if (r > 0) {
                e[a] = e[r];
                for(let o = r * n, c = a * n, l = 0; l !== n; ++l)t[c + l] = t[o + l];
                ++a;
            }
            return a !== e.length ? (this.times = e.slice(0, a), this.values = t.slice(0, a * n)) : (this.times = e, this.values = t), this;
        }
        clone() {
            const e = this.times.slice(), t = this.values.slice(), n = this.constructor, s = new n(this.name, e, t);
            return s.createInterpolant = this.createInterpolant, s;
        }
    }
    Rn.prototype.ValueTypeName = "";
    Rn.prototype.TimeBufferType = Float32Array;
    Rn.prototype.ValueBufferType = Float32Array;
    Rn.prototype.DefaultInterpolation = Ar;
    class Gs extends Rn {
        constructor(e, t, n){
            super(e, t, n);
        }
    }
    Gs.prototype.ValueTypeName = "bool";
    Gs.prototype.ValueBufferType = Array;
    Gs.prototype.DefaultInterpolation = Er;
    Gs.prototype.InterpolantFactoryMethodLinear = void 0;
    Gs.prototype.InterpolantFactoryMethodSmooth = void 0;
    class Qf extends Rn {
        constructor(e, t, n, s){
            super(e, t, n, s);
        }
    }
    Qf.prototype.ValueTypeName = "color";
    class Ls extends Rn {
        constructor(e, t, n, s){
            super(e, t, n, s);
        }
    }
    Ls.prototype.ValueTypeName = "number";
    class Mx extends Nr {
        constructor(e, t, n, s){
            super(e, t, n, s);
        }
        interpolate_(e, t, n, s) {
            const r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, c = (n - t) / (s - t);
            let l = e * o;
            for(let h = l + o; l !== h; l += 4)En.slerpFlat(r, 0, a, l - o, a, l, c);
            return r;
        }
    }
    class Us extends Rn {
        constructor(e, t, n, s){
            super(e, t, n, s);
        }
        InterpolantFactoryMethodLinear(e) {
            return new Mx(this.times, this.values, this.getValueSize(), e);
        }
    }
    Us.prototype.ValueTypeName = "quaternion";
    Us.prototype.InterpolantFactoryMethodSmooth = void 0;
    class Hs extends Rn {
        constructor(e, t, n){
            super(e, t, n);
        }
    }
    Hs.prototype.ValueTypeName = "string";
    Hs.prototype.ValueBufferType = Array;
    Hs.prototype.DefaultInterpolation = Er;
    Hs.prototype.InterpolantFactoryMethodLinear = void 0;
    Hs.prototype.InterpolantFactoryMethodSmooth = void 0;
    class Ns extends Rn {
        constructor(e, t, n, s){
            super(e, t, n, s);
        }
    }
    Ns.prototype.ValueTypeName = "vector";
    class hl {
        constructor(e = "", t = -1, n = [], s = Yl){
            this.name = e, this.tracks = n, this.duration = t, this.blendMode = s, this.uuid = Tn(), this.duration < 0 && this.resetDuration();
        }
        static parse(e) {
            const t = [], n = e.tracks, s = 1 / (e.fps || 1);
            for(let a = 0, o = n.length; a !== o; ++a)t.push(Ex(n[a]).scale(s));
            const r = new this(e.name, e.duration, t, e.blendMode);
            return r.uuid = e.uuid, r;
        }
        static toJSON(e) {
            const t = [], n = e.tracks, s = {
                name: e.name,
                duration: e.duration,
                tracks: t,
                uuid: e.uuid,
                blendMode: e.blendMode
            };
            for(let r = 0, a = n.length; r !== a; ++r)t.push(Rn.toJSON(n[r]));
            return s;
        }
        static CreateFromMorphTargetSequence(e, t, n, s) {
            const r = t.length, a = [];
            for(let o = 0; o < r; o++){
                let c = [], l = [];
                c.push((o + r - 1) % r, o, (o + 1) % r), l.push(0, 1, 0);
                const h = yx(c);
                c = wu(c, 1, h), l = wu(l, 1, h), !s && c[0] === 0 && (c.push(r), l.push(l[0])), a.push(new Ls(".morphTargetInfluences[" + t[o].name + "]", c, l).scale(1 / n));
            }
            return new this(e, -1, a);
        }
        static findByName(e, t) {
            let n = e;
            if (!Array.isArray(e)) {
                const s = e;
                n = s.geometry && s.geometry.animations || s.animations;
            }
            for(let s = 0; s < n.length; s++)if (n[s].name === t) return n[s];
            return null;
        }
        static CreateClipsFromMorphTargetSequences(e, t, n) {
            const s = {}, r = /^([\w-]*?)([\d]+)$/;
            for(let o = 0, c = e.length; o < c; o++){
                const l = e[o], h = l.name.match(r);
                if (h && h.length > 1) {
                    const u = h[1];
                    let d = s[u];
                    d || (s[u] = d = []), d.push(l);
                }
            }
            const a = [];
            for(const o in s)a.push(this.CreateFromMorphTargetSequence(o, s[o], t, n));
            return a;
        }
        static parseAnimation(e, t) {
            if (console.warn("THREE.AnimationClip: parseAnimation() is deprecated and will be removed with r185"), !e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
            const n = function(u, d, f, _, g) {
                if (f.length !== 0) {
                    const p = [], m = [];
                    Zf(f, p, m, _), p.length !== 0 && g.push(new u(d, p, m));
                }
            }, s = [], r = e.name || "default", a = e.fps || 30, o = e.blendMode;
            let c = e.length || -1;
            const l = e.hierarchy || [];
            for(let u = 0; u < l.length; u++){
                const d = l[u].keys;
                if (!(!d || d.length === 0)) if (d[0].morphTargets) {
                    const f = {};
                    let _;
                    for(_ = 0; _ < d.length; _++)if (d[_].morphTargets) for(let g = 0; g < d[_].morphTargets.length; g++)f[d[_].morphTargets[g]] = -1;
                    for(const g in f){
                        const p = [], m = [];
                        for(let v = 0; v !== d[_].morphTargets.length; ++v){
                            const y = d[_];
                            p.push(y.time), m.push(y.morphTarget === g ? 1 : 0);
                        }
                        s.push(new Ls(".morphTargetInfluence[" + g + "]", p, m));
                    }
                    c = f.length * a;
                } else {
                    const f = ".bones[" + t[u].name + "]";
                    n(Ns, f + ".position", d, "pos", s), n(Us, f + ".quaternion", d, "rot", s), n(Ns, f + ".scale", d, "scl", s);
                }
            }
            return s.length === 0 ? null : new this(r, c, s, o);
        }
        resetDuration() {
            const e = this.tracks;
            let t = 0;
            for(let n = 0, s = e.length; n !== s; ++n){
                const r = this.tracks[n];
                t = Math.max(t, r.times[r.times.length - 1]);
            }
            return this.duration = t, this;
        }
        trim() {
            for(let e = 0; e < this.tracks.length; e++)this.tracks[e].trim(0, this.duration);
            return this;
        }
        validate() {
            let e = !0;
            for(let t = 0; t < this.tracks.length; t++)e = e && this.tracks[t].validate();
            return e;
        }
        optimize() {
            for(let e = 0; e < this.tracks.length; e++)this.tracks[e].optimize();
            return this;
        }
        clone() {
            const e = [];
            for(let t = 0; t < this.tracks.length; t++)e.push(this.tracks[t].clone());
            return new this.constructor(this.name, this.duration, e, this.blendMode);
        }
        toJSON() {
            return this.constructor.toJSON(this);
        }
    }
    function Tx(i) {
        switch(i.toLowerCase()){
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
                return Ls;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
                return Ns;
            case "color":
                return Qf;
            case "quaternion":
                return Us;
            case "bool":
            case "boolean":
                return Gs;
            case "string":
                return Hs;
        }
        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + i);
    }
    function Ex(i) {
        if (i.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
        const e = Tx(i.type);
        if (i.times === void 0) {
            const t = [], n = [];
            Zf(i.keys, t, n, "value"), i.times = t, i.values = n;
        }
        return e.parse !== void 0 ? e.parse(i) : new e(i.name, i.times, i.values, i.interpolation);
    }
    const di = {
        enabled: !1,
        files: {},
        add: function(i, e) {
            this.enabled !== !1 && (this.files[i] = e);
        },
        get: function(i) {
            if (this.enabled !== !1) return this.files[i];
        },
        remove: function(i) {
            delete this.files[i];
        },
        clear: function() {
            this.files = {};
        }
    };
    class Ax {
        constructor(e, t, n){
            const s = this;
            let r = !1, a = 0, o = 0, c;
            const l = [];
            this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(h) {
                o++, r === !1 && s.onStart !== void 0 && s.onStart(h, a, o), r = !0;
            }, this.itemEnd = function(h) {
                a++, s.onProgress !== void 0 && s.onProgress(h, a, o), a === o && (r = !1, s.onLoad !== void 0 && s.onLoad());
            }, this.itemError = function(h) {
                s.onError !== void 0 && s.onError(h);
            }, this.resolveURL = function(h) {
                return c ? c(h) : h;
            }, this.setURLModifier = function(h) {
                return c = h, this;
            }, this.addHandler = function(h, u) {
                return l.push(h, u), this;
            }, this.removeHandler = function(h) {
                const u = l.indexOf(h);
                return u !== -1 && l.splice(u, 2), this;
            }, this.getHandler = function(h) {
                for(let u = 0, d = l.length; u < d; u += 2){
                    const f = l[u], _ = l[u + 1];
                    if (f.global && (f.lastIndex = 0), f.test(h)) return _;
                }
                return null;
            };
        }
    }
    const wx = new Ax;
    class zs {
        constructor(e){
            this.manager = e !== void 0 ? e : wx, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
        }
        load() {}
        loadAsync(e, t) {
            const n = this;
            return new Promise(function(s, r) {
                n.load(e, s, t, r);
            });
        }
        parse() {}
        setCrossOrigin(e) {
            return this.crossOrigin = e, this;
        }
        setWithCredentials(e) {
            return this.withCredentials = e, this;
        }
        setPath(e) {
            return this.path = e, this;
        }
        setResourcePath(e) {
            return this.resourcePath = e, this;
        }
        setRequestHeader(e) {
            return this.requestHeader = e, this;
        }
    }
    zs.DEFAULT_MATERIAL_NAME = "__DEFAULT";
    const Yn = {};
    class Rx extends Error {
        constructor(e, t){
            super(e), this.response = t;
        }
    }
    class ep extends zs {
        constructor(e){
            super(e), this.mimeType = "", this.responseType = "";
        }
        load(e, t, n, s) {
            e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
            const r = di.get(e);
            if (r !== void 0) return this.manager.itemStart(e), setTimeout(()=>{
                t && t(r), this.manager.itemEnd(e);
            }, 0), r;
            if (Yn[e] !== void 0) {
                Yn[e].push({
                    onLoad: t,
                    onProgress: n,
                    onError: s
                });
                return;
            }
            Yn[e] = [], Yn[e].push({
                onLoad: t,
                onProgress: n,
                onError: s
            });
            const a = new Request(e, {
                headers: new Headers(this.requestHeader),
                credentials: this.withCredentials ? "include" : "same-origin"
            }), o = this.mimeType, c = this.responseType;
            fetch(a).then((l)=>{
                if (l.status === 200 || l.status === 0) {
                    if (l.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || l.body === void 0 || l.body.getReader === void 0) return l;
                    const h = Yn[e], u = l.body.getReader(), d = l.headers.get("X-File-Size") || l.headers.get("Content-Length"), f = d ? parseInt(d) : 0, _ = f !== 0;
                    let g = 0;
                    const p = new ReadableStream({
                        start (m) {
                            v();
                            function v() {
                                u.read().then(({ done: y, value: x })=>{
                                    if (y) m.close();
                                    else {
                                        g += x.byteLength;
                                        const I = new ProgressEvent("progress", {
                                            lengthComputable: _,
                                            loaded: g,
                                            total: f
                                        });
                                        for(let w = 0, R = h.length; w < R; w++){
                                            const N = h[w];
                                            N.onProgress && N.onProgress(I);
                                        }
                                        m.enqueue(x), v();
                                    }
                                }, (y)=>{
                                    m.error(y);
                                });
                            }
                        }
                    });
                    return new Response(p);
                } else throw new Rx(`fetch for "${l.url}" responded with ${l.status}: ${l.statusText}`, l);
            }).then((l)=>{
                switch(c){
                    case "arraybuffer":
                        return l.arrayBuffer();
                    case "blob":
                        return l.blob();
                    case "document":
                        return l.text().then((h)=>new DOMParser().parseFromString(h, o));
                    case "json":
                        return l.json();
                    default:
                        if (o === "") return l.text();
                        {
                            const u = /charset="?([^;"\s]*)"?/i.exec(o), d = u && u[1] ? u[1].toLowerCase() : void 0, f = new TextDecoder(d);
                            return l.arrayBuffer().then((_)=>f.decode(_));
                        }
                }
            }).then((l)=>{
                di.add(e, l);
                const h = Yn[e];
                delete Yn[e];
                for(let u = 0, d = h.length; u < d; u++){
                    const f = h[u];
                    f.onLoad && f.onLoad(l);
                }
            }).catch((l)=>{
                const h = Yn[e];
                if (h === void 0) throw this.manager.itemError(e), l;
                delete Yn[e];
                for(let u = 0, d = h.length; u < d; u++){
                    const f = h[u];
                    f.onError && f.onError(l);
                }
                this.manager.itemError(e);
            }).finally(()=>{
                this.manager.itemEnd(e);
            }), this.manager.itemStart(e);
        }
        setResponseType(e) {
            return this.responseType = e, this;
        }
        setMimeType(e) {
            return this.mimeType = e, this;
        }
    }
    class Cx extends zs {
        constructor(e){
            super(e);
        }
        load(e, t, n, s) {
            this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
            const r = this, a = di.get(e);
            if (a !== void 0) return r.manager.itemStart(e), setTimeout(function() {
                t && t(a), r.manager.itemEnd(e);
            }, 0), a;
            const o = wr("img");
            function c() {
                h(), di.add(e, this), t && t(this), r.manager.itemEnd(e);
            }
            function l(u) {
                h(), s && s(u), r.manager.itemError(e), r.manager.itemEnd(e);
            }
            function h() {
                o.removeEventListener("load", c, !1), o.removeEventListener("error", l, !1);
            }
            return o.addEventListener("load", c, !1), o.addEventListener("error", l, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (o.crossOrigin = this.crossOrigin), r.manager.itemStart(e), o.src = e, o;
        }
    }
    class ul extends zs {
        constructor(e){
            super(e);
        }
        load(e, t, n, s) {
            const r = new Qt, a = new Cx(this.manager);
            return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(e, function(o) {
                r.image = o, r.needsUpdate = !0, t !== void 0 && t(r);
            }, n, s), r;
        }
    }
    class Za extends gt {
        constructor(e, t = 1){
            super(), this.isLight = !0, this.type = "Light", this.color = new Be(e), this.intensity = t;
        }
        dispose() {}
        copy(e, t) {
            return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (t.object.target = this.target.uuid), t;
        }
    }
    const Po = new He, Ru = new k, Cu = new k;
    class Ql {
        constructor(e){
            this.camera = e, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Ke(512, 512), this.map = null, this.mapPass = null, this.matrix = new He, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Zl, this._frameExtents = new Ke(1, 1), this._viewportCount = 1, this._viewports = [
                new nt(0, 0, 1, 1)
            ];
        }
        getViewportCount() {
            return this._viewportCount;
        }
        getFrustum() {
            return this._frustum;
        }
        updateMatrices(e) {
            const t = this.camera, n = this.matrix;
            Ru.setFromMatrixPosition(e.matrixWorld), t.position.copy(Ru), Cu.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(Cu), t.updateMatrixWorld(), Po.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Po), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(Po);
        }
        getViewport(e) {
            return this._viewports[e];
        }
        getFrameExtents() {
            return this._frameExtents;
        }
        dispose() {
            this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
        }
        copy(e) {
            return this.camera = e.camera.clone(), this.intensity = e.intensity, this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
        }
        clone() {
            return new this.constructor().copy(this);
        }
        toJSON() {
            const e = {};
            return this.intensity !== 1 && (e.intensity = this.intensity), this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
        }
    }
    class Px extends Ql {
        constructor(){
            super(new Wt(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
        }
        updateMatrices(e) {
            const t = this.camera, n = Is * 2 * e.angle * this.focus, s = this.mapSize.width / this.mapSize.height, r = e.distance || t.far;
            (n !== t.fov || s !== t.aspect || r !== t.far) && (t.fov = n, t.aspect = s, t.far = r, t.updateProjectionMatrix()), super.updateMatrices(e);
        }
        copy(e) {
            return super.copy(e), this.focus = e.focus, this;
        }
    }
    class Ix extends Za {
        constructor(e, t, n = 0, s = Math.PI / 3, r = 0, a = 2){
            super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(gt.DEFAULT_UP), this.updateMatrix(), this.target = new gt, this.distance = n, this.angle = s, this.penumbra = r, this.decay = a, this.map = null, this.shadow = new Px;
        }
        get power() {
            return this.intensity * Math.PI;
        }
        set power(e) {
            this.intensity = e / Math.PI;
        }
        dispose() {
            this.shadow.dispose();
        }
        copy(e, t) {
            return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
        }
    }
    const Pu = new He, Qs = new k, Io = new k;
    class Dx extends Ql {
        constructor(){
            super(new Wt(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new Ke(4, 2), this._viewportCount = 6, this._viewports = [
                new nt(2, 1, 1, 1),
                new nt(0, 1, 1, 1),
                new nt(3, 1, 1, 1),
                new nt(1, 1, 1, 1),
                new nt(3, 0, 1, 1),
                new nt(1, 0, 1, 1)
            ], this._cubeDirections = [
                new k(1, 0, 0),
                new k(-1, 0, 0),
                new k(0, 0, 1),
                new k(0, 0, -1),
                new k(0, 1, 0),
                new k(0, -1, 0)
            ], this._cubeUps = [
                new k(0, 1, 0),
                new k(0, 1, 0),
                new k(0, 1, 0),
                new k(0, 1, 0),
                new k(0, 0, 1),
                new k(0, 0, -1)
            ];
        }
        updateMatrices(e, t = 0) {
            const n = this.camera, s = this.matrix, r = e.distance || n.far;
            r !== n.far && (n.far = r, n.updateProjectionMatrix()), Qs.setFromMatrixPosition(e.matrixWorld), n.position.copy(Qs), Io.copy(n.position), Io.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(Io), n.updateMatrixWorld(), s.makeTranslation(-Qs.x, -Qs.y, -Qs.z), Pu.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Pu);
        }
    }
    class Lx extends Za {
        constructor(e, t, n = 0, s = 2){
            super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = s, this.shadow = new Dx;
        }
        get power() {
            return this.intensity * 4 * Math.PI;
        }
        set power(e) {
            this.intensity = e / (4 * Math.PI);
        }
        dispose() {
            this.shadow.dispose();
        }
        copy(e, t) {
            return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
        }
    }
    class eh extends Wf {
        constructor(e = -1, t = 1, n = 1, s = -1, r = .1, a = 2e3){
            super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = s, this.near = r, this.far = a, this.updateProjectionMatrix();
        }
        copy(e, t) {
            return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
        }
        setViewOffset(e, t, n, s, r, a) {
            this.view === null && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = s, this.view.width = r, this.view.height = a, this.updateProjectionMatrix();
        }
        clearViewOffset() {
            this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
            const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, s = (this.top + this.bottom) / 2;
            let r = n - e, a = n + e, o = s + t, c = s - t;
            if (this.view !== null && this.view.enabled) {
                const l = (this.right - this.left) / this.view.fullWidth / this.zoom, h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                r += l * this.view.offsetX, a = r + l * this.view.width, o -= h * this.view.offsetY, c = o - h * this.view.height;
            }
            this.projectionMatrix.makeOrthographic(r, a, o, c, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
        }
    }
    class Ux extends Ql {
        constructor(){
            super(new eh(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0;
        }
    }
    class tp extends Za {
        constructor(e, t){
            super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(gt.DEFAULT_UP), this.updateMatrix(), this.target = new gt, this.shadow = new Ux;
        }
        dispose() {
            this.shadow.dispose();
        }
        copy(e) {
            return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
        }
    }
    class Nx extends Za {
        constructor(e, t){
            super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight";
        }
    }
    class pr {
        static extractUrlBase(e) {
            const t = e.lastIndexOf("/");
            return t === -1 ? "./" : e.slice(0, t + 1);
        }
        static resolveURL(e, t) {
            return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
        }
    }
    class Bx extends zs {
        constructor(e){
            super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
                premultiplyAlpha: "none"
            };
        }
        setOptions(e) {
            return this.options = e, this;
        }
        load(e, t, n, s) {
            e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
            const r = this, a = di.get(e);
            if (a !== void 0) {
                if (r.manager.itemStart(e), a.then) {
                    a.then((l)=>{
                        t && t(l), r.manager.itemEnd(e);
                    }).catch((l)=>{
                        s && s(l);
                    });
                    return;
                }
                return setTimeout(function() {
                    t && t(a), r.manager.itemEnd(e);
                }, 0), a;
            }
            const o = {};
            o.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", o.headers = this.requestHeader;
            const c = fetch(e, o).then(function(l) {
                return l.blob();
            }).then(function(l) {
                return createImageBitmap(l, Object.assign(r.options, {
                    colorSpaceConversion: "none"
                }));
            }).then(function(l) {
                return di.add(e, l), t && t(l), r.manager.itemEnd(e), l;
            }).catch(function(l) {
                s && s(l), di.remove(e), r.manager.itemError(e), r.manager.itemEnd(e);
            });
            di.add(e, c), r.manager.itemStart(e);
        }
    }
    class Fx extends Wt {
        constructor(e = []){
            super(), this.isArrayCamera = !0, this.cameras = e, this.index = 0;
        }
    }
    class Ox {
        constructor(e = !0){
            this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
        }
        start() {
            this.startTime = Iu(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
        }
        stop() {
            this.getElapsedTime(), this.running = !1, this.autoStart = !1;
        }
        getElapsedTime() {
            return this.getDelta(), this.elapsedTime;
        }
        getDelta() {
            let e = 0;
            if (this.autoStart && !this.running) return this.start(), 0;
            if (this.running) {
                const t = Iu();
                e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
            }
            return e;
        }
    }
    function Iu() {
        return performance.now();
    }
    class kx {
        constructor(e, t, n){
            this.binding = e, this.valueSize = n;
            let s, r, a;
            switch(t){
                case "quaternion":
                    s = this._slerp, r = this._slerpAdditive, a = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(n * 6), this._workIndex = 5;
                    break;
                case "string":
                case "bool":
                    s = this._select, r = this._select, a = this._setAdditiveIdentityOther, this.buffer = new Array(n * 5);
                    break;
                default:
                    s = this._lerp, r = this._lerpAdditive, a = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(n * 5);
            }
            this._mixBufferRegion = s, this._mixBufferRegionAdditive = r, this._setIdentity = a, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
        }
        accumulate(e, t) {
            const n = this.buffer, s = this.valueSize, r = e * s + s;
            let a = this.cumulativeWeight;
            if (a === 0) {
                for(let o = 0; o !== s; ++o)n[r + o] = n[o];
                a = t;
            } else {
                a += t;
                const o = t / a;
                this._mixBufferRegion(n, r, 0, o, s);
            }
            this.cumulativeWeight = a;
        }
        accumulateAdditive(e) {
            const t = this.buffer, n = this.valueSize, s = n * this._addIndex;
            this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, s, 0, e, n), this.cumulativeWeightAdditive += e;
        }
        apply(e) {
            const t = this.valueSize, n = this.buffer, s = e * t + t, r = this.cumulativeWeight, a = this.cumulativeWeightAdditive, o = this.binding;
            if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
                const c = t * this._origIndex;
                this._mixBufferRegion(n, s, c, 1 - r, t);
            }
            a > 0 && this._mixBufferRegionAdditive(n, s, this._addIndex * t, 1, t);
            for(let c = t, l = t + t; c !== l; ++c)if (n[c] !== n[c + t]) {
                o.setValue(n, s);
                break;
            }
        }
        saveOriginalState() {
            const e = this.binding, t = this.buffer, n = this.valueSize, s = n * this._origIndex;
            e.getValue(t, s);
            for(let r = n, a = s; r !== a; ++r)t[r] = t[s + r % n];
            this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
        }
        restoreOriginalState() {
            const e = this.valueSize * 3;
            this.binding.setValue(this.buffer, e);
        }
        _setAdditiveIdentityNumeric() {
            const e = this._addIndex * this.valueSize, t = e + this.valueSize;
            for(let n = e; n < t; n++)this.buffer[n] = 0;
        }
        _setAdditiveIdentityQuaternion() {
            this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
        }
        _setAdditiveIdentityOther() {
            const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize;
            for(let n = 0; n < this.valueSize; n++)this.buffer[t + n] = this.buffer[e + n];
        }
        _select(e, t, n, s, r) {
            if (s >= .5) for(let a = 0; a !== r; ++a)e[t + a] = e[n + a];
        }
        _slerp(e, t, n, s) {
            En.slerpFlat(e, t, e, t, e, n, s);
        }
        _slerpAdditive(e, t, n, s, r) {
            const a = this._workIndex * r;
            En.multiplyQuaternionsFlat(e, a, e, t, e, n), En.slerpFlat(e, t, e, t, e, a, s);
        }
        _lerp(e, t, n, s, r) {
            const a = 1 - s;
            for(let o = 0; o !== r; ++o){
                const c = t + o;
                e[c] = e[c] * a + e[n + o] * s;
            }
        }
        _lerpAdditive(e, t, n, s, r) {
            for(let a = 0; a !== r; ++a){
                const o = t + a;
                e[o] = e[o] + e[n + a] * s;
            }
        }
    }
    const th = "\\[\\]\\.:\\/", Gx = new RegExp("[" + th + "]", "g"), nh = "[^" + th + "]", Hx = "[^" + th.replace("\\.", "") + "]", zx = /((?:WC+[\/:])*)/.source.replace("WC", nh), Vx = /(WCOD+)?/.source.replace("WCOD", Hx), Wx = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", nh), Xx = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", nh), Yx = new RegExp("^" + zx + Vx + Wx + Xx + "$"), qx = [
        "material",
        "materials",
        "bones",
        "map"
    ];
    class jx {
        constructor(e, t, n){
            const s = n || rt.parseTrackName(t);
            this._targetGroup = e, this._bindings = e.subscribe_(t, s);
        }
        getValue(e, t) {
            this.bind();
            const n = this._targetGroup.nCachedObjects_, s = this._bindings[n];
            s !== void 0 && s.getValue(e, t);
        }
        setValue(e, t) {
            const n = this._bindings;
            for(let s = this._targetGroup.nCachedObjects_, r = n.length; s !== r; ++s)n[s].setValue(e, t);
        }
        bind() {
            const e = this._bindings;
            for(let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)e[t].bind();
        }
        unbind() {
            const e = this._bindings;
            for(let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)e[t].unbind();
        }
    }
    class rt {
        constructor(e, t, n){
            this.path = t, this.parsedPath = n || rt.parseTrackName(t), this.node = rt.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
        }
        static create(e, t, n) {
            return e && e.isAnimationObjectGroup ? new rt.Composite(e, t, n) : new rt(e, t, n);
        }
        static sanitizeNodeName(e) {
            return e.replace(/\s/g, "_").replace(Gx, "");
        }
        static parseTrackName(e) {
            const t = Yx.exec(e);
            if (t === null) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
            const n = {
                nodeName: t[2],
                objectName: t[3],
                objectIndex: t[4],
                propertyName: t[5],
                propertyIndex: t[6]
            }, s = n.nodeName && n.nodeName.lastIndexOf(".");
            if (s !== void 0 && s !== -1) {
                const r = n.nodeName.substring(s + 1);
                qx.indexOf(r) !== -1 && (n.nodeName = n.nodeName.substring(0, s), n.objectName = r);
            }
            if (n.propertyName === null || n.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
            return n;
        }
        static findNode(e, t) {
            if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid) return e;
            if (e.skeleton) {
                const n = e.skeleton.getBoneByName(t);
                if (n !== void 0) return n;
            }
            if (e.children) {
                const n = function(r) {
                    for(let a = 0; a < r.length; a++){
                        const o = r[a];
                        if (o.name === t || o.uuid === t) return o;
                        const c = n(o.children);
                        if (c) return c;
                    }
                    return null;
                }, s = n(e.children);
                if (s) return s;
            }
            return null;
        }
        _getValue_unavailable() {}
        _setValue_unavailable() {}
        _getValue_direct(e, t) {
            e[t] = this.targetObject[this.propertyName];
        }
        _getValue_array(e, t) {
            const n = this.resolvedProperty;
            for(let s = 0, r = n.length; s !== r; ++s)e[t++] = n[s];
        }
        _getValue_arrayElement(e, t) {
            e[t] = this.resolvedProperty[this.propertyIndex];
        }
        _getValue_toArray(e, t) {
            this.resolvedProperty.toArray(e, t);
        }
        _setValue_direct(e, t) {
            this.targetObject[this.propertyName] = e[t];
        }
        _setValue_direct_setNeedsUpdate(e, t) {
            this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0;
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
            this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
        }
        _setValue_array(e, t) {
            const n = this.resolvedProperty;
            for(let s = 0, r = n.length; s !== r; ++s)n[s] = e[t++];
        }
        _setValue_array_setNeedsUpdate(e, t) {
            const n = this.resolvedProperty;
            for(let s = 0, r = n.length; s !== r; ++s)n[s] = e[t++];
            this.targetObject.needsUpdate = !0;
        }
        _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
            const n = this.resolvedProperty;
            for(let s = 0, r = n.length; s !== r; ++s)n[s] = e[t++];
            this.targetObject.matrixWorldNeedsUpdate = !0;
        }
        _setValue_arrayElement(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t];
        }
        _setValue_arrayElement_setNeedsUpdate(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0;
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
        }
        _setValue_fromArray(e, t) {
            this.resolvedProperty.fromArray(e, t);
        }
        _setValue_fromArray_setNeedsUpdate(e, t) {
            this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0;
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
            this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0;
        }
        _getValue_unbound(e, t) {
            this.bind(), this.getValue(e, t);
        }
        _setValue_unbound(e, t) {
            this.bind(), this.setValue(e, t);
        }
        bind() {
            let e = this.node;
            const t = this.parsedPath, n = t.objectName, s = t.propertyName;
            let r = t.propertyIndex;
            if (e || (e = rt.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
                console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
                return;
            }
            if (n) {
                let l = t.objectIndex;
                switch(n){
                    case "materials":
                        if (!e.material) {
                            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            return;
                        }
                        if (!e.material.materials) {
                            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                            return;
                        }
                        e = e.material.materials;
                        break;
                    case "bones":
                        if (!e.skeleton) {
                            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                            return;
                        }
                        e = e.skeleton.bones;
                        for(let h = 0; h < e.length; h++)if (e[h].name === l) {
                            l = h;
                            break;
                        }
                        break;
                    case "map":
                        if ("map" in e) {
                            e = e.map;
                            break;
                        }
                        if (!e.material) {
                            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            return;
                        }
                        if (!e.material.map) {
                            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                            return;
                        }
                        e = e.material.map;
                        break;
                    default:
                        if (e[n] === void 0) {
                            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                            return;
                        }
                        e = e[n];
                }
                if (l !== void 0) {
                    if (e[l] === void 0) {
                        console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                        return;
                    }
                    e = e[l];
                }
            }
            const a = e[s];
            if (a === void 0) {
                const l = t.nodeName;
                console.error("THREE.PropertyBinding: Trying to update property for track: " + l + "." + s + " but it wasn't found.", e);
                return;
            }
            let o = this.Versioning.None;
            this.targetObject = e, e.isMaterial === !0 ? o = this.Versioning.NeedsUpdate : e.isObject3D === !0 && (o = this.Versioning.MatrixWorldNeedsUpdate);
            let c = this.BindingType.Direct;
            if (r !== void 0) {
                if (s === "morphTargetInfluences") {
                    if (!e.geometry) {
                        console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                        return;
                    }
                    if (!e.geometry.morphAttributes) {
                        console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                        return;
                    }
                    e.morphTargetDictionary[r] !== void 0 && (r = e.morphTargetDictionary[r]);
                }
                c = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = r;
            } else a.fromArray !== void 0 && a.toArray !== void 0 ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = a) : Array.isArray(a) ? (c = this.BindingType.EntireArray, this.resolvedProperty = a) : this.propertyName = s;
            this.getValue = this.GetterByBindingType[c], this.setValue = this.SetterByBindingTypeAndVersioning[c][o];
        }
        unbind() {
            this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
        }
    }
    rt.Composite = jx;
    rt.prototype.BindingType = {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3
    };
    rt.prototype.Versioning = {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2
    };
    rt.prototype.GetterByBindingType = [
        rt.prototype._getValue_direct,
        rt.prototype._getValue_array,
        rt.prototype._getValue_arrayElement,
        rt.prototype._getValue_toArray
    ];
    rt.prototype.SetterByBindingTypeAndVersioning = [
        [
            rt.prototype._setValue_direct,
            rt.prototype._setValue_direct_setNeedsUpdate,
            rt.prototype._setValue_direct_setMatrixWorldNeedsUpdate
        ],
        [
            rt.prototype._setValue_array,
            rt.prototype._setValue_array_setNeedsUpdate,
            rt.prototype._setValue_array_setMatrixWorldNeedsUpdate
        ],
        [
            rt.prototype._setValue_arrayElement,
            rt.prototype._setValue_arrayElement_setNeedsUpdate,
            rt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
        ],
        [
            rt.prototype._setValue_fromArray,
            rt.prototype._setValue_fromArray_setNeedsUpdate,
            rt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
        ]
    ];
    class $x {
        constructor(e, t, n = null, s = t.blendMode){
            this._mixer = e, this._clip = t, this._localRoot = n, this.blendMode = s;
            const r = t.tracks, a = r.length, o = new Array(a), c = {
                endingStart: vs,
                endingEnd: vs
            };
            for(let l = 0; l !== a; ++l){
                const h = r[l].createInterpolant(null);
                o[l] = h, h.settings = c;
            }
            this._interpolantSettings = c, this._interpolants = o, this._propertyBindings = new Array(a), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = Pa, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
        }
        play() {
            return this._mixer._activateAction(this), this;
        }
        stop() {
            return this._mixer._deactivateAction(this), this.reset();
        }
        reset() {
            return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
        }
        isRunning() {
            return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
        }
        isScheduled() {
            return this._mixer._isActiveAction(this);
        }
        startAt(e) {
            return this._startTime = e, this;
        }
        setLoop(e, t) {
            return this.loop = e, this.repetitions = t, this;
        }
        setEffectiveWeight(e) {
            return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
        }
        getEffectiveWeight() {
            return this._effectiveWeight;
        }
        fadeIn(e) {
            return this._scheduleFading(e, 0, 1);
        }
        fadeOut(e) {
            return this._scheduleFading(e, 1, 0);
        }
        crossFadeFrom(e, t, n = !1) {
            if (e.fadeOut(t), this.fadeIn(t), n === !0) {
                const s = this._clip.duration, r = e._clip.duration, a = r / s, o = s / r;
                e.warp(1, a, t), this.warp(o, 1, t);
            }
            return this;
        }
        crossFadeTo(e, t, n = !1) {
            return e.crossFadeFrom(this, t, n);
        }
        stopFading() {
            const e = this._weightInterpolant;
            return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
        }
        setEffectiveTimeScale(e) {
            return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
        }
        getEffectiveTimeScale() {
            return this._effectiveTimeScale;
        }
        setDuration(e) {
            return this.timeScale = this._clip.duration / e, this.stopWarping();
        }
        syncWith(e) {
            return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
        }
        halt(e) {
            return this.warp(this._effectiveTimeScale, 0, e);
        }
        warp(e, t, n) {
            const s = this._mixer, r = s.time, a = this.timeScale;
            let o = this._timeScaleInterpolant;
            o === null && (o = s._lendControlInterpolant(), this._timeScaleInterpolant = o);
            const c = o.parameterPositions, l = o.sampleValues;
            return c[0] = r, c[1] = r + n, l[0] = e / a, l[1] = t / a, this;
        }
        stopWarping() {
            const e = this._timeScaleInterpolant;
            return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
        }
        getMixer() {
            return this._mixer;
        }
        getClip() {
            return this._clip;
        }
        getRoot() {
            return this._localRoot || this._mixer._root;
        }
        _update(e, t, n, s) {
            if (!this.enabled) {
                this._updateWeight(e);
                return;
            }
            const r = this._startTime;
            if (r !== null) {
                const c = (e - r) * n;
                c < 0 || n === 0 ? t = 0 : (this._startTime = null, t = n * c);
            }
            t *= this._updateTimeScale(e);
            const a = this._updateTime(t), o = this._updateWeight(e);
            if (o > 0) {
                const c = this._interpolants, l = this._propertyBindings;
                switch(this.blendMode){
                    case ng:
                        for(let h = 0, u = c.length; h !== u; ++h)c[h].evaluate(a), l[h].accumulateAdditive(o);
                        break;
                    case Yl:
                    default:
                        for(let h = 0, u = c.length; h !== u; ++h)c[h].evaluate(a), l[h].accumulate(s, o);
                }
            }
        }
        _updateWeight(e) {
            let t = 0;
            if (this.enabled) {
                t = this.weight;
                const n = this._weightInterpolant;
                if (n !== null) {
                    const s = n.evaluate(e)[0];
                    t *= s, e > n.parameterPositions[1] && (this.stopFading(), s === 0 && (this.enabled = !1));
                }
            }
            return this._effectiveWeight = t, t;
        }
        _updateTimeScale(e) {
            let t = 0;
            if (!this.paused) {
                t = this.timeScale;
                const n = this._timeScaleInterpolant;
                if (n !== null) {
                    const s = n.evaluate(e)[0];
                    t *= s, e > n.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t);
                }
            }
            return this._effectiveTimeScale = t, t;
        }
        _updateTime(e) {
            const t = this._clip.duration, n = this.loop;
            let s = this.time + e, r = this._loopCount;
            const a = n === tg;
            if (e === 0) return r === -1 ? s : a && (r & 1) === 1 ? t - s : s;
            if (n === or) {
                r === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                e: {
                    if (s >= t) s = t;
                    else if (s < 0) s = 0;
                    else {
                        this.time = s;
                        break e;
                    }
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = s, this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: e < 0 ? -1 : 1
                    });
                }
            } else {
                if (r === -1 && (e >= 0 ? (r = 0, this._setEndings(!0, this.repetitions === 0, a)) : this._setEndings(this.repetitions === 0, !0, a)), s >= t || s < 0) {
                    const o = Math.floor(s / t);
                    s -= t * o, r += Math.abs(o);
                    const c = this.repetitions - r;
                    if (c <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, s = e > 0 ? t : 0, this.time = s, this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: e > 0 ? 1 : -1
                    });
                    else {
                        if (c === 1) {
                            const l = e < 0;
                            this._setEndings(l, !l, a);
                        } else this._setEndings(!1, !1, a);
                        this._loopCount = r, this.time = s, this._mixer.dispatchEvent({
                            type: "loop",
                            action: this,
                            loopDelta: o
                        });
                    }
                } else this.time = s;
                if (a && (r & 1) === 1) return t - s;
            }
            return s;
        }
        _setEndings(e, t, n) {
            const s = this._interpolantSettings;
            n ? (s.endingStart = ys, s.endingEnd = ys) : (e ? s.endingStart = this.zeroSlopeAtStart ? ys : vs : s.endingStart = Oa, t ? s.endingEnd = this.zeroSlopeAtEnd ? ys : vs : s.endingEnd = Oa);
        }
        _scheduleFading(e, t, n) {
            const s = this._mixer, r = s.time;
            let a = this._weightInterpolant;
            a === null && (a = s._lendControlInterpolant(), this._weightInterpolant = a);
            const o = a.parameterPositions, c = a.sampleValues;
            return o[0] = r, c[0] = t, o[1] = r + e, c[1] = n, this;
        }
    }
    const Kx = new Float32Array(1);
    class Zx extends ji {
        constructor(e){
            super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
        }
        _bindAction(e, t) {
            const n = e._localRoot || this._root, s = e._clip.tracks, r = s.length, a = e._propertyBindings, o = e._interpolants, c = n.uuid, l = this._bindingsByRootAndName;
            let h = l[c];
            h === void 0 && (h = {}, l[c] = h);
            for(let u = 0; u !== r; ++u){
                const d = s[u], f = d.name;
                let _ = h[f];
                if (_ !== void 0) ++_.referenceCount, a[u] = _;
                else {
                    if (_ = a[u], _ !== void 0) {
                        _._cacheIndex === null && (++_.referenceCount, this._addInactiveBinding(_, c, f));
                        continue;
                    }
                    const g = t && t._propertyBindings[u].binding.parsedPath;
                    _ = new kx(rt.create(n, f, g), d.ValueTypeName, d.getValueSize()), ++_.referenceCount, this._addInactiveBinding(_, c, f), a[u] = _;
                }
                o[u].resultBuffer = _.buffer;
            }
        }
        _activateAction(e) {
            if (!this._isActiveAction(e)) {
                if (e._cacheIndex === null) {
                    const n = (e._localRoot || this._root).uuid, s = e._clip.uuid, r = this._actionsByClip[s];
                    this._bindAction(e, r && r.knownActions[0]), this._addInactiveAction(e, s, n);
                }
                const t = e._propertyBindings;
                for(let n = 0, s = t.length; n !== s; ++n){
                    const r = t[n];
                    r.useCount++ === 0 && (this._lendBinding(r), r.saveOriginalState());
                }
                this._lendAction(e);
            }
        }
        _deactivateAction(e) {
            if (this._isActiveAction(e)) {
                const t = e._propertyBindings;
                for(let n = 0, s = t.length; n !== s; ++n){
                    const r = t[n];
                    --r.useCount === 0 && (r.restoreOriginalState(), this._takeBackBinding(r));
                }
                this._takeBackAction(e);
            }
        }
        _initMemoryManager() {
            this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
            const e = this;
            this.stats = {
                actions: {
                    get total () {
                        return e._actions.length;
                    },
                    get inUse () {
                        return e._nActiveActions;
                    }
                },
                bindings: {
                    get total () {
                        return e._bindings.length;
                    },
                    get inUse () {
                        return e._nActiveBindings;
                    }
                },
                controlInterpolants: {
                    get total () {
                        return e._controlInterpolants.length;
                    },
                    get inUse () {
                        return e._nActiveControlInterpolants;
                    }
                }
            };
        }
        _isActiveAction(e) {
            const t = e._cacheIndex;
            return t !== null && t < this._nActiveActions;
        }
        _addInactiveAction(e, t, n) {
            const s = this._actions, r = this._actionsByClip;
            let a = r[t];
            if (a === void 0) a = {
                knownActions: [
                    e
                ],
                actionByRoot: {}
            }, e._byClipCacheIndex = 0, r[t] = a;
            else {
                const o = a.knownActions;
                e._byClipCacheIndex = o.length, o.push(e);
            }
            e._cacheIndex = s.length, s.push(e), a.actionByRoot[n] = e;
        }
        _removeInactiveAction(e) {
            const t = this._actions, n = t[t.length - 1], s = e._cacheIndex;
            n._cacheIndex = s, t[s] = n, t.pop(), e._cacheIndex = null;
            const r = e._clip.uuid, a = this._actionsByClip, o = a[r], c = o.knownActions, l = c[c.length - 1], h = e._byClipCacheIndex;
            l._byClipCacheIndex = h, c[h] = l, c.pop(), e._byClipCacheIndex = null;
            const u = o.actionByRoot, d = (e._localRoot || this._root).uuid;
            delete u[d], c.length === 0 && delete a[r], this._removeInactiveBindingsForAction(e);
        }
        _removeInactiveBindingsForAction(e) {
            const t = e._propertyBindings;
            for(let n = 0, s = t.length; n !== s; ++n){
                const r = t[n];
                --r.referenceCount === 0 && this._removeInactiveBinding(r);
            }
        }
        _lendAction(e) {
            const t = this._actions, n = e._cacheIndex, s = this._nActiveActions++, r = t[s];
            e._cacheIndex = s, t[s] = e, r._cacheIndex = n, t[n] = r;
        }
        _takeBackAction(e) {
            const t = this._actions, n = e._cacheIndex, s = --this._nActiveActions, r = t[s];
            e._cacheIndex = s, t[s] = e, r._cacheIndex = n, t[n] = r;
        }
        _addInactiveBinding(e, t, n) {
            const s = this._bindingsByRootAndName, r = this._bindings;
            let a = s[t];
            a === void 0 && (a = {}, s[t] = a), a[n] = e, e._cacheIndex = r.length, r.push(e);
        }
        _removeInactiveBinding(e) {
            const t = this._bindings, n = e.binding, s = n.rootNode.uuid, r = n.path, a = this._bindingsByRootAndName, o = a[s], c = t[t.length - 1], l = e._cacheIndex;
            c._cacheIndex = l, t[l] = c, t.pop(), delete o[r], Object.keys(o).length === 0 && delete a[s];
        }
        _lendBinding(e) {
            const t = this._bindings, n = e._cacheIndex, s = this._nActiveBindings++, r = t[s];
            e._cacheIndex = s, t[s] = e, r._cacheIndex = n, t[n] = r;
        }
        _takeBackBinding(e) {
            const t = this._bindings, n = e._cacheIndex, s = --this._nActiveBindings, r = t[s];
            e._cacheIndex = s, t[s] = e, r._cacheIndex = n, t[n] = r;
        }
        _lendControlInterpolant() {
            const e = this._controlInterpolants, t = this._nActiveControlInterpolants++;
            let n = e[t];
            return n === void 0 && (n = new Jf(new Float32Array(2), new Float32Array(2), 1, Kx), n.__cacheIndex = t, e[t] = n), n;
        }
        _takeBackControlInterpolant(e) {
            const t = this._controlInterpolants, n = e.__cacheIndex, s = --this._nActiveControlInterpolants, r = t[s];
            e.__cacheIndex = s, t[s] = e, r.__cacheIndex = n, t[n] = r;
        }
        clipAction(e, t, n) {
            const s = t || this._root, r = s.uuid;
            let a = typeof e == "string" ? hl.findByName(s, e) : e;
            const o = a !== null ? a.uuid : e, c = this._actionsByClip[o];
            let l = null;
            if (n === void 0 && (a !== null ? n = a.blendMode : n = Yl), c !== void 0) {
                const u = c.actionByRoot[r];
                if (u !== void 0 && u.blendMode === n) return u;
                l = c.knownActions[0], a === null && (a = l._clip);
            }
            if (a === null) return null;
            const h = new $x(this, a, t, n);
            return this._bindAction(h, l), this._addInactiveAction(h, o, r), h;
        }
        existingAction(e, t) {
            const n = t || this._root, s = n.uuid, r = typeof e == "string" ? hl.findByName(n, e) : e, a = r ? r.uuid : e, o = this._actionsByClip[a];
            return o !== void 0 && o.actionByRoot[s] || null;
        }
        stopAllAction() {
            const e = this._actions, t = this._nActiveActions;
            for(let n = t - 1; n >= 0; --n)e[n].stop();
            return this;
        }
        update(e) {
            e *= this.timeScale;
            const t = this._actions, n = this._nActiveActions, s = this.time += e, r = Math.sign(e), a = this._accuIndex ^= 1;
            for(let l = 0; l !== n; ++l)t[l]._update(s, e, r, a);
            const o = this._bindings, c = this._nActiveBindings;
            for(let l = 0; l !== c; ++l)o[l].apply(a);
            return this;
        }
        setTime(e) {
            this.time = 0;
            for(let t = 0; t < this._actions.length; t++)this._actions[t].time = 0;
            return this.update(e);
        }
        getRoot() {
            return this._root;
        }
        uncacheClip(e) {
            const t = this._actions, n = e.uuid, s = this._actionsByClip, r = s[n];
            if (r !== void 0) {
                const a = r.knownActions;
                for(let o = 0, c = a.length; o !== c; ++o){
                    const l = a[o];
                    this._deactivateAction(l);
                    const h = l._cacheIndex, u = t[t.length - 1];
                    l._cacheIndex = null, l._byClipCacheIndex = null, u._cacheIndex = h, t[h] = u, t.pop(), this._removeInactiveBindingsForAction(l);
                }
                delete s[n];
            }
        }
        uncacheRoot(e) {
            const t = e.uuid, n = this._actionsByClip;
            for(const a in n){
                const o = n[a].actionByRoot, c = o[t];
                c !== void 0 && (this._deactivateAction(c), this._removeInactiveAction(c));
            }
            const s = this._bindingsByRootAndName, r = s[t];
            if (r !== void 0) for(const a in r){
                const o = r[a];
                o.restoreOriginalState(), this._removeInactiveBinding(o);
            }
        }
        uncacheAction(e, t) {
            const n = this.existingAction(e, t);
            n !== null && (this._deactivateAction(n), this._removeInactiveAction(n));
        }
    }
    function Du(i, e, t, n) {
        const s = Jx(n);
        switch(t){
            case Rf:
                return i * e;
            case Pf:
                return i * e;
            case If:
                return i * e * 2;
            case zl:
                return i * e / s.components * s.byteLength;
            case Vl:
                return i * e / s.components * s.byteLength;
            case Df:
                return i * e * 2 / s.components * s.byteLength;
            case Wl:
                return i * e * 2 / s.components * s.byteLength;
            case Cf:
                return i * e * 3 / s.components * s.byteLength;
            case un:
                return i * e * 4 / s.components * s.byteLength;
            case Xl:
                return i * e * 4 / s.components * s.byteLength;
            case Ea:
            case Aa:
                return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 8;
            case wa:
            case Ra:
                return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 16;
            case Nc:
            case Fc:
                return Math.max(i, 16) * Math.max(e, 8) / 4;
            case Uc:
            case Bc:
                return Math.max(i, 8) * Math.max(e, 8) / 2;
            case Oc:
            case kc:
                return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 8;
            case Gc:
                return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 16;
            case Hc:
                return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 16;
            case zc:
                return Math.floor((i + 4) / 5) * Math.floor((e + 3) / 4) * 16;
            case Vc:
                return Math.floor((i + 4) / 5) * Math.floor((e + 4) / 5) * 16;
            case Wc:
                return Math.floor((i + 5) / 6) * Math.floor((e + 4) / 5) * 16;
            case Xc:
                return Math.floor((i + 5) / 6) * Math.floor((e + 5) / 6) * 16;
            case Yc:
                return Math.floor((i + 7) / 8) * Math.floor((e + 4) / 5) * 16;
            case qc:
                return Math.floor((i + 7) / 8) * Math.floor((e + 5) / 6) * 16;
            case jc:
                return Math.floor((i + 7) / 8) * Math.floor((e + 7) / 8) * 16;
            case $c:
                return Math.floor((i + 9) / 10) * Math.floor((e + 4) / 5) * 16;
            case Kc:
                return Math.floor((i + 9) / 10) * Math.floor((e + 5) / 6) * 16;
            case Zc:
                return Math.floor((i + 9) / 10) * Math.floor((e + 7) / 8) * 16;
            case Jc:
                return Math.floor((i + 9) / 10) * Math.floor((e + 9) / 10) * 16;
            case Qc:
                return Math.floor((i + 11) / 12) * Math.floor((e + 9) / 10) * 16;
            case el:
                return Math.floor((i + 11) / 12) * Math.floor((e + 11) / 12) * 16;
            case Ca:
            case tl:
            case nl:
                return Math.ceil(i / 4) * Math.ceil(e / 4) * 16;
            case Lf:
            case il:
                return Math.ceil(i / 4) * Math.ceil(e / 4) * 8;
            case sl:
            case rl:
                return Math.ceil(i / 4) * Math.ceil(e / 4) * 16;
        }
        throw new Error(`Unable to determine texture byte length for ${t} format.`);
    }
    function Jx(i) {
        switch(i){
            case ni:
            case Ef:
                return {
                    byteLength: 1,
                    components: 1
                };
            case br:
            case Af:
            case Lr:
                return {
                    byteLength: 2,
                    components: 1
                };
            case Gl:
            case Hl:
                return {
                    byteLength: 2,
                    components: 4
                };
            case zi:
            case kl:
            case Mn:
                return {
                    byteLength: 4,
                    components: 1
                };
            case wf:
                return {
                    byteLength: 4,
                    components: 3
                };
        }
        throw new Error(`Unknown texture type ${i}.`);
    }
    typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
        detail: {
            revision: Ol
        }
    }));
    typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Ol);
    function np() {
        let i = null, e = !1, t = null, n = null;
        function s(r, a) {
            t(r, a), n = i.requestAnimationFrame(s);
        }
        return {
            start: function() {
                e !== !0 && t !== null && (n = i.requestAnimationFrame(s), e = !0);
            },
            stop: function() {
                i.cancelAnimationFrame(n), e = !1;
            },
            setAnimationLoop: function(r) {
                t = r;
            },
            setContext: function(r) {
                i = r;
            }
        };
    }
    function Qx(i) {
        const e = new WeakMap;
        function t(o, c) {
            const l = o.array, h = o.usage, u = l.byteLength, d = i.createBuffer();
            i.bindBuffer(c, d), i.bufferData(c, l, h), o.onUploadCallback();
            let f;
            if (l instanceof Float32Array) f = i.FLOAT;
            else if (l instanceof Uint16Array) o.isFloat16BufferAttribute ? f = i.HALF_FLOAT : f = i.UNSIGNED_SHORT;
            else if (l instanceof Int16Array) f = i.SHORT;
            else if (l instanceof Uint32Array) f = i.UNSIGNED_INT;
            else if (l instanceof Int32Array) f = i.INT;
            else if (l instanceof Int8Array) f = i.BYTE;
            else if (l instanceof Uint8Array) f = i.UNSIGNED_BYTE;
            else if (l instanceof Uint8ClampedArray) f = i.UNSIGNED_BYTE;
            else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + l);
            return {
                buffer: d,
                type: f,
                bytesPerElement: l.BYTES_PER_ELEMENT,
                version: o.version,
                size: u
            };
        }
        function n(o, c, l) {
            const h = c.array, u = c.updateRanges;
            if (i.bindBuffer(l, o), u.length === 0) i.bufferSubData(l, 0, h);
            else {
                u.sort((f, _)=>f.start - _.start);
                let d = 0;
                for(let f = 1; f < u.length; f++){
                    const _ = u[d], g = u[f];
                    g.start <= _.start + _.count + 1 ? _.count = Math.max(_.count, g.start + g.count - _.start) : (++d, u[d] = g);
                }
                u.length = d + 1;
                for(let f = 0, _ = u.length; f < _; f++){
                    const g = u[f];
                    i.bufferSubData(l, g.start * h.BYTES_PER_ELEMENT, h, g.start, g.count);
                }
                c.clearUpdateRanges();
            }
            c.onUploadCallback();
        }
        function s(o) {
            return o.isInterleavedBufferAttribute && (o = o.data), e.get(o);
        }
        function r(o) {
            o.isInterleavedBufferAttribute && (o = o.data);
            const c = e.get(o);
            c && (i.deleteBuffer(c.buffer), e.delete(o));
        }
        function a(o, c) {
            if (o.isInterleavedBufferAttribute && (o = o.data), o.isGLBufferAttribute) {
                const h = e.get(o);
                (!h || h.version < o.version) && e.set(o, {
                    buffer: o.buffer,
                    type: o.type,
                    bytesPerElement: o.elementSize,
                    version: o.version
                });
                return;
            }
            const l = e.get(o);
            if (l === void 0) e.set(o, t(o, c));
            else if (l.version < o.version) {
                if (l.size !== o.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
                n(l.buffer, o, c), l.version = o.version;
            }
        }
        return {
            get: s,
            remove: r,
            update: a
        };
    }
    var e0 = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, t0 = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, n0 = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, i0 = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, s0 = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, r0 = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, a0 = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, o0 = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, c0 = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`, l0 = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`, h0 = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, u0 = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, d0 = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, f0 = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, p0 = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, m0 = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, _0 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, g0 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, x0 = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, v0 = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, y0 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, b0 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`, S0 = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`, M0 = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, T0 = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, E0 = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, A0 = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, w0 = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, R0 = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, C0 = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, P0 = "gl_FragColor = linearToOutputTexel( gl_FragColor );", I0 = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, D0 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, L0 = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, U0 = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, N0 = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, B0 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, F0 = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, O0 = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, k0 = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, G0 = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, H0 = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, z0 = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, V0 = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, W0 = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, X0 = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, Y0 = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, q0 = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, j0 = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, $0 = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, K0 = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, Z0 = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, J0 = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, Q0 = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, ev = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, tv = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, nv = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, iv = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, sv = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, rv = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, av = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, ov = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, cv = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, lv = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, hv = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, uv = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, dv = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, fv = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, pv = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, mv = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`, _v = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, gv = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, xv = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, vv = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, yv = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, bv = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, Sv = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, Mv = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, Tv = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, Ev = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, Av = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, wv = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, Rv = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, Cv = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, Pv = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, Iv = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, Dv = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, Lv = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, Uv = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, Nv = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`, Bv = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, Fv = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, Ov = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, kv = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, Gv = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, Hv = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, zv = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, Vv = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, Wv = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, Xv = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, Yv = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, qv = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, jv = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, $v = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, Kv = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, Zv = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, Jv = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
    const Qv = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, ey = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, ty = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, ny = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, iy = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, sy = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, ry = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, ay = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`, oy = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, cy = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, ly = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, hy = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, uy = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, dy = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, fy = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, py = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, my = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, _y = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, gy = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, xy = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, vy = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, yy = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, by = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Sy = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, My = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, Ty = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Ey = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Ay = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, wy = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, Ry = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, Cy = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Py = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, Iy = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, Dy = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, Ve = {
        alphahash_fragment: e0,
        alphahash_pars_fragment: t0,
        alphamap_fragment: n0,
        alphamap_pars_fragment: i0,
        alphatest_fragment: s0,
        alphatest_pars_fragment: r0,
        aomap_fragment: a0,
        aomap_pars_fragment: o0,
        batching_pars_vertex: c0,
        batching_vertex: l0,
        begin_vertex: h0,
        beginnormal_vertex: u0,
        bsdfs: d0,
        iridescence_fragment: f0,
        bumpmap_pars_fragment: p0,
        clipping_planes_fragment: m0,
        clipping_planes_pars_fragment: _0,
        clipping_planes_pars_vertex: g0,
        clipping_planes_vertex: x0,
        color_fragment: v0,
        color_pars_fragment: y0,
        color_pars_vertex: b0,
        color_vertex: S0,
        common: M0,
        cube_uv_reflection_fragment: T0,
        defaultnormal_vertex: E0,
        displacementmap_pars_vertex: A0,
        displacementmap_vertex: w0,
        emissivemap_fragment: R0,
        emissivemap_pars_fragment: C0,
        colorspace_fragment: P0,
        colorspace_pars_fragment: I0,
        envmap_fragment: D0,
        envmap_common_pars_fragment: L0,
        envmap_pars_fragment: U0,
        envmap_pars_vertex: N0,
        envmap_physical_pars_fragment: Y0,
        envmap_vertex: B0,
        fog_vertex: F0,
        fog_pars_vertex: O0,
        fog_fragment: k0,
        fog_pars_fragment: G0,
        gradientmap_pars_fragment: H0,
        lightmap_pars_fragment: z0,
        lights_lambert_fragment: V0,
        lights_lambert_pars_fragment: W0,
        lights_pars_begin: X0,
        lights_toon_fragment: q0,
        lights_toon_pars_fragment: j0,
        lights_phong_fragment: $0,
        lights_phong_pars_fragment: K0,
        lights_physical_fragment: Z0,
        lights_physical_pars_fragment: J0,
        lights_fragment_begin: Q0,
        lights_fragment_maps: ev,
        lights_fragment_end: tv,
        logdepthbuf_fragment: nv,
        logdepthbuf_pars_fragment: iv,
        logdepthbuf_pars_vertex: sv,
        logdepthbuf_vertex: rv,
        map_fragment: av,
        map_pars_fragment: ov,
        map_particle_fragment: cv,
        map_particle_pars_fragment: lv,
        metalnessmap_fragment: hv,
        metalnessmap_pars_fragment: uv,
        morphinstance_vertex: dv,
        morphcolor_vertex: fv,
        morphnormal_vertex: pv,
        morphtarget_pars_vertex: mv,
        morphtarget_vertex: _v,
        normal_fragment_begin: gv,
        normal_fragment_maps: xv,
        normal_pars_fragment: vv,
        normal_pars_vertex: yv,
        normal_vertex: bv,
        normalmap_pars_fragment: Sv,
        clearcoat_normal_fragment_begin: Mv,
        clearcoat_normal_fragment_maps: Tv,
        clearcoat_pars_fragment: Ev,
        iridescence_pars_fragment: Av,
        opaque_fragment: wv,
        packing: Rv,
        premultiplied_alpha_fragment: Cv,
        project_vertex: Pv,
        dithering_fragment: Iv,
        dithering_pars_fragment: Dv,
        roughnessmap_fragment: Lv,
        roughnessmap_pars_fragment: Uv,
        shadowmap_pars_fragment: Nv,
        shadowmap_pars_vertex: Bv,
        shadowmap_vertex: Fv,
        shadowmask_pars_fragment: Ov,
        skinbase_vertex: kv,
        skinning_pars_vertex: Gv,
        skinning_vertex: Hv,
        skinnormal_vertex: zv,
        specularmap_fragment: Vv,
        specularmap_pars_fragment: Wv,
        tonemapping_fragment: Xv,
        tonemapping_pars_fragment: Yv,
        transmission_fragment: qv,
        transmission_pars_fragment: jv,
        uv_pars_fragment: $v,
        uv_pars_vertex: Kv,
        uv_vertex: Zv,
        worldpos_vertex: Jv,
        background_vert: Qv,
        background_frag: ey,
        backgroundCube_vert: ty,
        backgroundCube_frag: ny,
        cube_vert: iy,
        cube_frag: sy,
        depth_vert: ry,
        depth_frag: ay,
        distanceRGBA_vert: oy,
        distanceRGBA_frag: cy,
        equirect_vert: ly,
        equirect_frag: hy,
        linedashed_vert: uy,
        linedashed_frag: dy,
        meshbasic_vert: fy,
        meshbasic_frag: py,
        meshlambert_vert: my,
        meshlambert_frag: _y,
        meshmatcap_vert: gy,
        meshmatcap_frag: xy,
        meshnormal_vert: vy,
        meshnormal_frag: yy,
        meshphong_vert: by,
        meshphong_frag: Sy,
        meshphysical_vert: My,
        meshphysical_frag: Ty,
        meshtoon_vert: Ey,
        meshtoon_frag: Ay,
        points_vert: wy,
        points_frag: Ry,
        shadow_vert: Cy,
        shadow_frag: Py,
        sprite_vert: Iy,
        sprite_frag: Dy
    }, ue = {
        common: {
            diffuse: {
                value: new Be(16777215)
            },
            opacity: {
                value: 1
            },
            map: {
                value: null
            },
            mapTransform: {
                value: new Ge
            },
            alphaMap: {
                value: null
            },
            alphaMapTransform: {
                value: new Ge
            },
            alphaTest: {
                value: 0
            }
        },
        specularmap: {
            specularMap: {
                value: null
            },
            specularMapTransform: {
                value: new Ge
            }
        },
        envmap: {
            envMap: {
                value: null
            },
            envMapRotation: {
                value: new Ge
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1
            },
            ior: {
                value: 1.5
            },
            refractionRatio: {
                value: .98
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            },
            aoMapTransform: {
                value: new Ge
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            },
            lightMapTransform: {
                value: new Ge
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpMapTransform: {
                value: new Ge
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalMapTransform: {
                value: new Ge
            },
            normalScale: {
                value: new Ke(1, 1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementMapTransform: {
                value: new Ge
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            },
            emissiveMapTransform: {
                value: new Ge
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            },
            metalnessMapTransform: {
                value: new Ge
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            },
            roughnessMapTransform: {
                value: new Ge
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 25e-5
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2e3
            },
            fogColor: {
                value: new Be(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            lightProbe: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {},
                    color: {}
                }
            },
            directionalLightShadows: {
                value: [],
                properties: {
                    shadowIntensity: 1,
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {}
                }
            },
            spotLightShadows: {
                value: [],
                properties: {
                    shadowIntensity: 1,
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotLightMap: {
                value: []
            },
            spotShadowMap: {
                value: []
            },
            spotLightMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {}
                }
            },
            pointLightShadows: {
                value: [],
                properties: {
                    shadowIntensity: 1,
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            },
            rectAreaLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            },
            ltc_1: {
                value: null
            },
            ltc_2: {
                value: null
            }
        },
        points: {
            diffuse: {
                value: new Be(16777215)
            },
            opacity: {
                value: 1
            },
            size: {
                value: 1
            },
            scale: {
                value: 1
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            alphaMapTransform: {
                value: new Ge
            },
            alphaTest: {
                value: 0
            },
            uvTransform: {
                value: new Ge
            }
        },
        sprite: {
            diffuse: {
                value: new Be(16777215)
            },
            opacity: {
                value: 1
            },
            center: {
                value: new Ke(.5, .5)
            },
            rotation: {
                value: 0
            },
            map: {
                value: null
            },
            mapTransform: {
                value: new Ge
            },
            alphaMap: {
                value: null
            },
            alphaMapTransform: {
                value: new Ge
            },
            alphaTest: {
                value: 0
            }
        }
    }, Ln = {
        basic: {
            uniforms: Vt([
                ue.common,
                ue.specularmap,
                ue.envmap,
                ue.aomap,
                ue.lightmap,
                ue.fog
            ]),
            vertexShader: Ve.meshbasic_vert,
            fragmentShader: Ve.meshbasic_frag
        },
        lambert: {
            uniforms: Vt([
                ue.common,
                ue.specularmap,
                ue.envmap,
                ue.aomap,
                ue.lightmap,
                ue.emissivemap,
                ue.bumpmap,
                ue.normalmap,
                ue.displacementmap,
                ue.fog,
                ue.lights,
                {
                    emissive: {
                        value: new Be(0)
                    }
                }
            ]),
            vertexShader: Ve.meshlambert_vert,
            fragmentShader: Ve.meshlambert_frag
        },
        phong: {
            uniforms: Vt([
                ue.common,
                ue.specularmap,
                ue.envmap,
                ue.aomap,
                ue.lightmap,
                ue.emissivemap,
                ue.bumpmap,
                ue.normalmap,
                ue.displacementmap,
                ue.fog,
                ue.lights,
                {
                    emissive: {
                        value: new Be(0)
                    },
                    specular: {
                        value: new Be(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }
            ]),
            vertexShader: Ve.meshphong_vert,
            fragmentShader: Ve.meshphong_frag
        },
        standard: {
            uniforms: Vt([
                ue.common,
                ue.envmap,
                ue.aomap,
                ue.lightmap,
                ue.emissivemap,
                ue.bumpmap,
                ue.normalmap,
                ue.displacementmap,
                ue.roughnessmap,
                ue.metalnessmap,
                ue.fog,
                ue.lights,
                {
                    emissive: {
                        value: new Be(0)
                    },
                    roughness: {
                        value: 1
                    },
                    metalness: {
                        value: 0
                    },
                    envMapIntensity: {
                        value: 1
                    }
                }
            ]),
            vertexShader: Ve.meshphysical_vert,
            fragmentShader: Ve.meshphysical_frag
        },
        toon: {
            uniforms: Vt([
                ue.common,
                ue.aomap,
                ue.lightmap,
                ue.emissivemap,
                ue.bumpmap,
                ue.normalmap,
                ue.displacementmap,
                ue.gradientmap,
                ue.fog,
                ue.lights,
                {
                    emissive: {
                        value: new Be(0)
                    }
                }
            ]),
            vertexShader: Ve.meshtoon_vert,
            fragmentShader: Ve.meshtoon_frag
        },
        matcap: {
            uniforms: Vt([
                ue.common,
                ue.bumpmap,
                ue.normalmap,
                ue.displacementmap,
                ue.fog,
                {
                    matcap: {
                        value: null
                    }
                }
            ]),
            vertexShader: Ve.meshmatcap_vert,
            fragmentShader: Ve.meshmatcap_frag
        },
        points: {
            uniforms: Vt([
                ue.points,
                ue.fog
            ]),
            vertexShader: Ve.points_vert,
            fragmentShader: Ve.points_frag
        },
        dashed: {
            uniforms: Vt([
                ue.common,
                ue.fog,
                {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }
            ]),
            vertexShader: Ve.linedashed_vert,
            fragmentShader: Ve.linedashed_frag
        },
        depth: {
            uniforms: Vt([
                ue.common,
                ue.displacementmap
            ]),
            vertexShader: Ve.depth_vert,
            fragmentShader: Ve.depth_frag
        },
        normal: {
            uniforms: Vt([
                ue.common,
                ue.bumpmap,
                ue.normalmap,
                ue.displacementmap,
                {
                    opacity: {
                        value: 1
                    }
                }
            ]),
            vertexShader: Ve.meshnormal_vert,
            fragmentShader: Ve.meshnormal_frag
        },
        sprite: {
            uniforms: Vt([
                ue.sprite,
                ue.fog
            ]),
            vertexShader: Ve.sprite_vert,
            fragmentShader: Ve.sprite_frag
        },
        background: {
            uniforms: {
                uvTransform: {
                    value: new Ge
                },
                t2D: {
                    value: null
                },
                backgroundIntensity: {
                    value: 1
                }
            },
            vertexShader: Ve.background_vert,
            fragmentShader: Ve.background_frag
        },
        backgroundCube: {
            uniforms: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                },
                backgroundBlurriness: {
                    value: 0
                },
                backgroundIntensity: {
                    value: 1
                },
                backgroundRotation: {
                    value: new Ge
                }
            },
            vertexShader: Ve.backgroundCube_vert,
            fragmentShader: Ve.backgroundCube_frag
        },
        cube: {
            uniforms: {
                tCube: {
                    value: null
                },
                tFlip: {
                    value: -1
                },
                opacity: {
                    value: 1
                }
            },
            vertexShader: Ve.cube_vert,
            fragmentShader: Ve.cube_frag
        },
        equirect: {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: Ve.equirect_vert,
            fragmentShader: Ve.equirect_frag
        },
        distanceRGBA: {
            uniforms: Vt([
                ue.common,
                ue.displacementmap,
                {
                    referencePosition: {
                        value: new k
                    },
                    nearDistance: {
                        value: 1
                    },
                    farDistance: {
                        value: 1e3
                    }
                }
            ]),
            vertexShader: Ve.distanceRGBA_vert,
            fragmentShader: Ve.distanceRGBA_frag
        },
        shadow: {
            uniforms: Vt([
                ue.lights,
                ue.fog,
                {
                    color: {
                        value: new Be(0)
                    },
                    opacity: {
                        value: 1
                    }
                }
            ]),
            vertexShader: Ve.shadow_vert,
            fragmentShader: Ve.shadow_frag
        }
    };
    Ln.physical = {
        uniforms: Vt([
            Ln.standard.uniforms,
            {
                clearcoat: {
                    value: 0
                },
                clearcoatMap: {
                    value: null
                },
                clearcoatMapTransform: {
                    value: new Ge
                },
                clearcoatNormalMap: {
                    value: null
                },
                clearcoatNormalMapTransform: {
                    value: new Ge
                },
                clearcoatNormalScale: {
                    value: new Ke(1, 1)
                },
                clearcoatRoughness: {
                    value: 0
                },
                clearcoatRoughnessMap: {
                    value: null
                },
                clearcoatRoughnessMapTransform: {
                    value: new Ge
                },
                dispersion: {
                    value: 0
                },
                iridescence: {
                    value: 0
                },
                iridescenceMap: {
                    value: null
                },
                iridescenceMapTransform: {
                    value: new Ge
                },
                iridescenceIOR: {
                    value: 1.3
                },
                iridescenceThicknessMinimum: {
                    value: 100
                },
                iridescenceThicknessMaximum: {
                    value: 400
                },
                iridescenceThicknessMap: {
                    value: null
                },
                iridescenceThicknessMapTransform: {
                    value: new Ge
                },
                sheen: {
                    value: 0
                },
                sheenColor: {
                    value: new Be(0)
                },
                sheenColorMap: {
                    value: null
                },
                sheenColorMapTransform: {
                    value: new Ge
                },
                sheenRoughness: {
                    value: 1
                },
                sheenRoughnessMap: {
                    value: null
                },
                sheenRoughnessMapTransform: {
                    value: new Ge
                },
                transmission: {
                    value: 0
                },
                transmissionMap: {
                    value: null
                },
                transmissionMapTransform: {
                    value: new Ge
                },
                transmissionSamplerSize: {
                    value: new Ke
                },
                transmissionSamplerMap: {
                    value: null
                },
                thickness: {
                    value: 0
                },
                thicknessMap: {
                    value: null
                },
                thicknessMapTransform: {
                    value: new Ge
                },
                attenuationDistance: {
                    value: 0
                },
                attenuationColor: {
                    value: new Be(0)
                },
                specularColor: {
                    value: new Be(1, 1, 1)
                },
                specularColorMap: {
                    value: null
                },
                specularColorMapTransform: {
                    value: new Ge
                },
                specularIntensity: {
                    value: 1
                },
                specularIntensityMap: {
                    value: null
                },
                specularIntensityMapTransform: {
                    value: new Ge
                },
                anisotropyVector: {
                    value: new Ke
                },
                anisotropyMap: {
                    value: null
                },
                anisotropyMapTransform: {
                    value: new Ge
                }
            }
        ]),
        vertexShader: Ve.meshphysical_vert,
        fragmentShader: Ve.meshphysical_frag
    };
    const ha = {
        r: 0,
        b: 0,
        g: 0
    }, Ei = new Bn, Ly = new He;
    function Uy(i, e, t, n, s, r, a) {
        const o = new Be(0);
        let c = r === !0 ? 0 : 1, l, h, u = null, d = 0, f = null;
        function _(y) {
            let x = y.isScene === !0 ? y.background : null;
            return x && x.isTexture && (x = (y.backgroundBlurriness > 0 ? t : e).get(x)), x;
        }
        function g(y) {
            let x = !1;
            const I = _(y);
            I === null ? m(o, c) : I && I.isColor && (m(I, 1), x = !0);
            const w = i.xr.getEnvironmentBlendMode();
            w === "additive" ? n.buffers.color.setClear(0, 0, 0, 1, a) : w === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, a), (i.autoClear || x) && (n.buffers.depth.setTest(!0), n.buffers.depth.setMask(!0), n.buffers.color.setMask(!0), i.clear(i.autoClearColor, i.autoClearDepth, i.autoClearStencil));
        }
        function p(y, x) {
            const I = _(x);
            I && (I.isCubeTexture || I.mapping === $a) ? (h === void 0 && (h = new kt(new ks(1, 1, 1), new xi({
                name: "BackgroundCubeMaterial",
                uniforms: Ds(Ln.backgroundCube.uniforms),
                vertexShader: Ln.backgroundCube.vertexShader,
                fragmentShader: Ln.backgroundCube.fragmentShader,
                side: Jt,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
                allowOverride: !1
            })), h.geometry.deleteAttribute("normal"), h.geometry.deleteAttribute("uv"), h.onBeforeRender = function(w, R, N) {
                this.matrixWorld.copyPosition(N.matrixWorld);
            }, Object.defineProperty(h.material, "envMap", {
                get: function() {
                    return this.uniforms.envMap.value;
                }
            }), s.update(h)), Ei.copy(x.backgroundRotation), Ei.x *= -1, Ei.y *= -1, Ei.z *= -1, I.isCubeTexture && I.isRenderTargetTexture === !1 && (Ei.y *= -1, Ei.z *= -1), h.material.uniforms.envMap.value = I, h.material.uniforms.flipEnvMap.value = I.isCubeTexture && I.isRenderTargetTexture === !1 ? -1 : 1, h.material.uniforms.backgroundBlurriness.value = x.backgroundBlurriness, h.material.uniforms.backgroundIntensity.value = x.backgroundIntensity, h.material.uniforms.backgroundRotation.value.setFromMatrix4(Ly.makeRotationFromEuler(Ei)), h.material.toneMapped = $e.getTransfer(I.colorSpace) !== ct, (u !== I || d !== I.version || f !== i.toneMapping) && (h.material.needsUpdate = !0, u = I, d = I.version, f = i.toneMapping), h.layers.enableAll(), y.unshift(h, h.geometry, h.material, 0, 0, null)) : I && I.isTexture && (l === void 0 && (l = new kt(new Ur(2, 2), new xi({
                name: "BackgroundMaterial",
                uniforms: Ds(Ln.background.uniforms),
                vertexShader: Ln.background.vertexShader,
                fragmentShader: Ln.background.fragmentShader,
                side: ti,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
                allowOverride: !1
            })), l.geometry.deleteAttribute("normal"), Object.defineProperty(l.material, "map", {
                get: function() {
                    return this.uniforms.t2D.value;
                }
            }), s.update(l)), l.material.uniforms.t2D.value = I, l.material.uniforms.backgroundIntensity.value = x.backgroundIntensity, l.material.toneMapped = $e.getTransfer(I.colorSpace) !== ct, I.matrixAutoUpdate === !0 && I.updateMatrix(), l.material.uniforms.uvTransform.value.copy(I.matrix), (u !== I || d !== I.version || f !== i.toneMapping) && (l.material.needsUpdate = !0, u = I, d = I.version, f = i.toneMapping), l.layers.enableAll(), y.unshift(l, l.geometry, l.material, 0, 0, null));
        }
        function m(y, x) {
            y.getRGB(ha, Vf(i)), n.buffers.color.setClear(ha.r, ha.g, ha.b, x, a);
        }
        function v() {
            h !== void 0 && (h.geometry.dispose(), h.material.dispose(), h = void 0), l !== void 0 && (l.geometry.dispose(), l.material.dispose(), l = void 0);
        }
        return {
            getClearColor: function() {
                return o;
            },
            setClearColor: function(y, x = 1) {
                o.set(y), c = x, m(o, c);
            },
            getClearAlpha: function() {
                return c;
            },
            setClearAlpha: function(y) {
                c = y, m(o, c);
            },
            render: g,
            addToRenderList: p,
            dispose: v
        };
    }
    function Ny(i, e) {
        const t = i.getParameter(i.MAX_VERTEX_ATTRIBS), n = {}, s = d(null);
        let r = s, a = !1;
        function o(S, D, j, z, K) {
            let ne = !1;
            const b = u(z, j, D);
            r !== b && (r = b, l(r.object)), ne = f(S, z, j, K), ne && _(S, z, j, K), K !== null && e.update(K, i.ELEMENT_ARRAY_BUFFER), (ne || a) && (a = !1, x(S, D, j, z), K !== null && i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, e.get(K).buffer));
        }
        function c() {
            return i.createVertexArray();
        }
        function l(S) {
            return i.bindVertexArray(S);
        }
        function h(S) {
            return i.deleteVertexArray(S);
        }
        function u(S, D, j) {
            const z = j.wireframe === !0;
            let K = n[S.id];
            K === void 0 && (K = {}, n[S.id] = K);
            let ne = K[D.id];
            ne === void 0 && (ne = {}, K[D.id] = ne);
            let b = ne[z];
            return b === void 0 && (b = d(c()), ne[z] = b), b;
        }
        function d(S) {
            const D = [], j = [], z = [];
            for(let K = 0; K < t; K++)D[K] = 0, j[K] = 0, z[K] = 0;
            return {
                geometry: null,
                program: null,
                wireframe: !1,
                newAttributes: D,
                enabledAttributes: j,
                attributeDivisors: z,
                object: S,
                attributes: {},
                index: null
            };
        }
        function f(S, D, j, z) {
            const K = r.attributes, ne = D.attributes;
            let b = 0;
            const C = j.getAttributes();
            for(const A in C)if (C[A].location >= 0) {
                const B = K[A];
                let V = ne[A];
                if (V === void 0 && (A === "instanceMatrix" && S.instanceMatrix && (V = S.instanceMatrix), A === "instanceColor" && S.instanceColor && (V = S.instanceColor)), B === void 0 || B.attribute !== V || V && B.data !== V.data) return !0;
                b++;
            }
            return r.attributesNum !== b || r.index !== z;
        }
        function _(S, D, j, z) {
            const K = {}, ne = D.attributes;
            let b = 0;
            const C = j.getAttributes();
            for(const A in C)if (C[A].location >= 0) {
                let B = ne[A];
                B === void 0 && (A === "instanceMatrix" && S.instanceMatrix && (B = S.instanceMatrix), A === "instanceColor" && S.instanceColor && (B = S.instanceColor));
                const V = {};
                V.attribute = B, B && B.data && (V.data = B.data), K[A] = V, b++;
            }
            r.attributes = K, r.attributesNum = b, r.index = z;
        }
        function g() {
            const S = r.newAttributes;
            for(let D = 0, j = S.length; D < j; D++)S[D] = 0;
        }
        function p(S) {
            m(S, 0);
        }
        function m(S, D) {
            const j = r.newAttributes, z = r.enabledAttributes, K = r.attributeDivisors;
            j[S] = 1, z[S] === 0 && (i.enableVertexAttribArray(S), z[S] = 1), K[S] !== D && (i.vertexAttribDivisor(S, D), K[S] = D);
        }
        function v() {
            const S = r.newAttributes, D = r.enabledAttributes;
            for(let j = 0, z = D.length; j < z; j++)D[j] !== S[j] && (i.disableVertexAttribArray(j), D[j] = 0);
        }
        function y(S, D, j, z, K, ne, b) {
            b === !0 ? i.vertexAttribIPointer(S, D, j, K, ne) : i.vertexAttribPointer(S, D, j, z, K, ne);
        }
        function x(S, D, j, z) {
            g();
            const K = z.attributes, ne = j.getAttributes(), b = D.defaultAttributeValues;
            for(const C in ne){
                const A = ne[C];
                if (A.location >= 0) {
                    let U = K[C];
                    if (U === void 0 && (C === "instanceMatrix" && S.instanceMatrix && (U = S.instanceMatrix), C === "instanceColor" && S.instanceColor && (U = S.instanceColor)), U !== void 0) {
                        const B = U.normalized, V = U.itemSize, q = e.get(U);
                        if (q === void 0) continue;
                        const te = q.buffer, H = q.type, $ = q.bytesPerElement, oe = H === i.INT || H === i.UNSIGNED_INT || U.gpuType === kl;
                        if (U.isInterleavedBufferAttribute) {
                            const ie = U.data, le = ie.stride, we = U.offset;
                            if (ie.isInstancedInterleavedBuffer) {
                                for(let he = 0; he < A.locationSize; he++)m(A.location + he, ie.meshPerAttribute);
                                S.isInstancedMesh !== !0 && z._maxInstanceCount === void 0 && (z._maxInstanceCount = ie.meshPerAttribute * ie.count);
                            } else for(let he = 0; he < A.locationSize; he++)p(A.location + he);
                            i.bindBuffer(i.ARRAY_BUFFER, te);
                            for(let he = 0; he < A.locationSize; he++)y(A.location + he, V / A.locationSize, H, B, le * $, (we + V / A.locationSize * he) * $, oe);
                        } else {
                            if (U.isInstancedBufferAttribute) {
                                for(let ie = 0; ie < A.locationSize; ie++)m(A.location + ie, U.meshPerAttribute);
                                S.isInstancedMesh !== !0 && z._maxInstanceCount === void 0 && (z._maxInstanceCount = U.meshPerAttribute * U.count);
                            } else for(let ie = 0; ie < A.locationSize; ie++)p(A.location + ie);
                            i.bindBuffer(i.ARRAY_BUFFER, te);
                            for(let ie = 0; ie < A.locationSize; ie++)y(A.location + ie, V / A.locationSize, H, B, V * $, V / A.locationSize * ie * $, oe);
                        }
                    } else if (b !== void 0) {
                        const B = b[C];
                        if (B !== void 0) switch(B.length){
                            case 2:
                                i.vertexAttrib2fv(A.location, B);
                                break;
                            case 3:
                                i.vertexAttrib3fv(A.location, B);
                                break;
                            case 4:
                                i.vertexAttrib4fv(A.location, B);
                                break;
                            default:
                                i.vertexAttrib1fv(A.location, B);
                        }
                    }
                }
            }
            v();
        }
        function I() {
            N();
            for(const S in n){
                const D = n[S];
                for(const j in D){
                    const z = D[j];
                    for(const K in z)h(z[K].object), delete z[K];
                    delete D[j];
                }
                delete n[S];
            }
        }
        function w(S) {
            if (n[S.id] === void 0) return;
            const D = n[S.id];
            for(const j in D){
                const z = D[j];
                for(const K in z)h(z[K].object), delete z[K];
                delete D[j];
            }
            delete n[S.id];
        }
        function R(S) {
            for(const D in n){
                const j = n[D];
                if (j[S.id] === void 0) continue;
                const z = j[S.id];
                for(const K in z)h(z[K].object), delete z[K];
                delete j[S.id];
            }
        }
        function N() {
            E(), a = !0, r !== s && (r = s, l(r.object));
        }
        function E() {
            s.geometry = null, s.program = null, s.wireframe = !1;
        }
        return {
            setup: o,
            reset: N,
            resetDefaultState: E,
            dispose: I,
            releaseStatesOfGeometry: w,
            releaseStatesOfProgram: R,
            initAttributes: g,
            enableAttribute: p,
            disableUnusedAttributes: v
        };
    }
    function By(i, e, t) {
        let n;
        function s(l) {
            n = l;
        }
        function r(l, h) {
            i.drawArrays(n, l, h), t.update(h, n, 1);
        }
        function a(l, h, u) {
            u !== 0 && (i.drawArraysInstanced(n, l, h, u), t.update(h, n, u));
        }
        function o(l, h, u) {
            if (u === 0) return;
            e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n, l, 0, h, 0, u);
            let f = 0;
            for(let _ = 0; _ < u; _++)f += h[_];
            t.update(f, n, 1);
        }
        function c(l, h, u, d) {
            if (u === 0) return;
            const f = e.get("WEBGL_multi_draw");
            if (f === null) for(let _ = 0; _ < l.length; _++)a(l[_], h[_], d[_]);
            else {
                f.multiDrawArraysInstancedWEBGL(n, l, 0, h, 0, d, 0, u);
                let _ = 0;
                for(let g = 0; g < u; g++)_ += h[g] * d[g];
                t.update(_, n, 1);
            }
        }
        this.setMode = s, this.render = r, this.renderInstances = a, this.renderMultiDraw = o, this.renderMultiDrawInstances = c;
    }
    function Fy(i, e, t, n) {
        let s;
        function r() {
            if (s !== void 0) return s;
            if (e.has("EXT_texture_filter_anisotropic") === !0) {
                const R = e.get("EXT_texture_filter_anisotropic");
                s = i.getParameter(R.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
            } else s = 0;
            return s;
        }
        function a(R) {
            return !(R !== un && n.convert(R) !== i.getParameter(i.IMPLEMENTATION_COLOR_READ_FORMAT));
        }
        function o(R) {
            const N = R === Lr && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
            return !(R !== ni && n.convert(R) !== i.getParameter(i.IMPLEMENTATION_COLOR_READ_TYPE) && R !== Mn && !N);
        }
        function c(R) {
            if (R === "highp") {
                if (i.getShaderPrecisionFormat(i.VERTEX_SHADER, i.HIGH_FLOAT).precision > 0 && i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.HIGH_FLOAT).precision > 0) return "highp";
                R = "mediump";
            }
            return R === "mediump" && i.getShaderPrecisionFormat(i.VERTEX_SHADER, i.MEDIUM_FLOAT).precision > 0 && i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
        }
        let l = t.precision !== void 0 ? t.precision : "highp";
        const h = c(l);
        h !== l && (console.warn("THREE.WebGLRenderer:", l, "not supported, using", h, "instead."), l = h);
        const u = t.logarithmicDepthBuffer === !0, d = t.reverseDepthBuffer === !0 && e.has("EXT_clip_control"), f = i.getParameter(i.MAX_TEXTURE_IMAGE_UNITS), _ = i.getParameter(i.MAX_VERTEX_TEXTURE_IMAGE_UNITS), g = i.getParameter(i.MAX_TEXTURE_SIZE), p = i.getParameter(i.MAX_CUBE_MAP_TEXTURE_SIZE), m = i.getParameter(i.MAX_VERTEX_ATTRIBS), v = i.getParameter(i.MAX_VERTEX_UNIFORM_VECTORS), y = i.getParameter(i.MAX_VARYING_VECTORS), x = i.getParameter(i.MAX_FRAGMENT_UNIFORM_VECTORS), I = _ > 0, w = i.getParameter(i.MAX_SAMPLES);
        return {
            isWebGL2: !0,
            getMaxAnisotropy: r,
            getMaxPrecision: c,
            textureFormatReadable: a,
            textureTypeReadable: o,
            precision: l,
            logarithmicDepthBuffer: u,
            reverseDepthBuffer: d,
            maxTextures: f,
            maxVertexTextures: _,
            maxTextureSize: g,
            maxCubemapSize: p,
            maxAttributes: m,
            maxVertexUniforms: v,
            maxVaryings: y,
            maxFragmentUniforms: x,
            vertexTextures: I,
            maxSamples: w
        };
    }
    function Oy(i) {
        const e = this;
        let t = null, n = 0, s = !1, r = !1;
        const a = new Ci, o = new Ge, c = {
            value: null,
            needsUpdate: !1
        };
        this.uniform = c, this.numPlanes = 0, this.numIntersection = 0, this.init = function(u, d) {
            const f = u.length !== 0 || d || n !== 0 || s;
            return s = d, n = u.length, f;
        }, this.beginShadows = function() {
            r = !0, h(null);
        }, this.endShadows = function() {
            r = !1;
        }, this.setGlobalState = function(u, d) {
            t = h(u, d, 0);
        }, this.setState = function(u, d, f) {
            const _ = u.clippingPlanes, g = u.clipIntersection, p = u.clipShadows, m = i.get(u);
            if (!s || _ === null || _.length === 0 || r && !p) r ? h(null) : l();
            else {
                const v = r ? 0 : n, y = v * 4;
                let x = m.clippingState || null;
                c.value = x, x = h(_, d, y, f);
                for(let I = 0; I !== y; ++I)x[I] = t[I];
                m.clippingState = x, this.numIntersection = g ? this.numPlanes : 0, this.numPlanes += v;
            }
        };
        function l() {
            c.value !== t && (c.value = t, c.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0;
        }
        function h(u, d, f, _) {
            const g = u !== null ? u.length : 0;
            let p = null;
            if (g !== 0) {
                if (p = c.value, _ !== !0 || p === null) {
                    const m = f + g * 4, v = d.matrixWorldInverse;
                    o.getNormalMatrix(v), (p === null || p.length < m) && (p = new Float32Array(m));
                    for(let y = 0, x = f; y !== g; ++y, x += 4)a.copy(u[y]).applyMatrix4(v, o), a.normal.toArray(p, x), p[x + 3] = a.constant;
                }
                c.value = p, c.needsUpdate = !0;
            }
            return e.numPlanes = g, e.numIntersection = 0, p;
        }
    }
    function ky(i) {
        let e = new WeakMap;
        function t(a, o) {
            return o === Dc ? a.mapping = Rs : o === Lc && (a.mapping = Cs), a;
        }
        function n(a) {
            if (a && a.isTexture) {
                const o = a.mapping;
                if (o === Dc || o === Lc) if (e.has(a)) {
                    const c = e.get(a).texture;
                    return t(c, a.mapping);
                } else {
                    const c = a.image;
                    if (c && c.height > 0) {
                        const l = new ix(c.height);
                        return l.fromEquirectangularTexture(i, a), e.set(a, l), a.addEventListener("dispose", s), t(l.texture, a.mapping);
                    } else return null;
                }
            }
            return a;
        }
        function s(a) {
            const o = a.target;
            o.removeEventListener("dispose", s);
            const c = e.get(o);
            c !== void 0 && (e.delete(o), c.dispose());
        }
        function r() {
            e = new WeakMap;
        }
        return {
            get: n,
            dispose: r
        };
    }
    const bs = 4, Lu = [
        .125,
        .215,
        .35,
        .446,
        .526,
        .582
    ], Bi = 20, Do = new eh, Uu = new Be;
    let Lo = null, Uo = 0, No = 0, Bo = !1;
    const Pi = (1 + Math.sqrt(5)) / 2, fs = 1 / Pi, Nu = [
        new k(-Pi, fs, 0),
        new k(Pi, fs, 0),
        new k(-fs, 0, Pi),
        new k(fs, 0, Pi),
        new k(0, Pi, -fs),
        new k(0, Pi, fs),
        new k(-1, 1, -1),
        new k(1, 1, -1),
        new k(-1, 1, 1),
        new k(1, 1, 1)
    ], Gy = new k;
    class Bu {
        constructor(e){
            this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
        }
        fromScene(e, t = 0, n = .1, s = 100, r = {}) {
            const { size: a = 256, position: o = Gy } = r;
            Lo = this._renderer.getRenderTarget(), Uo = this._renderer.getActiveCubeFace(), No = this._renderer.getActiveMipmapLevel(), Bo = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(a);
            const c = this._allocateTargets();
            return c.depthBuffer = !0, this._sceneToCubeUV(e, n, s, c, o), t > 0 && this._blur(c, 0, 0, t), this._applyPMREM(c), this._cleanup(c), c;
        }
        fromEquirectangular(e, t = null) {
            return this._fromTexture(e, t);
        }
        fromCubemap(e, t = null) {
            return this._fromTexture(e, t);
        }
        compileCubemapShader() {
            this._cubemapMaterial === null && (this._cubemapMaterial = ku(), this._compileMaterial(this._cubemapMaterial));
        }
        compileEquirectangularShader() {
            this._equirectMaterial === null && (this._equirectMaterial = Ou(), this._compileMaterial(this._equirectMaterial));
        }
        dispose() {
            this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
        }
        _setSize(e) {
            this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
        }
        _dispose() {
            this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
            for(let e = 0; e < this._lodPlanes.length; e++)this._lodPlanes[e].dispose();
        }
        _cleanup(e) {
            this._renderer.setRenderTarget(Lo, Uo, No), this._renderer.xr.enabled = Bo, e.scissorTest = !1, ua(e, 0, 0, e.width, e.height);
        }
        _fromTexture(e, t) {
            e.mapping === Rs || e.mapping === Cs ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), Lo = this._renderer.getRenderTarget(), Uo = this._renderer.getActiveCubeFace(), No = this._renderer.getActiveMipmapLevel(), Bo = this._renderer.xr.enabled, this._renderer.xr.enabled = !1;
            const n = t || this._allocateTargets();
            return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n;
        }
        _allocateTargets() {
            const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, n = {
                magFilter: an,
                minFilter: an,
                generateMipmaps: !1,
                type: Lr,
                format: un,
                colorSpace: $t,
                depthBuffer: !1
            }, s = Fu(e, t, n);
            if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
                this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = Fu(e, t, n);
                const { _lodMax: r } = this;
                ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = Hy(r)), this._blurMaterial = zy(r, e, t);
            }
            return s;
        }
        _compileMaterial(e) {
            const t = new kt(this._lodPlanes[0], e);
            this._renderer.compile(t, Do);
        }
        _sceneToCubeUV(e, t, n, s, r) {
            const c = new Wt(90, 1, t, n), l = [
                1,
                -1,
                1,
                1,
                1,
                1
            ], h = [
                1,
                1,
                1,
                -1,
                -1,
                -1
            ], u = this._renderer, d = u.autoClear, f = u.toneMapping;
            u.getClearColor(Uu), u.toneMapping = mi, u.autoClear = !1;
            const _ = new Fi({
                name: "PMREM.Background",
                side: Jt,
                depthWrite: !1,
                depthTest: !1
            }), g = new kt(new ks, _);
            let p = !1;
            const m = e.background;
            m ? m.isColor && (_.color.copy(m), e.background = null, p = !0) : (_.color.copy(Uu), p = !0);
            for(let v = 0; v < 6; v++){
                const y = v % 3;
                y === 0 ? (c.up.set(0, l[v], 0), c.position.set(r.x, r.y, r.z), c.lookAt(r.x + h[v], r.y, r.z)) : y === 1 ? (c.up.set(0, 0, l[v]), c.position.set(r.x, r.y, r.z), c.lookAt(r.x, r.y + h[v], r.z)) : (c.up.set(0, l[v], 0), c.position.set(r.x, r.y, r.z), c.lookAt(r.x, r.y, r.z + h[v]));
                const x = this._cubeSize;
                ua(s, y * x, v > 2 ? x : 0, x, x), u.setRenderTarget(s), p && u.render(g, c), u.render(e, c);
            }
            g.geometry.dispose(), g.material.dispose(), u.toneMapping = f, u.autoClear = d, e.background = m;
        }
        _textureToCubeUV(e, t) {
            const n = this._renderer, s = e.mapping === Rs || e.mapping === Cs;
            s ? (this._cubemapMaterial === null && (this._cubemapMaterial = ku()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = Ou());
            const r = s ? this._cubemapMaterial : this._equirectMaterial, a = new kt(this._lodPlanes[0], r), o = r.uniforms;
            o.envMap.value = e;
            const c = this._cubeSize;
            ua(t, 0, 0, 3 * c, 2 * c), n.setRenderTarget(t), n.render(a, Do);
        }
        _applyPMREM(e) {
            const t = this._renderer, n = t.autoClear;
            t.autoClear = !1;
            const s = this._lodPlanes.length;
            for(let r = 1; r < s; r++){
                const a = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1]), o = Nu[(s - r - 1) % Nu.length];
                this._blur(e, r - 1, r, a, o);
            }
            t.autoClear = n;
        }
        _blur(e, t, n, s, r) {
            const a = this._pingPongRenderTarget;
            this._halfBlur(e, a, t, n, s, "latitudinal", r), this._halfBlur(a, e, n, n, s, "longitudinal", r);
        }
        _halfBlur(e, t, n, s, r, a, o) {
            const c = this._renderer, l = this._blurMaterial;
            a !== "latitudinal" && a !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
            const h = 3, u = new kt(this._lodPlanes[s], l), d = l.uniforms, f = this._sizeLods[n] - 1, _ = isFinite(r) ? Math.PI / (2 * f) : 2 * Math.PI / (2 * Bi - 1), g = r / _, p = isFinite(r) ? 1 + Math.floor(h * g) : Bi;
            p > Bi && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${p} samples when the maximum is set to ${Bi}`);
            const m = [];
            let v = 0;
            for(let R = 0; R < Bi; ++R){
                const N = R / g, E = Math.exp(-N * N / 2);
                m.push(E), R === 0 ? v += E : R < p && (v += 2 * E);
            }
            for(let R = 0; R < m.length; R++)m[R] = m[R] / v;
            d.envMap.value = e.texture, d.samples.value = p, d.weights.value = m, d.latitudinal.value = a === "latitudinal", o && (d.poleAxis.value = o);
            const { _lodMax: y } = this;
            d.dTheta.value = _, d.mipInt.value = y - n;
            const x = this._sizeLods[s], I = 3 * x * (s > y - bs ? s - y + bs : 0), w = 4 * (this._cubeSize - x);
            ua(t, I, w, 3 * x, 2 * x), c.setRenderTarget(t), c.render(u, Do);
        }
    }
    function Hy(i) {
        const e = [], t = [], n = [];
        let s = i;
        const r = i - bs + 1 + Lu.length;
        for(let a = 0; a < r; a++){
            const o = Math.pow(2, s);
            t.push(o);
            let c = 1 / o;
            a > i - bs ? c = Lu[a - i + bs - 1] : a === 0 && (c = 0), n.push(c);
            const l = 1 / (o - 2), h = -l, u = 1 + l, d = [
                h,
                h,
                u,
                h,
                u,
                u,
                h,
                h,
                u,
                u,
                h,
                u
            ], f = 6, _ = 6, g = 3, p = 2, m = 1, v = new Float32Array(g * _ * f), y = new Float32Array(p * _ * f), x = new Float32Array(m * _ * f);
            for(let w = 0; w < f; w++){
                const R = w % 3 * 2 / 3 - 1, N = w > 2 ? 0 : -1, E = [
                    R,
                    N,
                    0,
                    R + 2 / 3,
                    N,
                    0,
                    R + 2 / 3,
                    N + 1,
                    0,
                    R,
                    N,
                    0,
                    R + 2 / 3,
                    N + 1,
                    0,
                    R,
                    N + 1,
                    0
                ];
                v.set(E, g * _ * w), y.set(d, p * _ * w);
                const S = [
                    w,
                    w,
                    w,
                    w,
                    w,
                    w
                ];
                x.set(S, m * _ * w);
            }
            const I = new On;
            I.setAttribute("position", new qt(v, g)), I.setAttribute("uv", new qt(y, p)), I.setAttribute("faceIndex", new qt(x, m)), e.push(I), s > bs && s--;
        }
        return {
            lodPlanes: e,
            sizeLods: t,
            sigmas: n
        };
    }
    function Fu(i, e, t) {
        const n = new Vi(i, e, t);
        return n.texture.mapping = $a, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n;
    }
    function ua(i, e, t, n, s) {
        i.viewport.set(e, t, n, s), i.scissor.set(e, t, n, s);
    }
    function zy(i, e, t) {
        const n = new Float32Array(Bi), s = new k(0, 1, 0);
        return new xi({
            name: "SphericalGaussianBlur",
            defines: {
                n: Bi,
                CUBEUV_TEXEL_WIDTH: 1 / e,
                CUBEUV_TEXEL_HEIGHT: 1 / t,
                CUBEUV_MAX_MIP: `${i}.0`
            },
            uniforms: {
                envMap: {
                    value: null
                },
                samples: {
                    value: 1
                },
                weights: {
                    value: n
                },
                latitudinal: {
                    value: !1
                },
                dTheta: {
                    value: 0
                },
                mipInt: {
                    value: 0
                },
                poleAxis: {
                    value: s
                }
            },
            vertexShader: ih(),
            fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
            blending: pi,
            depthTest: !1,
            depthWrite: !1
        });
    }
    function Ou() {
        return new xi({
            name: "EquirectangularToCubeUV",
            uniforms: {
                envMap: {
                    value: null
                }
            },
            vertexShader: ih(),
            fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
            blending: pi,
            depthTest: !1,
            depthWrite: !1
        });
    }
    function ku() {
        return new xi({
            name: "CubemapToCubeUV",
            uniforms: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                }
            },
            vertexShader: ih(),
            fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
            blending: pi,
            depthTest: !1,
            depthWrite: !1
        });
    }
    function ih() {
        return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
    }
    function Vy(i) {
        let e = new WeakMap, t = null;
        function n(o) {
            if (o && o.isTexture) {
                const c = o.mapping, l = c === Dc || c === Lc, h = c === Rs || c === Cs;
                if (l || h) {
                    let u = e.get(o);
                    const d = u !== void 0 ? u.texture.pmremVersion : 0;
                    if (o.isRenderTargetTexture && o.pmremVersion !== d) return t === null && (t = new Bu(i)), u = l ? t.fromEquirectangular(o, u) : t.fromCubemap(o, u), u.texture.pmremVersion = o.pmremVersion, e.set(o, u), u.texture;
                    if (u !== void 0) return u.texture;
                    {
                        const f = o.image;
                        return l && f && f.height > 0 || h && f && s(f) ? (t === null && (t = new Bu(i)), u = l ? t.fromEquirectangular(o) : t.fromCubemap(o), u.texture.pmremVersion = o.pmremVersion, e.set(o, u), o.addEventListener("dispose", r), u.texture) : null;
                    }
                }
            }
            return o;
        }
        function s(o) {
            let c = 0;
            const l = 6;
            for(let h = 0; h < l; h++)o[h] !== void 0 && c++;
            return c === l;
        }
        function r(o) {
            const c = o.target;
            c.removeEventListener("dispose", r);
            const l = e.get(c);
            l !== void 0 && (e.delete(c), l.dispose());
        }
        function a() {
            e = new WeakMap, t !== null && (t.dispose(), t = null);
        }
        return {
            get: n,
            dispose: a
        };
    }
    function Wy(i) {
        const e = {};
        function t(n) {
            if (e[n] !== void 0) return e[n];
            let s;
            switch(n){
                case "WEBGL_depth_texture":
                    s = i.getExtension("WEBGL_depth_texture") || i.getExtension("MOZ_WEBGL_depth_texture") || i.getExtension("WEBKIT_WEBGL_depth_texture");
                    break;
                case "EXT_texture_filter_anisotropic":
                    s = i.getExtension("EXT_texture_filter_anisotropic") || i.getExtension("MOZ_EXT_texture_filter_anisotropic") || i.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;
                case "WEBGL_compressed_texture_s3tc":
                    s = i.getExtension("WEBGL_compressed_texture_s3tc") || i.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;
                case "WEBGL_compressed_texture_pvrtc":
                    s = i.getExtension("WEBGL_compressed_texture_pvrtc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;
                default:
                    s = i.getExtension(n);
            }
            return e[n] = s, s;
        }
        return {
            has: function(n) {
                return t(n) !== null;
            },
            init: function() {
                t("EXT_color_buffer_float"), t("WEBGL_clip_cull_distance"), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture"), t("WEBGL_render_shared_exponent");
            },
            get: function(n) {
                const s = t(n);
                return s === null && Ia("THREE.WebGLRenderer: " + n + " extension not supported."), s;
            }
        };
    }
    function Xy(i, e, t, n) {
        const s = {}, r = new WeakMap;
        function a(u) {
            const d = u.target;
            d.index !== null && e.remove(d.index);
            for(const _ in d.attributes)e.remove(d.attributes[_]);
            d.removeEventListener("dispose", a), delete s[d.id];
            const f = r.get(d);
            f && (e.remove(f), r.delete(d)), n.releaseStatesOfGeometry(d), d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount, t.memory.geometries--;
        }
        function o(u, d) {
            return s[d.id] === !0 || (d.addEventListener("dispose", a), s[d.id] = !0, t.memory.geometries++), d;
        }
        function c(u) {
            const d = u.attributes;
            for(const f in d)e.update(d[f], i.ARRAY_BUFFER);
        }
        function l(u) {
            const d = [], f = u.index, _ = u.attributes.position;
            let g = 0;
            if (f !== null) {
                const v = f.array;
                g = f.version;
                for(let y = 0, x = v.length; y < x; y += 3){
                    const I = v[y + 0], w = v[y + 1], R = v[y + 2];
                    d.push(I, w, w, R, R, I);
                }
            } else if (_ !== void 0) {
                const v = _.array;
                g = _.version;
                for(let y = 0, x = v.length / 3 - 1; y < x; y += 3){
                    const I = y + 0, w = y + 1, R = y + 2;
                    d.push(I, w, w, R, R, I);
                }
            } else return;
            const p = new (Ff(d) ? zf : Hf)(d, 1);
            p.version = g;
            const m = r.get(u);
            m && e.remove(m), r.set(u, p);
        }
        function h(u) {
            const d = r.get(u);
            if (d) {
                const f = u.index;
                f !== null && d.version < f.version && l(u);
            } else l(u);
            return r.get(u);
        }
        return {
            get: o,
            update: c,
            getWireframeAttribute: h
        };
    }
    function Yy(i, e, t) {
        let n;
        function s(d) {
            n = d;
        }
        let r, a;
        function o(d) {
            r = d.type, a = d.bytesPerElement;
        }
        function c(d, f) {
            i.drawElements(n, f, r, d * a), t.update(f, n, 1);
        }
        function l(d, f, _) {
            _ !== 0 && (i.drawElementsInstanced(n, f, r, d * a, _), t.update(f, n, _));
        }
        function h(d, f, _) {
            if (_ === 0) return;
            e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n, f, 0, r, d, 0, _);
            let p = 0;
            for(let m = 0; m < _; m++)p += f[m];
            t.update(p, n, 1);
        }
        function u(d, f, _, g) {
            if (_ === 0) return;
            const p = e.get("WEBGL_multi_draw");
            if (p === null) for(let m = 0; m < d.length; m++)l(d[m] / a, f[m], g[m]);
            else {
                p.multiDrawElementsInstancedWEBGL(n, f, 0, r, d, 0, g, 0, _);
                let m = 0;
                for(let v = 0; v < _; v++)m += f[v] * g[v];
                t.update(m, n, 1);
            }
        }
        this.setMode = s, this.setIndex = o, this.render = c, this.renderInstances = l, this.renderMultiDraw = h, this.renderMultiDrawInstances = u;
    }
    function qy(i) {
        const e = {
            geometries: 0,
            textures: 0
        }, t = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
        };
        function n(r, a, o) {
            switch(t.calls++, a){
                case i.TRIANGLES:
                    t.triangles += o * (r / 3);
                    break;
                case i.LINES:
                    t.lines += o * (r / 2);
                    break;
                case i.LINE_STRIP:
                    t.lines += o * (r - 1);
                    break;
                case i.LINE_LOOP:
                    t.lines += o * r;
                    break;
                case i.POINTS:
                    t.points += o * r;
                    break;
                default:
                    console.error("THREE.WebGLInfo: Unknown draw mode:", a);
                    break;
            }
        }
        function s() {
            t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
        }
        return {
            memory: e,
            render: t,
            programs: null,
            autoReset: !0,
            reset: s,
            update: n
        };
    }
    function jy(i, e, t) {
        const n = new WeakMap, s = new nt;
        function r(a, o, c) {
            const l = a.morphTargetInfluences, h = o.morphAttributes.position || o.morphAttributes.normal || o.morphAttributes.color, u = h !== void 0 ? h.length : 0;
            let d = n.get(o);
            if (d === void 0 || d.count !== u) {
                let E = function() {
                    R.dispose(), n.delete(o), o.removeEventListener("dispose", E);
                };
                d !== void 0 && d.texture.dispose();
                const f = o.morphAttributes.position !== void 0, _ = o.morphAttributes.normal !== void 0, g = o.morphAttributes.color !== void 0, p = o.morphAttributes.position || [], m = o.morphAttributes.normal || [], v = o.morphAttributes.color || [];
                let y = 0;
                f === !0 && (y = 1), _ === !0 && (y = 2), g === !0 && (y = 3);
                let x = o.attributes.position.count * y, I = 1;
                x > e.maxTextureSize && (I = Math.ceil(x / e.maxTextureSize), x = e.maxTextureSize);
                const w = new Float32Array(x * I * 4 * u), R = new Of(w, x, I, u);
                R.type = Mn, R.needsUpdate = !0;
                const N = y * 4;
                for(let S = 0; S < u; S++){
                    const D = p[S], j = m[S], z = v[S], K = x * I * 4 * S;
                    for(let ne = 0; ne < D.count; ne++){
                        const b = ne * N;
                        f === !0 && (s.fromBufferAttribute(D, ne), w[K + b + 0] = s.x, w[K + b + 1] = s.y, w[K + b + 2] = s.z, w[K + b + 3] = 0), _ === !0 && (s.fromBufferAttribute(j, ne), w[K + b + 4] = s.x, w[K + b + 5] = s.y, w[K + b + 6] = s.z, w[K + b + 7] = 0), g === !0 && (s.fromBufferAttribute(z, ne), w[K + b + 8] = s.x, w[K + b + 9] = s.y, w[K + b + 10] = s.z, w[K + b + 11] = z.itemSize === 4 ? s.w : 1);
                    }
                }
                d = {
                    count: u,
                    texture: R,
                    size: new Ke(x, I)
                }, n.set(o, d), o.addEventListener("dispose", E);
            }
            if (a.isInstancedMesh === !0 && a.morphTexture !== null) c.getUniforms().setValue(i, "morphTexture", a.morphTexture, t);
            else {
                let f = 0;
                for(let g = 0; g < l.length; g++)f += l[g];
                const _ = o.morphTargetsRelative ? 1 : 1 - f;
                c.getUniforms().setValue(i, "morphTargetBaseInfluence", _), c.getUniforms().setValue(i, "morphTargetInfluences", l);
            }
            c.getUniforms().setValue(i, "morphTargetsTexture", d.texture, t), c.getUniforms().setValue(i, "morphTargetsTextureSize", d.size);
        }
        return {
            update: r
        };
    }
    function $y(i, e, t, n) {
        let s = new WeakMap;
        function r(c) {
            const l = n.render.frame, h = c.geometry, u = e.get(c, h);
            if (s.get(u) !== l && (e.update(u), s.set(u, l)), c.isInstancedMesh && (c.hasEventListener("dispose", o) === !1 && c.addEventListener("dispose", o), s.get(c) !== l && (t.update(c.instanceMatrix, i.ARRAY_BUFFER), c.instanceColor !== null && t.update(c.instanceColor, i.ARRAY_BUFFER), s.set(c, l))), c.isSkinnedMesh) {
                const d = c.skeleton;
                s.get(d) !== l && (d.update(), s.set(d, l));
            }
            return u;
        }
        function a() {
            s = new WeakMap;
        }
        function o(c) {
            const l = c.target;
            l.removeEventListener("dispose", o), t.remove(l.instanceMatrix), l.instanceColor !== null && t.remove(l.instanceColor);
        }
        return {
            update: r,
            dispose: a
        };
    }
    const ip = new Qt, Gu = new Kf(1, 1), sp = new Of, rp = new Gg, ap = new Xf, Hu = [], zu = [], Vu = new Float32Array(16), Wu = new Float32Array(9), Xu = new Float32Array(4);
    function Vs(i, e, t) {
        const n = i[0];
        if (n <= 0 || n > 0) return i;
        const s = e * t;
        let r = Hu[s];
        if (r === void 0 && (r = new Float32Array(s), Hu[s] = r), e !== 0) {
            n.toArray(r, 0);
            for(let a = 1, o = 0; a !== e; ++a)o += t, i[a].toArray(r, o);
        }
        return r;
    }
    function Et(i, e) {
        if (i.length !== e.length) return !1;
        for(let t = 0, n = i.length; t < n; t++)if (i[t] !== e[t]) return !1;
        return !0;
    }
    function At(i, e) {
        for(let t = 0, n = e.length; t < n; t++)i[t] = e[t];
    }
    function Ja(i, e) {
        let t = zu[e];
        t === void 0 && (t = new Int32Array(e), zu[e] = t);
        for(let n = 0; n !== e; ++n)t[n] = i.allocateTextureUnit();
        return t;
    }
    function Ky(i, e) {
        const t = this.cache;
        t[0] !== e && (i.uniform1f(this.addr, e), t[0] = e);
    }
    function Zy(i, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (i.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
        else {
            if (Et(t, e)) return;
            i.uniform2fv(this.addr, e), At(t, e);
        }
    }
    function Jy(i, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (i.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
        else if (e.r !== void 0) (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (i.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
        else {
            if (Et(t, e)) return;
            i.uniform3fv(this.addr, e), At(t, e);
        }
    }
    function Qy(i, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (i.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
        else {
            if (Et(t, e)) return;
            i.uniform4fv(this.addr, e), At(t, e);
        }
    }
    function eb(i, e) {
        const t = this.cache, n = e.elements;
        if (n === void 0) {
            if (Et(t, e)) return;
            i.uniformMatrix2fv(this.addr, !1, e), At(t, e);
        } else {
            if (Et(t, n)) return;
            Xu.set(n), i.uniformMatrix2fv(this.addr, !1, Xu), At(t, n);
        }
    }
    function tb(i, e) {
        const t = this.cache, n = e.elements;
        if (n === void 0) {
            if (Et(t, e)) return;
            i.uniformMatrix3fv(this.addr, !1, e), At(t, e);
        } else {
            if (Et(t, n)) return;
            Wu.set(n), i.uniformMatrix3fv(this.addr, !1, Wu), At(t, n);
        }
    }
    function nb(i, e) {
        const t = this.cache, n = e.elements;
        if (n === void 0) {
            if (Et(t, e)) return;
            i.uniformMatrix4fv(this.addr, !1, e), At(t, e);
        } else {
            if (Et(t, n)) return;
            Vu.set(n), i.uniformMatrix4fv(this.addr, !1, Vu), At(t, n);
        }
    }
    function ib(i, e) {
        const t = this.cache;
        t[0] !== e && (i.uniform1i(this.addr, e), t[0] = e);
    }
    function sb(i, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (i.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
        else {
            if (Et(t, e)) return;
            i.uniform2iv(this.addr, e), At(t, e);
        }
    }
    function rb(i, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (i.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
        else {
            if (Et(t, e)) return;
            i.uniform3iv(this.addr, e), At(t, e);
        }
    }
    function ab(i, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (i.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
        else {
            if (Et(t, e)) return;
            i.uniform4iv(this.addr, e), At(t, e);
        }
    }
    function ob(i, e) {
        const t = this.cache;
        t[0] !== e && (i.uniform1ui(this.addr, e), t[0] = e);
    }
    function cb(i, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (i.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
        else {
            if (Et(t, e)) return;
            i.uniform2uiv(this.addr, e), At(t, e);
        }
    }
    function lb(i, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (i.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
        else {
            if (Et(t, e)) return;
            i.uniform3uiv(this.addr, e), At(t, e);
        }
    }
    function hb(i, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (i.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
        else {
            if (Et(t, e)) return;
            i.uniform4uiv(this.addr, e), At(t, e);
        }
    }
    function ub(i, e, t) {
        const n = this.cache, s = t.allocateTextureUnit();
        n[0] !== s && (i.uniform1i(this.addr, s), n[0] = s);
        let r;
        this.type === i.SAMPLER_2D_SHADOW ? (Gu.compareFunction = Bf, r = Gu) : r = ip, t.setTexture2D(e || r, s);
    }
    function db(i, e, t) {
        const n = this.cache, s = t.allocateTextureUnit();
        n[0] !== s && (i.uniform1i(this.addr, s), n[0] = s), t.setTexture3D(e || rp, s);
    }
    function fb(i, e, t) {
        const n = this.cache, s = t.allocateTextureUnit();
        n[0] !== s && (i.uniform1i(this.addr, s), n[0] = s), t.setTextureCube(e || ap, s);
    }
    function pb(i, e, t) {
        const n = this.cache, s = t.allocateTextureUnit();
        n[0] !== s && (i.uniform1i(this.addr, s), n[0] = s), t.setTexture2DArray(e || sp, s);
    }
    function mb(i) {
        switch(i){
            case 5126:
                return Ky;
            case 35664:
                return Zy;
            case 35665:
                return Jy;
            case 35666:
                return Qy;
            case 35674:
                return eb;
            case 35675:
                return tb;
            case 35676:
                return nb;
            case 5124:
            case 35670:
                return ib;
            case 35667:
            case 35671:
                return sb;
            case 35668:
            case 35672:
                return rb;
            case 35669:
            case 35673:
                return ab;
            case 5125:
                return ob;
            case 36294:
                return cb;
            case 36295:
                return lb;
            case 36296:
                return hb;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
                return ub;
            case 35679:
            case 36299:
            case 36307:
                return db;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
                return fb;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
                return pb;
        }
    }
    function _b(i, e) {
        i.uniform1fv(this.addr, e);
    }
    function gb(i, e) {
        const t = Vs(e, this.size, 2);
        i.uniform2fv(this.addr, t);
    }
    function xb(i, e) {
        const t = Vs(e, this.size, 3);
        i.uniform3fv(this.addr, t);
    }
    function vb(i, e) {
        const t = Vs(e, this.size, 4);
        i.uniform4fv(this.addr, t);
    }
    function yb(i, e) {
        const t = Vs(e, this.size, 4);
        i.uniformMatrix2fv(this.addr, !1, t);
    }
    function bb(i, e) {
        const t = Vs(e, this.size, 9);
        i.uniformMatrix3fv(this.addr, !1, t);
    }
    function Sb(i, e) {
        const t = Vs(e, this.size, 16);
        i.uniformMatrix4fv(this.addr, !1, t);
    }
    function Mb(i, e) {
        i.uniform1iv(this.addr, e);
    }
    function Tb(i, e) {
        i.uniform2iv(this.addr, e);
    }
    function Eb(i, e) {
        i.uniform3iv(this.addr, e);
    }
    function Ab(i, e) {
        i.uniform4iv(this.addr, e);
    }
    function wb(i, e) {
        i.uniform1uiv(this.addr, e);
    }
    function Rb(i, e) {
        i.uniform2uiv(this.addr, e);
    }
    function Cb(i, e) {
        i.uniform3uiv(this.addr, e);
    }
    function Pb(i, e) {
        i.uniform4uiv(this.addr, e);
    }
    function Ib(i, e, t) {
        const n = this.cache, s = e.length, r = Ja(t, s);
        Et(n, r) || (i.uniform1iv(this.addr, r), At(n, r));
        for(let a = 0; a !== s; ++a)t.setTexture2D(e[a] || ip, r[a]);
    }
    function Db(i, e, t) {
        const n = this.cache, s = e.length, r = Ja(t, s);
        Et(n, r) || (i.uniform1iv(this.addr, r), At(n, r));
        for(let a = 0; a !== s; ++a)t.setTexture3D(e[a] || rp, r[a]);
    }
    function Lb(i, e, t) {
        const n = this.cache, s = e.length, r = Ja(t, s);
        Et(n, r) || (i.uniform1iv(this.addr, r), At(n, r));
        for(let a = 0; a !== s; ++a)t.setTextureCube(e[a] || ap, r[a]);
    }
    function Ub(i, e, t) {
        const n = this.cache, s = e.length, r = Ja(t, s);
        Et(n, r) || (i.uniform1iv(this.addr, r), At(n, r));
        for(let a = 0; a !== s; ++a)t.setTexture2DArray(e[a] || sp, r[a]);
    }
    function Nb(i) {
        switch(i){
            case 5126:
                return _b;
            case 35664:
                return gb;
            case 35665:
                return xb;
            case 35666:
                return vb;
            case 35674:
                return yb;
            case 35675:
                return bb;
            case 35676:
                return Sb;
            case 5124:
            case 35670:
                return Mb;
            case 35667:
            case 35671:
                return Tb;
            case 35668:
            case 35672:
                return Eb;
            case 35669:
            case 35673:
                return Ab;
            case 5125:
                return wb;
            case 36294:
                return Rb;
            case 36295:
                return Cb;
            case 36296:
                return Pb;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
                return Ib;
            case 35679:
            case 36299:
            case 36307:
                return Db;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
                return Lb;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
                return Ub;
        }
    }
    class Bb {
        constructor(e, t, n){
            this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.setValue = mb(t.type);
        }
    }
    class Fb {
        constructor(e, t, n){
            this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = Nb(t.type);
        }
    }
    class Ob {
        constructor(e){
            this.id = e, this.seq = [], this.map = {};
        }
        setValue(e, t, n) {
            const s = this.seq;
            for(let r = 0, a = s.length; r !== a; ++r){
                const o = s[r];
                o.setValue(e, t[o.id], n);
            }
        }
    }
    const Fo = /(\w+)(\])?(\[|\.)?/g;
    function Yu(i, e) {
        i.seq.push(e), i.map[e.id] = e;
    }
    function kb(i, e, t) {
        const n = i.name, s = n.length;
        for(Fo.lastIndex = 0;;){
            const r = Fo.exec(n), a = Fo.lastIndex;
            let o = r[1];
            const c = r[2] === "]", l = r[3];
            if (c && (o = o | 0), l === void 0 || l === "[" && a + 2 === s) {
                Yu(t, l === void 0 ? new Bb(o, i, e) : new Fb(o, i, e));
                break;
            } else {
                let u = t.map[o];
                u === void 0 && (u = new Ob(o), Yu(t, u)), t = u;
            }
        }
    }
    class La {
        constructor(e, t){
            this.seq = [], this.map = {};
            const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
            for(let s = 0; s < n; ++s){
                const r = e.getActiveUniform(t, s), a = e.getUniformLocation(t, r.name);
                kb(r, a, this);
            }
        }
        setValue(e, t, n, s) {
            const r = this.map[t];
            r !== void 0 && r.setValue(e, n, s);
        }
        setOptional(e, t, n) {
            const s = t[n];
            s !== void 0 && this.setValue(e, n, s);
        }
        static upload(e, t, n, s) {
            for(let r = 0, a = t.length; r !== a; ++r){
                const o = t[r], c = n[o.id];
                c.needsUpdate !== !1 && o.setValue(e, c.value, s);
            }
        }
        static seqWithValue(e, t) {
            const n = [];
            for(let s = 0, r = e.length; s !== r; ++s){
                const a = e[s];
                a.id in t && n.push(a);
            }
            return n;
        }
    }
    function qu(i, e, t) {
        const n = i.createShader(e);
        return i.shaderSource(n, t), i.compileShader(n), n;
    }
    const Gb = 37297;
    let Hb = 0;
    function zb(i, e) {
        const t = i.split(`
`), n = [], s = Math.max(e - 6, 0), r = Math.min(e + 6, t.length);
        for(let a = s; a < r; a++){
            const o = a + 1;
            n.push(`${o === e ? ">" : " "} ${o}: ${t[a]}`);
        }
        return n.join(`
`);
    }
    const ju = new Ge;
    function Vb(i) {
        $e._getMatrix(ju, $e.workingColorSpace, i);
        const e = `mat3( ${ju.elements.map((t)=>t.toFixed(4))} )`;
        switch($e.getTransfer(i)){
            case ka:
                return [
                    e,
                    "LinearTransferOETF"
                ];
            case ct:
                return [
                    e,
                    "sRGBTransferOETF"
                ];
            default:
                return console.warn("THREE.WebGLProgram: Unsupported color space: ", i), [
                    e,
                    "LinearTransferOETF"
                ];
        }
    }
    function $u(i, e, t) {
        const n = i.getShaderParameter(e, i.COMPILE_STATUS), s = i.getShaderInfoLog(e).trim();
        if (n && s === "") return "";
        const r = /ERROR: 0:(\d+)/.exec(s);
        if (r) {
            const a = parseInt(r[1]);
            return t.toUpperCase() + `

` + s + `

` + zb(i.getShaderSource(e), a);
        } else return s;
    }
    function Wb(i, e) {
        const t = Vb(e);
        return [
            `vec4 ${i}( vec4 value ) {`,
            `	return ${t[1]}( vec4( value.rgb * ${t[0]}, value.a ) );`,
            "}"
        ].join(`
`);
    }
    function Xb(i, e) {
        let t;
        switch(e){
            case q_:
                t = "Linear";
                break;
            case j_:
                t = "Reinhard";
                break;
            case $_:
                t = "Cineon";
                break;
            case K_:
                t = "ACESFilmic";
                break;
            case J_:
                t = "AgX";
                break;
            case Q_:
                t = "Neutral";
                break;
            case Z_:
                t = "Custom";
                break;
            default:
                console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear";
        }
        return "vec3 " + i + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
    }
    const da = new k;
    function Yb() {
        $e.getLuminanceCoefficients(da);
        const i = da.x.toFixed(4), e = da.y.toFixed(4), t = da.z.toFixed(4);
        return [
            "float luminance( const in vec3 rgb ) {",
            `	const vec3 weights = vec3( ${i}, ${e}, ${t} );`,
            "	return dot( weights, rgb );",
            "}"
        ].join(`
`);
    }
    function qb(i) {
        return [
            i.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
            i.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
        ].filter(cr).join(`
`);
    }
    function jb(i) {
        const e = [];
        for(const t in i){
            const n = i[t];
            n !== !1 && e.push("#define " + t + " " + n);
        }
        return e.join(`
`);
    }
    function $b(i, e) {
        const t = {}, n = i.getProgramParameter(e, i.ACTIVE_ATTRIBUTES);
        for(let s = 0; s < n; s++){
            const r = i.getActiveAttrib(e, s), a = r.name;
            let o = 1;
            r.type === i.FLOAT_MAT2 && (o = 2), r.type === i.FLOAT_MAT3 && (o = 3), r.type === i.FLOAT_MAT4 && (o = 4), t[a] = {
                type: r.type,
                location: i.getAttribLocation(e, a),
                locationSize: o
            };
        }
        return t;
    }
    function cr(i) {
        return i !== "";
    }
    function Ku(i, e) {
        const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
        return i.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
    }
    function Zu(i, e) {
        return i.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
    }
    const Kb = /^[ \t]*#include +<([\w\d./]+)>/gm;
    function dl(i) {
        return i.replace(Kb, Jb);
    }
    const Zb = new Map;
    function Jb(i, e) {
        let t = Ve[e];
        if (t === void 0) {
            const n = Zb.get(e);
            if (n !== void 0) t = Ve[n], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, n);
            else throw new Error("Can not resolve #include <" + e + ">");
        }
        return dl(t);
    }
    const Qb = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
    function Ju(i) {
        return i.replace(Qb, eS);
    }
    function eS(i, e, t, n) {
        let s = "";
        for(let r = parseInt(e); r < parseInt(t); r++)s += n.replace(/\[\s*i\s*\]/g, "[ " + r + " ]").replace(/UNROLLED_LOOP_INDEX/g, r);
        return s;
    }
    function Qu(i) {
        let e = `precision ${i.precision} float;
	precision ${i.precision} int;
	precision ${i.precision} sampler2D;
	precision ${i.precision} samplerCube;
	precision ${i.precision} sampler3D;
	precision ${i.precision} sampler2DArray;
	precision ${i.precision} sampler2DShadow;
	precision ${i.precision} samplerCubeShadow;
	precision ${i.precision} sampler2DArrayShadow;
	precision ${i.precision} isampler2D;
	precision ${i.precision} isampler3D;
	precision ${i.precision} isamplerCube;
	precision ${i.precision} isampler2DArray;
	precision ${i.precision} usampler2D;
	precision ${i.precision} usampler3D;
	precision ${i.precision} usamplerCube;
	precision ${i.precision} usampler2DArray;
	`;
        return i.precision === "highp" ? e += `
#define HIGH_PRECISION` : i.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : i.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
    }
    function tS(i) {
        let e = "SHADOWMAP_TYPE_BASIC";
        return i.shadowMapType === bf ? e = "SHADOWMAP_TYPE_PCF" : i.shadowMapType === A_ ? e = "SHADOWMAP_TYPE_PCF_SOFT" : i.shadowMapType === jn && (e = "SHADOWMAP_TYPE_VSM"), e;
    }
    function nS(i) {
        let e = "ENVMAP_TYPE_CUBE";
        if (i.envMap) switch(i.envMapMode){
            case Rs:
            case Cs:
                e = "ENVMAP_TYPE_CUBE";
                break;
            case $a:
                e = "ENVMAP_TYPE_CUBE_UV";
                break;
        }
        return e;
    }
    function iS(i) {
        let e = "ENVMAP_MODE_REFLECTION";
        if (i.envMap) switch(i.envMapMode){
            case Cs:
                e = "ENVMAP_MODE_REFRACTION";
                break;
        }
        return e;
    }
    function sS(i) {
        let e = "ENVMAP_BLENDING_NONE";
        if (i.envMap) switch(i.combine){
            case Sf:
                e = "ENVMAP_BLENDING_MULTIPLY";
                break;
            case X_:
                e = "ENVMAP_BLENDING_MIX";
                break;
            case Y_:
                e = "ENVMAP_BLENDING_ADD";
                break;
        }
        return e;
    }
    function rS(i) {
        const e = i.envMapCubeUVHeight;
        if (e === null) return null;
        const t = Math.log2(e) - 2, n = 1 / e;
        return {
            texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
            texelHeight: n,
            maxMip: t
        };
    }
    function aS(i, e, t, n) {
        const s = i.getContext(), r = t.defines;
        let a = t.vertexShader, o = t.fragmentShader;
        const c = tS(t), l = nS(t), h = iS(t), u = sS(t), d = rS(t), f = qb(t), _ = jb(r), g = s.createProgram();
        let p, m, v = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
        t.isRawShaderMaterial ? (p = [
            "#define SHADER_TYPE " + t.shaderType,
            "#define SHADER_NAME " + t.shaderName,
            _
        ].filter(cr).join(`
`), p.length > 0 && (p += `
`), m = [
            "#define SHADER_TYPE " + t.shaderType,
            "#define SHADER_NAME " + t.shaderName,
            _
        ].filter(cr).join(`
`), m.length > 0 && (m += `
`)) : (p = [
            Qu(t),
            "#define SHADER_TYPE " + t.shaderType,
            "#define SHADER_NAME " + t.shaderName,
            _,
            t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
            t.batching ? "#define USE_BATCHING" : "",
            t.batchingColor ? "#define USE_BATCHING_COLOR" : "",
            t.instancing ? "#define USE_INSTANCING" : "",
            t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
            t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
            t.useFog && t.fog ? "#define USE_FOG" : "",
            t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
            t.map ? "#define USE_MAP" : "",
            t.envMap ? "#define USE_ENVMAP" : "",
            t.envMap ? "#define " + h : "",
            t.lightMap ? "#define USE_LIGHTMAP" : "",
            t.aoMap ? "#define USE_AOMAP" : "",
            t.bumpMap ? "#define USE_BUMPMAP" : "",
            t.normalMap ? "#define USE_NORMALMAP" : "",
            t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
            t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
            t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
            t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
            t.anisotropy ? "#define USE_ANISOTROPY" : "",
            t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
            t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
            t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
            t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
            t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
            t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
            t.specularMap ? "#define USE_SPECULARMAP" : "",
            t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
            t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
            t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
            t.metalnessMap ? "#define USE_METALNESSMAP" : "",
            t.alphaMap ? "#define USE_ALPHAMAP" : "",
            t.alphaHash ? "#define USE_ALPHAHASH" : "",
            t.transmission ? "#define USE_TRANSMISSION" : "",
            t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
            t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
            t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
            t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
            t.mapUv ? "#define MAP_UV " + t.mapUv : "",
            t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
            t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
            t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
            t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
            t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
            t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
            t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "",
            t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
            t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
            t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "",
            t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
            t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "",
            t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "",
            t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "",
            t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "",
            t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "",
            t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "",
            t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
            t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "",
            t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "",
            t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "",
            t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
            t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
            t.vertexColors ? "#define USE_COLOR" : "",
            t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
            t.vertexUv1s ? "#define USE_UV1" : "",
            t.vertexUv2s ? "#define USE_UV2" : "",
            t.vertexUv3s ? "#define USE_UV3" : "",
            t.pointsUvs ? "#define USE_POINTS_UV" : "",
            t.flatShading ? "#define FLAT_SHADED" : "",
            t.skinning ? "#define USE_SKINNING" : "",
            t.morphTargets ? "#define USE_MORPHTARGETS" : "",
            t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
            t.morphColors ? "#define USE_MORPHCOLORS" : "",
            t.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "",
            t.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "",
            t.doubleSided ? "#define DOUBLE_SIDED" : "",
            t.flipSided ? "#define FLIP_SIDED" : "",
            t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
            t.shadowMapEnabled ? "#define " + c : "",
            t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
            t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
            t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
            t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
            "uniform mat4 modelMatrix;",
            "uniform mat4 modelViewMatrix;",
            "uniform mat4 projectionMatrix;",
            "uniform mat4 viewMatrix;",
            "uniform mat3 normalMatrix;",
            "uniform vec3 cameraPosition;",
            "uniform bool isOrthographic;",
            "#ifdef USE_INSTANCING",
            "	attribute mat4 instanceMatrix;",
            "#endif",
            "#ifdef USE_INSTANCING_COLOR",
            "	attribute vec3 instanceColor;",
            "#endif",
            "#ifdef USE_INSTANCING_MORPH",
            "	uniform sampler2D morphTexture;",
            "#endif",
            "attribute vec3 position;",
            "attribute vec3 normal;",
            "attribute vec2 uv;",
            "#ifdef USE_UV1",
            "	attribute vec2 uv1;",
            "#endif",
            "#ifdef USE_UV2",
            "	attribute vec2 uv2;",
            "#endif",
            "#ifdef USE_UV3",
            "	attribute vec2 uv3;",
            "#endif",
            "#ifdef USE_TANGENT",
            "	attribute vec4 tangent;",
            "#endif",
            "#if defined( USE_COLOR_ALPHA )",
            "	attribute vec4 color;",
            "#elif defined( USE_COLOR )",
            "	attribute vec3 color;",
            "#endif",
            "#ifdef USE_SKINNING",
            "	attribute vec4 skinIndex;",
            "	attribute vec4 skinWeight;",
            "#endif",
            `
`
        ].filter(cr).join(`
`), m = [
            Qu(t),
            "#define SHADER_TYPE " + t.shaderType,
            "#define SHADER_NAME " + t.shaderName,
            _,
            t.useFog && t.fog ? "#define USE_FOG" : "",
            t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
            t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
            t.map ? "#define USE_MAP" : "",
            t.matcap ? "#define USE_MATCAP" : "",
            t.envMap ? "#define USE_ENVMAP" : "",
            t.envMap ? "#define " + l : "",
            t.envMap ? "#define " + h : "",
            t.envMap ? "#define " + u : "",
            d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "",
            d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "",
            d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "",
            t.lightMap ? "#define USE_LIGHTMAP" : "",
            t.aoMap ? "#define USE_AOMAP" : "",
            t.bumpMap ? "#define USE_BUMPMAP" : "",
            t.normalMap ? "#define USE_NORMALMAP" : "",
            t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
            t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
            t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
            t.anisotropy ? "#define USE_ANISOTROPY" : "",
            t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
            t.clearcoat ? "#define USE_CLEARCOAT" : "",
            t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
            t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
            t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
            t.dispersion ? "#define USE_DISPERSION" : "",
            t.iridescence ? "#define USE_IRIDESCENCE" : "",
            t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
            t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
            t.specularMap ? "#define USE_SPECULARMAP" : "",
            t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
            t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
            t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
            t.metalnessMap ? "#define USE_METALNESSMAP" : "",
            t.alphaMap ? "#define USE_ALPHAMAP" : "",
            t.alphaTest ? "#define USE_ALPHATEST" : "",
            t.alphaHash ? "#define USE_ALPHAHASH" : "",
            t.sheen ? "#define USE_SHEEN" : "",
            t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
            t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
            t.transmission ? "#define USE_TRANSMISSION" : "",
            t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
            t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
            t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
            t.vertexColors || t.instancingColor || t.batchingColor ? "#define USE_COLOR" : "",
            t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
            t.vertexUv1s ? "#define USE_UV1" : "",
            t.vertexUv2s ? "#define USE_UV2" : "",
            t.vertexUv3s ? "#define USE_UV3" : "",
            t.pointsUvs ? "#define USE_POINTS_UV" : "",
            t.gradientMap ? "#define USE_GRADIENTMAP" : "",
            t.flatShading ? "#define FLAT_SHADED" : "",
            t.doubleSided ? "#define DOUBLE_SIDED" : "",
            t.flipSided ? "#define FLIP_SIDED" : "",
            t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
            t.shadowMapEnabled ? "#define " + c : "",
            t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
            t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
            t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
            t.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "",
            t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
            t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
            "uniform mat4 viewMatrix;",
            "uniform vec3 cameraPosition;",
            "uniform bool isOrthographic;",
            t.toneMapping !== mi ? "#define TONE_MAPPING" : "",
            t.toneMapping !== mi ? Ve.tonemapping_pars_fragment : "",
            t.toneMapping !== mi ? Xb("toneMapping", t.toneMapping) : "",
            t.dithering ? "#define DITHERING" : "",
            t.opaque ? "#define OPAQUE" : "",
            Ve.colorspace_pars_fragment,
            Wb("linearToOutputTexel", t.outputColorSpace),
            Yb(),
            t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
            `
`
        ].filter(cr).join(`
`)), a = dl(a), a = Ku(a, t), a = Zu(a, t), o = dl(o), o = Ku(o, t), o = Zu(o, t), a = Ju(a), o = Ju(o), t.isRawShaderMaterial !== !0 && (v = `#version 300 es
`, p = [
            f,
            "#define attribute in",
            "#define varying out",
            "#define texture2D texture"
        ].join(`
`) + `
` + p, m = [
            "#define varying in",
            t.glslVersion === jh ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
            t.glslVersion === jh ? "" : "#define gl_FragColor pc_fragColor",
            "#define gl_FragDepthEXT gl_FragDepth",
            "#define texture2D texture",
            "#define textureCube texture",
            "#define texture2DProj textureProj",
            "#define texture2DLodEXT textureLod",
            "#define texture2DProjLodEXT textureProjLod",
            "#define textureCubeLodEXT textureLod",
            "#define texture2DGradEXT textureGrad",
            "#define texture2DProjGradEXT textureProjGrad",
            "#define textureCubeGradEXT textureGrad"
        ].join(`
`) + `
` + m);
        const y = v + p + a, x = v + m + o, I = qu(s, s.VERTEX_SHADER, y), w = qu(s, s.FRAGMENT_SHADER, x);
        s.attachShader(g, I), s.attachShader(g, w), t.index0AttributeName !== void 0 ? s.bindAttribLocation(g, 0, t.index0AttributeName) : t.morphTargets === !0 && s.bindAttribLocation(g, 0, "position"), s.linkProgram(g);
        function R(D) {
            if (i.debug.checkShaderErrors) {
                const j = s.getProgramInfoLog(g).trim(), z = s.getShaderInfoLog(I).trim(), K = s.getShaderInfoLog(w).trim();
                let ne = !0, b = !0;
                if (s.getProgramParameter(g, s.LINK_STATUS) === !1) if (ne = !1, typeof i.debug.onShaderError == "function") i.debug.onShaderError(s, g, I, w);
                else {
                    const C = $u(s, I, "vertex"), A = $u(s, w, "fragment");
                    console.error("THREE.WebGLProgram: Shader Error " + s.getError() + " - VALIDATE_STATUS " + s.getProgramParameter(g, s.VALIDATE_STATUS) + `

Material Name: ` + D.name + `
Material Type: ` + D.type + `

Program Info Log: ` + j + `
` + C + `
` + A);
                }
                else j !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", j) : (z === "" || K === "") && (b = !1);
                b && (D.diagnostics = {
                    runnable: ne,
                    programLog: j,
                    vertexShader: {
                        log: z,
                        prefix: p
                    },
                    fragmentShader: {
                        log: K,
                        prefix: m
                    }
                });
            }
            s.deleteShader(I), s.deleteShader(w), N = new La(s, g), E = $b(s, g);
        }
        let N;
        this.getUniforms = function() {
            return N === void 0 && R(this), N;
        };
        let E;
        this.getAttributes = function() {
            return E === void 0 && R(this), E;
        };
        let S = t.rendererExtensionParallelShaderCompile === !1;
        return this.isReady = function() {
            return S === !1 && (S = s.getProgramParameter(g, Gb)), S;
        }, this.destroy = function() {
            n.releaseStatesOfProgram(this), s.deleteProgram(g), this.program = void 0;
        }, this.type = t.shaderType, this.name = t.shaderName, this.id = Hb++, this.cacheKey = e, this.usedTimes = 1, this.program = g, this.vertexShader = I, this.fragmentShader = w, this;
    }
    let oS = 0;
    class cS {
        constructor(){
            this.shaderCache = new Map, this.materialCache = new Map;
        }
        update(e) {
            const t = e.vertexShader, n = e.fragmentShader, s = this._getShaderStage(t), r = this._getShaderStage(n), a = this._getShaderCacheForMaterial(e);
            return a.has(s) === !1 && (a.add(s), s.usedTimes++), a.has(r) === !1 && (a.add(r), r.usedTimes++), this;
        }
        remove(e) {
            const t = this.materialCache.get(e);
            for (const n of t)n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
            return this.materialCache.delete(e), this;
        }
        getVertexShaderID(e) {
            return this._getShaderStage(e.vertexShader).id;
        }
        getFragmentShaderID(e) {
            return this._getShaderStage(e.fragmentShader).id;
        }
        dispose() {
            this.shaderCache.clear(), this.materialCache.clear();
        }
        _getShaderCacheForMaterial(e) {
            const t = this.materialCache;
            let n = t.get(e);
            return n === void 0 && (n = new Set, t.set(e, n)), n;
        }
        _getShaderStage(e) {
            const t = this.shaderCache;
            let n = t.get(e);
            return n === void 0 && (n = new lS(e), t.set(e, n)), n;
        }
    }
    class lS {
        constructor(e){
            this.id = oS++, this.code = e, this.usedTimes = 0;
        }
    }
    function hS(i, e, t, n, s, r, a) {
        const o = new kf, c = new cS, l = new Set, h = [], u = s.logarithmicDepthBuffer, d = s.vertexTextures;
        let f = s.precision;
        const _ = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "toon",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            MeshMatcapMaterial: "matcap",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow",
            SpriteMaterial: "sprite"
        };
        function g(E) {
            return l.add(E), E === 0 ? "uv" : `uv${E}`;
        }
        function p(E, S, D, j, z) {
            const K = j.fog, ne = z.geometry, b = E.isMeshStandardMaterial ? j.environment : null, C = (E.isMeshStandardMaterial ? t : e).get(E.envMap || b), A = C && C.mapping === $a ? C.image.height : null, U = _[E.type];
            E.precision !== null && (f = s.getMaxPrecision(E.precision), f !== E.precision && console.warn("THREE.WebGLProgram.getParameters:", E.precision, "not supported, using", f, "instead."));
            const B = ne.morphAttributes.position || ne.morphAttributes.normal || ne.morphAttributes.color, V = B !== void 0 ? B.length : 0;
            let q = 0;
            ne.morphAttributes.position !== void 0 && (q = 1), ne.morphAttributes.normal !== void 0 && (q = 2), ne.morphAttributes.color !== void 0 && (q = 3);
            let te, H, $, oe;
            if (U) {
                const at = Ln[U];
                te = at.vertexShader, H = at.fragmentShader;
            } else te = E.vertexShader, H = E.fragmentShader, c.update(E), $ = c.getVertexShaderID(E), oe = c.getFragmentShaderID(E);
            const ie = i.getRenderTarget(), le = i.state.buffers.depth.getReversed(), we = z.isInstancedMesh === !0, he = z.isBatchedMesh === !0, tt = !!E.map, We = !!E.matcap, Le = !!C, L = !!E.aoMap, Ce = !!E.lightMap, ge = !!E.bumpMap, Xe = !!E.normalMap, Ee = !!E.displacementMap, lt = !!E.emissiveMap, Ae = !!E.metalnessMap, P = !!E.roughnessMap, M = E.anisotropy > 0, W = E.clearcoat > 0, Q = E.dispersion > 0, re = E.iridescence > 0, J = E.sheen > 0, Te = E.transmission > 0, fe = M && !!E.anisotropyMap, ve = W && !!E.clearcoatMap, Ze = W && !!E.clearcoatNormalMap, ce = W && !!E.clearcoatRoughnessMap, ye = re && !!E.iridescenceMap, Ie = re && !!E.iridescenceThicknessMap, Ue = J && !!E.sheenColorMap, be = J && !!E.sheenRoughnessMap, je = !!E.specularMap, ze = !!E.specularColorMap, ht = !!E.specularIntensityMap, F = Te && !!E.transmissionMap, pe = Te && !!E.thicknessMap, Z = !!E.gradientMap, ee = !!E.alphaMap, _e = E.alphaTest > 0, me = !!E.alphaHash, ke = !!E.extensions;
            let xt = mi;
            E.toneMapped && (ie === null || ie.isXRRenderTarget === !0) && (xt = i.toneMapping);
            const Bt = {
                shaderID: U,
                shaderType: E.type,
                shaderName: E.name,
                vertexShader: te,
                fragmentShader: H,
                defines: E.defines,
                customVertexShaderID: $,
                customFragmentShaderID: oe,
                isRawShaderMaterial: E.isRawShaderMaterial === !0,
                glslVersion: E.glslVersion,
                precision: f,
                batching: he,
                batchingColor: he && z._colorsTexture !== null,
                instancing: we,
                instancingColor: we && z.instanceColor !== null,
                instancingMorph: we && z.morphTexture !== null,
                supportsVertexTextures: d,
                outputColorSpace: ie === null ? i.outputColorSpace : ie.isXRRenderTarget === !0 ? ie.texture.colorSpace : $t,
                alphaToCoverage: !!E.alphaToCoverage,
                map: tt,
                matcap: We,
                envMap: Le,
                envMapMode: Le && C.mapping,
                envMapCubeUVHeight: A,
                aoMap: L,
                lightMap: Ce,
                bumpMap: ge,
                normalMap: Xe,
                displacementMap: d && Ee,
                emissiveMap: lt,
                normalMapObjectSpace: Xe && E.normalMapType === ag,
                normalMapTangentSpace: Xe && E.normalMapType === Nf,
                metalnessMap: Ae,
                roughnessMap: P,
                anisotropy: M,
                anisotropyMap: fe,
                clearcoat: W,
                clearcoatMap: ve,
                clearcoatNormalMap: Ze,
                clearcoatRoughnessMap: ce,
                dispersion: Q,
                iridescence: re,
                iridescenceMap: ye,
                iridescenceThicknessMap: Ie,
                sheen: J,
                sheenColorMap: Ue,
                sheenRoughnessMap: be,
                specularMap: je,
                specularColorMap: ze,
                specularIntensityMap: ht,
                transmission: Te,
                transmissionMap: F,
                thicknessMap: pe,
                gradientMap: Z,
                opaque: E.transparent === !1 && E.blending === Ms && E.alphaToCoverage === !1,
                alphaMap: ee,
                alphaTest: _e,
                alphaHash: me,
                combine: E.combine,
                mapUv: tt && g(E.map.channel),
                aoMapUv: L && g(E.aoMap.channel),
                lightMapUv: Ce && g(E.lightMap.channel),
                bumpMapUv: ge && g(E.bumpMap.channel),
                normalMapUv: Xe && g(E.normalMap.channel),
                displacementMapUv: Ee && g(E.displacementMap.channel),
                emissiveMapUv: lt && g(E.emissiveMap.channel),
                metalnessMapUv: Ae && g(E.metalnessMap.channel),
                roughnessMapUv: P && g(E.roughnessMap.channel),
                anisotropyMapUv: fe && g(E.anisotropyMap.channel),
                clearcoatMapUv: ve && g(E.clearcoatMap.channel),
                clearcoatNormalMapUv: Ze && g(E.clearcoatNormalMap.channel),
                clearcoatRoughnessMapUv: ce && g(E.clearcoatRoughnessMap.channel),
                iridescenceMapUv: ye && g(E.iridescenceMap.channel),
                iridescenceThicknessMapUv: Ie && g(E.iridescenceThicknessMap.channel),
                sheenColorMapUv: Ue && g(E.sheenColorMap.channel),
                sheenRoughnessMapUv: be && g(E.sheenRoughnessMap.channel),
                specularMapUv: je && g(E.specularMap.channel),
                specularColorMapUv: ze && g(E.specularColorMap.channel),
                specularIntensityMapUv: ht && g(E.specularIntensityMap.channel),
                transmissionMapUv: F && g(E.transmissionMap.channel),
                thicknessMapUv: pe && g(E.thicknessMap.channel),
                alphaMapUv: ee && g(E.alphaMap.channel),
                vertexTangents: !!ne.attributes.tangent && (Xe || M),
                vertexColors: E.vertexColors,
                vertexAlphas: E.vertexColors === !0 && !!ne.attributes.color && ne.attributes.color.itemSize === 4,
                pointsUvs: z.isPoints === !0 && !!ne.attributes.uv && (tt || ee),
                fog: !!K,
                useFog: E.fog === !0,
                fogExp2: !!K && K.isFogExp2,
                flatShading: E.flatShading === !0,
                sizeAttenuation: E.sizeAttenuation === !0,
                logarithmicDepthBuffer: u,
                reverseDepthBuffer: le,
                skinning: z.isSkinnedMesh === !0,
                morphTargets: ne.morphAttributes.position !== void 0,
                morphNormals: ne.morphAttributes.normal !== void 0,
                morphColors: ne.morphAttributes.color !== void 0,
                morphTargetsCount: V,
                morphTextureStride: q,
                numDirLights: S.directional.length,
                numPointLights: S.point.length,
                numSpotLights: S.spot.length,
                numSpotLightMaps: S.spotLightMap.length,
                numRectAreaLights: S.rectArea.length,
                numHemiLights: S.hemi.length,
                numDirLightShadows: S.directionalShadowMap.length,
                numPointLightShadows: S.pointShadowMap.length,
                numSpotLightShadows: S.spotShadowMap.length,
                numSpotLightShadowsWithMaps: S.numSpotLightShadowsWithMaps,
                numLightProbes: S.numLightProbes,
                numClippingPlanes: a.numPlanes,
                numClipIntersection: a.numIntersection,
                dithering: E.dithering,
                shadowMapEnabled: i.shadowMap.enabled && D.length > 0,
                shadowMapType: i.shadowMap.type,
                toneMapping: xt,
                decodeVideoTexture: tt && E.map.isVideoTexture === !0 && $e.getTransfer(E.map.colorSpace) === ct,
                decodeVideoTextureEmissive: lt && E.emissiveMap.isVideoTexture === !0 && $e.getTransfer(E.emissiveMap.colorSpace) === ct,
                premultipliedAlpha: E.premultipliedAlpha,
                doubleSided: E.side === Un,
                flipSided: E.side === Jt,
                useDepthPacking: E.depthPacking >= 0,
                depthPacking: E.depthPacking || 0,
                index0AttributeName: E.index0AttributeName,
                extensionClipCullDistance: ke && E.extensions.clipCullDistance === !0 && n.has("WEBGL_clip_cull_distance"),
                extensionMultiDraw: (ke && E.extensions.multiDraw === !0 || he) && n.has("WEBGL_multi_draw"),
                rendererExtensionParallelShaderCompile: n.has("KHR_parallel_shader_compile"),
                customProgramCacheKey: E.customProgramCacheKey()
            };
            return Bt.vertexUv1s = l.has(1), Bt.vertexUv2s = l.has(2), Bt.vertexUv3s = l.has(3), l.clear(), Bt;
        }
        function m(E) {
            const S = [];
            if (E.shaderID ? S.push(E.shaderID) : (S.push(E.customVertexShaderID), S.push(E.customFragmentShaderID)), E.defines !== void 0) for(const D in E.defines)S.push(D), S.push(E.defines[D]);
            return E.isRawShaderMaterial === !1 && (v(S, E), y(S, E), S.push(i.outputColorSpace)), S.push(E.customProgramCacheKey), S.join();
        }
        function v(E, S) {
            E.push(S.precision), E.push(S.outputColorSpace), E.push(S.envMapMode), E.push(S.envMapCubeUVHeight), E.push(S.mapUv), E.push(S.alphaMapUv), E.push(S.lightMapUv), E.push(S.aoMapUv), E.push(S.bumpMapUv), E.push(S.normalMapUv), E.push(S.displacementMapUv), E.push(S.emissiveMapUv), E.push(S.metalnessMapUv), E.push(S.roughnessMapUv), E.push(S.anisotropyMapUv), E.push(S.clearcoatMapUv), E.push(S.clearcoatNormalMapUv), E.push(S.clearcoatRoughnessMapUv), E.push(S.iridescenceMapUv), E.push(S.iridescenceThicknessMapUv), E.push(S.sheenColorMapUv), E.push(S.sheenRoughnessMapUv), E.push(S.specularMapUv), E.push(S.specularColorMapUv), E.push(S.specularIntensityMapUv), E.push(S.transmissionMapUv), E.push(S.thicknessMapUv), E.push(S.combine), E.push(S.fogExp2), E.push(S.sizeAttenuation), E.push(S.morphTargetsCount), E.push(S.morphAttributeCount), E.push(S.numDirLights), E.push(S.numPointLights), E.push(S.numSpotLights), E.push(S.numSpotLightMaps), E.push(S.numHemiLights), E.push(S.numRectAreaLights), E.push(S.numDirLightShadows), E.push(S.numPointLightShadows), E.push(S.numSpotLightShadows), E.push(S.numSpotLightShadowsWithMaps), E.push(S.numLightProbes), E.push(S.shadowMapType), E.push(S.toneMapping), E.push(S.numClippingPlanes), E.push(S.numClipIntersection), E.push(S.depthPacking);
        }
        function y(E, S) {
            o.disableAll(), S.supportsVertexTextures && o.enable(0), S.instancing && o.enable(1), S.instancingColor && o.enable(2), S.instancingMorph && o.enable(3), S.matcap && o.enable(4), S.envMap && o.enable(5), S.normalMapObjectSpace && o.enable(6), S.normalMapTangentSpace && o.enable(7), S.clearcoat && o.enable(8), S.iridescence && o.enable(9), S.alphaTest && o.enable(10), S.vertexColors && o.enable(11), S.vertexAlphas && o.enable(12), S.vertexUv1s && o.enable(13), S.vertexUv2s && o.enable(14), S.vertexUv3s && o.enable(15), S.vertexTangents && o.enable(16), S.anisotropy && o.enable(17), S.alphaHash && o.enable(18), S.batching && o.enable(19), S.dispersion && o.enable(20), S.batchingColor && o.enable(21), E.push(o.mask), o.disableAll(), S.fog && o.enable(0), S.useFog && o.enable(1), S.flatShading && o.enable(2), S.logarithmicDepthBuffer && o.enable(3), S.reverseDepthBuffer && o.enable(4), S.skinning && o.enable(5), S.morphTargets && o.enable(6), S.morphNormals && o.enable(7), S.morphColors && o.enable(8), S.premultipliedAlpha && o.enable(9), S.shadowMapEnabled && o.enable(10), S.doubleSided && o.enable(11), S.flipSided && o.enable(12), S.useDepthPacking && o.enable(13), S.dithering && o.enable(14), S.transmission && o.enable(15), S.sheen && o.enable(16), S.opaque && o.enable(17), S.pointsUvs && o.enable(18), S.decodeVideoTexture && o.enable(19), S.decodeVideoTextureEmissive && o.enable(20), S.alphaToCoverage && o.enable(21), E.push(o.mask);
        }
        function x(E) {
            const S = _[E.type];
            let D;
            if (S) {
                const j = Ln[S];
                D = Qg.clone(j.uniforms);
            } else D = E.uniforms;
            return D;
        }
        function I(E, S) {
            let D;
            for(let j = 0, z = h.length; j < z; j++){
                const K = h[j];
                if (K.cacheKey === S) {
                    D = K, ++D.usedTimes;
                    break;
                }
            }
            return D === void 0 && (D = new aS(i, S, E, r), h.push(D)), D;
        }
        function w(E) {
            if (--E.usedTimes === 0) {
                const S = h.indexOf(E);
                h[S] = h[h.length - 1], h.pop(), E.destroy();
            }
        }
        function R(E) {
            c.remove(E);
        }
        function N() {
            c.dispose();
        }
        return {
            getParameters: p,
            getProgramCacheKey: m,
            getUniforms: x,
            acquireProgram: I,
            releaseProgram: w,
            releaseShaderCache: R,
            programs: h,
            dispose: N
        };
    }
    function uS() {
        let i = new WeakMap;
        function e(a) {
            return i.has(a);
        }
        function t(a) {
            let o = i.get(a);
            return o === void 0 && (o = {}, i.set(a, o)), o;
        }
        function n(a) {
            i.delete(a);
        }
        function s(a, o, c) {
            i.get(a)[o] = c;
        }
        function r() {
            i = new WeakMap;
        }
        return {
            has: e,
            get: t,
            remove: n,
            update: s,
            dispose: r
        };
    }
    function dS(i, e) {
        return i.groupOrder !== e.groupOrder ? i.groupOrder - e.groupOrder : i.renderOrder !== e.renderOrder ? i.renderOrder - e.renderOrder : i.material.id !== e.material.id ? i.material.id - e.material.id : i.z !== e.z ? i.z - e.z : i.id - e.id;
    }
    function ed(i, e) {
        return i.groupOrder !== e.groupOrder ? i.groupOrder - e.groupOrder : i.renderOrder !== e.renderOrder ? i.renderOrder - e.renderOrder : i.z !== e.z ? e.z - i.z : i.id - e.id;
    }
    function td() {
        const i = [];
        let e = 0;
        const t = [], n = [], s = [];
        function r() {
            e = 0, t.length = 0, n.length = 0, s.length = 0;
        }
        function a(u, d, f, _, g, p) {
            let m = i[e];
            return m === void 0 ? (m = {
                id: u.id,
                object: u,
                geometry: d,
                material: f,
                groupOrder: _,
                renderOrder: u.renderOrder,
                z: g,
                group: p
            }, i[e] = m) : (m.id = u.id, m.object = u, m.geometry = d, m.material = f, m.groupOrder = _, m.renderOrder = u.renderOrder, m.z = g, m.group = p), e++, m;
        }
        function o(u, d, f, _, g, p) {
            const m = a(u, d, f, _, g, p);
            f.transmission > 0 ? n.push(m) : f.transparent === !0 ? s.push(m) : t.push(m);
        }
        function c(u, d, f, _, g, p) {
            const m = a(u, d, f, _, g, p);
            f.transmission > 0 ? n.unshift(m) : f.transparent === !0 ? s.unshift(m) : t.unshift(m);
        }
        function l(u, d) {
            t.length > 1 && t.sort(u || dS), n.length > 1 && n.sort(d || ed), s.length > 1 && s.sort(d || ed);
        }
        function h() {
            for(let u = e, d = i.length; u < d; u++){
                const f = i[u];
                if (f.id === null) break;
                f.id = null, f.object = null, f.geometry = null, f.material = null, f.group = null;
            }
        }
        return {
            opaque: t,
            transmissive: n,
            transparent: s,
            init: r,
            push: o,
            unshift: c,
            finish: h,
            sort: l
        };
    }
    function fS() {
        let i = new WeakMap;
        function e(n, s) {
            const r = i.get(n);
            let a;
            return r === void 0 ? (a = new td, i.set(n, [
                a
            ])) : s >= r.length ? (a = new td, r.push(a)) : a = r[s], a;
        }
        function t() {
            i = new WeakMap;
        }
        return {
            get: e,
            dispose: t
        };
    }
    function pS() {
        const i = {};
        return {
            get: function(e) {
                if (i[e.id] !== void 0) return i[e.id];
                let t;
                switch(e.type){
                    case "DirectionalLight":
                        t = {
                            direction: new k,
                            color: new Be
                        };
                        break;
                    case "SpotLight":
                        t = {
                            position: new k,
                            direction: new k,
                            color: new Be,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0
                        };
                        break;
                    case "PointLight":
                        t = {
                            position: new k,
                            color: new Be,
                            distance: 0,
                            decay: 0
                        };
                        break;
                    case "HemisphereLight":
                        t = {
                            direction: new k,
                            skyColor: new Be,
                            groundColor: new Be
                        };
                        break;
                    case "RectAreaLight":
                        t = {
                            color: new Be,
                            position: new k,
                            halfWidth: new k,
                            halfHeight: new k
                        };
                        break;
                }
                return i[e.id] = t, t;
            }
        };
    }
    function mS() {
        const i = {};
        return {
            get: function(e) {
                if (i[e.id] !== void 0) return i[e.id];
                let t;
                switch(e.type){
                    case "DirectionalLight":
                        t = {
                            shadowIntensity: 1,
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new Ke
                        };
                        break;
                    case "SpotLight":
                        t = {
                            shadowIntensity: 1,
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new Ke
                        };
                        break;
                    case "PointLight":
                        t = {
                            shadowIntensity: 1,
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new Ke,
                            shadowCameraNear: 1,
                            shadowCameraFar: 1e3
                        };
                        break;
                }
                return i[e.id] = t, t;
            }
        };
    }
    let _S = 0;
    function gS(i, e) {
        return (e.castShadow ? 2 : 0) - (i.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (i.map ? 1 : 0);
    }
    function xS(i) {
        const e = new pS, t = mS(), n = {
            version: 0,
            hash: {
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1,
                numSpotMaps: -1,
                numLightProbes: -1
            },
            ambient: [
                0,
                0,
                0
            ],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotLightMap: [],
            spotShadow: [],
            spotShadowMap: [],
            spotLightMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
            numSpotLightShadowsWithMaps: 0,
            numLightProbes: 0
        };
        for(let l = 0; l < 9; l++)n.probe.push(new k);
        const s = new k, r = new He, a = new He;
        function o(l) {
            let h = 0, u = 0, d = 0;
            for(let E = 0; E < 9; E++)n.probe[E].set(0, 0, 0);
            let f = 0, _ = 0, g = 0, p = 0, m = 0, v = 0, y = 0, x = 0, I = 0, w = 0, R = 0;
            l.sort(gS);
            for(let E = 0, S = l.length; E < S; E++){
                const D = l[E], j = D.color, z = D.intensity, K = D.distance, ne = D.shadow && D.shadow.map ? D.shadow.map.texture : null;
                if (D.isAmbientLight) h += j.r * z, u += j.g * z, d += j.b * z;
                else if (D.isLightProbe) {
                    for(let b = 0; b < 9; b++)n.probe[b].addScaledVector(D.sh.coefficients[b], z);
                    R++;
                } else if (D.isDirectionalLight) {
                    const b = e.get(D);
                    if (b.color.copy(D.color).multiplyScalar(D.intensity), D.castShadow) {
                        const C = D.shadow, A = t.get(D);
                        A.shadowIntensity = C.intensity, A.shadowBias = C.bias, A.shadowNormalBias = C.normalBias, A.shadowRadius = C.radius, A.shadowMapSize = C.mapSize, n.directionalShadow[f] = A, n.directionalShadowMap[f] = ne, n.directionalShadowMatrix[f] = D.shadow.matrix, v++;
                    }
                    n.directional[f] = b, f++;
                } else if (D.isSpotLight) {
                    const b = e.get(D);
                    b.position.setFromMatrixPosition(D.matrixWorld), b.color.copy(j).multiplyScalar(z), b.distance = K, b.coneCos = Math.cos(D.angle), b.penumbraCos = Math.cos(D.angle * (1 - D.penumbra)), b.decay = D.decay, n.spot[g] = b;
                    const C = D.shadow;
                    if (D.map && (n.spotLightMap[I] = D.map, I++, C.updateMatrices(D), D.castShadow && w++), n.spotLightMatrix[g] = C.matrix, D.castShadow) {
                        const A = t.get(D);
                        A.shadowIntensity = C.intensity, A.shadowBias = C.bias, A.shadowNormalBias = C.normalBias, A.shadowRadius = C.radius, A.shadowMapSize = C.mapSize, n.spotShadow[g] = A, n.spotShadowMap[g] = ne, x++;
                    }
                    g++;
                } else if (D.isRectAreaLight) {
                    const b = e.get(D);
                    b.color.copy(j).multiplyScalar(z), b.halfWidth.set(D.width * .5, 0, 0), b.halfHeight.set(0, D.height * .5, 0), n.rectArea[p] = b, p++;
                } else if (D.isPointLight) {
                    const b = e.get(D);
                    if (b.color.copy(D.color).multiplyScalar(D.intensity), b.distance = D.distance, b.decay = D.decay, D.castShadow) {
                        const C = D.shadow, A = t.get(D);
                        A.shadowIntensity = C.intensity, A.shadowBias = C.bias, A.shadowNormalBias = C.normalBias, A.shadowRadius = C.radius, A.shadowMapSize = C.mapSize, A.shadowCameraNear = C.camera.near, A.shadowCameraFar = C.camera.far, n.pointShadow[_] = A, n.pointShadowMap[_] = ne, n.pointShadowMatrix[_] = D.shadow.matrix, y++;
                    }
                    n.point[_] = b, _++;
                } else if (D.isHemisphereLight) {
                    const b = e.get(D);
                    b.skyColor.copy(D.color).multiplyScalar(z), b.groundColor.copy(D.groundColor).multiplyScalar(z), n.hemi[m] = b, m++;
                }
            }
            p > 0 && (i.has("OES_texture_float_linear") === !0 ? (n.rectAreaLTC1 = ue.LTC_FLOAT_1, n.rectAreaLTC2 = ue.LTC_FLOAT_2) : (n.rectAreaLTC1 = ue.LTC_HALF_1, n.rectAreaLTC2 = ue.LTC_HALF_2)), n.ambient[0] = h, n.ambient[1] = u, n.ambient[2] = d;
            const N = n.hash;
            (N.directionalLength !== f || N.pointLength !== _ || N.spotLength !== g || N.rectAreaLength !== p || N.hemiLength !== m || N.numDirectionalShadows !== v || N.numPointShadows !== y || N.numSpotShadows !== x || N.numSpotMaps !== I || N.numLightProbes !== R) && (n.directional.length = f, n.spot.length = g, n.rectArea.length = p, n.point.length = _, n.hemi.length = m, n.directionalShadow.length = v, n.directionalShadowMap.length = v, n.pointShadow.length = y, n.pointShadowMap.length = y, n.spotShadow.length = x, n.spotShadowMap.length = x, n.directionalShadowMatrix.length = v, n.pointShadowMatrix.length = y, n.spotLightMatrix.length = x + I - w, n.spotLightMap.length = I, n.numSpotLightShadowsWithMaps = w, n.numLightProbes = R, N.directionalLength = f, N.pointLength = _, N.spotLength = g, N.rectAreaLength = p, N.hemiLength = m, N.numDirectionalShadows = v, N.numPointShadows = y, N.numSpotShadows = x, N.numSpotMaps = I, N.numLightProbes = R, n.version = _S++);
        }
        function c(l, h) {
            let u = 0, d = 0, f = 0, _ = 0, g = 0;
            const p = h.matrixWorldInverse;
            for(let m = 0, v = l.length; m < v; m++){
                const y = l[m];
                if (y.isDirectionalLight) {
                    const x = n.directional[u];
                    x.direction.setFromMatrixPosition(y.matrixWorld), s.setFromMatrixPosition(y.target.matrixWorld), x.direction.sub(s), x.direction.transformDirection(p), u++;
                } else if (y.isSpotLight) {
                    const x = n.spot[f];
                    x.position.setFromMatrixPosition(y.matrixWorld), x.position.applyMatrix4(p), x.direction.setFromMatrixPosition(y.matrixWorld), s.setFromMatrixPosition(y.target.matrixWorld), x.direction.sub(s), x.direction.transformDirection(p), f++;
                } else if (y.isRectAreaLight) {
                    const x = n.rectArea[_];
                    x.position.setFromMatrixPosition(y.matrixWorld), x.position.applyMatrix4(p), a.identity(), r.copy(y.matrixWorld), r.premultiply(p), a.extractRotation(r), x.halfWidth.set(y.width * .5, 0, 0), x.halfHeight.set(0, y.height * .5, 0), x.halfWidth.applyMatrix4(a), x.halfHeight.applyMatrix4(a), _++;
                } else if (y.isPointLight) {
                    const x = n.point[d];
                    x.position.setFromMatrixPosition(y.matrixWorld), x.position.applyMatrix4(p), d++;
                } else if (y.isHemisphereLight) {
                    const x = n.hemi[g];
                    x.direction.setFromMatrixPosition(y.matrixWorld), x.direction.transformDirection(p), g++;
                }
            }
        }
        return {
            setup: o,
            setupView: c,
            state: n
        };
    }
    function nd(i) {
        const e = new xS(i), t = [], n = [];
        function s(h) {
            l.camera = h, t.length = 0, n.length = 0;
        }
        function r(h) {
            t.push(h);
        }
        function a(h) {
            n.push(h);
        }
        function o() {
            e.setup(t);
        }
        function c(h) {
            e.setupView(t, h);
        }
        const l = {
            lightsArray: t,
            shadowsArray: n,
            camera: null,
            lights: e,
            transmissionRenderTarget: {}
        };
        return {
            init: s,
            state: l,
            setupLights: o,
            setupLightsView: c,
            pushLight: r,
            pushShadow: a
        };
    }
    function vS(i) {
        let e = new WeakMap;
        function t(s, r = 0) {
            const a = e.get(s);
            let o;
            return a === void 0 ? (o = new nd(i), e.set(s, [
                o
            ])) : r >= a.length ? (o = new nd(i), a.push(o)) : o = a[r], o;
        }
        function n() {
            e = new WeakMap;
        }
        return {
            get: t,
            dispose: n
        };
    }
    const yS = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, bS = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
    function SS(i, e, t) {
        let n = new Zl;
        const s = new Ke, r = new Ke, a = new nt, o = new gx({
            depthPacking: rg
        }), c = new xx, l = {}, h = t.maxTextureSize, u = {
            [ti]: Jt,
            [Jt]: ti,
            [Un]: Un
        }, d = new xi({
            defines: {
                VSM_SAMPLES: 8
            },
            uniforms: {
                shadow_pass: {
                    value: null
                },
                resolution: {
                    value: new Ke
                },
                radius: {
                    value: 4
                }
            },
            vertexShader: yS,
            fragmentShader: bS
        }), f = d.clone();
        f.defines.HORIZONTAL_PASS = 1;
        const _ = new On;
        _.setAttribute("position", new qt(new Float32Array([
            -1,
            -1,
            .5,
            3,
            -1,
            .5,
            -1,
            3,
            .5
        ]), 3));
        const g = new kt(_, d), p = this;
        this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = bf;
        let m = this.type;
        this.render = function(w, R, N) {
            if (p.enabled === !1 || p.autoUpdate === !1 && p.needsUpdate === !1 || w.length === 0) return;
            const E = i.getRenderTarget(), S = i.getActiveCubeFace(), D = i.getActiveMipmapLevel(), j = i.state;
            j.setBlending(pi), j.buffers.color.setClear(1, 1, 1, 1), j.buffers.depth.setTest(!0), j.setScissorTest(!1);
            const z = m !== jn && this.type === jn, K = m === jn && this.type !== jn;
            for(let ne = 0, b = w.length; ne < b; ne++){
                const C = w[ne], A = C.shadow;
                if (A === void 0) {
                    console.warn("THREE.WebGLShadowMap:", C, "has no shadow.");
                    continue;
                }
                if (A.autoUpdate === !1 && A.needsUpdate === !1) continue;
                s.copy(A.mapSize);
                const U = A.getFrameExtents();
                if (s.multiply(U), r.copy(A.mapSize), (s.x > h || s.y > h) && (s.x > h && (r.x = Math.floor(h / U.x), s.x = r.x * U.x, A.mapSize.x = r.x), s.y > h && (r.y = Math.floor(h / U.y), s.y = r.y * U.y, A.mapSize.y = r.y)), A.map === null || z === !0 || K === !0) {
                    const V = this.type !== jn ? {
                        minFilter: Yt,
                        magFilter: Yt
                    } : {};
                    A.map !== null && A.map.dispose(), A.map = new Vi(s.x, s.y, V), A.map.texture.name = C.name + ".shadowMap", A.camera.updateProjectionMatrix();
                }
                i.setRenderTarget(A.map), i.clear();
                const B = A.getViewportCount();
                for(let V = 0; V < B; V++){
                    const q = A.getViewport(V);
                    a.set(r.x * q.x, r.y * q.y, r.x * q.z, r.y * q.w), j.viewport(a), A.updateMatrices(C, V), n = A.getFrustum(), x(R, N, A.camera, C, this.type);
                }
                A.isPointLightShadow !== !0 && this.type === jn && v(A, N), A.needsUpdate = !1;
            }
            m = this.type, p.needsUpdate = !1, i.setRenderTarget(E, S, D);
        };
        function v(w, R) {
            const N = e.update(g);
            d.defines.VSM_SAMPLES !== w.blurSamples && (d.defines.VSM_SAMPLES = w.blurSamples, f.defines.VSM_SAMPLES = w.blurSamples, d.needsUpdate = !0, f.needsUpdate = !0), w.mapPass === null && (w.mapPass = new Vi(s.x, s.y)), d.uniforms.shadow_pass.value = w.map.texture, d.uniforms.resolution.value = w.mapSize, d.uniforms.radius.value = w.radius, i.setRenderTarget(w.mapPass), i.clear(), i.renderBufferDirect(R, null, N, d, g, null), f.uniforms.shadow_pass.value = w.mapPass.texture, f.uniforms.resolution.value = w.mapSize, f.uniforms.radius.value = w.radius, i.setRenderTarget(w.map), i.clear(), i.renderBufferDirect(R, null, N, f, g, null);
        }
        function y(w, R, N, E) {
            let S = null;
            const D = N.isPointLight === !0 ? w.customDistanceMaterial : w.customDepthMaterial;
            if (D !== void 0) S = D;
            else if (S = N.isPointLight === !0 ? c : o, i.localClippingEnabled && R.clipShadows === !0 && Array.isArray(R.clippingPlanes) && R.clippingPlanes.length !== 0 || R.displacementMap && R.displacementScale !== 0 || R.alphaMap && R.alphaTest > 0 || R.map && R.alphaTest > 0) {
                const j = S.uuid, z = R.uuid;
                let K = l[j];
                K === void 0 && (K = {}, l[j] = K);
                let ne = K[z];
                ne === void 0 && (ne = S.clone(), K[z] = ne, R.addEventListener("dispose", I)), S = ne;
            }
            if (S.visible = R.visible, S.wireframe = R.wireframe, E === jn ? S.side = R.shadowSide !== null ? R.shadowSide : R.side : S.side = R.shadowSide !== null ? R.shadowSide : u[R.side], S.alphaMap = R.alphaMap, S.alphaTest = R.alphaTest, S.map = R.map, S.clipShadows = R.clipShadows, S.clippingPlanes = R.clippingPlanes, S.clipIntersection = R.clipIntersection, S.displacementMap = R.displacementMap, S.displacementScale = R.displacementScale, S.displacementBias = R.displacementBias, S.wireframeLinewidth = R.wireframeLinewidth, S.linewidth = R.linewidth, N.isPointLight === !0 && S.isMeshDistanceMaterial === !0) {
                const j = i.properties.get(S);
                j.light = N;
            }
            return S;
        }
        function x(w, R, N, E, S) {
            if (w.visible === !1) return;
            if (w.layers.test(R.layers) && (w.isMesh || w.isLine || w.isPoints) && (w.castShadow || w.receiveShadow && S === jn) && (!w.frustumCulled || n.intersectsObject(w))) {
                w.modelViewMatrix.multiplyMatrices(N.matrixWorldInverse, w.matrixWorld);
                const z = e.update(w), K = w.material;
                if (Array.isArray(K)) {
                    const ne = z.groups;
                    for(let b = 0, C = ne.length; b < C; b++){
                        const A = ne[b], U = K[A.materialIndex];
                        if (U && U.visible) {
                            const B = y(w, U, E, S);
                            w.onBeforeShadow(i, w, R, N, z, B, A), i.renderBufferDirect(N, null, z, B, w, A), w.onAfterShadow(i, w, R, N, z, B, A);
                        }
                    }
                } else if (K.visible) {
                    const ne = y(w, K, E, S);
                    w.onBeforeShadow(i, w, R, N, z, ne, null), i.renderBufferDirect(N, null, z, ne, w, null), w.onAfterShadow(i, w, R, N, z, ne, null);
                }
            }
            const j = w.children;
            for(let z = 0, K = j.length; z < K; z++)x(j[z], R, N, E, S);
        }
        function I(w) {
            w.target.removeEventListener("dispose", I);
            for(const N in l){
                const E = l[N], S = w.target.uuid;
                S in E && (E[S].dispose(), delete E[S]);
            }
        }
    }
    const MS = {
        [Ec]: Ac,
        [wc]: Pc,
        [Rc]: Ic,
        [ws]: Cc,
        [Ac]: Ec,
        [Pc]: wc,
        [Ic]: Rc,
        [Cc]: ws
    };
    function TS(i, e) {
        function t() {
            let F = !1;
            const pe = new nt;
            let Z = null;
            const ee = new nt(0, 0, 0, 0);
            return {
                setMask: function(_e) {
                    Z !== _e && !F && (i.colorMask(_e, _e, _e, _e), Z = _e);
                },
                setLocked: function(_e) {
                    F = _e;
                },
                setClear: function(_e, me, ke, xt, Bt) {
                    Bt === !0 && (_e *= xt, me *= xt, ke *= xt), pe.set(_e, me, ke, xt), ee.equals(pe) === !1 && (i.clearColor(_e, me, ke, xt), ee.copy(pe));
                },
                reset: function() {
                    F = !1, Z = null, ee.set(-1, 0, 0, 0);
                }
            };
        }
        function n() {
            let F = !1, pe = !1, Z = null, ee = null, _e = null;
            return {
                setReversed: function(me) {
                    if (pe !== me) {
                        const ke = e.get("EXT_clip_control");
                        me ? ke.clipControlEXT(ke.LOWER_LEFT_EXT, ke.ZERO_TO_ONE_EXT) : ke.clipControlEXT(ke.LOWER_LEFT_EXT, ke.NEGATIVE_ONE_TO_ONE_EXT), pe = me;
                        const xt = _e;
                        _e = null, this.setClear(xt);
                    }
                },
                getReversed: function() {
                    return pe;
                },
                setTest: function(me) {
                    me ? ie(i.DEPTH_TEST) : le(i.DEPTH_TEST);
                },
                setMask: function(me) {
                    Z !== me && !F && (i.depthMask(me), Z = me);
                },
                setFunc: function(me) {
                    if (pe && (me = MS[me]), ee !== me) {
                        switch(me){
                            case Ec:
                                i.depthFunc(i.NEVER);
                                break;
                            case Ac:
                                i.depthFunc(i.ALWAYS);
                                break;
                            case wc:
                                i.depthFunc(i.LESS);
                                break;
                            case ws:
                                i.depthFunc(i.LEQUAL);
                                break;
                            case Rc:
                                i.depthFunc(i.EQUAL);
                                break;
                            case Cc:
                                i.depthFunc(i.GEQUAL);
                                break;
                            case Pc:
                                i.depthFunc(i.GREATER);
                                break;
                            case Ic:
                                i.depthFunc(i.NOTEQUAL);
                                break;
                            default:
                                i.depthFunc(i.LEQUAL);
                        }
                        ee = me;
                    }
                },
                setLocked: function(me) {
                    F = me;
                },
                setClear: function(me) {
                    _e !== me && (pe && (me = 1 - me), i.clearDepth(me), _e = me);
                },
                reset: function() {
                    F = !1, Z = null, ee = null, _e = null, pe = !1;
                }
            };
        }
        function s() {
            let F = !1, pe = null, Z = null, ee = null, _e = null, me = null, ke = null, xt = null, Bt = null;
            return {
                setTest: function(at) {
                    F || (at ? ie(i.STENCIL_TEST) : le(i.STENCIL_TEST));
                },
                setMask: function(at) {
                    pe !== at && !F && (i.stencilMask(at), pe = at);
                },
                setFunc: function(at, pn, Gn) {
                    (Z !== at || ee !== pn || _e !== Gn) && (i.stencilFunc(at, pn, Gn), Z = at, ee = pn, _e = Gn);
                },
                setOp: function(at, pn, Gn) {
                    (me !== at || ke !== pn || xt !== Gn) && (i.stencilOp(at, pn, Gn), me = at, ke = pn, xt = Gn);
                },
                setLocked: function(at) {
                    F = at;
                },
                setClear: function(at) {
                    Bt !== at && (i.clearStencil(at), Bt = at);
                },
                reset: function() {
                    F = !1, pe = null, Z = null, ee = null, _e = null, me = null, ke = null, xt = null, Bt = null;
                }
            };
        }
        const r = new t, a = new n, o = new s, c = new WeakMap, l = new WeakMap;
        let h = {}, u = {}, d = new WeakMap, f = [], _ = null, g = !1, p = null, m = null, v = null, y = null, x = null, I = null, w = null, R = new Be(0, 0, 0), N = 0, E = !1, S = null, D = null, j = null, z = null, K = null;
        const ne = i.getParameter(i.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        let b = !1, C = 0;
        const A = i.getParameter(i.VERSION);
        A.indexOf("WebGL") !== -1 ? (C = parseFloat(/^WebGL (\d)/.exec(A)[1]), b = C >= 1) : A.indexOf("OpenGL ES") !== -1 && (C = parseFloat(/^OpenGL ES (\d)/.exec(A)[1]), b = C >= 2);
        let U = null, B = {};
        const V = i.getParameter(i.SCISSOR_BOX), q = i.getParameter(i.VIEWPORT), te = new nt().fromArray(V), H = new nt().fromArray(q);
        function $(F, pe, Z, ee) {
            const _e = new Uint8Array(4), me = i.createTexture();
            i.bindTexture(F, me), i.texParameteri(F, i.TEXTURE_MIN_FILTER, i.NEAREST), i.texParameteri(F, i.TEXTURE_MAG_FILTER, i.NEAREST);
            for(let ke = 0; ke < Z; ke++)F === i.TEXTURE_3D || F === i.TEXTURE_2D_ARRAY ? i.texImage3D(pe, 0, i.RGBA, 1, 1, ee, 0, i.RGBA, i.UNSIGNED_BYTE, _e) : i.texImage2D(pe + ke, 0, i.RGBA, 1, 1, 0, i.RGBA, i.UNSIGNED_BYTE, _e);
            return me;
        }
        const oe = {};
        oe[i.TEXTURE_2D] = $(i.TEXTURE_2D, i.TEXTURE_2D, 1), oe[i.TEXTURE_CUBE_MAP] = $(i.TEXTURE_CUBE_MAP, i.TEXTURE_CUBE_MAP_POSITIVE_X, 6), oe[i.TEXTURE_2D_ARRAY] = $(i.TEXTURE_2D_ARRAY, i.TEXTURE_2D_ARRAY, 1, 1), oe[i.TEXTURE_3D] = $(i.TEXTURE_3D, i.TEXTURE_3D, 1, 1), r.setClear(0, 0, 0, 1), a.setClear(1), o.setClear(0), ie(i.DEPTH_TEST), a.setFunc(ws), ge(!1), Xe(zh), ie(i.CULL_FACE), L(pi);
        function ie(F) {
            h[F] !== !0 && (i.enable(F), h[F] = !0);
        }
        function le(F) {
            h[F] !== !1 && (i.disable(F), h[F] = !1);
        }
        function we(F, pe) {
            return u[F] !== pe ? (i.bindFramebuffer(F, pe), u[F] = pe, F === i.DRAW_FRAMEBUFFER && (u[i.FRAMEBUFFER] = pe), F === i.FRAMEBUFFER && (u[i.DRAW_FRAMEBUFFER] = pe), !0) : !1;
        }
        function he(F, pe) {
            let Z = f, ee = !1;
            if (F) {
                Z = d.get(pe), Z === void 0 && (Z = [], d.set(pe, Z));
                const _e = F.textures;
                if (Z.length !== _e.length || Z[0] !== i.COLOR_ATTACHMENT0) {
                    for(let me = 0, ke = _e.length; me < ke; me++)Z[me] = i.COLOR_ATTACHMENT0 + me;
                    Z.length = _e.length, ee = !0;
                }
            } else Z[0] !== i.BACK && (Z[0] = i.BACK, ee = !0);
            ee && i.drawBuffers(Z);
        }
        function tt(F) {
            return _ !== F ? (i.useProgram(F), _ = F, !0) : !1;
        }
        const We = {
            [Ni]: i.FUNC_ADD,
            [R_]: i.FUNC_SUBTRACT,
            [C_]: i.FUNC_REVERSE_SUBTRACT
        };
        We[P_] = i.MIN, We[I_] = i.MAX;
        const Le = {
            [D_]: i.ZERO,
            [L_]: i.ONE,
            [U_]: i.SRC_COLOR,
            [Mc]: i.SRC_ALPHA,
            [G_]: i.SRC_ALPHA_SATURATE,
            [O_]: i.DST_COLOR,
            [B_]: i.DST_ALPHA,
            [N_]: i.ONE_MINUS_SRC_COLOR,
            [Tc]: i.ONE_MINUS_SRC_ALPHA,
            [k_]: i.ONE_MINUS_DST_COLOR,
            [F_]: i.ONE_MINUS_DST_ALPHA,
            [H_]: i.CONSTANT_COLOR,
            [z_]: i.ONE_MINUS_CONSTANT_COLOR,
            [V_]: i.CONSTANT_ALPHA,
            [W_]: i.ONE_MINUS_CONSTANT_ALPHA
        };
        function L(F, pe, Z, ee, _e, me, ke, xt, Bt, at) {
            if (F === pi) {
                g === !0 && (le(i.BLEND), g = !1);
                return;
            }
            if (g === !1 && (ie(i.BLEND), g = !0), F !== w_) {
                if (F !== p || at !== E) {
                    if ((m !== Ni || x !== Ni) && (i.blendEquation(i.FUNC_ADD), m = Ni, x = Ni), at) switch(F){
                        case Ms:
                            i.blendFuncSeparate(i.ONE, i.ONE_MINUS_SRC_ALPHA, i.ONE, i.ONE_MINUS_SRC_ALPHA);
                            break;
                        case Vh:
                            i.blendFunc(i.ONE, i.ONE);
                            break;
                        case Wh:
                            i.blendFuncSeparate(i.ZERO, i.ONE_MINUS_SRC_COLOR, i.ZERO, i.ONE);
                            break;
                        case Xh:
                            i.blendFuncSeparate(i.ZERO, i.SRC_COLOR, i.ZERO, i.SRC_ALPHA);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", F);
                            break;
                    }
                    else switch(F){
                        case Ms:
                            i.blendFuncSeparate(i.SRC_ALPHA, i.ONE_MINUS_SRC_ALPHA, i.ONE, i.ONE_MINUS_SRC_ALPHA);
                            break;
                        case Vh:
                            i.blendFunc(i.SRC_ALPHA, i.ONE);
                            break;
                        case Wh:
                            i.blendFuncSeparate(i.ZERO, i.ONE_MINUS_SRC_COLOR, i.ZERO, i.ONE);
                            break;
                        case Xh:
                            i.blendFunc(i.ZERO, i.SRC_COLOR);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", F);
                            break;
                    }
                    v = null, y = null, I = null, w = null, R.set(0, 0, 0), N = 0, p = F, E = at;
                }
                return;
            }
            _e = _e || pe, me = me || Z, ke = ke || ee, (pe !== m || _e !== x) && (i.blendEquationSeparate(We[pe], We[_e]), m = pe, x = _e), (Z !== v || ee !== y || me !== I || ke !== w) && (i.blendFuncSeparate(Le[Z], Le[ee], Le[me], Le[ke]), v = Z, y = ee, I = me, w = ke), (xt.equals(R) === !1 || Bt !== N) && (i.blendColor(xt.r, xt.g, xt.b, Bt), R.copy(xt), N = Bt), p = F, E = !1;
        }
        function Ce(F, pe) {
            F.side === Un ? le(i.CULL_FACE) : ie(i.CULL_FACE);
            let Z = F.side === Jt;
            pe && (Z = !Z), ge(Z), F.blending === Ms && F.transparent === !1 ? L(pi) : L(F.blending, F.blendEquation, F.blendSrc, F.blendDst, F.blendEquationAlpha, F.blendSrcAlpha, F.blendDstAlpha, F.blendColor, F.blendAlpha, F.premultipliedAlpha), a.setFunc(F.depthFunc), a.setTest(F.depthTest), a.setMask(F.depthWrite), r.setMask(F.colorWrite);
            const ee = F.stencilWrite;
            o.setTest(ee), ee && (o.setMask(F.stencilWriteMask), o.setFunc(F.stencilFunc, F.stencilRef, F.stencilFuncMask), o.setOp(F.stencilFail, F.stencilZFail, F.stencilZPass)), lt(F.polygonOffset, F.polygonOffsetFactor, F.polygonOffsetUnits), F.alphaToCoverage === !0 ? ie(i.SAMPLE_ALPHA_TO_COVERAGE) : le(i.SAMPLE_ALPHA_TO_COVERAGE);
        }
        function ge(F) {
            S !== F && (F ? i.frontFace(i.CW) : i.frontFace(i.CCW), S = F);
        }
        function Xe(F) {
            F !== T_ ? (ie(i.CULL_FACE), F !== D && (F === zh ? i.cullFace(i.BACK) : F === E_ ? i.cullFace(i.FRONT) : i.cullFace(i.FRONT_AND_BACK))) : le(i.CULL_FACE), D = F;
        }
        function Ee(F) {
            F !== j && (b && i.lineWidth(F), j = F);
        }
        function lt(F, pe, Z) {
            F ? (ie(i.POLYGON_OFFSET_FILL), (z !== pe || K !== Z) && (i.polygonOffset(pe, Z), z = pe, K = Z)) : le(i.POLYGON_OFFSET_FILL);
        }
        function Ae(F) {
            F ? ie(i.SCISSOR_TEST) : le(i.SCISSOR_TEST);
        }
        function P(F) {
            F === void 0 && (F = i.TEXTURE0 + ne - 1), U !== F && (i.activeTexture(F), U = F);
        }
        function M(F, pe, Z) {
            Z === void 0 && (U === null ? Z = i.TEXTURE0 + ne - 1 : Z = U);
            let ee = B[Z];
            ee === void 0 && (ee = {
                type: void 0,
                texture: void 0
            }, B[Z] = ee), (ee.type !== F || ee.texture !== pe) && (U !== Z && (i.activeTexture(Z), U = Z), i.bindTexture(F, pe || oe[F]), ee.type = F, ee.texture = pe);
        }
        function W() {
            const F = B[U];
            F !== void 0 && F.type !== void 0 && (i.bindTexture(F.type, null), F.type = void 0, F.texture = void 0);
        }
        function Q() {
            try {
                i.compressedTexImage2D(...arguments);
            } catch (F) {
                console.error("THREE.WebGLState:", F);
            }
        }
        function re() {
            try {
                i.compressedTexImage3D(...arguments);
            } catch (F) {
                console.error("THREE.WebGLState:", F);
            }
        }
        function J() {
            try {
                i.texSubImage2D(...arguments);
            } catch (F) {
                console.error("THREE.WebGLState:", F);
            }
        }
        function Te() {
            try {
                i.texSubImage3D(...arguments);
            } catch (F) {
                console.error("THREE.WebGLState:", F);
            }
        }
        function fe() {
            try {
                i.compressedTexSubImage2D(...arguments);
            } catch (F) {
                console.error("THREE.WebGLState:", F);
            }
        }
        function ve() {
            try {
                i.compressedTexSubImage3D(...arguments);
            } catch (F) {
                console.error("THREE.WebGLState:", F);
            }
        }
        function Ze() {
            try {
                i.texStorage2D(...arguments);
            } catch (F) {
                console.error("THREE.WebGLState:", F);
            }
        }
        function ce() {
            try {
                i.texStorage3D(...arguments);
            } catch (F) {
                console.error("THREE.WebGLState:", F);
            }
        }
        function ye() {
            try {
                i.texImage2D(...arguments);
            } catch (F) {
                console.error("THREE.WebGLState:", F);
            }
        }
        function Ie() {
            try {
                i.texImage3D(...arguments);
            } catch (F) {
                console.error("THREE.WebGLState:", F);
            }
        }
        function Ue(F) {
            te.equals(F) === !1 && (i.scissor(F.x, F.y, F.z, F.w), te.copy(F));
        }
        function be(F) {
            H.equals(F) === !1 && (i.viewport(F.x, F.y, F.z, F.w), H.copy(F));
        }
        function je(F, pe) {
            let Z = l.get(pe);
            Z === void 0 && (Z = new WeakMap, l.set(pe, Z));
            let ee = Z.get(F);
            ee === void 0 && (ee = i.getUniformBlockIndex(pe, F.name), Z.set(F, ee));
        }
        function ze(F, pe) {
            const ee = l.get(pe).get(F);
            c.get(pe) !== ee && (i.uniformBlockBinding(pe, ee, F.__bindingPointIndex), c.set(pe, ee));
        }
        function ht() {
            i.disable(i.BLEND), i.disable(i.CULL_FACE), i.disable(i.DEPTH_TEST), i.disable(i.POLYGON_OFFSET_FILL), i.disable(i.SCISSOR_TEST), i.disable(i.STENCIL_TEST), i.disable(i.SAMPLE_ALPHA_TO_COVERAGE), i.blendEquation(i.FUNC_ADD), i.blendFunc(i.ONE, i.ZERO), i.blendFuncSeparate(i.ONE, i.ZERO, i.ONE, i.ZERO), i.blendColor(0, 0, 0, 0), i.colorMask(!0, !0, !0, !0), i.clearColor(0, 0, 0, 0), i.depthMask(!0), i.depthFunc(i.LESS), a.setReversed(!1), i.clearDepth(1), i.stencilMask(4294967295), i.stencilFunc(i.ALWAYS, 0, 4294967295), i.stencilOp(i.KEEP, i.KEEP, i.KEEP), i.clearStencil(0), i.cullFace(i.BACK), i.frontFace(i.CCW), i.polygonOffset(0, 0), i.activeTexture(i.TEXTURE0), i.bindFramebuffer(i.FRAMEBUFFER, null), i.bindFramebuffer(i.DRAW_FRAMEBUFFER, null), i.bindFramebuffer(i.READ_FRAMEBUFFER, null), i.useProgram(null), i.lineWidth(1), i.scissor(0, 0, i.canvas.width, i.canvas.height), i.viewport(0, 0, i.canvas.width, i.canvas.height), h = {}, U = null, B = {}, u = {}, d = new WeakMap, f = [], _ = null, g = !1, p = null, m = null, v = null, y = null, x = null, I = null, w = null, R = new Be(0, 0, 0), N = 0, E = !1, S = null, D = null, j = null, z = null, K = null, te.set(0, 0, i.canvas.width, i.canvas.height), H.set(0, 0, i.canvas.width, i.canvas.height), r.reset(), a.reset(), o.reset();
        }
        return {
            buffers: {
                color: r,
                depth: a,
                stencil: o
            },
            enable: ie,
            disable: le,
            bindFramebuffer: we,
            drawBuffers: he,
            useProgram: tt,
            setBlending: L,
            setMaterial: Ce,
            setFlipSided: ge,
            setCullFace: Xe,
            setLineWidth: Ee,
            setPolygonOffset: lt,
            setScissorTest: Ae,
            activeTexture: P,
            bindTexture: M,
            unbindTexture: W,
            compressedTexImage2D: Q,
            compressedTexImage3D: re,
            texImage2D: ye,
            texImage3D: Ie,
            updateUBOMapping: je,
            uniformBlockBinding: ze,
            texStorage2D: Ze,
            texStorage3D: ce,
            texSubImage2D: J,
            texSubImage3D: Te,
            compressedTexSubImage2D: fe,
            compressedTexSubImage3D: ve,
            scissor: Ue,
            viewport: be,
            reset: ht
        };
    }
    function ES(i, e, t, n, s, r, a) {
        const o = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, c = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), l = new Ke, h = new WeakMap;
        let u;
        const d = new WeakMap;
        let f = !1;
        try {
            f = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
        } catch  {}
        function _(P, M) {
            return f ? new OffscreenCanvas(P, M) : wr("canvas");
        }
        function g(P, M, W) {
            let Q = 1;
            const re = Ae(P);
            if ((re.width > W || re.height > W) && (Q = W / Math.max(re.width, re.height)), Q < 1) if (typeof HTMLImageElement < "u" && P instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && P instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && P instanceof ImageBitmap || typeof VideoFrame < "u" && P instanceof VideoFrame) {
                const J = Math.floor(Q * re.width), Te = Math.floor(Q * re.height);
                u === void 0 && (u = _(J, Te));
                const fe = M ? _(J, Te) : u;
                return fe.width = J, fe.height = Te, fe.getContext("2d").drawImage(P, 0, 0, J, Te), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + re.width + "x" + re.height + ") to (" + J + "x" + Te + ")."), fe;
            } else return "data" in P && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + re.width + "x" + re.height + ")."), P;
            return P;
        }
        function p(P) {
            return P.generateMipmaps;
        }
        function m(P) {
            i.generateMipmap(P);
        }
        function v(P) {
            return P.isWebGLCubeRenderTarget ? i.TEXTURE_CUBE_MAP : P.isWebGL3DRenderTarget ? i.TEXTURE_3D : P.isWebGLArrayRenderTarget || P.isCompressedArrayTexture ? i.TEXTURE_2D_ARRAY : i.TEXTURE_2D;
        }
        function y(P, M, W, Q, re = !1) {
            if (P !== null) {
                if (i[P] !== void 0) return i[P];
                console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + P + "'");
            }
            let J = M;
            if (M === i.RED && (W === i.FLOAT && (J = i.R32F), W === i.HALF_FLOAT && (J = i.R16F), W === i.UNSIGNED_BYTE && (J = i.R8)), M === i.RED_INTEGER && (W === i.UNSIGNED_BYTE && (J = i.R8UI), W === i.UNSIGNED_SHORT && (J = i.R16UI), W === i.UNSIGNED_INT && (J = i.R32UI), W === i.BYTE && (J = i.R8I), W === i.SHORT && (J = i.R16I), W === i.INT && (J = i.R32I)), M === i.RG && (W === i.FLOAT && (J = i.RG32F), W === i.HALF_FLOAT && (J = i.RG16F), W === i.UNSIGNED_BYTE && (J = i.RG8)), M === i.RG_INTEGER && (W === i.UNSIGNED_BYTE && (J = i.RG8UI), W === i.UNSIGNED_SHORT && (J = i.RG16UI), W === i.UNSIGNED_INT && (J = i.RG32UI), W === i.BYTE && (J = i.RG8I), W === i.SHORT && (J = i.RG16I), W === i.INT && (J = i.RG32I)), M === i.RGB_INTEGER && (W === i.UNSIGNED_BYTE && (J = i.RGB8UI), W === i.UNSIGNED_SHORT && (J = i.RGB16UI), W === i.UNSIGNED_INT && (J = i.RGB32UI), W === i.BYTE && (J = i.RGB8I), W === i.SHORT && (J = i.RGB16I), W === i.INT && (J = i.RGB32I)), M === i.RGBA_INTEGER && (W === i.UNSIGNED_BYTE && (J = i.RGBA8UI), W === i.UNSIGNED_SHORT && (J = i.RGBA16UI), W === i.UNSIGNED_INT && (J = i.RGBA32UI), W === i.BYTE && (J = i.RGBA8I), W === i.SHORT && (J = i.RGBA16I), W === i.INT && (J = i.RGBA32I)), M === i.RGB && W === i.UNSIGNED_INT_5_9_9_9_REV && (J = i.RGB9_E5), M === i.RGBA) {
                const Te = re ? ka : $e.getTransfer(Q);
                W === i.FLOAT && (J = i.RGBA32F), W === i.HALF_FLOAT && (J = i.RGBA16F), W === i.UNSIGNED_BYTE && (J = Te === ct ? i.SRGB8_ALPHA8 : i.RGBA8), W === i.UNSIGNED_SHORT_4_4_4_4 && (J = i.RGBA4), W === i.UNSIGNED_SHORT_5_5_5_1 && (J = i.RGB5_A1);
            }
            return (J === i.R16F || J === i.R32F || J === i.RG16F || J === i.RG32F || J === i.RGBA16F || J === i.RGBA32F) && e.get("EXT_color_buffer_float"), J;
        }
        function x(P, M) {
            let W;
            return P ? M === null || M === zi || M === Sr ? W = i.DEPTH24_STENCIL8 : M === Mn ? W = i.DEPTH32F_STENCIL8 : M === br && (W = i.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : M === null || M === zi || M === Sr ? W = i.DEPTH_COMPONENT24 : M === Mn ? W = i.DEPTH_COMPONENT32F : M === br && (W = i.DEPTH_COMPONENT16), W;
        }
        function I(P, M) {
            return p(P) === !0 || P.isFramebufferTexture && P.minFilter !== Yt && P.minFilter !== an ? Math.log2(Math.max(M.width, M.height)) + 1 : P.mipmaps !== void 0 && P.mipmaps.length > 0 ? P.mipmaps.length : P.isCompressedTexture && Array.isArray(P.image) ? M.mipmaps.length : 1;
        }
        function w(P) {
            const M = P.target;
            M.removeEventListener("dispose", w), N(M), M.isVideoTexture && h.delete(M);
        }
        function R(P) {
            const M = P.target;
            M.removeEventListener("dispose", R), S(M);
        }
        function N(P) {
            const M = n.get(P);
            if (M.__webglInit === void 0) return;
            const W = P.source, Q = d.get(W);
            if (Q) {
                const re = Q[M.__cacheKey];
                re.usedTimes--, re.usedTimes === 0 && E(P), Object.keys(Q).length === 0 && d.delete(W);
            }
            n.remove(P);
        }
        function E(P) {
            const M = n.get(P);
            i.deleteTexture(M.__webglTexture);
            const W = P.source, Q = d.get(W);
            delete Q[M.__cacheKey], a.memory.textures--;
        }
        function S(P) {
            const M = n.get(P);
            if (P.depthTexture && (P.depthTexture.dispose(), n.remove(P.depthTexture)), P.isWebGLCubeRenderTarget) for(let Q = 0; Q < 6; Q++){
                if (Array.isArray(M.__webglFramebuffer[Q])) for(let re = 0; re < M.__webglFramebuffer[Q].length; re++)i.deleteFramebuffer(M.__webglFramebuffer[Q][re]);
                else i.deleteFramebuffer(M.__webglFramebuffer[Q]);
                M.__webglDepthbuffer && i.deleteRenderbuffer(M.__webglDepthbuffer[Q]);
            }
            else {
                if (Array.isArray(M.__webglFramebuffer)) for(let Q = 0; Q < M.__webglFramebuffer.length; Q++)i.deleteFramebuffer(M.__webglFramebuffer[Q]);
                else i.deleteFramebuffer(M.__webglFramebuffer);
                if (M.__webglDepthbuffer && i.deleteRenderbuffer(M.__webglDepthbuffer), M.__webglMultisampledFramebuffer && i.deleteFramebuffer(M.__webglMultisampledFramebuffer), M.__webglColorRenderbuffer) for(let Q = 0; Q < M.__webglColorRenderbuffer.length; Q++)M.__webglColorRenderbuffer[Q] && i.deleteRenderbuffer(M.__webglColorRenderbuffer[Q]);
                M.__webglDepthRenderbuffer && i.deleteRenderbuffer(M.__webglDepthRenderbuffer);
            }
            const W = P.textures;
            for(let Q = 0, re = W.length; Q < re; Q++){
                const J = n.get(W[Q]);
                J.__webglTexture && (i.deleteTexture(J.__webglTexture), a.memory.textures--), n.remove(W[Q]);
            }
            n.remove(P);
        }
        let D = 0;
        function j() {
            D = 0;
        }
        function z() {
            const P = D;
            return P >= s.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + P + " texture units while this GPU supports only " + s.maxTextures), D += 1, P;
        }
        function K(P) {
            const M = [];
            return M.push(P.wrapS), M.push(P.wrapT), M.push(P.wrapR || 0), M.push(P.magFilter), M.push(P.minFilter), M.push(P.anisotropy), M.push(P.internalFormat), M.push(P.format), M.push(P.type), M.push(P.generateMipmaps), M.push(P.premultiplyAlpha), M.push(P.flipY), M.push(P.unpackAlignment), M.push(P.colorSpace), M.join();
        }
        function ne(P, M) {
            const W = n.get(P);
            if (P.isVideoTexture && Ee(P), P.isRenderTargetTexture === !1 && P.version > 0 && W.__version !== P.version) {
                const Q = P.image;
                if (Q === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
                else if (Q.complete === !1) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
                else {
                    H(W, P, M);
                    return;
                }
            }
            t.bindTexture(i.TEXTURE_2D, W.__webglTexture, i.TEXTURE0 + M);
        }
        function b(P, M) {
            const W = n.get(P);
            if (P.version > 0 && W.__version !== P.version) {
                H(W, P, M);
                return;
            }
            t.bindTexture(i.TEXTURE_2D_ARRAY, W.__webglTexture, i.TEXTURE0 + M);
        }
        function C(P, M) {
            const W = n.get(P);
            if (P.version > 0 && W.__version !== P.version) {
                H(W, P, M);
                return;
            }
            t.bindTexture(i.TEXTURE_3D, W.__webglTexture, i.TEXTURE0 + M);
        }
        function A(P, M) {
            const W = n.get(P);
            if (P.version > 0 && W.__version !== P.version) {
                $(W, P, M);
                return;
            }
            t.bindTexture(i.TEXTURE_CUBE_MAP, W.__webglTexture, i.TEXTURE0 + M);
        }
        const U = {
            [Ps]: i.REPEAT,
            [ui]: i.CLAMP_TO_EDGE,
            [Fa]: i.MIRRORED_REPEAT
        }, B = {
            [Yt]: i.NEAREST,
            [Tf]: i.NEAREST_MIPMAP_NEAREST,
            [ar]: i.NEAREST_MIPMAP_LINEAR,
            [an]: i.LINEAR,
            [Ta]: i.LINEAR_MIPMAP_NEAREST,
            [Kn]: i.LINEAR_MIPMAP_LINEAR
        }, V = {
            [og]: i.NEVER,
            [fg]: i.ALWAYS,
            [cg]: i.LESS,
            [Bf]: i.LEQUAL,
            [lg]: i.EQUAL,
            [dg]: i.GEQUAL,
            [hg]: i.GREATER,
            [ug]: i.NOTEQUAL
        };
        function q(P, M) {
            if (M.type === Mn && e.has("OES_texture_float_linear") === !1 && (M.magFilter === an || M.magFilter === Ta || M.magFilter === ar || M.magFilter === Kn || M.minFilter === an || M.minFilter === Ta || M.minFilter === ar || M.minFilter === Kn) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), i.texParameteri(P, i.TEXTURE_WRAP_S, U[M.wrapS]), i.texParameteri(P, i.TEXTURE_WRAP_T, U[M.wrapT]), (P === i.TEXTURE_3D || P === i.TEXTURE_2D_ARRAY) && i.texParameteri(P, i.TEXTURE_WRAP_R, U[M.wrapR]), i.texParameteri(P, i.TEXTURE_MAG_FILTER, B[M.magFilter]), i.texParameteri(P, i.TEXTURE_MIN_FILTER, B[M.minFilter]), M.compareFunction && (i.texParameteri(P, i.TEXTURE_COMPARE_MODE, i.COMPARE_REF_TO_TEXTURE), i.texParameteri(P, i.TEXTURE_COMPARE_FUNC, V[M.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
                if (M.magFilter === Yt || M.minFilter !== ar && M.minFilter !== Kn || M.type === Mn && e.has("OES_texture_float_linear") === !1) return;
                if (M.anisotropy > 1 || n.get(M).__currentAnisotropy) {
                    const W = e.get("EXT_texture_filter_anisotropic");
                    i.texParameterf(P, W.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(M.anisotropy, s.getMaxAnisotropy())), n.get(M).__currentAnisotropy = M.anisotropy;
                }
            }
        }
        function te(P, M) {
            let W = !1;
            P.__webglInit === void 0 && (P.__webglInit = !0, M.addEventListener("dispose", w));
            const Q = M.source;
            let re = d.get(Q);
            re === void 0 && (re = {}, d.set(Q, re));
            const J = K(M);
            if (J !== P.__cacheKey) {
                re[J] === void 0 && (re[J] = {
                    texture: i.createTexture(),
                    usedTimes: 0
                }, a.memory.textures++, W = !0), re[J].usedTimes++;
                const Te = re[P.__cacheKey];
                Te !== void 0 && (re[P.__cacheKey].usedTimes--, Te.usedTimes === 0 && E(M)), P.__cacheKey = J, P.__webglTexture = re[J].texture;
            }
            return W;
        }
        function H(P, M, W) {
            let Q = i.TEXTURE_2D;
            (M.isDataArrayTexture || M.isCompressedArrayTexture) && (Q = i.TEXTURE_2D_ARRAY), M.isData3DTexture && (Q = i.TEXTURE_3D);
            const re = te(P, M), J = M.source;
            t.bindTexture(Q, P.__webglTexture, i.TEXTURE0 + W);
            const Te = n.get(J);
            if (J.version !== Te.__version || re === !0) {
                t.activeTexture(i.TEXTURE0 + W);
                const fe = $e.getPrimaries($e.workingColorSpace), ve = M.colorSpace === hi ? null : $e.getPrimaries(M.colorSpace), Ze = M.colorSpace === hi || fe === ve ? i.NONE : i.BROWSER_DEFAULT_WEBGL;
                i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, M.flipY), i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, M.premultiplyAlpha), i.pixelStorei(i.UNPACK_ALIGNMENT, M.unpackAlignment), i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ze);
                let ce = g(M.image, !1, s.maxTextureSize);
                ce = lt(M, ce);
                const ye = r.convert(M.format, M.colorSpace), Ie = r.convert(M.type);
                let Ue = y(M.internalFormat, ye, Ie, M.colorSpace, M.isVideoTexture);
                q(Q, M);
                let be;
                const je = M.mipmaps, ze = M.isVideoTexture !== !0, ht = Te.__version === void 0 || re === !0, F = J.dataReady, pe = I(M, ce);
                if (M.isDepthTexture) Ue = x(M.format === Tr, M.type), ht && (ze ? t.texStorage2D(i.TEXTURE_2D, 1, Ue, ce.width, ce.height) : t.texImage2D(i.TEXTURE_2D, 0, Ue, ce.width, ce.height, 0, ye, Ie, null));
                else if (M.isDataTexture) if (je.length > 0) {
                    ze && ht && t.texStorage2D(i.TEXTURE_2D, pe, Ue, je[0].width, je[0].height);
                    for(let Z = 0, ee = je.length; Z < ee; Z++)be = je[Z], ze ? F && t.texSubImage2D(i.TEXTURE_2D, Z, 0, 0, be.width, be.height, ye, Ie, be.data) : t.texImage2D(i.TEXTURE_2D, Z, Ue, be.width, be.height, 0, ye, Ie, be.data);
                    M.generateMipmaps = !1;
                } else ze ? (ht && t.texStorage2D(i.TEXTURE_2D, pe, Ue, ce.width, ce.height), F && t.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, ce.width, ce.height, ye, Ie, ce.data)) : t.texImage2D(i.TEXTURE_2D, 0, Ue, ce.width, ce.height, 0, ye, Ie, ce.data);
                else if (M.isCompressedTexture) if (M.isCompressedArrayTexture) {
                    ze && ht && t.texStorage3D(i.TEXTURE_2D_ARRAY, pe, Ue, je[0].width, je[0].height, ce.depth);
                    for(let Z = 0, ee = je.length; Z < ee; Z++)if (be = je[Z], M.format !== un) if (ye !== null) if (ze) {
                        if (F) if (M.layerUpdates.size > 0) {
                            const _e = Du(be.width, be.height, M.format, M.type);
                            for (const me of M.layerUpdates){
                                const ke = be.data.subarray(me * _e / be.data.BYTES_PER_ELEMENT, (me + 1) * _e / be.data.BYTES_PER_ELEMENT);
                                t.compressedTexSubImage3D(i.TEXTURE_2D_ARRAY, Z, 0, 0, me, be.width, be.height, 1, ye, ke);
                            }
                            M.clearLayerUpdates();
                        } else t.compressedTexSubImage3D(i.TEXTURE_2D_ARRAY, Z, 0, 0, 0, be.width, be.height, ce.depth, ye, be.data);
                    } else t.compressedTexImage3D(i.TEXTURE_2D_ARRAY, Z, Ue, be.width, be.height, ce.depth, 0, be.data, 0, 0);
                    else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                    else ze ? F && t.texSubImage3D(i.TEXTURE_2D_ARRAY, Z, 0, 0, 0, be.width, be.height, ce.depth, ye, Ie, be.data) : t.texImage3D(i.TEXTURE_2D_ARRAY, Z, Ue, be.width, be.height, ce.depth, 0, ye, Ie, be.data);
                } else {
                    ze && ht && t.texStorage2D(i.TEXTURE_2D, pe, Ue, je[0].width, je[0].height);
                    for(let Z = 0, ee = je.length; Z < ee; Z++)be = je[Z], M.format !== un ? ye !== null ? ze ? F && t.compressedTexSubImage2D(i.TEXTURE_2D, Z, 0, 0, be.width, be.height, ye, be.data) : t.compressedTexImage2D(i.TEXTURE_2D, Z, Ue, be.width, be.height, 0, be.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : ze ? F && t.texSubImage2D(i.TEXTURE_2D, Z, 0, 0, be.width, be.height, ye, Ie, be.data) : t.texImage2D(i.TEXTURE_2D, Z, Ue, be.width, be.height, 0, ye, Ie, be.data);
                }
                else if (M.isDataArrayTexture) if (ze) {
                    if (ht && t.texStorage3D(i.TEXTURE_2D_ARRAY, pe, Ue, ce.width, ce.height, ce.depth), F) if (M.layerUpdates.size > 0) {
                        const Z = Du(ce.width, ce.height, M.format, M.type);
                        for (const ee of M.layerUpdates){
                            const _e = ce.data.subarray(ee * Z / ce.data.BYTES_PER_ELEMENT, (ee + 1) * Z / ce.data.BYTES_PER_ELEMENT);
                            t.texSubImage3D(i.TEXTURE_2D_ARRAY, 0, 0, 0, ee, ce.width, ce.height, 1, ye, Ie, _e);
                        }
                        M.clearLayerUpdates();
                    } else t.texSubImage3D(i.TEXTURE_2D_ARRAY, 0, 0, 0, 0, ce.width, ce.height, ce.depth, ye, Ie, ce.data);
                } else t.texImage3D(i.TEXTURE_2D_ARRAY, 0, Ue, ce.width, ce.height, ce.depth, 0, ye, Ie, ce.data);
                else if (M.isData3DTexture) ze ? (ht && t.texStorage3D(i.TEXTURE_3D, pe, Ue, ce.width, ce.height, ce.depth), F && t.texSubImage3D(i.TEXTURE_3D, 0, 0, 0, 0, ce.width, ce.height, ce.depth, ye, Ie, ce.data)) : t.texImage3D(i.TEXTURE_3D, 0, Ue, ce.width, ce.height, ce.depth, 0, ye, Ie, ce.data);
                else if (M.isFramebufferTexture) {
                    if (ht) if (ze) t.texStorage2D(i.TEXTURE_2D, pe, Ue, ce.width, ce.height);
                    else {
                        let Z = ce.width, ee = ce.height;
                        for(let _e = 0; _e < pe; _e++)t.texImage2D(i.TEXTURE_2D, _e, Ue, Z, ee, 0, ye, Ie, null), Z >>= 1, ee >>= 1;
                    }
                } else if (je.length > 0) {
                    if (ze && ht) {
                        const Z = Ae(je[0]);
                        t.texStorage2D(i.TEXTURE_2D, pe, Ue, Z.width, Z.height);
                    }
                    for(let Z = 0, ee = je.length; Z < ee; Z++)be = je[Z], ze ? F && t.texSubImage2D(i.TEXTURE_2D, Z, 0, 0, ye, Ie, be) : t.texImage2D(i.TEXTURE_2D, Z, Ue, ye, Ie, be);
                    M.generateMipmaps = !1;
                } else if (ze) {
                    if (ht) {
                        const Z = Ae(ce);
                        t.texStorage2D(i.TEXTURE_2D, pe, Ue, Z.width, Z.height);
                    }
                    F && t.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, ye, Ie, ce);
                } else t.texImage2D(i.TEXTURE_2D, 0, Ue, ye, Ie, ce);
                p(M) && m(Q), Te.__version = J.version, M.onUpdate && M.onUpdate(M);
            }
            P.__version = M.version;
        }
        function $(P, M, W) {
            if (M.image.length !== 6) return;
            const Q = te(P, M), re = M.source;
            t.bindTexture(i.TEXTURE_CUBE_MAP, P.__webglTexture, i.TEXTURE0 + W);
            const J = n.get(re);
            if (re.version !== J.__version || Q === !0) {
                t.activeTexture(i.TEXTURE0 + W);
                const Te = $e.getPrimaries($e.workingColorSpace), fe = M.colorSpace === hi ? null : $e.getPrimaries(M.colorSpace), ve = M.colorSpace === hi || Te === fe ? i.NONE : i.BROWSER_DEFAULT_WEBGL;
                i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, M.flipY), i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, M.premultiplyAlpha), i.pixelStorei(i.UNPACK_ALIGNMENT, M.unpackAlignment), i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL, ve);
                const Ze = M.isCompressedTexture || M.image[0].isCompressedTexture, ce = M.image[0] && M.image[0].isDataTexture, ye = [];
                for(let ee = 0; ee < 6; ee++)!Ze && !ce ? ye[ee] = g(M.image[ee], !0, s.maxCubemapSize) : ye[ee] = ce ? M.image[ee].image : M.image[ee], ye[ee] = lt(M, ye[ee]);
                const Ie = ye[0], Ue = r.convert(M.format, M.colorSpace), be = r.convert(M.type), je = y(M.internalFormat, Ue, be, M.colorSpace), ze = M.isVideoTexture !== !0, ht = J.__version === void 0 || Q === !0, F = re.dataReady;
                let pe = I(M, Ie);
                q(i.TEXTURE_CUBE_MAP, M);
                let Z;
                if (Ze) {
                    ze && ht && t.texStorage2D(i.TEXTURE_CUBE_MAP, pe, je, Ie.width, Ie.height);
                    for(let ee = 0; ee < 6; ee++){
                        Z = ye[ee].mipmaps;
                        for(let _e = 0; _e < Z.length; _e++){
                            const me = Z[_e];
                            M.format !== un ? Ue !== null ? ze ? F && t.compressedTexSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + ee, _e, 0, 0, me.width, me.height, Ue, me.data) : t.compressedTexImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + ee, _e, je, me.width, me.height, 0, me.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : ze ? F && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + ee, _e, 0, 0, me.width, me.height, Ue, be, me.data) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + ee, _e, je, me.width, me.height, 0, Ue, be, me.data);
                        }
                    }
                } else {
                    if (Z = M.mipmaps, ze && ht) {
                        Z.length > 0 && pe++;
                        const ee = Ae(ye[0]);
                        t.texStorage2D(i.TEXTURE_CUBE_MAP, pe, je, ee.width, ee.height);
                    }
                    for(let ee = 0; ee < 6; ee++)if (ce) {
                        ze ? F && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + ee, 0, 0, 0, ye[ee].width, ye[ee].height, Ue, be, ye[ee].data) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + ee, 0, je, ye[ee].width, ye[ee].height, 0, Ue, be, ye[ee].data);
                        for(let _e = 0; _e < Z.length; _e++){
                            const ke = Z[_e].image[ee].image;
                            ze ? F && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + ee, _e + 1, 0, 0, ke.width, ke.height, Ue, be, ke.data) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + ee, _e + 1, je, ke.width, ke.height, 0, Ue, be, ke.data);
                        }
                    } else {
                        ze ? F && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + ee, 0, 0, 0, Ue, be, ye[ee]) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + ee, 0, je, Ue, be, ye[ee]);
                        for(let _e = 0; _e < Z.length; _e++){
                            const me = Z[_e];
                            ze ? F && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + ee, _e + 1, 0, 0, Ue, be, me.image[ee]) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + ee, _e + 1, je, Ue, be, me.image[ee]);
                        }
                    }
                }
                p(M) && m(i.TEXTURE_CUBE_MAP), J.__version = re.version, M.onUpdate && M.onUpdate(M);
            }
            P.__version = M.version;
        }
        function oe(P, M, W, Q, re, J) {
            const Te = r.convert(W.format, W.colorSpace), fe = r.convert(W.type), ve = y(W.internalFormat, Te, fe, W.colorSpace), Ze = n.get(M), ce = n.get(W);
            if (ce.__renderTarget = M, !Ze.__hasExternalTextures) {
                const ye = Math.max(1, M.width >> J), Ie = Math.max(1, M.height >> J);
                re === i.TEXTURE_3D || re === i.TEXTURE_2D_ARRAY ? t.texImage3D(re, J, ve, ye, Ie, M.depth, 0, Te, fe, null) : t.texImage2D(re, J, ve, ye, Ie, 0, Te, fe, null);
            }
            t.bindFramebuffer(i.FRAMEBUFFER, P), Xe(M) ? o.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER, Q, re, ce.__webglTexture, 0, ge(M)) : (re === i.TEXTURE_2D || re >= i.TEXTURE_CUBE_MAP_POSITIVE_X && re <= i.TEXTURE_CUBE_MAP_NEGATIVE_Z) && i.framebufferTexture2D(i.FRAMEBUFFER, Q, re, ce.__webglTexture, J), t.bindFramebuffer(i.FRAMEBUFFER, null);
        }
        function ie(P, M, W) {
            if (i.bindRenderbuffer(i.RENDERBUFFER, P), M.depthBuffer) {
                const Q = M.depthTexture, re = Q && Q.isDepthTexture ? Q.type : null, J = x(M.stencilBuffer, re), Te = M.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT, fe = ge(M);
                Xe(M) ? o.renderbufferStorageMultisampleEXT(i.RENDERBUFFER, fe, J, M.width, M.height) : W ? i.renderbufferStorageMultisample(i.RENDERBUFFER, fe, J, M.width, M.height) : i.renderbufferStorage(i.RENDERBUFFER, J, M.width, M.height), i.framebufferRenderbuffer(i.FRAMEBUFFER, Te, i.RENDERBUFFER, P);
            } else {
                const Q = M.textures;
                for(let re = 0; re < Q.length; re++){
                    const J = Q[re], Te = r.convert(J.format, J.colorSpace), fe = r.convert(J.type), ve = y(J.internalFormat, Te, fe, J.colorSpace), Ze = ge(M);
                    W && Xe(M) === !1 ? i.renderbufferStorageMultisample(i.RENDERBUFFER, Ze, ve, M.width, M.height) : Xe(M) ? o.renderbufferStorageMultisampleEXT(i.RENDERBUFFER, Ze, ve, M.width, M.height) : i.renderbufferStorage(i.RENDERBUFFER, ve, M.width, M.height);
                }
            }
            i.bindRenderbuffer(i.RENDERBUFFER, null);
        }
        function le(P, M) {
            if (M && M.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
            if (t.bindFramebuffer(i.FRAMEBUFFER, P), !(M.depthTexture && M.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
            const Q = n.get(M.depthTexture);
            Q.__renderTarget = M, (!Q.__webglTexture || M.depthTexture.image.width !== M.width || M.depthTexture.image.height !== M.height) && (M.depthTexture.image.width = M.width, M.depthTexture.image.height = M.height, M.depthTexture.needsUpdate = !0), ne(M.depthTexture, 0);
            const re = Q.__webglTexture, J = ge(M);
            if (M.depthTexture.format === Mr) Xe(M) ? o.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.TEXTURE_2D, re, 0, J) : i.framebufferTexture2D(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.TEXTURE_2D, re, 0);
            else if (M.depthTexture.format === Tr) Xe(M) ? o.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.TEXTURE_2D, re, 0, J) : i.framebufferTexture2D(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.TEXTURE_2D, re, 0);
            else throw new Error("Unknown depthTexture format");
        }
        function we(P) {
            const M = n.get(P), W = P.isWebGLCubeRenderTarget === !0;
            if (M.__boundDepthTexture !== P.depthTexture) {
                const Q = P.depthTexture;
                if (M.__depthDisposeCallback && M.__depthDisposeCallback(), Q) {
                    const re = ()=>{
                        delete M.__boundDepthTexture, delete M.__depthDisposeCallback, Q.removeEventListener("dispose", re);
                    };
                    Q.addEventListener("dispose", re), M.__depthDisposeCallback = re;
                }
                M.__boundDepthTexture = Q;
            }
            if (P.depthTexture && !M.__autoAllocateDepthBuffer) {
                if (W) throw new Error("target.depthTexture not supported in Cube render targets");
                le(M.__webglFramebuffer, P);
            } else if (W) {
                M.__webglDepthbuffer = [];
                for(let Q = 0; Q < 6; Q++)if (t.bindFramebuffer(i.FRAMEBUFFER, M.__webglFramebuffer[Q]), M.__webglDepthbuffer[Q] === void 0) M.__webglDepthbuffer[Q] = i.createRenderbuffer(), ie(M.__webglDepthbuffer[Q], P, !1);
                else {
                    const re = P.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT, J = M.__webglDepthbuffer[Q];
                    i.bindRenderbuffer(i.RENDERBUFFER, J), i.framebufferRenderbuffer(i.FRAMEBUFFER, re, i.RENDERBUFFER, J);
                }
            } else if (t.bindFramebuffer(i.FRAMEBUFFER, M.__webglFramebuffer), M.__webglDepthbuffer === void 0) M.__webglDepthbuffer = i.createRenderbuffer(), ie(M.__webglDepthbuffer, P, !1);
            else {
                const Q = P.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT, re = M.__webglDepthbuffer;
                i.bindRenderbuffer(i.RENDERBUFFER, re), i.framebufferRenderbuffer(i.FRAMEBUFFER, Q, i.RENDERBUFFER, re);
            }
            t.bindFramebuffer(i.FRAMEBUFFER, null);
        }
        function he(P, M, W) {
            const Q = n.get(P);
            M !== void 0 && oe(Q.__webglFramebuffer, P, P.texture, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, 0), W !== void 0 && we(P);
        }
        function tt(P) {
            const M = P.texture, W = n.get(P), Q = n.get(M);
            P.addEventListener("dispose", R);
            const re = P.textures, J = P.isWebGLCubeRenderTarget === !0, Te = re.length > 1;
            if (Te || (Q.__webglTexture === void 0 && (Q.__webglTexture = i.createTexture()), Q.__version = M.version, a.memory.textures++), J) {
                W.__webglFramebuffer = [];
                for(let fe = 0; fe < 6; fe++)if (M.mipmaps && M.mipmaps.length > 0) {
                    W.__webglFramebuffer[fe] = [];
                    for(let ve = 0; ve < M.mipmaps.length; ve++)W.__webglFramebuffer[fe][ve] = i.createFramebuffer();
                } else W.__webglFramebuffer[fe] = i.createFramebuffer();
            } else {
                if (M.mipmaps && M.mipmaps.length > 0) {
                    W.__webglFramebuffer = [];
                    for(let fe = 0; fe < M.mipmaps.length; fe++)W.__webglFramebuffer[fe] = i.createFramebuffer();
                } else W.__webglFramebuffer = i.createFramebuffer();
                if (Te) for(let fe = 0, ve = re.length; fe < ve; fe++){
                    const Ze = n.get(re[fe]);
                    Ze.__webglTexture === void 0 && (Ze.__webglTexture = i.createTexture(), a.memory.textures++);
                }
                if (P.samples > 0 && Xe(P) === !1) {
                    W.__webglMultisampledFramebuffer = i.createFramebuffer(), W.__webglColorRenderbuffer = [], t.bindFramebuffer(i.FRAMEBUFFER, W.__webglMultisampledFramebuffer);
                    for(let fe = 0; fe < re.length; fe++){
                        const ve = re[fe];
                        W.__webglColorRenderbuffer[fe] = i.createRenderbuffer(), i.bindRenderbuffer(i.RENDERBUFFER, W.__webglColorRenderbuffer[fe]);
                        const Ze = r.convert(ve.format, ve.colorSpace), ce = r.convert(ve.type), ye = y(ve.internalFormat, Ze, ce, ve.colorSpace, P.isXRRenderTarget === !0), Ie = ge(P);
                        i.renderbufferStorageMultisample(i.RENDERBUFFER, Ie, ye, P.width, P.height), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + fe, i.RENDERBUFFER, W.__webglColorRenderbuffer[fe]);
                    }
                    i.bindRenderbuffer(i.RENDERBUFFER, null), P.depthBuffer && (W.__webglDepthRenderbuffer = i.createRenderbuffer(), ie(W.__webglDepthRenderbuffer, P, !0)), t.bindFramebuffer(i.FRAMEBUFFER, null);
                }
            }
            if (J) {
                t.bindTexture(i.TEXTURE_CUBE_MAP, Q.__webglTexture), q(i.TEXTURE_CUBE_MAP, M);
                for(let fe = 0; fe < 6; fe++)if (M.mipmaps && M.mipmaps.length > 0) for(let ve = 0; ve < M.mipmaps.length; ve++)oe(W.__webglFramebuffer[fe][ve], P, M, i.COLOR_ATTACHMENT0, i.TEXTURE_CUBE_MAP_POSITIVE_X + fe, ve);
                else oe(W.__webglFramebuffer[fe], P, M, i.COLOR_ATTACHMENT0, i.TEXTURE_CUBE_MAP_POSITIVE_X + fe, 0);
                p(M) && m(i.TEXTURE_CUBE_MAP), t.unbindTexture();
            } else if (Te) {
                for(let fe = 0, ve = re.length; fe < ve; fe++){
                    const Ze = re[fe], ce = n.get(Ze);
                    t.bindTexture(i.TEXTURE_2D, ce.__webglTexture), q(i.TEXTURE_2D, Ze), oe(W.__webglFramebuffer, P, Ze, i.COLOR_ATTACHMENT0 + fe, i.TEXTURE_2D, 0), p(Ze) && m(i.TEXTURE_2D);
                }
                t.unbindTexture();
            } else {
                let fe = i.TEXTURE_2D;
                if ((P.isWebGL3DRenderTarget || P.isWebGLArrayRenderTarget) && (fe = P.isWebGL3DRenderTarget ? i.TEXTURE_3D : i.TEXTURE_2D_ARRAY), t.bindTexture(fe, Q.__webglTexture), q(fe, M), M.mipmaps && M.mipmaps.length > 0) for(let ve = 0; ve < M.mipmaps.length; ve++)oe(W.__webglFramebuffer[ve], P, M, i.COLOR_ATTACHMENT0, fe, ve);
                else oe(W.__webglFramebuffer, P, M, i.COLOR_ATTACHMENT0, fe, 0);
                p(M) && m(fe), t.unbindTexture();
            }
            P.depthBuffer && we(P);
        }
        function We(P) {
            const M = P.textures;
            for(let W = 0, Q = M.length; W < Q; W++){
                const re = M[W];
                if (p(re)) {
                    const J = v(P), Te = n.get(re).__webglTexture;
                    t.bindTexture(J, Te), m(J), t.unbindTexture();
                }
            }
        }
        const Le = [], L = [];
        function Ce(P) {
            if (P.samples > 0) {
                if (Xe(P) === !1) {
                    const M = P.textures, W = P.width, Q = P.height;
                    let re = i.COLOR_BUFFER_BIT;
                    const J = P.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT, Te = n.get(P), fe = M.length > 1;
                    if (fe) for(let ve = 0; ve < M.length; ve++)t.bindFramebuffer(i.FRAMEBUFFER, Te.__webglMultisampledFramebuffer), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + ve, i.RENDERBUFFER, null), t.bindFramebuffer(i.FRAMEBUFFER, Te.__webglFramebuffer), i.framebufferTexture2D(i.DRAW_FRAMEBUFFER, i.COLOR_ATTACHMENT0 + ve, i.TEXTURE_2D, null, 0);
                    t.bindFramebuffer(i.READ_FRAMEBUFFER, Te.__webglMultisampledFramebuffer), t.bindFramebuffer(i.DRAW_FRAMEBUFFER, Te.__webglFramebuffer);
                    for(let ve = 0; ve < M.length; ve++){
                        if (P.resolveDepthBuffer && (P.depthBuffer && (re |= i.DEPTH_BUFFER_BIT), P.stencilBuffer && P.resolveStencilBuffer && (re |= i.STENCIL_BUFFER_BIT)), fe) {
                            i.framebufferRenderbuffer(i.READ_FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.RENDERBUFFER, Te.__webglColorRenderbuffer[ve]);
                            const Ze = n.get(M[ve]).__webglTexture;
                            i.framebufferTexture2D(i.DRAW_FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, Ze, 0);
                        }
                        i.blitFramebuffer(0, 0, W, Q, 0, 0, W, Q, re, i.NEAREST), c === !0 && (Le.length = 0, L.length = 0, Le.push(i.COLOR_ATTACHMENT0 + ve), P.depthBuffer && P.resolveDepthBuffer === !1 && (Le.push(J), L.push(J), i.invalidateFramebuffer(i.DRAW_FRAMEBUFFER, L)), i.invalidateFramebuffer(i.READ_FRAMEBUFFER, Le));
                    }
                    if (t.bindFramebuffer(i.READ_FRAMEBUFFER, null), t.bindFramebuffer(i.DRAW_FRAMEBUFFER, null), fe) for(let ve = 0; ve < M.length; ve++){
                        t.bindFramebuffer(i.FRAMEBUFFER, Te.__webglMultisampledFramebuffer), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + ve, i.RENDERBUFFER, Te.__webglColorRenderbuffer[ve]);
                        const Ze = n.get(M[ve]).__webglTexture;
                        t.bindFramebuffer(i.FRAMEBUFFER, Te.__webglFramebuffer), i.framebufferTexture2D(i.DRAW_FRAMEBUFFER, i.COLOR_ATTACHMENT0 + ve, i.TEXTURE_2D, Ze, 0);
                    }
                    t.bindFramebuffer(i.DRAW_FRAMEBUFFER, Te.__webglMultisampledFramebuffer);
                } else if (P.depthBuffer && P.resolveDepthBuffer === !1 && c) {
                    const M = P.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT;
                    i.invalidateFramebuffer(i.DRAW_FRAMEBUFFER, [
                        M
                    ]);
                }
            }
        }
        function ge(P) {
            return Math.min(s.maxSamples, P.samples);
        }
        function Xe(P) {
            const M = n.get(P);
            return P.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && M.__useRenderToTexture !== !1;
        }
        function Ee(P) {
            const M = a.render.frame;
            h.get(P) !== M && (h.set(P, M), P.update());
        }
        function lt(P, M) {
            const W = P.colorSpace, Q = P.format, re = P.type;
            return P.isCompressedTexture === !0 || P.isVideoTexture === !0 || W !== $t && W !== hi && ($e.getTransfer(W) === ct ? (Q !== un || re !== ni) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", W)), M;
        }
        function Ae(P) {
            return typeof HTMLImageElement < "u" && P instanceof HTMLImageElement ? (l.width = P.naturalWidth || P.width, l.height = P.naturalHeight || P.height) : typeof VideoFrame < "u" && P instanceof VideoFrame ? (l.width = P.displayWidth, l.height = P.displayHeight) : (l.width = P.width, l.height = P.height), l;
        }
        this.allocateTextureUnit = z, this.resetTextureUnits = j, this.setTexture2D = ne, this.setTexture2DArray = b, this.setTexture3D = C, this.setTextureCube = A, this.rebindTextures = he, this.setupRenderTarget = tt, this.updateRenderTargetMipmap = We, this.updateMultisampleRenderTarget = Ce, this.setupDepthRenderbuffer = we, this.setupFrameBufferTexture = oe, this.useMultisampledRTT = Xe;
    }
    function AS(i, e) {
        function t(n, s = hi) {
            let r;
            const a = $e.getTransfer(s);
            if (n === ni) return i.UNSIGNED_BYTE;
            if (n === Gl) return i.UNSIGNED_SHORT_4_4_4_4;
            if (n === Hl) return i.UNSIGNED_SHORT_5_5_5_1;
            if (n === wf) return i.UNSIGNED_INT_5_9_9_9_REV;
            if (n === Ef) return i.BYTE;
            if (n === Af) return i.SHORT;
            if (n === br) return i.UNSIGNED_SHORT;
            if (n === kl) return i.INT;
            if (n === zi) return i.UNSIGNED_INT;
            if (n === Mn) return i.FLOAT;
            if (n === Lr) return i.HALF_FLOAT;
            if (n === Rf) return i.ALPHA;
            if (n === Cf) return i.RGB;
            if (n === un) return i.RGBA;
            if (n === Pf) return i.LUMINANCE;
            if (n === If) return i.LUMINANCE_ALPHA;
            if (n === Mr) return i.DEPTH_COMPONENT;
            if (n === Tr) return i.DEPTH_STENCIL;
            if (n === zl) return i.RED;
            if (n === Vl) return i.RED_INTEGER;
            if (n === Df) return i.RG;
            if (n === Wl) return i.RG_INTEGER;
            if (n === Xl) return i.RGBA_INTEGER;
            if (n === Ea || n === Aa || n === wa || n === Ra) if (a === ct) if (r = e.get("WEBGL_compressed_texture_s3tc_srgb"), r !== null) {
                if (n === Ea) return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                if (n === Aa) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                if (n === wa) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                if (n === Ra) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
            } else return null;
            else if (r = e.get("WEBGL_compressed_texture_s3tc"), r !== null) {
                if (n === Ea) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (n === Aa) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (n === wa) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (n === Ra) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            } else return null;
            if (n === Uc || n === Nc || n === Bc || n === Fc) if (r = e.get("WEBGL_compressed_texture_pvrtc"), r !== null) {
                if (n === Uc) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (n === Nc) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (n === Bc) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (n === Fc) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            } else return null;
            if (n === Oc || n === kc || n === Gc) if (r = e.get("WEBGL_compressed_texture_etc"), r !== null) {
                if (n === Oc || n === kc) return a === ct ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
                if (n === Gc) return a === ct ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC;
            } else return null;
            if (n === Hc || n === zc || n === Vc || n === Wc || n === Xc || n === Yc || n === qc || n === jc || n === $c || n === Kc || n === Zc || n === Jc || n === Qc || n === el) if (r = e.get("WEBGL_compressed_texture_astc"), r !== null) {
                if (n === Hc) return a === ct ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (n === zc) return a === ct ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (n === Vc) return a === ct ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (n === Wc) return a === ct ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (n === Xc) return a === ct ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (n === Yc) return a === ct ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (n === qc) return a === ct ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (n === jc) return a === ct ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (n === $c) return a === ct ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (n === Kc) return a === ct ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (n === Zc) return a === ct ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (n === Jc) return a === ct ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (n === Qc) return a === ct ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (n === el) return a === ct ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR;
            } else return null;
            if (n === Ca || n === tl || n === nl) if (r = e.get("EXT_texture_compression_bptc"), r !== null) {
                if (n === Ca) return a === ct ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                if (n === tl) return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                if (n === nl) return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
            } else return null;
            if (n === Lf || n === il || n === sl || n === rl) if (r = e.get("EXT_texture_compression_rgtc"), r !== null) {
                if (n === Ca) return r.COMPRESSED_RED_RGTC1_EXT;
                if (n === il) return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                if (n === sl) return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
                if (n === rl) return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
            } else return null;
            return n === Sr ? i.UNSIGNED_INT_24_8 : i[n] !== void 0 ? i[n] : null;
        }
        return {
            convert: t
        };
    }
    const wS = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, RS = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
    class CS {
        constructor(){
            this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
        }
        init(e, t, n) {
            if (this.texture === null) {
                const s = new Qt, r = e.properties.get(s);
                r.__webglTexture = t.texture, (t.depthNear !== n.depthNear || t.depthFar !== n.depthFar) && (this.depthNear = t.depthNear, this.depthFar = t.depthFar), this.texture = s;
            }
        }
        getMesh(e) {
            if (this.texture !== null && this.mesh === null) {
                const t = e.cameras[0].viewport, n = new xi({
                    vertexShader: wS,
                    fragmentShader: RS,
                    uniforms: {
                        depthColor: {
                            value: this.texture
                        },
                        depthWidth: {
                            value: t.z
                        },
                        depthHeight: {
                            value: t.w
                        }
                    }
                });
                this.mesh = new kt(new Ur(20, 20), n);
            }
            return this.mesh;
        }
        reset() {
            this.texture = null, this.mesh = null;
        }
        getDepthTexture() {
            return this.texture;
        }
    }
    class PS extends ji {
        constructor(e, t){
            super();
            const n = this;
            let s = null, r = 1, a = null, o = "local-floor", c = 1, l = null, h = null, u = null, d = null, f = null, _ = null;
            const g = new CS, p = t.getContextAttributes();
            let m = null, v = null;
            const y = [], x = [], I = new Ke;
            let w = null;
            const R = new Wt;
            R.viewport = new nt;
            const N = new Wt;
            N.viewport = new nt;
            const E = [
                R,
                N
            ], S = new Fx;
            let D = null, j = null;
            this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(H) {
                let $ = y[H];
                return $ === void 0 && ($ = new Eo, y[H] = $), $.getTargetRaySpace();
            }, this.getControllerGrip = function(H) {
                let $ = y[H];
                return $ === void 0 && ($ = new Eo, y[H] = $), $.getGripSpace();
            }, this.getHand = function(H) {
                let $ = y[H];
                return $ === void 0 && ($ = new Eo, y[H] = $), $.getHandSpace();
            };
            function z(H) {
                const $ = x.indexOf(H.inputSource);
                if ($ === -1) return;
                const oe = y[$];
                oe !== void 0 && (oe.update(H.inputSource, H.frame, l || a), oe.dispatchEvent({
                    type: H.type,
                    data: H.inputSource
                }));
            }
            function K() {
                s.removeEventListener("select", z), s.removeEventListener("selectstart", z), s.removeEventListener("selectend", z), s.removeEventListener("squeeze", z), s.removeEventListener("squeezestart", z), s.removeEventListener("squeezeend", z), s.removeEventListener("end", K), s.removeEventListener("inputsourceschange", ne);
                for(let H = 0; H < y.length; H++){
                    const $ = x[H];
                    $ !== null && (x[H] = null, y[H].disconnect($));
                }
                D = null, j = null, g.reset(), e.setRenderTarget(m), f = null, d = null, u = null, s = null, v = null, te.stop(), n.isPresenting = !1, e.setPixelRatio(w), e.setSize(I.width, I.height, !1), n.dispatchEvent({
                    type: "sessionend"
                });
            }
            this.setFramebufferScaleFactor = function(H) {
                r = H, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
            }, this.setReferenceSpaceType = function(H) {
                o = H, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
            }, this.getReferenceSpace = function() {
                return l || a;
            }, this.setReferenceSpace = function(H) {
                l = H;
            }, this.getBaseLayer = function() {
                return d !== null ? d : f;
            }, this.getBinding = function() {
                return u;
            }, this.getFrame = function() {
                return _;
            }, this.getSession = function() {
                return s;
            }, this.setSession = async function(H) {
                if (s = H, s !== null) {
                    if (m = e.getRenderTarget(), s.addEventListener("select", z), s.addEventListener("selectstart", z), s.addEventListener("selectend", z), s.addEventListener("squeeze", z), s.addEventListener("squeezestart", z), s.addEventListener("squeezeend", z), s.addEventListener("end", K), s.addEventListener("inputsourceschange", ne), p.xrCompatible !== !0 && await t.makeXRCompatible(), w = e.getPixelRatio(), e.getSize(I), typeof XRWebGLBinding < "u" && "createProjectionLayer" in XRWebGLBinding.prototype) {
                        let oe = null, ie = null, le = null;
                        p.depth && (le = p.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, oe = p.stencil ? Tr : Mr, ie = p.stencil ? Sr : zi);
                        const we = {
                            colorFormat: t.RGBA8,
                            depthFormat: le,
                            scaleFactor: r
                        };
                        u = new XRWebGLBinding(s, t), d = u.createProjectionLayer(we), s.updateRenderState({
                            layers: [
                                d
                            ]
                        }), e.setPixelRatio(1), e.setSize(d.textureWidth, d.textureHeight, !1), v = new Vi(d.textureWidth, d.textureHeight, {
                            format: un,
                            type: ni,
                            depthTexture: new Kf(d.textureWidth, d.textureHeight, ie, void 0, void 0, void 0, void 0, void 0, void 0, oe),
                            stencilBuffer: p.stencil,
                            colorSpace: e.outputColorSpace,
                            samples: p.antialias ? 4 : 0,
                            resolveDepthBuffer: d.ignoreDepthValues === !1,
                            resolveStencilBuffer: d.ignoreDepthValues === !1
                        });
                    } else {
                        const oe = {
                            antialias: p.antialias,
                            alpha: !0,
                            depth: p.depth,
                            stencil: p.stencil,
                            framebufferScaleFactor: r
                        };
                        f = new XRWebGLLayer(s, t, oe), s.updateRenderState({
                            baseLayer: f
                        }), e.setPixelRatio(1), e.setSize(f.framebufferWidth, f.framebufferHeight, !1), v = new Vi(f.framebufferWidth, f.framebufferHeight, {
                            format: un,
                            type: ni,
                            colorSpace: e.outputColorSpace,
                            stencilBuffer: p.stencil,
                            resolveDepthBuffer: f.ignoreDepthValues === !1,
                            resolveStencilBuffer: f.ignoreDepthValues === !1
                        });
                    }
                    v.isXRRenderTarget = !0, this.setFoveation(c), l = null, a = await s.requestReferenceSpace(o), te.setContext(s), te.start(), n.isPresenting = !0, n.dispatchEvent({
                        type: "sessionstart"
                    });
                }
            }, this.getEnvironmentBlendMode = function() {
                if (s !== null) return s.environmentBlendMode;
            }, this.getDepthTexture = function() {
                return g.getDepthTexture();
            };
            function ne(H) {
                for(let $ = 0; $ < H.removed.length; $++){
                    const oe = H.removed[$], ie = x.indexOf(oe);
                    ie >= 0 && (x[ie] = null, y[ie].disconnect(oe));
                }
                for(let $ = 0; $ < H.added.length; $++){
                    const oe = H.added[$];
                    let ie = x.indexOf(oe);
                    if (ie === -1) {
                        for(let we = 0; we < y.length; we++)if (we >= x.length) {
                            x.push(oe), ie = we;
                            break;
                        } else if (x[we] === null) {
                            x[we] = oe, ie = we;
                            break;
                        }
                        if (ie === -1) break;
                    }
                    const le = y[ie];
                    le && le.connect(oe);
                }
            }
            const b = new k, C = new k;
            function A(H, $, oe) {
                b.setFromMatrixPosition($.matrixWorld), C.setFromMatrixPosition(oe.matrixWorld);
                const ie = b.distanceTo(C), le = $.projectionMatrix.elements, we = oe.projectionMatrix.elements, he = le[14] / (le[10] - 1), tt = le[14] / (le[10] + 1), We = (le[9] + 1) / le[5], Le = (le[9] - 1) / le[5], L = (le[8] - 1) / le[0], Ce = (we[8] + 1) / we[0], ge = he * L, Xe = he * Ce, Ee = ie / (-L + Ce), lt = Ee * -L;
                if ($.matrixWorld.decompose(H.position, H.quaternion, H.scale), H.translateX(lt), H.translateZ(Ee), H.matrixWorld.compose(H.position, H.quaternion, H.scale), H.matrixWorldInverse.copy(H.matrixWorld).invert(), le[10] === -1) H.projectionMatrix.copy($.projectionMatrix), H.projectionMatrixInverse.copy($.projectionMatrixInverse);
                else {
                    const Ae = he + Ee, P = tt + Ee, M = ge - lt, W = Xe + (ie - lt), Q = We * tt / P * Ae, re = Le * tt / P * Ae;
                    H.projectionMatrix.makePerspective(M, W, Q, re, Ae, P), H.projectionMatrixInverse.copy(H.projectionMatrix).invert();
                }
            }
            function U(H, $) {
                $ === null ? H.matrixWorld.copy(H.matrix) : H.matrixWorld.multiplyMatrices($.matrixWorld, H.matrix), H.matrixWorldInverse.copy(H.matrixWorld).invert();
            }
            this.updateCamera = function(H) {
                if (s === null) return;
                let $ = H.near, oe = H.far;
                g.texture !== null && (g.depthNear > 0 && ($ = g.depthNear), g.depthFar > 0 && (oe = g.depthFar)), S.near = N.near = R.near = $, S.far = N.far = R.far = oe, (D !== S.near || j !== S.far) && (s.updateRenderState({
                    depthNear: S.near,
                    depthFar: S.far
                }), D = S.near, j = S.far), R.layers.mask = H.layers.mask | 2, N.layers.mask = H.layers.mask | 4, S.layers.mask = R.layers.mask | N.layers.mask;
                const ie = H.parent, le = S.cameras;
                U(S, ie);
                for(let we = 0; we < le.length; we++)U(le[we], ie);
                le.length === 2 ? A(S, R, N) : S.projectionMatrix.copy(R.projectionMatrix), B(H, S, ie);
            };
            function B(H, $, oe) {
                oe === null ? H.matrix.copy($.matrixWorld) : (H.matrix.copy(oe.matrixWorld), H.matrix.invert(), H.matrix.multiply($.matrixWorld)), H.matrix.decompose(H.position, H.quaternion, H.scale), H.updateMatrixWorld(!0), H.projectionMatrix.copy($.projectionMatrix), H.projectionMatrixInverse.copy($.projectionMatrixInverse), H.isPerspectiveCamera && (H.fov = Is * 2 * Math.atan(1 / H.projectionMatrix.elements[5]), H.zoom = 1);
            }
            this.getCamera = function() {
                return S;
            }, this.getFoveation = function() {
                if (!(d === null && f === null)) return c;
            }, this.setFoveation = function(H) {
                c = H, d !== null && (d.fixedFoveation = H), f !== null && f.fixedFoveation !== void 0 && (f.fixedFoveation = H);
            }, this.hasDepthSensing = function() {
                return g.texture !== null;
            }, this.getDepthSensingMesh = function() {
                return g.getMesh(S);
            };
            let V = null;
            function q(H, $) {
                if (h = $.getViewerPose(l || a), _ = $, h !== null) {
                    const oe = h.views;
                    f !== null && (e.setRenderTargetFramebuffer(v, f.framebuffer), e.setRenderTarget(v));
                    let ie = !1;
                    oe.length !== S.cameras.length && (S.cameras.length = 0, ie = !0);
                    for(let he = 0; he < oe.length; he++){
                        const tt = oe[he];
                        let We = null;
                        if (f !== null) We = f.getViewport(tt);
                        else {
                            const L = u.getViewSubImage(d, tt);
                            We = L.viewport, he === 0 && (e.setRenderTargetTextures(v, L.colorTexture, L.depthStencilTexture), e.setRenderTarget(v));
                        }
                        let Le = E[he];
                        Le === void 0 && (Le = new Wt, Le.layers.enable(he), Le.viewport = new nt, E[he] = Le), Le.matrix.fromArray(tt.transform.matrix), Le.matrix.decompose(Le.position, Le.quaternion, Le.scale), Le.projectionMatrix.fromArray(tt.projectionMatrix), Le.projectionMatrixInverse.copy(Le.projectionMatrix).invert(), Le.viewport.set(We.x, We.y, We.width, We.height), he === 0 && (S.matrix.copy(Le.matrix), S.matrix.decompose(S.position, S.quaternion, S.scale)), ie === !0 && S.cameras.push(Le);
                    }
                    const le = s.enabledFeatures;
                    if (le && le.includes("depth-sensing") && s.depthUsage == "gpu-optimized" && u) {
                        const he = u.getDepthInformation(oe[0]);
                        he && he.isValid && he.texture && g.init(e, he, s.renderState);
                    }
                }
                for(let oe = 0; oe < y.length; oe++){
                    const ie = x[oe], le = y[oe];
                    ie !== null && le !== void 0 && le.update(ie, $, l || a);
                }
                V && V(H, $), $.detectedPlanes && n.dispatchEvent({
                    type: "planesdetected",
                    data: $
                }), _ = null;
            }
            const te = new np;
            te.setAnimationLoop(q), this.setAnimationLoop = function(H) {
                V = H;
            }, this.dispose = function() {};
        }
    }
    const Ai = new Bn, IS = new He;
    function DS(i, e) {
        function t(p, m) {
            p.matrixAutoUpdate === !0 && p.updateMatrix(), m.value.copy(p.matrix);
        }
        function n(p, m) {
            m.color.getRGB(p.fogColor.value, Vf(i)), m.isFog ? (p.fogNear.value = m.near, p.fogFar.value = m.far) : m.isFogExp2 && (p.fogDensity.value = m.density);
        }
        function s(p, m, v, y, x) {
            m.isMeshBasicMaterial || m.isMeshLambertMaterial ? r(p, m) : m.isMeshToonMaterial ? (r(p, m), u(p, m)) : m.isMeshPhongMaterial ? (r(p, m), h(p, m)) : m.isMeshStandardMaterial ? (r(p, m), d(p, m), m.isMeshPhysicalMaterial && f(p, m, x)) : m.isMeshMatcapMaterial ? (r(p, m), _(p, m)) : m.isMeshDepthMaterial ? r(p, m) : m.isMeshDistanceMaterial ? (r(p, m), g(p, m)) : m.isMeshNormalMaterial ? r(p, m) : m.isLineBasicMaterial ? (a(p, m), m.isLineDashedMaterial && o(p, m)) : m.isPointsMaterial ? c(p, m, v, y) : m.isSpriteMaterial ? l(p, m) : m.isShadowMaterial ? (p.color.value.copy(m.color), p.opacity.value = m.opacity) : m.isShaderMaterial && (m.uniformsNeedUpdate = !1);
        }
        function r(p, m) {
            p.opacity.value = m.opacity, m.color && p.diffuse.value.copy(m.color), m.emissive && p.emissive.value.copy(m.emissive).multiplyScalar(m.emissiveIntensity), m.map && (p.map.value = m.map, t(m.map, p.mapTransform)), m.alphaMap && (p.alphaMap.value = m.alphaMap, t(m.alphaMap, p.alphaMapTransform)), m.bumpMap && (p.bumpMap.value = m.bumpMap, t(m.bumpMap, p.bumpMapTransform), p.bumpScale.value = m.bumpScale, m.side === Jt && (p.bumpScale.value *= -1)), m.normalMap && (p.normalMap.value = m.normalMap, t(m.normalMap, p.normalMapTransform), p.normalScale.value.copy(m.normalScale), m.side === Jt && p.normalScale.value.negate()), m.displacementMap && (p.displacementMap.value = m.displacementMap, t(m.displacementMap, p.displacementMapTransform), p.displacementScale.value = m.displacementScale, p.displacementBias.value = m.displacementBias), m.emissiveMap && (p.emissiveMap.value = m.emissiveMap, t(m.emissiveMap, p.emissiveMapTransform)), m.specularMap && (p.specularMap.value = m.specularMap, t(m.specularMap, p.specularMapTransform)), m.alphaTest > 0 && (p.alphaTest.value = m.alphaTest);
            const v = e.get(m), y = v.envMap, x = v.envMapRotation;
            y && (p.envMap.value = y, Ai.copy(x), Ai.x *= -1, Ai.y *= -1, Ai.z *= -1, y.isCubeTexture && y.isRenderTargetTexture === !1 && (Ai.y *= -1, Ai.z *= -1), p.envMapRotation.value.setFromMatrix4(IS.makeRotationFromEuler(Ai)), p.flipEnvMap.value = y.isCubeTexture && y.isRenderTargetTexture === !1 ? -1 : 1, p.reflectivity.value = m.reflectivity, p.ior.value = m.ior, p.refractionRatio.value = m.refractionRatio), m.lightMap && (p.lightMap.value = m.lightMap, p.lightMapIntensity.value = m.lightMapIntensity, t(m.lightMap, p.lightMapTransform)), m.aoMap && (p.aoMap.value = m.aoMap, p.aoMapIntensity.value = m.aoMapIntensity, t(m.aoMap, p.aoMapTransform));
        }
        function a(p, m) {
            p.diffuse.value.copy(m.color), p.opacity.value = m.opacity, m.map && (p.map.value = m.map, t(m.map, p.mapTransform));
        }
        function o(p, m) {
            p.dashSize.value = m.dashSize, p.totalSize.value = m.dashSize + m.gapSize, p.scale.value = m.scale;
        }
        function c(p, m, v, y) {
            p.diffuse.value.copy(m.color), p.opacity.value = m.opacity, p.size.value = m.size * v, p.scale.value = y * .5, m.map && (p.map.value = m.map, t(m.map, p.uvTransform)), m.alphaMap && (p.alphaMap.value = m.alphaMap, t(m.alphaMap, p.alphaMapTransform)), m.alphaTest > 0 && (p.alphaTest.value = m.alphaTest);
        }
        function l(p, m) {
            p.diffuse.value.copy(m.color), p.opacity.value = m.opacity, p.rotation.value = m.rotation, m.map && (p.map.value = m.map, t(m.map, p.mapTransform)), m.alphaMap && (p.alphaMap.value = m.alphaMap, t(m.alphaMap, p.alphaMapTransform)), m.alphaTest > 0 && (p.alphaTest.value = m.alphaTest);
        }
        function h(p, m) {
            p.specular.value.copy(m.specular), p.shininess.value = Math.max(m.shininess, 1e-4);
        }
        function u(p, m) {
            m.gradientMap && (p.gradientMap.value = m.gradientMap);
        }
        function d(p, m) {
            p.metalness.value = m.metalness, m.metalnessMap && (p.metalnessMap.value = m.metalnessMap, t(m.metalnessMap, p.metalnessMapTransform)), p.roughness.value = m.roughness, m.roughnessMap && (p.roughnessMap.value = m.roughnessMap, t(m.roughnessMap, p.roughnessMapTransform)), m.envMap && (p.envMapIntensity.value = m.envMapIntensity);
        }
        function f(p, m, v) {
            p.ior.value = m.ior, m.sheen > 0 && (p.sheenColor.value.copy(m.sheenColor).multiplyScalar(m.sheen), p.sheenRoughness.value = m.sheenRoughness, m.sheenColorMap && (p.sheenColorMap.value = m.sheenColorMap, t(m.sheenColorMap, p.sheenColorMapTransform)), m.sheenRoughnessMap && (p.sheenRoughnessMap.value = m.sheenRoughnessMap, t(m.sheenRoughnessMap, p.sheenRoughnessMapTransform))), m.clearcoat > 0 && (p.clearcoat.value = m.clearcoat, p.clearcoatRoughness.value = m.clearcoatRoughness, m.clearcoatMap && (p.clearcoatMap.value = m.clearcoatMap, t(m.clearcoatMap, p.clearcoatMapTransform)), m.clearcoatRoughnessMap && (p.clearcoatRoughnessMap.value = m.clearcoatRoughnessMap, t(m.clearcoatRoughnessMap, p.clearcoatRoughnessMapTransform)), m.clearcoatNormalMap && (p.clearcoatNormalMap.value = m.clearcoatNormalMap, t(m.clearcoatNormalMap, p.clearcoatNormalMapTransform), p.clearcoatNormalScale.value.copy(m.clearcoatNormalScale), m.side === Jt && p.clearcoatNormalScale.value.negate())), m.dispersion > 0 && (p.dispersion.value = m.dispersion), m.iridescence > 0 && (p.iridescence.value = m.iridescence, p.iridescenceIOR.value = m.iridescenceIOR, p.iridescenceThicknessMinimum.value = m.iridescenceThicknessRange[0], p.iridescenceThicknessMaximum.value = m.iridescenceThicknessRange[1], m.iridescenceMap && (p.iridescenceMap.value = m.iridescenceMap, t(m.iridescenceMap, p.iridescenceMapTransform)), m.iridescenceThicknessMap && (p.iridescenceThicknessMap.value = m.iridescenceThicknessMap, t(m.iridescenceThicknessMap, p.iridescenceThicknessMapTransform))), m.transmission > 0 && (p.transmission.value = m.transmission, p.transmissionSamplerMap.value = v.texture, p.transmissionSamplerSize.value.set(v.width, v.height), m.transmissionMap && (p.transmissionMap.value = m.transmissionMap, t(m.transmissionMap, p.transmissionMapTransform)), p.thickness.value = m.thickness, m.thicknessMap && (p.thicknessMap.value = m.thicknessMap, t(m.thicknessMap, p.thicknessMapTransform)), p.attenuationDistance.value = m.attenuationDistance, p.attenuationColor.value.copy(m.attenuationColor)), m.anisotropy > 0 && (p.anisotropyVector.value.set(m.anisotropy * Math.cos(m.anisotropyRotation), m.anisotropy * Math.sin(m.anisotropyRotation)), m.anisotropyMap && (p.anisotropyMap.value = m.anisotropyMap, t(m.anisotropyMap, p.anisotropyMapTransform))), p.specularIntensity.value = m.specularIntensity, p.specularColor.value.copy(m.specularColor), m.specularColorMap && (p.specularColorMap.value = m.specularColorMap, t(m.specularColorMap, p.specularColorMapTransform)), m.specularIntensityMap && (p.specularIntensityMap.value = m.specularIntensityMap, t(m.specularIntensityMap, p.specularIntensityMapTransform));
        }
        function _(p, m) {
            m.matcap && (p.matcap.value = m.matcap);
        }
        function g(p, m) {
            const v = e.get(m).light;
            p.referencePosition.value.setFromMatrixPosition(v.matrixWorld), p.nearDistance.value = v.shadow.camera.near, p.farDistance.value = v.shadow.camera.far;
        }
        return {
            refreshFogUniforms: n,
            refreshMaterialUniforms: s
        };
    }
    function LS(i, e, t, n) {
        let s = {}, r = {}, a = [];
        const o = i.getParameter(i.MAX_UNIFORM_BUFFER_BINDINGS);
        function c(v, y) {
            const x = y.program;
            n.uniformBlockBinding(v, x);
        }
        function l(v, y) {
            let x = s[v.id];
            x === void 0 && (_(v), x = h(v), s[v.id] = x, v.addEventListener("dispose", p));
            const I = y.program;
            n.updateUBOMapping(v, I);
            const w = e.render.frame;
            r[v.id] !== w && (d(v), r[v.id] = w);
        }
        function h(v) {
            const y = u();
            v.__bindingPointIndex = y;
            const x = i.createBuffer(), I = v.__size, w = v.usage;
            return i.bindBuffer(i.UNIFORM_BUFFER, x), i.bufferData(i.UNIFORM_BUFFER, I, w), i.bindBuffer(i.UNIFORM_BUFFER, null), i.bindBufferBase(i.UNIFORM_BUFFER, y, x), x;
        }
        function u() {
            for(let v = 0; v < o; v++)if (a.indexOf(v) === -1) return a.push(v), v;
            return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
        }
        function d(v) {
            const y = s[v.id], x = v.uniforms, I = v.__cache;
            i.bindBuffer(i.UNIFORM_BUFFER, y);
            for(let w = 0, R = x.length; w < R; w++){
                const N = Array.isArray(x[w]) ? x[w] : [
                    x[w]
                ];
                for(let E = 0, S = N.length; E < S; E++){
                    const D = N[E];
                    if (f(D, w, E, I) === !0) {
                        const j = D.__offset, z = Array.isArray(D.value) ? D.value : [
                            D.value
                        ];
                        let K = 0;
                        for(let ne = 0; ne < z.length; ne++){
                            const b = z[ne], C = g(b);
                            typeof b == "number" || typeof b == "boolean" ? (D.__data[0] = b, i.bufferSubData(i.UNIFORM_BUFFER, j + K, D.__data)) : b.isMatrix3 ? (D.__data[0] = b.elements[0], D.__data[1] = b.elements[1], D.__data[2] = b.elements[2], D.__data[3] = 0, D.__data[4] = b.elements[3], D.__data[5] = b.elements[4], D.__data[6] = b.elements[5], D.__data[7] = 0, D.__data[8] = b.elements[6], D.__data[9] = b.elements[7], D.__data[10] = b.elements[8], D.__data[11] = 0) : (b.toArray(D.__data, K), K += C.storage / Float32Array.BYTES_PER_ELEMENT);
                        }
                        i.bufferSubData(i.UNIFORM_BUFFER, j, D.__data);
                    }
                }
            }
            i.bindBuffer(i.UNIFORM_BUFFER, null);
        }
        function f(v, y, x, I) {
            const w = v.value, R = y + "_" + x;
            if (I[R] === void 0) return typeof w == "number" || typeof w == "boolean" ? I[R] = w : I[R] = w.clone(), !0;
            {
                const N = I[R];
                if (typeof w == "number" || typeof w == "boolean") {
                    if (N !== w) return I[R] = w, !0;
                } else if (N.equals(w) === !1) return N.copy(w), !0;
            }
            return !1;
        }
        function _(v) {
            const y = v.uniforms;
            let x = 0;
            const I = 16;
            for(let R = 0, N = y.length; R < N; R++){
                const E = Array.isArray(y[R]) ? y[R] : [
                    y[R]
                ];
                for(let S = 0, D = E.length; S < D; S++){
                    const j = E[S], z = Array.isArray(j.value) ? j.value : [
                        j.value
                    ];
                    for(let K = 0, ne = z.length; K < ne; K++){
                        const b = z[K], C = g(b), A = x % I, U = A % C.boundary, B = A + U;
                        x += U, B !== 0 && I - B < C.storage && (x += I - B), j.__data = new Float32Array(C.storage / Float32Array.BYTES_PER_ELEMENT), j.__offset = x, x += C.storage;
                    }
                }
            }
            const w = x % I;
            return w > 0 && (x += I - w), v.__size = x, v.__cache = {}, this;
        }
        function g(v) {
            const y = {
                boundary: 0,
                storage: 0
            };
            return typeof v == "number" || typeof v == "boolean" ? (y.boundary = 4, y.storage = 4) : v.isVector2 ? (y.boundary = 8, y.storage = 8) : v.isVector3 || v.isColor ? (y.boundary = 16, y.storage = 12) : v.isVector4 ? (y.boundary = 16, y.storage = 16) : v.isMatrix3 ? (y.boundary = 48, y.storage = 48) : v.isMatrix4 ? (y.boundary = 64, y.storage = 64) : v.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", v), y;
        }
        function p(v) {
            const y = v.target;
            y.removeEventListener("dispose", p);
            const x = a.indexOf(y.__bindingPointIndex);
            a.splice(x, 1), i.deleteBuffer(s[y.id]), delete s[y.id], delete r[y.id];
        }
        function m() {
            for(const v in s)i.deleteBuffer(s[v]);
            a = [], s = {}, r = {};
        }
        return {
            bind: c,
            update: l,
            dispose: m
        };
    }
    let US = class {
        constructor(e = {}){
            const { canvas: t = Ig(), context: n = null, depth: s = !0, stencil: r = !1, alpha: a = !1, antialias: o = !1, premultipliedAlpha: c = !0, preserveDrawingBuffer: l = !1, powerPreference: h = "default", failIfMajorPerformanceCaveat: u = !1, reverseDepthBuffer: d = !1 } = e;
            this.isWebGLRenderer = !0;
            let f;
            if (n !== null) {
                if (typeof WebGLRenderingContext < "u" && n instanceof WebGLRenderingContext) throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
                f = n.getContextAttributes().alpha;
            } else f = a;
            const _ = new Uint32Array(4), g = new Int32Array(4);
            let p = null, m = null;
            const v = [], y = [];
            this.domElement = t, this.debug = {
                checkShaderErrors: !0,
                onShaderError: null
            }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.toneMapping = mi, this.toneMappingExposure = 1, this.transmissionResolutionScale = 1;
            const x = this;
            let I = !1;
            this._outputColorSpace = Dt;
            let w = 0, R = 0, N = null, E = -1, S = null;
            const D = new nt, j = new nt;
            let z = null;
            const K = new Be(0);
            let ne = 0, b = t.width, C = t.height, A = 1, U = null, B = null;
            const V = new nt(0, 0, b, C), q = new nt(0, 0, b, C);
            let te = !1;
            const H = new Zl;
            let $ = !1, oe = !1;
            const ie = new He, le = new He, we = new k, he = new nt, tt = {
                background: null,
                fog: null,
                environment: null,
                overrideMaterial: null,
                isScene: !0
            };
            let We = !1;
            function Le() {
                return N === null ? A : 1;
            }
            let L = n;
            function Ce(T, O) {
                return t.getContext(T, O);
            }
            try {
                const T = {
                    alpha: !0,
                    depth: s,
                    stencil: r,
                    antialias: o,
                    premultipliedAlpha: c,
                    preserveDrawingBuffer: l,
                    powerPreference: h,
                    failIfMajorPerformanceCaveat: u
                };
                if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${Ol}`), t.addEventListener("webglcontextlost", ee, !1), t.addEventListener("webglcontextrestored", _e, !1), t.addEventListener("webglcontextcreationerror", me, !1), L === null) {
                    const O = "webgl2";
                    if (L = Ce(O, T), L === null) throw Ce(O) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
                }
            } catch (T) {
                throw console.error("THREE.WebGLRenderer: " + T.message), T;
            }
            let ge, Xe, Ee, lt, Ae, P, M, W, Q, re, J, Te, fe, ve, Ze, ce, ye, Ie, Ue, be, je, ze, ht, F;
            function pe() {
                ge = new Wy(L), ge.init(), ze = new AS(L, ge), Xe = new Fy(L, ge, e, ze), Ee = new TS(L, ge), Xe.reverseDepthBuffer && d && Ee.buffers.depth.setReversed(!0), lt = new qy(L), Ae = new uS, P = new ES(L, ge, Ee, Ae, Xe, ze, lt), M = new ky(x), W = new Vy(x), Q = new Qx(L), ht = new Ny(L, Q), re = new Xy(L, Q, lt, ht), J = new $y(L, re, Q, lt), Ue = new jy(L, Xe, P), ce = new Oy(Ae), Te = new hS(x, M, W, ge, Xe, ht, ce), fe = new DS(x, Ae), ve = new fS, Ze = new vS(ge), Ie = new Uy(x, M, W, Ee, J, f, c), ye = new SS(x, J, Xe), F = new LS(L, lt, Xe, Ee), be = new By(L, ge, lt), je = new Yy(L, ge, lt), lt.programs = Te.programs, x.capabilities = Xe, x.extensions = ge, x.properties = Ae, x.renderLists = ve, x.shadowMap = ye, x.state = Ee, x.info = lt;
            }
            pe();
            const Z = new PS(x, L);
            this.xr = Z, this.getContext = function() {
                return L;
            }, this.getContextAttributes = function() {
                return L.getContextAttributes();
            }, this.forceContextLoss = function() {
                const T = ge.get("WEBGL_lose_context");
                T && T.loseContext();
            }, this.forceContextRestore = function() {
                const T = ge.get("WEBGL_lose_context");
                T && T.restoreContext();
            }, this.getPixelRatio = function() {
                return A;
            }, this.setPixelRatio = function(T) {
                T !== void 0 && (A = T, this.setSize(b, C, !1));
            }, this.getSize = function(T) {
                return T.set(b, C);
            }, this.setSize = function(T, O, X = !0) {
                if (Z.isPresenting) {
                    console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                    return;
                }
                b = T, C = O, t.width = Math.floor(T * A), t.height = Math.floor(O * A), X === !0 && (t.style.width = T + "px", t.style.height = O + "px"), this.setViewport(0, 0, T, O);
            }, this.getDrawingBufferSize = function(T) {
                return T.set(b * A, C * A).floor();
            }, this.setDrawingBufferSize = function(T, O, X) {
                b = T, C = O, A = X, t.width = Math.floor(T * X), t.height = Math.floor(O * X), this.setViewport(0, 0, T, O);
            }, this.getCurrentViewport = function(T) {
                return T.copy(D);
            }, this.getViewport = function(T) {
                return T.copy(V);
            }, this.setViewport = function(T, O, X, Y) {
                T.isVector4 ? V.set(T.x, T.y, T.z, T.w) : V.set(T, O, X, Y), Ee.viewport(D.copy(V).multiplyScalar(A).round());
            }, this.getScissor = function(T) {
                return T.copy(q);
            }, this.setScissor = function(T, O, X, Y) {
                T.isVector4 ? q.set(T.x, T.y, T.z, T.w) : q.set(T, O, X, Y), Ee.scissor(j.copy(q).multiplyScalar(A).round());
            }, this.getScissorTest = function() {
                return te;
            }, this.setScissorTest = function(T) {
                Ee.setScissorTest(te = T);
            }, this.setOpaqueSort = function(T) {
                U = T;
            }, this.setTransparentSort = function(T) {
                B = T;
            }, this.getClearColor = function(T) {
                return T.copy(Ie.getClearColor());
            }, this.setClearColor = function() {
                Ie.setClearColor(...arguments);
            }, this.getClearAlpha = function() {
                return Ie.getClearAlpha();
            }, this.setClearAlpha = function() {
                Ie.setClearAlpha(...arguments);
            }, this.clear = function(T = !0, O = !0, X = !0) {
                let Y = 0;
                if (T) {
                    let G = !1;
                    if (N !== null) {
                        const ae = N.texture.format;
                        G = ae === Xl || ae === Wl || ae === Vl;
                    }
                    if (G) {
                        const ae = N.texture.type, de = ae === ni || ae === zi || ae === br || ae === Sr || ae === Gl || ae === Hl, xe = Ie.getClearColor(), Se = Ie.getClearAlpha(), Ne = xe.r, De = xe.g, Re = xe.b;
                        de ? (_[0] = Ne, _[1] = De, _[2] = Re, _[3] = Se, L.clearBufferuiv(L.COLOR, 0, _)) : (g[0] = Ne, g[1] = De, g[2] = Re, g[3] = Se, L.clearBufferiv(L.COLOR, 0, g));
                    } else Y |= L.COLOR_BUFFER_BIT;
                }
                O && (Y |= L.DEPTH_BUFFER_BIT), X && (Y |= L.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), L.clear(Y);
            }, this.clearColor = function() {
                this.clear(!0, !1, !1);
            }, this.clearDepth = function() {
                this.clear(!1, !0, !1);
            }, this.clearStencil = function() {
                this.clear(!1, !1, !0);
            }, this.dispose = function() {
                t.removeEventListener("webglcontextlost", ee, !1), t.removeEventListener("webglcontextrestored", _e, !1), t.removeEventListener("webglcontextcreationerror", me, !1), Ie.dispose(), ve.dispose(), Ze.dispose(), Ae.dispose(), M.dispose(), W.dispose(), J.dispose(), ht.dispose(), F.dispose(), Te.dispose(), Z.dispose(), Z.removeEventListener("sessionstart", Nh), Z.removeEventListener("sessionend", Bh), vi.stop();
            };
            function ee(T) {
                T.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), I = !0;
            }
            function _e() {
                console.log("THREE.WebGLRenderer: Context Restored."), I = !1;
                const T = lt.autoReset, O = ye.enabled, X = ye.autoUpdate, Y = ye.needsUpdate, G = ye.type;
                pe(), lt.autoReset = T, ye.enabled = O, ye.autoUpdate = X, ye.needsUpdate = Y, ye.type = G;
            }
            function me(T) {
                console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", T.statusMessage);
            }
            function ke(T) {
                const O = T.target;
                O.removeEventListener("dispose", ke), xt(O);
            }
            function xt(T) {
                Bt(T), Ae.remove(T);
            }
            function Bt(T) {
                const O = Ae.get(T).programs;
                O !== void 0 && (O.forEach(function(X) {
                    Te.releaseProgram(X);
                }), T.isShaderMaterial && Te.releaseShaderCache(T));
            }
            this.renderBufferDirect = function(T, O, X, Y, G, ae) {
                O === null && (O = tt);
                const de = G.isMesh && G.matrixWorld.determinant() < 0, xe = x_(T, O, X, Y, G);
                Ee.setMaterial(Y, de);
                let Se = X.index, Ne = 1;
                if (Y.wireframe === !0) {
                    if (Se = re.getWireframeAttribute(X), Se === void 0) return;
                    Ne = 2;
                }
                const De = X.drawRange, Re = X.attributes.position;
                let Je = De.start * Ne, it = (De.start + De.count) * Ne;
                ae !== null && (Je = Math.max(Je, ae.start * Ne), it = Math.min(it, (ae.start + ae.count) * Ne)), Se !== null ? (Je = Math.max(Je, 0), it = Math.min(it, Se.count)) : Re != null && (Je = Math.max(Je, 0), it = Math.min(it, Re.count));
                const Mt = it - Je;
                if (Mt < 0 || Mt === 1 / 0) return;
                ht.setup(G, Y, xe, X, Se);
                let vt, Qe = be;
                if (Se !== null && (vt = Q.get(Se), Qe = je, Qe.setIndex(vt)), G.isMesh) Y.wireframe === !0 ? (Ee.setLineWidth(Y.wireframeLinewidth * Le()), Qe.setMode(L.LINES)) : Qe.setMode(L.TRIANGLES);
                else if (G.isLine) {
                    let Pe = Y.linewidth;
                    Pe === void 0 && (Pe = 1), Ee.setLineWidth(Pe * Le()), G.isLineSegments ? Qe.setMode(L.LINES) : G.isLineLoop ? Qe.setMode(L.LINE_LOOP) : Qe.setMode(L.LINE_STRIP);
                } else G.isPoints ? Qe.setMode(L.POINTS) : G.isSprite && Qe.setMode(L.TRIANGLES);
                if (G.isBatchedMesh) if (G._multiDrawInstances !== null) Ia("THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."), Qe.renderMultiDrawInstances(G._multiDrawStarts, G._multiDrawCounts, G._multiDrawCount, G._multiDrawInstances);
                else if (ge.get("WEBGL_multi_draw")) Qe.renderMultiDraw(G._multiDrawStarts, G._multiDrawCounts, G._multiDrawCount);
                else {
                    const Pe = G._multiDrawStarts, It = G._multiDrawCounts, st = G._multiDrawCount, mn = Se ? Q.get(Se).bytesPerElement : 1, Ji = Ae.get(Y).currentProgram.getUniforms();
                    for(let tn = 0; tn < st; tn++)Ji.setValue(L, "_gl_DrawID", tn), Qe.render(Pe[tn] / mn, It[tn]);
                }
                else if (G.isInstancedMesh) Qe.renderInstances(Je, Mt, G.count);
                else if (X.isInstancedBufferGeometry) {
                    const Pe = X._maxInstanceCount !== void 0 ? X._maxInstanceCount : 1 / 0, It = Math.min(X.instanceCount, Pe);
                    Qe.renderInstances(Je, Mt, It);
                } else Qe.render(Je, Mt);
            };
            function at(T, O, X) {
                T.transparent === !0 && T.side === Un && T.forceSinglePass === !1 ? (T.side = Jt, T.needsUpdate = !0, kr(T, O, X), T.side = ti, T.needsUpdate = !0, kr(T, O, X), T.side = Un) : kr(T, O, X);
            }
            this.compile = function(T, O, X = null) {
                X === null && (X = T), m = Ze.get(X), m.init(O), y.push(m), X.traverseVisible(function(G) {
                    G.isLight && G.layers.test(O.layers) && (m.pushLight(G), G.castShadow && m.pushShadow(G));
                }), T !== X && T.traverseVisible(function(G) {
                    G.isLight && G.layers.test(O.layers) && (m.pushLight(G), G.castShadow && m.pushShadow(G));
                }), m.setupLights();
                const Y = new Set;
                return T.traverse(function(G) {
                    if (!(G.isMesh || G.isPoints || G.isLine || G.isSprite)) return;
                    const ae = G.material;
                    if (ae) if (Array.isArray(ae)) for(let de = 0; de < ae.length; de++){
                        const xe = ae[de];
                        at(xe, X, G), Y.add(xe);
                    }
                    else at(ae, X, G), Y.add(ae);
                }), m = y.pop(), Y;
            }, this.compileAsync = function(T, O, X = null) {
                const Y = this.compile(T, O, X);
                return new Promise((G)=>{
                    function ae() {
                        if (Y.forEach(function(de) {
                            Ae.get(de).currentProgram.isReady() && Y.delete(de);
                        }), Y.size === 0) {
                            G(T);
                            return;
                        }
                        setTimeout(ae, 10);
                    }
                    ge.get("KHR_parallel_shader_compile") !== null ? ae() : setTimeout(ae, 10);
                });
            };
            let pn = null;
            function Gn(T) {
                pn && pn(T);
            }
            function Nh() {
                vi.stop();
            }
            function Bh() {
                vi.start();
            }
            const vi = new np;
            vi.setAnimationLoop(Gn), typeof self < "u" && vi.setContext(self), this.setAnimationLoop = function(T) {
                pn = T, Z.setAnimationLoop(T), T === null ? vi.stop() : vi.start();
            }, Z.addEventListener("sessionstart", Nh), Z.addEventListener("sessionend", Bh), this.render = function(T, O) {
                if (O !== void 0 && O.isCamera !== !0) {
                    console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                    return;
                }
                if (I === !0) return;
                if (T.matrixWorldAutoUpdate === !0 && T.updateMatrixWorld(), O.parent === null && O.matrixWorldAutoUpdate === !0 && O.updateMatrixWorld(), Z.enabled === !0 && Z.isPresenting === !0 && (Z.cameraAutoUpdate === !0 && Z.updateCamera(O), O = Z.getCamera()), T.isScene === !0 && T.onBeforeRender(x, T, O, N), m = Ze.get(T, y.length), m.init(O), y.push(m), le.multiplyMatrices(O.projectionMatrix, O.matrixWorldInverse), H.setFromProjectionMatrix(le), oe = this.localClippingEnabled, $ = ce.init(this.clippingPlanes, oe), p = ve.get(T, v.length), p.init(), v.push(p), Z.enabled === !0 && Z.isPresenting === !0) {
                    const ae = x.xr.getDepthSensingMesh();
                    ae !== null && no(ae, O, -1 / 0, x.sortObjects);
                }
                no(T, O, 0, x.sortObjects), p.finish(), x.sortObjects === !0 && p.sort(U, B), We = Z.enabled === !1 || Z.isPresenting === !1 || Z.hasDepthSensing() === !1, We && Ie.addToRenderList(p, T), this.info.render.frame++, $ === !0 && ce.beginShadows();
                const X = m.state.shadowsArray;
                ye.render(X, T, O), $ === !0 && ce.endShadows(), this.info.autoReset === !0 && this.info.reset();
                const Y = p.opaque, G = p.transmissive;
                if (m.setupLights(), O.isArrayCamera) {
                    const ae = O.cameras;
                    if (G.length > 0) for(let de = 0, xe = ae.length; de < xe; de++){
                        const Se = ae[de];
                        Oh(Y, G, T, Se);
                    }
                    We && Ie.render(T);
                    for(let de = 0, xe = ae.length; de < xe; de++){
                        const Se = ae[de];
                        Fh(p, T, Se, Se.viewport);
                    }
                } else G.length > 0 && Oh(Y, G, T, O), We && Ie.render(T), Fh(p, T, O);
                N !== null && R === 0 && (P.updateMultisampleRenderTarget(N), P.updateRenderTargetMipmap(N)), T.isScene === !0 && T.onAfterRender(x, T, O), ht.resetDefaultState(), E = -1, S = null, y.pop(), y.length > 0 ? (m = y[y.length - 1], $ === !0 && ce.setGlobalState(x.clippingPlanes, m.state.camera)) : m = null, v.pop(), v.length > 0 ? p = v[v.length - 1] : p = null;
            };
            function no(T, O, X, Y) {
                if (T.visible === !1) return;
                if (T.layers.test(O.layers)) {
                    if (T.isGroup) X = T.renderOrder;
                    else if (T.isLOD) T.autoUpdate === !0 && T.update(O);
                    else if (T.isLight) m.pushLight(T), T.castShadow && m.pushShadow(T);
                    else if (T.isSprite) {
                        if (!T.frustumCulled || H.intersectsSprite(T)) {
                            Y && he.setFromMatrixPosition(T.matrixWorld).applyMatrix4(le);
                            const de = J.update(T), xe = T.material;
                            xe.visible && p.push(T, de, xe, X, he.z, null);
                        }
                    } else if ((T.isMesh || T.isLine || T.isPoints) && (!T.frustumCulled || H.intersectsObject(T))) {
                        const de = J.update(T), xe = T.material;
                        if (Y && (T.boundingSphere !== void 0 ? (T.boundingSphere === null && T.computeBoundingSphere(), he.copy(T.boundingSphere.center)) : (de.boundingSphere === null && de.computeBoundingSphere(), he.copy(de.boundingSphere.center)), he.applyMatrix4(T.matrixWorld).applyMatrix4(le)), Array.isArray(xe)) {
                            const Se = de.groups;
                            for(let Ne = 0, De = Se.length; Ne < De; Ne++){
                                const Re = Se[Ne], Je = xe[Re.materialIndex];
                                Je && Je.visible && p.push(T, de, Je, X, he.z, Re);
                            }
                        } else xe.visible && p.push(T, de, xe, X, he.z, null);
                    }
                }
                const ae = T.children;
                for(let de = 0, xe = ae.length; de < xe; de++)no(ae[de], O, X, Y);
            }
            function Fh(T, O, X, Y) {
                const G = T.opaque, ae = T.transmissive, de = T.transparent;
                m.setupLightsView(X), $ === !0 && ce.setGlobalState(x.clippingPlanes, X), Y && Ee.viewport(D.copy(Y)), G.length > 0 && Or(G, O, X), ae.length > 0 && Or(ae, O, X), de.length > 0 && Or(de, O, X), Ee.buffers.depth.setTest(!0), Ee.buffers.depth.setMask(!0), Ee.buffers.color.setMask(!0), Ee.setPolygonOffset(!1);
            }
            function Oh(T, O, X, Y) {
                if ((X.isScene === !0 ? X.overrideMaterial : null) !== null) return;
                m.state.transmissionRenderTarget[Y.id] === void 0 && (m.state.transmissionRenderTarget[Y.id] = new Vi(1, 1, {
                    generateMipmaps: !0,
                    type: ge.has("EXT_color_buffer_half_float") || ge.has("EXT_color_buffer_float") ? Lr : ni,
                    minFilter: Kn,
                    samples: 4,
                    stencilBuffer: r,
                    resolveDepthBuffer: !1,
                    resolveStencilBuffer: !1,
                    colorSpace: $e.workingColorSpace
                }));
                const ae = m.state.transmissionRenderTarget[Y.id], de = Y.viewport || D;
                ae.setSize(de.z * x.transmissionResolutionScale, de.w * x.transmissionResolutionScale);
                const xe = x.getRenderTarget();
                x.setRenderTarget(ae), x.getClearColor(K), ne = x.getClearAlpha(), ne < 1 && x.setClearColor(16777215, .5), x.clear(), We && Ie.render(X);
                const Se = x.toneMapping;
                x.toneMapping = mi;
                const Ne = Y.viewport;
                if (Y.viewport !== void 0 && (Y.viewport = void 0), m.setupLightsView(Y), $ === !0 && ce.setGlobalState(x.clippingPlanes, Y), Or(T, X, Y), P.updateMultisampleRenderTarget(ae), P.updateRenderTargetMipmap(ae), ge.has("WEBGL_multisampled_render_to_texture") === !1) {
                    let De = !1;
                    for(let Re = 0, Je = O.length; Re < Je; Re++){
                        const it = O[Re], Mt = it.object, vt = it.geometry, Qe = it.material, Pe = it.group;
                        if (Qe.side === Un && Mt.layers.test(Y.layers)) {
                            const It = Qe.side;
                            Qe.side = Jt, Qe.needsUpdate = !0, kh(Mt, X, Y, vt, Qe, Pe), Qe.side = It, Qe.needsUpdate = !0, De = !0;
                        }
                    }
                    De === !0 && (P.updateMultisampleRenderTarget(ae), P.updateRenderTargetMipmap(ae));
                }
                x.setRenderTarget(xe), x.setClearColor(K, ne), Ne !== void 0 && (Y.viewport = Ne), x.toneMapping = Se;
            }
            function Or(T, O, X) {
                const Y = O.isScene === !0 ? O.overrideMaterial : null;
                for(let G = 0, ae = T.length; G < ae; G++){
                    const de = T[G], xe = de.object, Se = de.geometry, Ne = de.group;
                    let De = de.material;
                    De.allowOverride === !0 && Y !== null && (De = Y), xe.layers.test(X.layers) && kh(xe, O, X, Se, De, Ne);
                }
            }
            function kh(T, O, X, Y, G, ae) {
                T.onBeforeRender(x, O, X, Y, G, ae), T.modelViewMatrix.multiplyMatrices(X.matrixWorldInverse, T.matrixWorld), T.normalMatrix.getNormalMatrix(T.modelViewMatrix), G.onBeforeRender(x, O, X, Y, T, ae), G.transparent === !0 && G.side === Un && G.forceSinglePass === !1 ? (G.side = Jt, G.needsUpdate = !0, x.renderBufferDirect(X, O, Y, G, T, ae), G.side = ti, G.needsUpdate = !0, x.renderBufferDirect(X, O, Y, G, T, ae), G.side = Un) : x.renderBufferDirect(X, O, Y, G, T, ae), T.onAfterRender(x, O, X, Y, G, ae);
            }
            function kr(T, O, X) {
                O.isScene !== !0 && (O = tt);
                const Y = Ae.get(T), G = m.state.lights, ae = m.state.shadowsArray, de = G.state.version, xe = Te.getParameters(T, G.state, ae, O, X), Se = Te.getProgramCacheKey(xe);
                let Ne = Y.programs;
                Y.environment = T.isMeshStandardMaterial ? O.environment : null, Y.fog = O.fog, Y.envMap = (T.isMeshStandardMaterial ? W : M).get(T.envMap || Y.environment), Y.envMapRotation = Y.environment !== null && T.envMap === null ? O.environmentRotation : T.envMapRotation, Ne === void 0 && (T.addEventListener("dispose", ke), Ne = new Map, Y.programs = Ne);
                let De = Ne.get(Se);
                if (De !== void 0) {
                    if (Y.currentProgram === De && Y.lightsStateVersion === de) return Hh(T, xe), De;
                } else xe.uniforms = Te.getUniforms(T), T.onBeforeCompile(xe, x), De = Te.acquireProgram(xe, Se), Ne.set(Se, De), Y.uniforms = xe.uniforms;
                const Re = Y.uniforms;
                return (!T.isShaderMaterial && !T.isRawShaderMaterial || T.clipping === !0) && (Re.clippingPlanes = ce.uniform), Hh(T, xe), Y.needsLights = y_(T), Y.lightsStateVersion = de, Y.needsLights && (Re.ambientLightColor.value = G.state.ambient, Re.lightProbe.value = G.state.probe, Re.directionalLights.value = G.state.directional, Re.directionalLightShadows.value = G.state.directionalShadow, Re.spotLights.value = G.state.spot, Re.spotLightShadows.value = G.state.spotShadow, Re.rectAreaLights.value = G.state.rectArea, Re.ltc_1.value = G.state.rectAreaLTC1, Re.ltc_2.value = G.state.rectAreaLTC2, Re.pointLights.value = G.state.point, Re.pointLightShadows.value = G.state.pointShadow, Re.hemisphereLights.value = G.state.hemi, Re.directionalShadowMap.value = G.state.directionalShadowMap, Re.directionalShadowMatrix.value = G.state.directionalShadowMatrix, Re.spotShadowMap.value = G.state.spotShadowMap, Re.spotLightMatrix.value = G.state.spotLightMatrix, Re.spotLightMap.value = G.state.spotLightMap, Re.pointShadowMap.value = G.state.pointShadowMap, Re.pointShadowMatrix.value = G.state.pointShadowMatrix), Y.currentProgram = De, Y.uniformsList = null, De;
            }
            function Gh(T) {
                if (T.uniformsList === null) {
                    const O = T.currentProgram.getUniforms();
                    T.uniformsList = La.seqWithValue(O.seq, T.uniforms);
                }
                return T.uniformsList;
            }
            function Hh(T, O) {
                const X = Ae.get(T);
                X.outputColorSpace = O.outputColorSpace, X.batching = O.batching, X.batchingColor = O.batchingColor, X.instancing = O.instancing, X.instancingColor = O.instancingColor, X.instancingMorph = O.instancingMorph, X.skinning = O.skinning, X.morphTargets = O.morphTargets, X.morphNormals = O.morphNormals, X.morphColors = O.morphColors, X.morphTargetsCount = O.morphTargetsCount, X.numClippingPlanes = O.numClippingPlanes, X.numIntersection = O.numClipIntersection, X.vertexAlphas = O.vertexAlphas, X.vertexTangents = O.vertexTangents, X.toneMapping = O.toneMapping;
            }
            function x_(T, O, X, Y, G) {
                O.isScene !== !0 && (O = tt), P.resetTextureUnits();
                const ae = O.fog, de = Y.isMeshStandardMaterial ? O.environment : null, xe = N === null ? x.outputColorSpace : N.isXRRenderTarget === !0 ? N.texture.colorSpace : $t, Se = (Y.isMeshStandardMaterial ? W : M).get(Y.envMap || de), Ne = Y.vertexColors === !0 && !!X.attributes.color && X.attributes.color.itemSize === 4, De = !!X.attributes.tangent && (!!Y.normalMap || Y.anisotropy > 0), Re = !!X.morphAttributes.position, Je = !!X.morphAttributes.normal, it = !!X.morphAttributes.color;
                let Mt = mi;
                Y.toneMapped && (N === null || N.isXRRenderTarget === !0) && (Mt = x.toneMapping);
                const vt = X.morphAttributes.position || X.morphAttributes.normal || X.morphAttributes.color, Qe = vt !== void 0 ? vt.length : 0, Pe = Ae.get(Y), It = m.state.lights;
                if ($ === !0 && (oe === !0 || T !== S)) {
                    const Ht = T === S && Y.id === E;
                    ce.setState(Y, T, Ht);
                }
                let st = !1;
                Y.version === Pe.__version ? (Pe.needsLights && Pe.lightsStateVersion !== It.state.version || Pe.outputColorSpace !== xe || G.isBatchedMesh && Pe.batching === !1 || !G.isBatchedMesh && Pe.batching === !0 || G.isBatchedMesh && Pe.batchingColor === !0 && G.colorTexture === null || G.isBatchedMesh && Pe.batchingColor === !1 && G.colorTexture !== null || G.isInstancedMesh && Pe.instancing === !1 || !G.isInstancedMesh && Pe.instancing === !0 || G.isSkinnedMesh && Pe.skinning === !1 || !G.isSkinnedMesh && Pe.skinning === !0 || G.isInstancedMesh && Pe.instancingColor === !0 && G.instanceColor === null || G.isInstancedMesh && Pe.instancingColor === !1 && G.instanceColor !== null || G.isInstancedMesh && Pe.instancingMorph === !0 && G.morphTexture === null || G.isInstancedMesh && Pe.instancingMorph === !1 && G.morphTexture !== null || Pe.envMap !== Se || Y.fog === !0 && Pe.fog !== ae || Pe.numClippingPlanes !== void 0 && (Pe.numClippingPlanes !== ce.numPlanes || Pe.numIntersection !== ce.numIntersection) || Pe.vertexAlphas !== Ne || Pe.vertexTangents !== De || Pe.morphTargets !== Re || Pe.morphNormals !== Je || Pe.morphColors !== it || Pe.toneMapping !== Mt || Pe.morphTargetsCount !== Qe) && (st = !0) : (st = !0, Pe.__version = Y.version);
                let mn = Pe.currentProgram;
                st === !0 && (mn = kr(Y, O, G));
                let Ji = !1, tn = !1, Xs = !1;
                const dt = mn.getUniforms(), on = Pe.uniforms;
                if (Ee.useProgram(mn.program) && (Ji = !0, tn = !0, Xs = !0), Y.id !== E && (E = Y.id, tn = !0), Ji || S !== T) {
                    Ee.buffers.depth.getReversed() ? (ie.copy(T.projectionMatrix), Lg(ie), Ug(ie), dt.setValue(L, "projectionMatrix", ie)) : dt.setValue(L, "projectionMatrix", T.projectionMatrix), dt.setValue(L, "viewMatrix", T.matrixWorldInverse);
                    const Kt = dt.map.cameraPosition;
                    Kt !== void 0 && Kt.setValue(L, we.setFromMatrixPosition(T.matrixWorld)), Xe.logarithmicDepthBuffer && dt.setValue(L, "logDepthBufFC", 2 / (Math.log(T.far + 1) / Math.LN2)), (Y.isMeshPhongMaterial || Y.isMeshToonMaterial || Y.isMeshLambertMaterial || Y.isMeshBasicMaterial || Y.isMeshStandardMaterial || Y.isShaderMaterial) && dt.setValue(L, "isOrthographic", T.isOrthographicCamera === !0), S !== T && (S = T, tn = !0, Xs = !0);
                }
                if (G.isSkinnedMesh) {
                    dt.setOptional(L, G, "bindMatrix"), dt.setOptional(L, G, "bindMatrixInverse");
                    const Ht = G.skeleton;
                    Ht && (Ht.boneTexture === null && Ht.computeBoneTexture(), dt.setValue(L, "boneTexture", Ht.boneTexture, P));
                }
                G.isBatchedMesh && (dt.setOptional(L, G, "batchingTexture"), dt.setValue(L, "batchingTexture", G._matricesTexture, P), dt.setOptional(L, G, "batchingIdTexture"), dt.setValue(L, "batchingIdTexture", G._indirectTexture, P), dt.setOptional(L, G, "batchingColorTexture"), G._colorsTexture !== null && dt.setValue(L, "batchingColorTexture", G._colorsTexture, P));
                const cn = X.morphAttributes;
                if ((cn.position !== void 0 || cn.normal !== void 0 || cn.color !== void 0) && Ue.update(G, X, mn), (tn || Pe.receiveShadow !== G.receiveShadow) && (Pe.receiveShadow = G.receiveShadow, dt.setValue(L, "receiveShadow", G.receiveShadow)), Y.isMeshGouraudMaterial && Y.envMap !== null && (on.envMap.value = Se, on.flipEnvMap.value = Se.isCubeTexture && Se.isRenderTargetTexture === !1 ? -1 : 1), Y.isMeshStandardMaterial && Y.envMap === null && O.environment !== null && (on.envMapIntensity.value = O.environmentIntensity), tn && (dt.setValue(L, "toneMappingExposure", x.toneMappingExposure), Pe.needsLights && v_(on, Xs), ae && Y.fog === !0 && fe.refreshFogUniforms(on, ae), fe.refreshMaterialUniforms(on, Y, A, C, m.state.transmissionRenderTarget[T.id]), La.upload(L, Gh(Pe), on, P)), Y.isShaderMaterial && Y.uniformsNeedUpdate === !0 && (La.upload(L, Gh(Pe), on, P), Y.uniformsNeedUpdate = !1), Y.isSpriteMaterial && dt.setValue(L, "center", G.center), dt.setValue(L, "modelViewMatrix", G.modelViewMatrix), dt.setValue(L, "normalMatrix", G.normalMatrix), dt.setValue(L, "modelMatrix", G.matrixWorld), Y.isShaderMaterial || Y.isRawShaderMaterial) {
                    const Ht = Y.uniformsGroups;
                    for(let Kt = 0, io = Ht.length; Kt < io; Kt++){
                        const yi = Ht[Kt];
                        F.update(yi, mn), F.bind(yi, mn);
                    }
                }
                return mn;
            }
            function v_(T, O) {
                T.ambientLightColor.needsUpdate = O, T.lightProbe.needsUpdate = O, T.directionalLights.needsUpdate = O, T.directionalLightShadows.needsUpdate = O, T.pointLights.needsUpdate = O, T.pointLightShadows.needsUpdate = O, T.spotLights.needsUpdate = O, T.spotLightShadows.needsUpdate = O, T.rectAreaLights.needsUpdate = O, T.hemisphereLights.needsUpdate = O;
            }
            function y_(T) {
                return T.isMeshLambertMaterial || T.isMeshToonMaterial || T.isMeshPhongMaterial || T.isMeshStandardMaterial || T.isShadowMaterial || T.isShaderMaterial && T.lights === !0;
            }
            this.getActiveCubeFace = function() {
                return w;
            }, this.getActiveMipmapLevel = function() {
                return R;
            }, this.getRenderTarget = function() {
                return N;
            }, this.setRenderTargetTextures = function(T, O, X) {
                const Y = Ae.get(T);
                Y.__autoAllocateDepthBuffer = T.resolveDepthBuffer === !1, Y.__autoAllocateDepthBuffer === !1 && (Y.__useRenderToTexture = !1), Ae.get(T.texture).__webglTexture = O, Ae.get(T.depthTexture).__webglTexture = Y.__autoAllocateDepthBuffer ? void 0 : X, Y.__hasExternalTextures = !0;
            }, this.setRenderTargetFramebuffer = function(T, O) {
                const X = Ae.get(T);
                X.__webglFramebuffer = O, X.__useDefaultFramebuffer = O === void 0;
            };
            const b_ = L.createFramebuffer();
            this.setRenderTarget = function(T, O = 0, X = 0) {
                N = T, w = O, R = X;
                let Y = !0, G = null, ae = !1, de = !1;
                if (T) {
                    const Se = Ae.get(T);
                    if (Se.__useDefaultFramebuffer !== void 0) Ee.bindFramebuffer(L.FRAMEBUFFER, null), Y = !1;
                    else if (Se.__webglFramebuffer === void 0) P.setupRenderTarget(T);
                    else if (Se.__hasExternalTextures) P.rebindTextures(T, Ae.get(T.texture).__webglTexture, Ae.get(T.depthTexture).__webglTexture);
                    else if (T.depthBuffer) {
                        const Re = T.depthTexture;
                        if (Se.__boundDepthTexture !== Re) {
                            if (Re !== null && Ae.has(Re) && (T.width !== Re.image.width || T.height !== Re.image.height)) throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
                            P.setupDepthRenderbuffer(T);
                        }
                    }
                    const Ne = T.texture;
                    (Ne.isData3DTexture || Ne.isDataArrayTexture || Ne.isCompressedArrayTexture) && (de = !0);
                    const De = Ae.get(T).__webglFramebuffer;
                    T.isWebGLCubeRenderTarget ? (Array.isArray(De[O]) ? G = De[O][X] : G = De[O], ae = !0) : T.samples > 0 && P.useMultisampledRTT(T) === !1 ? G = Ae.get(T).__webglMultisampledFramebuffer : Array.isArray(De) ? G = De[X] : G = De, D.copy(T.viewport), j.copy(T.scissor), z = T.scissorTest;
                } else D.copy(V).multiplyScalar(A).floor(), j.copy(q).multiplyScalar(A).floor(), z = te;
                if (X !== 0 && (G = b_), Ee.bindFramebuffer(L.FRAMEBUFFER, G) && Y && Ee.drawBuffers(T, G), Ee.viewport(D), Ee.scissor(j), Ee.setScissorTest(z), ae) {
                    const Se = Ae.get(T.texture);
                    L.framebufferTexture2D(L.FRAMEBUFFER, L.COLOR_ATTACHMENT0, L.TEXTURE_CUBE_MAP_POSITIVE_X + O, Se.__webglTexture, X);
                } else if (de) {
                    const Se = Ae.get(T.texture), Ne = O;
                    L.framebufferTextureLayer(L.FRAMEBUFFER, L.COLOR_ATTACHMENT0, Se.__webglTexture, X, Ne);
                } else if (T !== null && X !== 0) {
                    const Se = Ae.get(T.texture);
                    L.framebufferTexture2D(L.FRAMEBUFFER, L.COLOR_ATTACHMENT0, L.TEXTURE_2D, Se.__webglTexture, X);
                }
                E = -1;
            }, this.readRenderTargetPixels = function(T, O, X, Y, G, ae, de) {
                if (!(T && T.isWebGLRenderTarget)) {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                    return;
                }
                let xe = Ae.get(T).__webglFramebuffer;
                if (T.isWebGLCubeRenderTarget && de !== void 0 && (xe = xe[de]), xe) {
                    Ee.bindFramebuffer(L.FRAMEBUFFER, xe);
                    try {
                        const Se = T.texture, Ne = Se.format, De = Se.type;
                        if (!Xe.textureFormatReadable(Ne)) {
                            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                            return;
                        }
                        if (!Xe.textureTypeReadable(De)) {
                            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                            return;
                        }
                        O >= 0 && O <= T.width - Y && X >= 0 && X <= T.height - G && L.readPixels(O, X, Y, G, ze.convert(Ne), ze.convert(De), ae);
                    } finally{
                        const Se = N !== null ? Ae.get(N).__webglFramebuffer : null;
                        Ee.bindFramebuffer(L.FRAMEBUFFER, Se);
                    }
                }
            }, this.readRenderTargetPixelsAsync = async function(T, O, X, Y, G, ae, de) {
                if (!(T && T.isWebGLRenderTarget)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                let xe = Ae.get(T).__webglFramebuffer;
                if (T.isWebGLCubeRenderTarget && de !== void 0 && (xe = xe[de]), xe) if (O >= 0 && O <= T.width - Y && X >= 0 && X <= T.height - G) {
                    Ee.bindFramebuffer(L.FRAMEBUFFER, xe);
                    const Se = T.texture, Ne = Se.format, De = Se.type;
                    if (!Xe.textureFormatReadable(Ne)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
                    if (!Xe.textureTypeReadable(De)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
                    const Re = L.createBuffer();
                    L.bindBuffer(L.PIXEL_PACK_BUFFER, Re), L.bufferData(L.PIXEL_PACK_BUFFER, ae.byteLength, L.STREAM_READ), L.readPixels(O, X, Y, G, ze.convert(Ne), ze.convert(De), 0);
                    const Je = N !== null ? Ae.get(N).__webglFramebuffer : null;
                    Ee.bindFramebuffer(L.FRAMEBUFFER, Je);
                    const it = L.fenceSync(L.SYNC_GPU_COMMANDS_COMPLETE, 0);
                    return L.flush(), await Dg(L, it, 4), L.bindBuffer(L.PIXEL_PACK_BUFFER, Re), L.getBufferSubData(L.PIXEL_PACK_BUFFER, 0, ae), L.deleteBuffer(Re), L.deleteSync(it), ae;
                } else throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.");
            }, this.copyFramebufferToTexture = function(T, O = null, X = 0) {
                const Y = Math.pow(2, -X), G = Math.floor(T.image.width * Y), ae = Math.floor(T.image.height * Y), de = O !== null ? O.x : 0, xe = O !== null ? O.y : 0;
                P.setTexture2D(T, 0), L.copyTexSubImage2D(L.TEXTURE_2D, X, 0, 0, de, xe, G, ae), Ee.unbindTexture();
            };
            const S_ = L.createFramebuffer(), M_ = L.createFramebuffer();
            this.copyTextureToTexture = function(T, O, X = null, Y = null, G = 0, ae = null) {
                ae === null && (G !== 0 ? (Ia("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."), ae = G, G = 0) : ae = 0);
                let de, xe, Se, Ne, De, Re, Je, it, Mt;
                const vt = T.isCompressedTexture ? T.mipmaps[ae] : T.image;
                if (X !== null) de = X.max.x - X.min.x, xe = X.max.y - X.min.y, Se = X.isBox3 ? X.max.z - X.min.z : 1, Ne = X.min.x, De = X.min.y, Re = X.isBox3 ? X.min.z : 0;
                else {
                    const cn = Math.pow(2, -G);
                    de = Math.floor(vt.width * cn), xe = Math.floor(vt.height * cn), T.isDataArrayTexture ? Se = vt.depth : T.isData3DTexture ? Se = Math.floor(vt.depth * cn) : Se = 1, Ne = 0, De = 0, Re = 0;
                }
                Y !== null ? (Je = Y.x, it = Y.y, Mt = Y.z) : (Je = 0, it = 0, Mt = 0);
                const Qe = ze.convert(O.format), Pe = ze.convert(O.type);
                let It;
                O.isData3DTexture ? (P.setTexture3D(O, 0), It = L.TEXTURE_3D) : O.isDataArrayTexture || O.isCompressedArrayTexture ? (P.setTexture2DArray(O, 0), It = L.TEXTURE_2D_ARRAY) : (P.setTexture2D(O, 0), It = L.TEXTURE_2D), L.pixelStorei(L.UNPACK_FLIP_Y_WEBGL, O.flipY), L.pixelStorei(L.UNPACK_PREMULTIPLY_ALPHA_WEBGL, O.premultiplyAlpha), L.pixelStorei(L.UNPACK_ALIGNMENT, O.unpackAlignment);
                const st = L.getParameter(L.UNPACK_ROW_LENGTH), mn = L.getParameter(L.UNPACK_IMAGE_HEIGHT), Ji = L.getParameter(L.UNPACK_SKIP_PIXELS), tn = L.getParameter(L.UNPACK_SKIP_ROWS), Xs = L.getParameter(L.UNPACK_SKIP_IMAGES);
                L.pixelStorei(L.UNPACK_ROW_LENGTH, vt.width), L.pixelStorei(L.UNPACK_IMAGE_HEIGHT, vt.height), L.pixelStorei(L.UNPACK_SKIP_PIXELS, Ne), L.pixelStorei(L.UNPACK_SKIP_ROWS, De), L.pixelStorei(L.UNPACK_SKIP_IMAGES, Re);
                const dt = T.isDataArrayTexture || T.isData3DTexture, on = O.isDataArrayTexture || O.isData3DTexture;
                if (T.isDepthTexture) {
                    const cn = Ae.get(T), Ht = Ae.get(O), Kt = Ae.get(cn.__renderTarget), io = Ae.get(Ht.__renderTarget);
                    Ee.bindFramebuffer(L.READ_FRAMEBUFFER, Kt.__webglFramebuffer), Ee.bindFramebuffer(L.DRAW_FRAMEBUFFER, io.__webglFramebuffer);
                    for(let yi = 0; yi < Se; yi++)dt && (L.framebufferTextureLayer(L.READ_FRAMEBUFFER, L.COLOR_ATTACHMENT0, Ae.get(T).__webglTexture, G, Re + yi), L.framebufferTextureLayer(L.DRAW_FRAMEBUFFER, L.COLOR_ATTACHMENT0, Ae.get(O).__webglTexture, ae, Mt + yi)), L.blitFramebuffer(Ne, De, de, xe, Je, it, de, xe, L.DEPTH_BUFFER_BIT, L.NEAREST);
                    Ee.bindFramebuffer(L.READ_FRAMEBUFFER, null), Ee.bindFramebuffer(L.DRAW_FRAMEBUFFER, null);
                } else if (G !== 0 || T.isRenderTargetTexture || Ae.has(T)) {
                    const cn = Ae.get(T), Ht = Ae.get(O);
                    Ee.bindFramebuffer(L.READ_FRAMEBUFFER, S_), Ee.bindFramebuffer(L.DRAW_FRAMEBUFFER, M_);
                    for(let Kt = 0; Kt < Se; Kt++)dt ? L.framebufferTextureLayer(L.READ_FRAMEBUFFER, L.COLOR_ATTACHMENT0, cn.__webglTexture, G, Re + Kt) : L.framebufferTexture2D(L.READ_FRAMEBUFFER, L.COLOR_ATTACHMENT0, L.TEXTURE_2D, cn.__webglTexture, G), on ? L.framebufferTextureLayer(L.DRAW_FRAMEBUFFER, L.COLOR_ATTACHMENT0, Ht.__webglTexture, ae, Mt + Kt) : L.framebufferTexture2D(L.DRAW_FRAMEBUFFER, L.COLOR_ATTACHMENT0, L.TEXTURE_2D, Ht.__webglTexture, ae), G !== 0 ? L.blitFramebuffer(Ne, De, de, xe, Je, it, de, xe, L.COLOR_BUFFER_BIT, L.NEAREST) : on ? L.copyTexSubImage3D(It, ae, Je, it, Mt + Kt, Ne, De, de, xe) : L.copyTexSubImage2D(It, ae, Je, it, Ne, De, de, xe);
                    Ee.bindFramebuffer(L.READ_FRAMEBUFFER, null), Ee.bindFramebuffer(L.DRAW_FRAMEBUFFER, null);
                } else on ? T.isDataTexture || T.isData3DTexture ? L.texSubImage3D(It, ae, Je, it, Mt, de, xe, Se, Qe, Pe, vt.data) : O.isCompressedArrayTexture ? L.compressedTexSubImage3D(It, ae, Je, it, Mt, de, xe, Se, Qe, vt.data) : L.texSubImage3D(It, ae, Je, it, Mt, de, xe, Se, Qe, Pe, vt) : T.isDataTexture ? L.texSubImage2D(L.TEXTURE_2D, ae, Je, it, de, xe, Qe, Pe, vt.data) : T.isCompressedTexture ? L.compressedTexSubImage2D(L.TEXTURE_2D, ae, Je, it, vt.width, vt.height, Qe, vt.data) : L.texSubImage2D(L.TEXTURE_2D, ae, Je, it, de, xe, Qe, Pe, vt);
                L.pixelStorei(L.UNPACK_ROW_LENGTH, st), L.pixelStorei(L.UNPACK_IMAGE_HEIGHT, mn), L.pixelStorei(L.UNPACK_SKIP_PIXELS, Ji), L.pixelStorei(L.UNPACK_SKIP_ROWS, tn), L.pixelStorei(L.UNPACK_SKIP_IMAGES, Xs), ae === 0 && O.generateMipmaps && L.generateMipmap(It), Ee.unbindTexture();
            }, this.copyTextureToTexture3D = function(T, O, X = null, Y = null, G = 0) {
                return Ia('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'), this.copyTextureToTexture(T, O, X, Y, G);
            }, this.initRenderTarget = function(T) {
                Ae.get(T).__webglFramebuffer === void 0 && P.setupRenderTarget(T);
            }, this.initTexture = function(T) {
                T.isCubeTexture ? P.setTextureCube(T, 0) : T.isData3DTexture ? P.setTexture3D(T, 0) : T.isDataArrayTexture || T.isCompressedArrayTexture ? P.setTexture2DArray(T, 0) : P.setTexture2D(T, 0), Ee.unbindTexture();
            }, this.resetState = function() {
                w = 0, R = 0, N = null, Ee.reset(), ht.reset();
            }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                detail: this
            }));
        }
        get coordinateSystem() {
            return Zn;
        }
        get outputColorSpace() {
            return this._outputColorSpace;
        }
        set outputColorSpace(e) {
            this._outputColorSpace = e;
            const t = this.getContext();
            t.drawingBufferColorSpace = $e._getDrawingBufferColorSpace(e), t.unpackColorSpace = $e._getUnpackColorSpace();
        }
    };
    function id(i, e) {
        if (e === ig) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), i;
        if (e === al || e === Uf) {
            let t = i.getIndex();
            if (t === null) {
                const a = [], o = i.getAttribute("position");
                if (o !== void 0) {
                    for(let c = 0; c < o.count; c++)a.push(c);
                    i.setIndex(a), t = i.getIndex();
                } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), i;
            }
            const n = t.count - 2, s = [];
            if (e === al) for(let a = 1; a <= n; a++)s.push(t.getX(0)), s.push(t.getX(a)), s.push(t.getX(a + 1));
            else for(let a = 0; a < n; a++)a % 2 === 0 ? (s.push(t.getX(a)), s.push(t.getX(a + 1)), s.push(t.getX(a + 2))) : (s.push(t.getX(a + 2)), s.push(t.getX(a + 1)), s.push(t.getX(a)));
            s.length / 3 !== n && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
            const r = i.clone();
            return r.setIndex(s), r.clearGroups(), r;
        } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), i;
    }
    class sd extends zs {
        constructor(e){
            super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {
                return new kS(t);
            }), this.register(function(t) {
                return new GS(t);
            }), this.register(function(t) {
                return new $S(t);
            }), this.register(function(t) {
                return new KS(t);
            }), this.register(function(t) {
                return new ZS(t);
            }), this.register(function(t) {
                return new zS(t);
            }), this.register(function(t) {
                return new VS(t);
            }), this.register(function(t) {
                return new WS(t);
            }), this.register(function(t) {
                return new XS(t);
            }), this.register(function(t) {
                return new OS(t);
            }), this.register(function(t) {
                return new YS(t);
            }), this.register(function(t) {
                return new HS(t);
            }), this.register(function(t) {
                return new jS(t);
            }), this.register(function(t) {
                return new qS(t);
            }), this.register(function(t) {
                return new BS(t);
            }), this.register(function(t) {
                return new JS(t);
            }), this.register(function(t) {
                return new QS(t);
            });
        }
        load(e, t, n, s) {
            const r = this;
            let a;
            if (this.resourcePath !== "") a = this.resourcePath;
            else if (this.path !== "") {
                const l = pr.extractUrlBase(e);
                a = pr.resolveURL(l, this.path);
            } else a = pr.extractUrlBase(e);
            this.manager.itemStart(e);
            const o = function(l) {
                s ? s(l) : console.error(l), r.manager.itemError(e), r.manager.itemEnd(e);
            }, c = new ep(this.manager);
            c.setPath(this.path), c.setResponseType("arraybuffer"), c.setRequestHeader(this.requestHeader), c.setWithCredentials(this.withCredentials), c.load(e, function(l) {
                try {
                    r.parse(l, a, function(h) {
                        t(h), r.manager.itemEnd(e);
                    }, o);
                } catch (h) {
                    o(h);
                }
            }, n, o);
        }
        setDRACOLoader(e) {
            return this.dracoLoader = e, this;
        }
        setKTX2Loader(e) {
            return this.ktx2Loader = e, this;
        }
        setMeshoptDecoder(e) {
            return this.meshoptDecoder = e, this;
        }
        register(e) {
            return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
        }
        unregister(e) {
            return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
        }
        parse(e, t, n, s) {
            let r;
            const a = {}, o = {}, c = new TextDecoder;
            if (typeof e == "string") r = JSON.parse(e);
            else if (e instanceof ArrayBuffer) if (c.decode(new Uint8Array(e, 0, 4)) === op) {
                try {
                    a[qe.KHR_BINARY_GLTF] = new eM(e);
                } catch (u) {
                    s && s(u);
                    return;
                }
                r = JSON.parse(a[qe.KHR_BINARY_GLTF].content);
            } else r = JSON.parse(c.decode(e));
            else r = e;
            if (r.asset === void 0 || r.asset.version[0] < 2) {
                s && s(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
                return;
            }
            const l = new fM(r, {
                path: t || this.resourcePath || "",
                crossOrigin: this.crossOrigin,
                requestHeader: this.requestHeader,
                manager: this.manager,
                ktx2Loader: this.ktx2Loader,
                meshoptDecoder: this.meshoptDecoder
            });
            l.fileLoader.setRequestHeader(this.requestHeader);
            for(let h = 0; h < this.pluginCallbacks.length; h++){
                const u = this.pluginCallbacks[h](l);
                u.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), o[u.name] = u, a[u.name] = !0;
            }
            if (r.extensionsUsed) for(let h = 0; h < r.extensionsUsed.length; ++h){
                const u = r.extensionsUsed[h], d = r.extensionsRequired || [];
                switch(u){
                    case qe.KHR_MATERIALS_UNLIT:
                        a[u] = new FS;
                        break;
                    case qe.KHR_DRACO_MESH_COMPRESSION:
                        a[u] = new tM(r, this.dracoLoader);
                        break;
                    case qe.KHR_TEXTURE_TRANSFORM:
                        a[u] = new nM;
                        break;
                    case qe.KHR_MESH_QUANTIZATION:
                        a[u] = new iM;
                        break;
                    default:
                        d.indexOf(u) >= 0 && o[u] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + u + '".');
                }
            }
            l.setExtensions(a), l.setPlugins(o), l.parse(n, s);
        }
        parseAsync(e, t) {
            const n = this;
            return new Promise(function(s, r) {
                n.parse(e, t, s, r);
            });
        }
    }
    function NS() {
        let i = {};
        return {
            get: function(e) {
                return i[e];
            },
            add: function(e, t) {
                i[e] = t;
            },
            remove: function(e) {
                delete i[e];
            },
            removeAll: function() {
                i = {};
            }
        };
    }
    const qe = {
        KHR_BINARY_GLTF: "KHR_binary_glTF",
        KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
        KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
        KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
        KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
        KHR_MATERIALS_IOR: "KHR_materials_ior",
        KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
        KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
        KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
        KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
        KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
        KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
        KHR_MATERIALS_VOLUME: "KHR_materials_volume",
        KHR_TEXTURE_BASISU: "KHR_texture_basisu",
        KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
        KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
        KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
        EXT_MATERIALS_BUMP: "EXT_materials_bump",
        EXT_TEXTURE_WEBP: "EXT_texture_webp",
        EXT_TEXTURE_AVIF: "EXT_texture_avif",
        EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
        EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
    };
    class BS {
        constructor(e){
            this.parser = e, this.name = qe.KHR_LIGHTS_PUNCTUAL, this.cache = {
                refs: {},
                uses: {}
            };
        }
        _markDefs() {
            const e = this.parser, t = this.parser.json.nodes || [];
            for(let n = 0, s = t.length; n < s; n++){
                const r = t[n];
                r.extensions && r.extensions[this.name] && r.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, r.extensions[this.name].light);
            }
        }
        _loadLight(e) {
            const t = this.parser, n = "light:" + e;
            let s = t.cache.get(n);
            if (s) return s;
            const r = t.json, c = ((r.extensions && r.extensions[this.name] || {}).lights || [])[e];
            let l;
            const h = new Be(16777215);
            c.color !== void 0 && h.setRGB(c.color[0], c.color[1], c.color[2], $t);
            const u = c.range !== void 0 ? c.range : 0;
            switch(c.type){
                case "directional":
                    l = new tp(h), l.target.position.set(0, 0, -1), l.add(l.target);
                    break;
                case "point":
                    l = new Lx(h), l.distance = u;
                    break;
                case "spot":
                    l = new Ix(h), l.distance = u, c.spot = c.spot || {}, c.spot.innerConeAngle = c.spot.innerConeAngle !== void 0 ? c.spot.innerConeAngle : 0, c.spot.outerConeAngle = c.spot.outerConeAngle !== void 0 ? c.spot.outerConeAngle : Math.PI / 4, l.angle = c.spot.outerConeAngle, l.penumbra = 1 - c.spot.innerConeAngle / c.spot.outerConeAngle, l.target.position.set(0, 0, -1), l.add(l.target);
                    break;
                default:
                    throw new Error("THREE.GLTFLoader: Unexpected light type: " + c.type);
            }
            return l.position.set(0, 0, 0), $n(l, c), c.intensity !== void 0 && (l.intensity = c.intensity), l.name = t.createUniqueName(c.name || "light_" + e), s = Promise.resolve(l), t.cache.add(n, s), s;
        }
        getDependency(e, t) {
            if (e === "light") return this._loadLight(t);
        }
        createNodeAttachment(e) {
            const t = this, n = this.parser, r = n.json.nodes[e], o = (r.extensions && r.extensions[this.name] || {}).light;
            return o === void 0 ? null : this._loadLight(o).then(function(c) {
                return n._getNodeRef(t.cache, o, c);
            });
        }
    }
    class FS {
        constructor(){
            this.name = qe.KHR_MATERIALS_UNLIT;
        }
        getMaterialType() {
            return Fi;
        }
        extendParams(e, t, n) {
            const s = [];
            e.color = new Be(1, 1, 1), e.opacity = 1;
            const r = t.pbrMetallicRoughness;
            if (r) {
                if (Array.isArray(r.baseColorFactor)) {
                    const a = r.baseColorFactor;
                    e.color.setRGB(a[0], a[1], a[2], $t), e.opacity = a[3];
                }
                r.baseColorTexture !== void 0 && s.push(n.assignTexture(e, "map", r.baseColorTexture, Dt));
            }
            return Promise.all(s);
        }
    }
    class OS {
        constructor(e){
            this.parser = e, this.name = qe.KHR_MATERIALS_EMISSIVE_STRENGTH;
        }
        extendMaterialParams(e, t) {
            const s = this.parser.json.materials[e];
            if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
            const r = s.extensions[this.name].emissiveStrength;
            return r !== void 0 && (t.emissiveIntensity = r), Promise.resolve();
        }
    }
    class kS {
        constructor(e){
            this.parser = e, this.name = qe.KHR_MATERIALS_CLEARCOAT;
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : kn;
        }
        extendMaterialParams(e, t) {
            const n = this.parser, s = n.json.materials[e];
            if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
            const r = [], a = s.extensions[this.name];
            if (a.clearcoatFactor !== void 0 && (t.clearcoat = a.clearcoatFactor), a.clearcoatTexture !== void 0 && r.push(n.assignTexture(t, "clearcoatMap", a.clearcoatTexture)), a.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = a.clearcoatRoughnessFactor), a.clearcoatRoughnessTexture !== void 0 && r.push(n.assignTexture(t, "clearcoatRoughnessMap", a.clearcoatRoughnessTexture)), a.clearcoatNormalTexture !== void 0 && (r.push(n.assignTexture(t, "clearcoatNormalMap", a.clearcoatNormalTexture)), a.clearcoatNormalTexture.scale !== void 0)) {
                const o = a.clearcoatNormalTexture.scale;
                t.clearcoatNormalScale = new Ke(o, o);
            }
            return Promise.all(r);
        }
    }
    class GS {
        constructor(e){
            this.parser = e, this.name = qe.KHR_MATERIALS_DISPERSION;
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : kn;
        }
        extendMaterialParams(e, t) {
            const s = this.parser.json.materials[e];
            if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
            const r = s.extensions[this.name];
            return t.dispersion = r.dispersion !== void 0 ? r.dispersion : 0, Promise.resolve();
        }
    }
    class HS {
        constructor(e){
            this.parser = e, this.name = qe.KHR_MATERIALS_IRIDESCENCE;
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : kn;
        }
        extendMaterialParams(e, t) {
            const n = this.parser, s = n.json.materials[e];
            if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
            const r = [], a = s.extensions[this.name];
            return a.iridescenceFactor !== void 0 && (t.iridescence = a.iridescenceFactor), a.iridescenceTexture !== void 0 && r.push(n.assignTexture(t, "iridescenceMap", a.iridescenceTexture)), a.iridescenceIor !== void 0 && (t.iridescenceIOR = a.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [
                100,
                400
            ]), a.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = a.iridescenceThicknessMinimum), a.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = a.iridescenceThicknessMaximum), a.iridescenceThicknessTexture !== void 0 && r.push(n.assignTexture(t, "iridescenceThicknessMap", a.iridescenceThicknessTexture)), Promise.all(r);
        }
    }
    class zS {
        constructor(e){
            this.parser = e, this.name = qe.KHR_MATERIALS_SHEEN;
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : kn;
        }
        extendMaterialParams(e, t) {
            const n = this.parser, s = n.json.materials[e];
            if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
            const r = [];
            t.sheenColor = new Be(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
            const a = s.extensions[this.name];
            if (a.sheenColorFactor !== void 0) {
                const o = a.sheenColorFactor;
                t.sheenColor.setRGB(o[0], o[1], o[2], $t);
            }
            return a.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = a.sheenRoughnessFactor), a.sheenColorTexture !== void 0 && r.push(n.assignTexture(t, "sheenColorMap", a.sheenColorTexture, Dt)), a.sheenRoughnessTexture !== void 0 && r.push(n.assignTexture(t, "sheenRoughnessMap", a.sheenRoughnessTexture)), Promise.all(r);
        }
    }
    class VS {
        constructor(e){
            this.parser = e, this.name = qe.KHR_MATERIALS_TRANSMISSION;
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : kn;
        }
        extendMaterialParams(e, t) {
            const n = this.parser, s = n.json.materials[e];
            if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
            const r = [], a = s.extensions[this.name];
            return a.transmissionFactor !== void 0 && (t.transmission = a.transmissionFactor), a.transmissionTexture !== void 0 && r.push(n.assignTexture(t, "transmissionMap", a.transmissionTexture)), Promise.all(r);
        }
    }
    class WS {
        constructor(e){
            this.parser = e, this.name = qe.KHR_MATERIALS_VOLUME;
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : kn;
        }
        extendMaterialParams(e, t) {
            const n = this.parser, s = n.json.materials[e];
            if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
            const r = [], a = s.extensions[this.name];
            t.thickness = a.thicknessFactor !== void 0 ? a.thicknessFactor : 0, a.thicknessTexture !== void 0 && r.push(n.assignTexture(t, "thicknessMap", a.thicknessTexture)), t.attenuationDistance = a.attenuationDistance || 1 / 0;
            const o = a.attenuationColor || [
                1,
                1,
                1
            ];
            return t.attenuationColor = new Be().setRGB(o[0], o[1], o[2], $t), Promise.all(r);
        }
    }
    class XS {
        constructor(e){
            this.parser = e, this.name = qe.KHR_MATERIALS_IOR;
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : kn;
        }
        extendMaterialParams(e, t) {
            const s = this.parser.json.materials[e];
            if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
            const r = s.extensions[this.name];
            return t.ior = r.ior !== void 0 ? r.ior : 1.5, Promise.resolve();
        }
    }
    class YS {
        constructor(e){
            this.parser = e, this.name = qe.KHR_MATERIALS_SPECULAR;
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : kn;
        }
        extendMaterialParams(e, t) {
            const n = this.parser, s = n.json.materials[e];
            if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
            const r = [], a = s.extensions[this.name];
            t.specularIntensity = a.specularFactor !== void 0 ? a.specularFactor : 1, a.specularTexture !== void 0 && r.push(n.assignTexture(t, "specularIntensityMap", a.specularTexture));
            const o = a.specularColorFactor || [
                1,
                1,
                1
            ];
            return t.specularColor = new Be().setRGB(o[0], o[1], o[2], $t), a.specularColorTexture !== void 0 && r.push(n.assignTexture(t, "specularColorMap", a.specularColorTexture, Dt)), Promise.all(r);
        }
    }
    class qS {
        constructor(e){
            this.parser = e, this.name = qe.EXT_MATERIALS_BUMP;
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : kn;
        }
        extendMaterialParams(e, t) {
            const n = this.parser, s = n.json.materials[e];
            if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
            const r = [], a = s.extensions[this.name];
            return t.bumpScale = a.bumpFactor !== void 0 ? a.bumpFactor : 1, a.bumpTexture !== void 0 && r.push(n.assignTexture(t, "bumpMap", a.bumpTexture)), Promise.all(r);
        }
    }
    class jS {
        constructor(e){
            this.parser = e, this.name = qe.KHR_MATERIALS_ANISOTROPY;
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : kn;
        }
        extendMaterialParams(e, t) {
            const n = this.parser, s = n.json.materials[e];
            if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
            const r = [], a = s.extensions[this.name];
            return a.anisotropyStrength !== void 0 && (t.anisotropy = a.anisotropyStrength), a.anisotropyRotation !== void 0 && (t.anisotropyRotation = a.anisotropyRotation), a.anisotropyTexture !== void 0 && r.push(n.assignTexture(t, "anisotropyMap", a.anisotropyTexture)), Promise.all(r);
        }
    }
    class $S {
        constructor(e){
            this.parser = e, this.name = qe.KHR_TEXTURE_BASISU;
        }
        loadTexture(e) {
            const t = this.parser, n = t.json, s = n.textures[e];
            if (!s.extensions || !s.extensions[this.name]) return null;
            const r = s.extensions[this.name], a = t.options.ktx2Loader;
            if (!a) {
                if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                return null;
            }
            return t.loadTextureImage(e, r.source, a);
        }
    }
    class KS {
        constructor(e){
            this.parser = e, this.name = qe.EXT_TEXTURE_WEBP, this.isSupported = null;
        }
        loadTexture(e) {
            const t = this.name, n = this.parser, s = n.json, r = s.textures[e];
            if (!r.extensions || !r.extensions[t]) return null;
            const a = r.extensions[t], o = s.images[a.source];
            let c = n.textureLoader;
            if (o.uri) {
                const l = n.options.manager.getHandler(o.uri);
                l !== null && (c = l);
            }
            return this.detectSupport().then(function(l) {
                if (l) return n.loadTextureImage(e, a.source, c);
                if (s.extensionsRequired && s.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                return n.loadTexture(e);
            });
        }
        detectSupport() {
            return this.isSupported || (this.isSupported = new Promise(function(e) {
                const t = new Image;
                t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
                    e(t.height === 1);
                };
            })), this.isSupported;
        }
    }
    class ZS {
        constructor(e){
            this.parser = e, this.name = qe.EXT_TEXTURE_AVIF, this.isSupported = null;
        }
        loadTexture(e) {
            const t = this.name, n = this.parser, s = n.json, r = s.textures[e];
            if (!r.extensions || !r.extensions[t]) return null;
            const a = r.extensions[t], o = s.images[a.source];
            let c = n.textureLoader;
            if (o.uri) {
                const l = n.options.manager.getHandler(o.uri);
                l !== null && (c = l);
            }
            return this.detectSupport().then(function(l) {
                if (l) return n.loadTextureImage(e, a.source, c);
                if (s.extensionsRequired && s.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
                return n.loadTexture(e);
            });
        }
        detectSupport() {
            return this.isSupported || (this.isSupported = new Promise(function(e) {
                const t = new Image;
                t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function() {
                    e(t.height === 1);
                };
            })), this.isSupported;
        }
    }
    class JS {
        constructor(e){
            this.name = qe.EXT_MESHOPT_COMPRESSION, this.parser = e;
        }
        loadBufferView(e) {
            const t = this.parser.json, n = t.bufferViews[e];
            if (n.extensions && n.extensions[this.name]) {
                const s = n.extensions[this.name], r = this.parser.getDependency("buffer", s.buffer), a = this.parser.options.meshoptDecoder;
                if (!a || !a.supported) {
                    if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                    return null;
                }
                return r.then(function(o) {
                    const c = s.byteOffset || 0, l = s.byteLength || 0, h = s.count, u = s.byteStride, d = new Uint8Array(o, c, l);
                    return a.decodeGltfBufferAsync ? a.decodeGltfBufferAsync(h, u, d, s.mode, s.filter).then(function(f) {
                        return f.buffer;
                    }) : a.ready.then(function() {
                        const f = new ArrayBuffer(h * u);
                        return a.decodeGltfBuffer(new Uint8Array(f), h, u, d, s.mode, s.filter), f;
                    });
                });
            } else return null;
        }
    }
    class QS {
        constructor(e){
            this.name = qe.EXT_MESH_GPU_INSTANCING, this.parser = e;
        }
        createNodeMesh(e) {
            const t = this.parser.json, n = t.nodes[e];
            if (!n.extensions || !n.extensions[this.name] || n.mesh === void 0) return null;
            const s = t.meshes[n.mesh];
            for (const l of s.primitives)if (l.mode !== hn.TRIANGLES && l.mode !== hn.TRIANGLE_STRIP && l.mode !== hn.TRIANGLE_FAN && l.mode !== void 0) return null;
            const a = n.extensions[this.name].attributes, o = [], c = {};
            for(const l in a)o.push(this.parser.getDependency("accessor", a[l]).then((h)=>(c[l] = h, c[l])));
            return o.length < 1 ? null : (o.push(this.parser.createNodeMesh(e)), Promise.all(o).then((l)=>{
                const h = l.pop(), u = h.isGroup ? h.children : [
                    h
                ], d = l[0].count, f = [];
                for (const _ of u){
                    const g = new He, p = new k, m = new En, v = new k(1, 1, 1), y = new ux(_.geometry, _.material, d);
                    for(let x = 0; x < d; x++)c.TRANSLATION && p.fromBufferAttribute(c.TRANSLATION, x), c.ROTATION && m.fromBufferAttribute(c.ROTATION, x), c.SCALE && v.fromBufferAttribute(c.SCALE, x), y.setMatrixAt(x, g.compose(p, m, v));
                    for(const x in c)if (x === "_COLOR_0") {
                        const I = c[x];
                        y.instanceColor = new cl(I.array, I.itemSize, I.normalized);
                    } else x !== "TRANSLATION" && x !== "ROTATION" && x !== "SCALE" && _.geometry.setAttribute(x, c[x]);
                    gt.prototype.copy.call(y, _), this.parser.assignFinalMaterial(y), f.push(y);
                }
                return h.isGroup ? (h.clear(), h.add(...f), h) : f[0];
            }));
        }
    }
    const op = "glTF", er = 12, rd = {
        JSON: 1313821514,
        BIN: 5130562
    };
    class eM {
        constructor(e){
            this.name = qe.KHR_BINARY_GLTF, this.content = null, this.body = null;
            const t = new DataView(e, 0, er), n = new TextDecoder;
            if (this.header = {
                magic: n.decode(new Uint8Array(e.slice(0, 4))),
                version: t.getUint32(4, !0),
                length: t.getUint32(8, !0)
            }, this.header.magic !== op) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
            if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
            const s = this.header.length - er, r = new DataView(e, er);
            let a = 0;
            for(; a < s;){
                const o = r.getUint32(a, !0);
                a += 4;
                const c = r.getUint32(a, !0);
                if (a += 4, c === rd.JSON) {
                    const l = new Uint8Array(e, er + a, o);
                    this.content = n.decode(l);
                } else if (c === rd.BIN) {
                    const l = er + a;
                    this.body = e.slice(l, l + o);
                }
                a += o;
            }
            if (this.content === null) throw new Error("THREE.GLTFLoader: JSON content not found.");
        }
    }
    class tM {
        constructor(e, t){
            if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
            this.name = qe.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload();
        }
        decodePrimitive(e, t) {
            const n = this.json, s = this.dracoLoader, r = e.extensions[this.name].bufferView, a = e.extensions[this.name].attributes, o = {}, c = {}, l = {};
            for(const h in a){
                const u = fl[h] || h.toLowerCase();
                o[u] = a[h];
            }
            for(const h in e.attributes){
                const u = fl[h] || h.toLowerCase();
                if (a[h] !== void 0) {
                    const d = n.accessors[e.attributes[h]], f = Es[d.componentType];
                    l[u] = f.name, c[u] = d.normalized === !0;
                }
            }
            return t.getDependency("bufferView", r).then(function(h) {
                return new Promise(function(u, d) {
                    s.decodeDracoFile(h, function(f) {
                        for(const _ in f.attributes){
                            const g = f.attributes[_], p = c[_];
                            p !== void 0 && (g.normalized = p);
                        }
                        u(f);
                    }, o, l, $t, d);
                });
            });
        }
    }
    class nM {
        constructor(){
            this.name = qe.KHR_TEXTURE_TRANSFORM;
        }
        extendTexture(e, t) {
            return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.texCoord !== void 0 && (e.channel = t.texCoord), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e;
        }
    }
    class iM {
        constructor(){
            this.name = qe.KHR_MESH_QUANTIZATION;
        }
    }
    class cp extends Nr {
        constructor(e, t, n, s){
            super(e, t, n, s);
        }
        copySampleValue_(e) {
            const t = this.resultBuffer, n = this.sampleValues, s = this.valueSize, r = e * s * 3 + s;
            for(let a = 0; a !== s; a++)t[a] = n[r + a];
            return t;
        }
        interpolate_(e, t, n, s) {
            const r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, c = o * 2, l = o * 3, h = s - t, u = (n - t) / h, d = u * u, f = d * u, _ = e * l, g = _ - l, p = -2 * f + 3 * d, m = f - d, v = 1 - p, y = m - d + u;
            for(let x = 0; x !== o; x++){
                const I = a[g + x + o], w = a[g + x + c] * h, R = a[_ + x + o], N = a[_ + x] * h;
                r[x] = v * I + y * w + p * R + m * N;
            }
            return r;
        }
    }
    const sM = new En;
    class rM extends cp {
        interpolate_(e, t, n, s) {
            const r = super.interpolate_(e, t, n, s);
            return sM.fromArray(r).normalize().toArray(r), r;
        }
    }
    const hn = {
        POINTS: 0,
        LINES: 1,
        LINE_LOOP: 2,
        LINE_STRIP: 3,
        TRIANGLES: 4,
        TRIANGLE_STRIP: 5,
        TRIANGLE_FAN: 6
    }, Es = {
        5120: Int8Array,
        5121: Uint8Array,
        5122: Int16Array,
        5123: Uint16Array,
        5125: Uint32Array,
        5126: Float32Array
    }, ad = {
        9728: Yt,
        9729: an,
        9984: Tf,
        9985: Ta,
        9986: ar,
        9987: Kn
    }, od = {
        33071: ui,
        33648: Fa,
        10497: Ps
    }, Oo = {
        SCALAR: 1,
        VEC2: 2,
        VEC3: 3,
        VEC4: 4,
        MAT2: 4,
        MAT3: 9,
        MAT4: 16
    }, fl = {
        POSITION: "position",
        NORMAL: "normal",
        TANGENT: "tangent",
        TEXCOORD_0: "uv",
        TEXCOORD_1: "uv1",
        TEXCOORD_2: "uv2",
        TEXCOORD_3: "uv3",
        COLOR_0: "color",
        WEIGHTS_0: "skinWeight",
        JOINTS_0: "skinIndex"
    }, li = {
        scale: "scale",
        translation: "position",
        rotation: "quaternion",
        weights: "morphTargetInfluences"
    }, aM = {
        CUBICSPLINE: void 0,
        LINEAR: Ar,
        STEP: Er
    }, ko = {
        OPAQUE: "OPAQUE",
        MASK: "MASK",
        BLEND: "BLEND"
    };
    function oM(i) {
        return i.DefaultMaterial === void 0 && (i.DefaultMaterial = new Rr({
            color: 16777215,
            emissive: 0,
            metalness: 1,
            roughness: 1,
            transparent: !1,
            depthTest: !0,
            side: ti
        })), i.DefaultMaterial;
    }
    function wi(i, e, t) {
        for(const n in t.extensions)i[n] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[n] = t.extensions[n]);
    }
    function $n(i, e) {
        e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(i.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras));
    }
    function cM(i, e, t) {
        let n = !1, s = !1, r = !1;
        for(let l = 0, h = e.length; l < h; l++){
            const u = e[l];
            if (u.POSITION !== void 0 && (n = !0), u.NORMAL !== void 0 && (s = !0), u.COLOR_0 !== void 0 && (r = !0), n && s && r) break;
        }
        if (!n && !s && !r) return Promise.resolve(i);
        const a = [], o = [], c = [];
        for(let l = 0, h = e.length; l < h; l++){
            const u = e[l];
            if (n) {
                const d = u.POSITION !== void 0 ? t.getDependency("accessor", u.POSITION) : i.attributes.position;
                a.push(d);
            }
            if (s) {
                const d = u.NORMAL !== void 0 ? t.getDependency("accessor", u.NORMAL) : i.attributes.normal;
                o.push(d);
            }
            if (r) {
                const d = u.COLOR_0 !== void 0 ? t.getDependency("accessor", u.COLOR_0) : i.attributes.color;
                c.push(d);
            }
        }
        return Promise.all([
            Promise.all(a),
            Promise.all(o),
            Promise.all(c)
        ]).then(function(l) {
            const h = l[0], u = l[1], d = l[2];
            return n && (i.morphAttributes.position = h), s && (i.morphAttributes.normal = u), r && (i.morphAttributes.color = d), i.morphTargetsRelative = !0, i;
        });
    }
    function lM(i, e) {
        if (i.updateMorphTargets(), e.weights !== void 0) for(let t = 0, n = e.weights.length; t < n; t++)i.morphTargetInfluences[t] = e.weights[t];
        if (e.extras && Array.isArray(e.extras.targetNames)) {
            const t = e.extras.targetNames;
            if (i.morphTargetInfluences.length === t.length) {
                i.morphTargetDictionary = {};
                for(let n = 0, s = t.length; n < s; n++)i.morphTargetDictionary[t[n]] = n;
            } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
        }
    }
    function hM(i) {
        let e;
        const t = i.extensions && i.extensions[qe.KHR_DRACO_MESH_COMPRESSION];
        if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + Go(t.attributes) : e = i.indices + ":" + Go(i.attributes) + ":" + i.mode, i.targets !== void 0) for(let n = 0, s = i.targets.length; n < s; n++)e += ":" + Go(i.targets[n]);
        return e;
    }
    function Go(i) {
        let e = "";
        const t = Object.keys(i).sort();
        for(let n = 0, s = t.length; n < s; n++)e += t[n] + ":" + i[t[n]] + ";";
        return e;
    }
    function pl(i) {
        switch(i){
            case Int8Array:
                return 1 / 127;
            case Uint8Array:
                return 1 / 255;
            case Int16Array:
                return 1 / 32767;
            case Uint16Array:
                return 1 / 65535;
            default:
                throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
        }
    }
    function uM(i) {
        return i.search(/\.jpe?g($|\?)/i) > 0 || i.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : i.search(/\.webp($|\?)/i) > 0 || i.search(/^data\:image\/webp/) === 0 ? "image/webp" : i.search(/\.ktx2($|\?)/i) > 0 || i.search(/^data\:image\/ktx2/) === 0 ? "image/ktx2" : "image/png";
    }
    const dM = new He;
    class fM {
        constructor(e = {}, t = {}){
            this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new NS, this.associations = new Map, this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = {
                refs: {},
                uses: {}
            }, this.cameraCache = {
                refs: {},
                uses: {}
            }, this.lightCache = {
                refs: {},
                uses: {}
            }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
            let n = !1, s = -1, r = !1, a = -1;
            if (typeof navigator < "u") {
                const o = navigator.userAgent;
                n = /^((?!chrome|android).)*safari/i.test(o) === !0;
                const c = o.match(/Version\/(\d+)/);
                s = n && c ? parseInt(c[1], 10) : -1, r = o.indexOf("Firefox") > -1, a = r ? o.match(/Firefox\/([0-9]+)\./)[1] : -1;
            }
            typeof createImageBitmap > "u" || n && s < 17 || r && a < 98 ? this.textureLoader = new ul(this.options.manager) : this.textureLoader = new Bx(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new ep(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0);
        }
        setExtensions(e) {
            this.extensions = e;
        }
        setPlugins(e) {
            this.plugins = e;
        }
        parse(e, t) {
            const n = this, s = this.json, r = this.extensions;
            this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(a) {
                return a._markDefs && a._markDefs();
            }), Promise.all(this._invokeAll(function(a) {
                return a.beforeRoot && a.beforeRoot();
            })).then(function() {
                return Promise.all([
                    n.getDependencies("scene"),
                    n.getDependencies("animation"),
                    n.getDependencies("camera")
                ]);
            }).then(function(a) {
                const o = {
                    scene: a[0][s.scene || 0],
                    scenes: a[0],
                    animations: a[1],
                    cameras: a[2],
                    asset: s.asset,
                    parser: n,
                    userData: {}
                };
                return wi(r, o, s), $n(o, s), Promise.all(n._invokeAll(function(c) {
                    return c.afterRoot && c.afterRoot(o);
                })).then(function() {
                    for (const c of o.scenes)c.updateMatrixWorld();
                    e(o);
                });
            }).catch(t);
        }
        _markDefs() {
            const e = this.json.nodes || [], t = this.json.skins || [], n = this.json.meshes || [];
            for(let s = 0, r = t.length; s < r; s++){
                const a = t[s].joints;
                for(let o = 0, c = a.length; o < c; o++)e[a[o]].isBone = !0;
            }
            for(let s = 0, r = e.length; s < r; s++){
                const a = e[s];
                a.mesh !== void 0 && (this._addNodeRef(this.meshCache, a.mesh), a.skin !== void 0 && (n[a.mesh].isSkinnedMesh = !0)), a.camera !== void 0 && this._addNodeRef(this.cameraCache, a.camera);
            }
        }
        _addNodeRef(e, t) {
            t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
        }
        _getNodeRef(e, t, n) {
            if (e.refs[t] <= 1) return n;
            const s = n.clone(), r = (a, o)=>{
                const c = this.associations.get(a);
                c != null && this.associations.set(o, c);
                for (const [l, h] of a.children.entries())r(h, o.children[l]);
            };
            return r(n, s), s.name += "_instance_" + e.uses[t]++, s;
        }
        _invokeOne(e) {
            const t = Object.values(this.plugins);
            t.push(this);
            for(let n = 0; n < t.length; n++){
                const s = e(t[n]);
                if (s) return s;
            }
            return null;
        }
        _invokeAll(e) {
            const t = Object.values(this.plugins);
            t.unshift(this);
            const n = [];
            for(let s = 0; s < t.length; s++){
                const r = e(t[s]);
                r && n.push(r);
            }
            return n;
        }
        getDependency(e, t) {
            const n = e + ":" + t;
            let s = this.cache.get(n);
            if (!s) {
                switch(e){
                    case "scene":
                        s = this.loadScene(t);
                        break;
                    case "node":
                        s = this._invokeOne(function(r) {
                            return r.loadNode && r.loadNode(t);
                        });
                        break;
                    case "mesh":
                        s = this._invokeOne(function(r) {
                            return r.loadMesh && r.loadMesh(t);
                        });
                        break;
                    case "accessor":
                        s = this.loadAccessor(t);
                        break;
                    case "bufferView":
                        s = this._invokeOne(function(r) {
                            return r.loadBufferView && r.loadBufferView(t);
                        });
                        break;
                    case "buffer":
                        s = this.loadBuffer(t);
                        break;
                    case "material":
                        s = this._invokeOne(function(r) {
                            return r.loadMaterial && r.loadMaterial(t);
                        });
                        break;
                    case "texture":
                        s = this._invokeOne(function(r) {
                            return r.loadTexture && r.loadTexture(t);
                        });
                        break;
                    case "skin":
                        s = this.loadSkin(t);
                        break;
                    case "animation":
                        s = this._invokeOne(function(r) {
                            return r.loadAnimation && r.loadAnimation(t);
                        });
                        break;
                    case "camera":
                        s = this.loadCamera(t);
                        break;
                    default:
                        if (s = this._invokeOne(function(r) {
                            return r != this && r.getDependency && r.getDependency(e, t);
                        }), !s) throw new Error("Unknown type: " + e);
                        break;
                }
                this.cache.add(n, s);
            }
            return s;
        }
        getDependencies(e) {
            let t = this.cache.get(e);
            if (!t) {
                const n = this, s = this.json[e + (e === "mesh" ? "es" : "s")] || [];
                t = Promise.all(s.map(function(r, a) {
                    return n.getDependency(e, a);
                })), this.cache.add(e, t);
            }
            return t;
        }
        loadBuffer(e) {
            const t = this.json.buffers[e], n = this.fileLoader;
            if (t.type && t.type !== "arraybuffer") throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
            if (t.uri === void 0 && e === 0) return Promise.resolve(this.extensions[qe.KHR_BINARY_GLTF].body);
            const s = this.options;
            return new Promise(function(r, a) {
                n.load(pr.resolveURL(t.uri, s.path), r, void 0, function() {
                    a(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
                });
            });
        }
        loadBufferView(e) {
            const t = this.json.bufferViews[e];
            return this.getDependency("buffer", t.buffer).then(function(n) {
                const s = t.byteLength || 0, r = t.byteOffset || 0;
                return n.slice(r, r + s);
            });
        }
        loadAccessor(e) {
            const t = this, n = this.json, s = this.json.accessors[e];
            if (s.bufferView === void 0 && s.sparse === void 0) {
                const a = Oo[s.type], o = Es[s.componentType], c = s.normalized === !0, l = new o(s.count * a);
                return Promise.resolve(new qt(l, a, c));
            }
            const r = [];
            return s.bufferView !== void 0 ? r.push(this.getDependency("bufferView", s.bufferView)) : r.push(null), s.sparse !== void 0 && (r.push(this.getDependency("bufferView", s.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", s.sparse.values.bufferView))), Promise.all(r).then(function(a) {
                const o = a[0], c = Oo[s.type], l = Es[s.componentType], h = l.BYTES_PER_ELEMENT, u = h * c, d = s.byteOffset || 0, f = s.bufferView !== void 0 ? n.bufferViews[s.bufferView].byteStride : void 0, _ = s.normalized === !0;
                let g, p;
                if (f && f !== u) {
                    const m = Math.floor(d / f), v = "InterleavedBuffer:" + s.bufferView + ":" + s.componentType + ":" + m + ":" + s.count;
                    let y = t.cache.get(v);
                    y || (g = new l(o, m * f, s.count * f / h), y = new ax(g, f / h), t.cache.add(v, y)), p = new $l(y, c, d % f / h, _);
                } else o === null ? g = new l(s.count * c) : g = new l(o, d, s.count * c), p = new qt(g, c, _);
                if (s.sparse !== void 0) {
                    const m = Oo.SCALAR, v = Es[s.sparse.indices.componentType], y = s.sparse.indices.byteOffset || 0, x = s.sparse.values.byteOffset || 0, I = new v(a[1], y, s.sparse.count * m), w = new l(a[2], x, s.sparse.count * c);
                    o !== null && (p = new qt(p.array.slice(), p.itemSize, p.normalized)), p.normalized = !1;
                    for(let R = 0, N = I.length; R < N; R++){
                        const E = I[R];
                        if (p.setX(E, w[R * c]), c >= 2 && p.setY(E, w[R * c + 1]), c >= 3 && p.setZ(E, w[R * c + 2]), c >= 4 && p.setW(E, w[R * c + 3]), c >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
                    }
                    p.normalized = _;
                }
                return p;
            });
        }
        loadTexture(e) {
            const t = this.json, n = this.options, r = t.textures[e].source, a = t.images[r];
            let o = this.textureLoader;
            if (a.uri) {
                const c = n.manager.getHandler(a.uri);
                c !== null && (o = c);
            }
            return this.loadTextureImage(e, r, o);
        }
        loadTextureImage(e, t, n) {
            const s = this, r = this.json, a = r.textures[e], o = r.images[t], c = (o.uri || o.bufferView) + ":" + a.sampler;
            if (this.textureCache[c]) return this.textureCache[c];
            const l = this.loadImageSource(t, n).then(function(h) {
                h.flipY = !1, h.name = a.name || o.name || "", h.name === "" && typeof o.uri == "string" && o.uri.startsWith("data:image/") === !1 && (h.name = o.uri);
                const d = (r.samplers || {})[a.sampler] || {};
                return h.magFilter = ad[d.magFilter] || an, h.minFilter = ad[d.minFilter] || Kn, h.wrapS = od[d.wrapS] || Ps, h.wrapT = od[d.wrapT] || Ps, h.generateMipmaps = !h.isCompressedTexture && h.minFilter !== Yt && h.minFilter !== an, s.associations.set(h, {
                    textures: e
                }), h;
            }).catch(function() {
                return null;
            });
            return this.textureCache[c] = l, l;
        }
        loadImageSource(e, t) {
            const n = this, s = this.json, r = this.options;
            if (this.sourceCache[e] !== void 0) return this.sourceCache[e].then((u)=>u.clone());
            const a = s.images[e], o = self.URL || self.webkitURL;
            let c = a.uri || "", l = !1;
            if (a.bufferView !== void 0) c = n.getDependency("bufferView", a.bufferView).then(function(u) {
                l = !0;
                const d = new Blob([
                    u
                ], {
                    type: a.mimeType
                });
                return c = o.createObjectURL(d), c;
            });
            else if (a.uri === void 0) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
            const h = Promise.resolve(c).then(function(u) {
                return new Promise(function(d, f) {
                    let _ = d;
                    t.isImageBitmapLoader === !0 && (_ = function(g) {
                        const p = new Qt(g);
                        p.needsUpdate = !0, d(p);
                    }), t.load(pr.resolveURL(u, r.path), _, void 0, f);
                });
            }).then(function(u) {
                return l === !0 && o.revokeObjectURL(c), $n(u, a), u.userData.mimeType = a.mimeType || uM(a.uri), u;
            }).catch(function(u) {
                throw console.error("THREE.GLTFLoader: Couldn't load texture", c), u;
            });
            return this.sourceCache[e] = h, h;
        }
        assignTexture(e, t, n, s) {
            const r = this;
            return this.getDependency("texture", n.index).then(function(a) {
                if (!a) return null;
                if (n.texCoord !== void 0 && n.texCoord > 0 && (a = a.clone(), a.channel = n.texCoord), r.extensions[qe.KHR_TEXTURE_TRANSFORM]) {
                    const o = n.extensions !== void 0 ? n.extensions[qe.KHR_TEXTURE_TRANSFORM] : void 0;
                    if (o) {
                        const c = r.associations.get(a);
                        a = r.extensions[qe.KHR_TEXTURE_TRANSFORM].extendTexture(a, o), r.associations.set(a, c);
                    }
                }
                return s !== void 0 && (a.colorSpace = s), e[t] = a, a;
            });
        }
        assignFinalMaterial(e) {
            const t = e.geometry;
            let n = e.material;
            const s = t.attributes.tangent === void 0, r = t.attributes.color !== void 0, a = t.attributes.normal === void 0;
            if (e.isPoints) {
                const o = "PointsMaterial:" + n.uuid;
                let c = this.cache.get(o);
                c || (c = new $f, Nn.prototype.copy.call(c, n), c.color.copy(n.color), c.map = n.map, c.sizeAttenuation = !1, this.cache.add(o, c)), n = c;
            } else if (e.isLine) {
                const o = "LineBasicMaterial:" + n.uuid;
                let c = this.cache.get(o);
                c || (c = new jf, Nn.prototype.copy.call(c, n), c.color.copy(n.color), c.map = n.map, this.cache.add(o, c)), n = c;
            }
            if (s || r || a) {
                let o = "ClonedMaterial:" + n.uuid + ":";
                s && (o += "derivative-tangents:"), r && (o += "vertex-colors:"), a && (o += "flat-shading:");
                let c = this.cache.get(o);
                c || (c = n.clone(), r && (c.vertexColors = !0), a && (c.flatShading = !0), s && (c.normalScale && (c.normalScale.y *= -1), c.clearcoatNormalScale && (c.clearcoatNormalScale.y *= -1)), this.cache.add(o, c), this.associations.set(c, this.associations.get(n))), n = c;
            }
            e.material = n;
        }
        getMaterialType() {
            return Rr;
        }
        loadMaterial(e) {
            const t = this, n = this.json, s = this.extensions, r = n.materials[e];
            let a;
            const o = {}, c = r.extensions || {}, l = [];
            if (c[qe.KHR_MATERIALS_UNLIT]) {
                const u = s[qe.KHR_MATERIALS_UNLIT];
                a = u.getMaterialType(), l.push(u.extendParams(o, r, t));
            } else {
                const u = r.pbrMetallicRoughness || {};
                if (o.color = new Be(1, 1, 1), o.opacity = 1, Array.isArray(u.baseColorFactor)) {
                    const d = u.baseColorFactor;
                    o.color.setRGB(d[0], d[1], d[2], $t), o.opacity = d[3];
                }
                u.baseColorTexture !== void 0 && l.push(t.assignTexture(o, "map", u.baseColorTexture, Dt)), o.metalness = u.metallicFactor !== void 0 ? u.metallicFactor : 1, o.roughness = u.roughnessFactor !== void 0 ? u.roughnessFactor : 1, u.metallicRoughnessTexture !== void 0 && (l.push(t.assignTexture(o, "metalnessMap", u.metallicRoughnessTexture)), l.push(t.assignTexture(o, "roughnessMap", u.metallicRoughnessTexture))), a = this._invokeOne(function(d) {
                    return d.getMaterialType && d.getMaterialType(e);
                }), l.push(Promise.all(this._invokeAll(function(d) {
                    return d.extendMaterialParams && d.extendMaterialParams(e, o);
                })));
            }
            r.doubleSided === !0 && (o.side = Un);
            const h = r.alphaMode || ko.OPAQUE;
            if (h === ko.BLEND ? (o.transparent = !0, o.depthWrite = !1) : (o.transparent = !1, h === ko.MASK && (o.alphaTest = r.alphaCutoff !== void 0 ? r.alphaCutoff : .5)), r.normalTexture !== void 0 && a !== Fi && (l.push(t.assignTexture(o, "normalMap", r.normalTexture)), o.normalScale = new Ke(1, 1), r.normalTexture.scale !== void 0)) {
                const u = r.normalTexture.scale;
                o.normalScale.set(u, u);
            }
            if (r.occlusionTexture !== void 0 && a !== Fi && (l.push(t.assignTexture(o, "aoMap", r.occlusionTexture)), r.occlusionTexture.strength !== void 0 && (o.aoMapIntensity = r.occlusionTexture.strength)), r.emissiveFactor !== void 0 && a !== Fi) {
                const u = r.emissiveFactor;
                o.emissive = new Be().setRGB(u[0], u[1], u[2], $t);
            }
            return r.emissiveTexture !== void 0 && a !== Fi && l.push(t.assignTexture(o, "emissiveMap", r.emissiveTexture, Dt)), Promise.all(l).then(function() {
                const u = new a(o);
                return r.name && (u.name = r.name), $n(u, r), t.associations.set(u, {
                    materials: e
                }), r.extensions && wi(s, u, r), u;
            });
        }
        createUniqueName(e) {
            const t = rt.sanitizeNodeName(e || "");
            return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t);
        }
        loadGeometries(e) {
            const t = this, n = this.extensions, s = this.primitiveCache;
            function r(o) {
                return n[qe.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(o, t).then(function(c) {
                    return cd(c, o, t);
                });
            }
            const a = [];
            for(let o = 0, c = e.length; o < c; o++){
                const l = e[o], h = hM(l), u = s[h];
                if (u) a.push(u.promise);
                else {
                    let d;
                    l.extensions && l.extensions[qe.KHR_DRACO_MESH_COMPRESSION] ? d = r(l) : d = cd(new On, l, t), s[h] = {
                        primitive: l,
                        promise: d
                    }, a.push(d);
                }
            }
            return Promise.all(a);
        }
        loadMesh(e) {
            const t = this, n = this.json, s = this.extensions, r = n.meshes[e], a = r.primitives, o = [];
            for(let c = 0, l = a.length; c < l; c++){
                const h = a[c].material === void 0 ? oM(this.cache) : this.getDependency("material", a[c].material);
                o.push(h);
            }
            return o.push(t.loadGeometries(a)), Promise.all(o).then(function(c) {
                const l = c.slice(0, c.length - 1), h = c[c.length - 1], u = [];
                for(let f = 0, _ = h.length; f < _; f++){
                    const g = h[f], p = a[f];
                    let m;
                    const v = l[f];
                    if (p.mode === hn.TRIANGLES || p.mode === hn.TRIANGLE_STRIP || p.mode === hn.TRIANGLE_FAN || p.mode === void 0) m = r.isSkinnedMesh === !0 ? new cx(g, v) : new kt(g, v), m.isSkinnedMesh === !0 && m.normalizeSkinWeights(), p.mode === hn.TRIANGLE_STRIP ? m.geometry = id(m.geometry, Uf) : p.mode === hn.TRIANGLE_FAN && (m.geometry = id(m.geometry, al));
                    else if (p.mode === hn.LINES) m = new px(g, v);
                    else if (p.mode === hn.LINE_STRIP) m = new Jl(g, v);
                    else if (p.mode === hn.LINE_LOOP) m = new mx(g, v);
                    else if (p.mode === hn.POINTS) m = new _x(g, v);
                    else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + p.mode);
                    Object.keys(m.geometry.morphAttributes).length > 0 && lM(m, r), m.name = t.createUniqueName(r.name || "mesh_" + e), $n(m, r), p.extensions && wi(s, m, p), t.assignFinalMaterial(m), u.push(m);
                }
                for(let f = 0, _ = u.length; f < _; f++)t.associations.set(u[f], {
                    meshes: e,
                    primitives: f
                });
                if (u.length === 1) return r.extensions && wi(s, u[0], r), u[0];
                const d = new Oi;
                r.extensions && wi(s, d, r), t.associations.set(d, {
                    meshes: e
                });
                for(let f = 0, _ = u.length; f < _; f++)d.add(u[f]);
                return d;
            });
        }
        loadCamera(e) {
            let t;
            const n = this.json.cameras[e], s = n[n.type];
            if (!s) {
                console.warn("THREE.GLTFLoader: Missing camera parameters.");
                return;
            }
            return n.type === "perspective" ? t = new Wt(Pg.radToDeg(s.yfov), s.aspectRatio || 1, s.znear || 1, s.zfar || 2e6) : n.type === "orthographic" && (t = new eh(-s.xmag, s.xmag, s.ymag, -s.ymag, s.znear, s.zfar)), n.name && (t.name = this.createUniqueName(n.name)), $n(t, n), Promise.resolve(t);
        }
        loadSkin(e) {
            const t = this.json.skins[e], n = [];
            for(let s = 0, r = t.joints.length; s < r; s++)n.push(this._loadNodeShallow(t.joints[s]));
            return t.inverseBindMatrices !== void 0 ? n.push(this.getDependency("accessor", t.inverseBindMatrices)) : n.push(null), Promise.all(n).then(function(s) {
                const r = s.pop(), a = s, o = [], c = [];
                for(let l = 0, h = a.length; l < h; l++){
                    const u = a[l];
                    if (u) {
                        o.push(u);
                        const d = new He;
                        r !== null && d.fromArray(r.array, l * 16), c.push(d);
                    } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[l]);
                }
                return new Kl(o, c);
            });
        }
        loadAnimation(e) {
            const t = this.json, n = this, s = t.animations[e], r = s.name ? s.name : "animation_" + e, a = [], o = [], c = [], l = [], h = [];
            for(let u = 0, d = s.channels.length; u < d; u++){
                const f = s.channels[u], _ = s.samplers[f.sampler], g = f.target, p = g.node, m = s.parameters !== void 0 ? s.parameters[_.input] : _.input, v = s.parameters !== void 0 ? s.parameters[_.output] : _.output;
                g.node !== void 0 && (a.push(this.getDependency("node", p)), o.push(this.getDependency("accessor", m)), c.push(this.getDependency("accessor", v)), l.push(_), h.push(g));
            }
            return Promise.all([
                Promise.all(a),
                Promise.all(o),
                Promise.all(c),
                Promise.all(l),
                Promise.all(h)
            ]).then(function(u) {
                const d = u[0], f = u[1], _ = u[2], g = u[3], p = u[4], m = [];
                for(let v = 0, y = d.length; v < y; v++){
                    const x = d[v], I = f[v], w = _[v], R = g[v], N = p[v];
                    if (x === void 0) continue;
                    x.updateMatrix && x.updateMatrix();
                    const E = n._createAnimationTracks(x, I, w, R, N);
                    if (E) for(let S = 0; S < E.length; S++)m.push(E[S]);
                }
                return new hl(r, void 0, m);
            });
        }
        createNodeMesh(e) {
            const t = this.json, n = this, s = t.nodes[e];
            return s.mesh === void 0 ? null : n.getDependency("mesh", s.mesh).then(function(r) {
                const a = n._getNodeRef(n.meshCache, s.mesh, r);
                return s.weights !== void 0 && a.traverse(function(o) {
                    if (o.isMesh) for(let c = 0, l = s.weights.length; c < l; c++)o.morphTargetInfluences[c] = s.weights[c];
                }), a;
            });
        }
        loadNode(e) {
            const t = this.json, n = this, s = t.nodes[e], r = n._loadNodeShallow(e), a = [], o = s.children || [];
            for(let l = 0, h = o.length; l < h; l++)a.push(n.getDependency("node", o[l]));
            const c = s.skin === void 0 ? Promise.resolve(null) : n.getDependency("skin", s.skin);
            return Promise.all([
                r,
                Promise.all(a),
                c
            ]).then(function(l) {
                const h = l[0], u = l[1], d = l[2];
                d !== null && h.traverse(function(f) {
                    f.isSkinnedMesh && f.bind(d, dM);
                });
                for(let f = 0, _ = u.length; f < _; f++)h.add(u[f]);
                return h;
            });
        }
        _loadNodeShallow(e) {
            const t = this.json, n = this.extensions, s = this;
            if (this.nodeCache[e] !== void 0) return this.nodeCache[e];
            const r = t.nodes[e], a = r.name ? s.createUniqueName(r.name) : "", o = [], c = s._invokeOne(function(l) {
                return l.createNodeMesh && l.createNodeMesh(e);
            });
            return c && o.push(c), r.camera !== void 0 && o.push(s.getDependency("camera", r.camera).then(function(l) {
                return s._getNodeRef(s.cameraCache, r.camera, l);
            })), s._invokeAll(function(l) {
                return l.createNodeAttachment && l.createNodeAttachment(e);
            }).forEach(function(l) {
                o.push(l);
            }), this.nodeCache[e] = Promise.all(o).then(function(l) {
                let h;
                if (r.isBone === !0 ? h = new Yf : l.length > 1 ? h = new Oi : l.length === 1 ? h = l[0] : h = new gt, h !== l[0]) for(let u = 0, d = l.length; u < d; u++)h.add(l[u]);
                if (r.name && (h.userData.name = r.name, h.name = a), $n(h, r), r.extensions && wi(n, h, r), r.matrix !== void 0) {
                    const u = new He;
                    u.fromArray(r.matrix), h.applyMatrix4(u);
                } else r.translation !== void 0 && h.position.fromArray(r.translation), r.rotation !== void 0 && h.quaternion.fromArray(r.rotation), r.scale !== void 0 && h.scale.fromArray(r.scale);
                return s.associations.has(h) || s.associations.set(h, {}), s.associations.get(h).nodes = e, h;
            }), this.nodeCache[e];
        }
        loadScene(e) {
            const t = this.extensions, n = this.json.scenes[e], s = this, r = new Oi;
            n.name && (r.name = s.createUniqueName(n.name)), $n(r, n), n.extensions && wi(t, r, n);
            const a = n.nodes || [], o = [];
            for(let c = 0, l = a.length; c < l; c++)o.push(s.getDependency("node", a[c]));
            return Promise.all(o).then(function(c) {
                for(let h = 0, u = c.length; h < u; h++)r.add(c[h]);
                const l = (h)=>{
                    const u = new Map;
                    for (const [d, f] of s.associations)(d instanceof Nn || d instanceof Qt) && u.set(d, f);
                    return h.traverse((d)=>{
                        const f = s.associations.get(d);
                        f != null && u.set(d, f);
                    }), u;
                };
                return s.associations = l(r), r;
            });
        }
        _createAnimationTracks(e, t, n, s, r) {
            const a = [], o = e.name ? e.name : e.uuid, c = [];
            li[r.path] === li.weights ? e.traverse(function(d) {
                d.morphTargetInfluences && c.push(d.name ? d.name : d.uuid);
            }) : c.push(o);
            let l;
            switch(li[r.path]){
                case li.weights:
                    l = Ls;
                    break;
                case li.rotation:
                    l = Us;
                    break;
                case li.translation:
                case li.scale:
                    l = Ns;
                    break;
                default:
                    switch(n.itemSize){
                        case 1:
                            l = Ls;
                            break;
                        case 2:
                        case 3:
                        default:
                            l = Ns;
                            break;
                    }
                    break;
            }
            const h = s.interpolation !== void 0 ? aM[s.interpolation] : Ar, u = this._getArrayFromAccessor(n);
            for(let d = 0, f = c.length; d < f; d++){
                const _ = new l(c[d] + "." + li[r.path], t.array, u, h);
                s.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(_), a.push(_);
            }
            return a;
        }
        _getArrayFromAccessor(e) {
            let t = e.array;
            if (e.normalized) {
                const n = pl(t.constructor), s = new Float32Array(t.length);
                for(let r = 0, a = t.length; r < a; r++)s[r] = t[r] * n;
                t = s;
            }
            return t;
        }
        _createCubicSplineTrackInterpolant(e) {
            e.createInterpolant = function(n) {
                const s = this instanceof Us ? rM : cp;
                return new s(this.times, this.values, this.getValueSize() / 3, n);
            }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0;
        }
    }
    function pM(i, e, t) {
        const n = e.attributes, s = new fn;
        if (n.POSITION !== void 0) {
            const o = t.json.accessors[n.POSITION], c = o.min, l = o.max;
            if (c !== void 0 && l !== void 0) {
                if (s.set(new k(c[0], c[1], c[2]), new k(l[0], l[1], l[2])), o.normalized) {
                    const h = pl(Es[o.componentType]);
                    s.min.multiplyScalar(h), s.max.multiplyScalar(h);
                }
            } else {
                console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                return;
            }
        } else return;
        const r = e.targets;
        if (r !== void 0) {
            const o = new k, c = new k;
            for(let l = 0, h = r.length; l < h; l++){
                const u = r[l];
                if (u.POSITION !== void 0) {
                    const d = t.json.accessors[u.POSITION], f = d.min, _ = d.max;
                    if (f !== void 0 && _ !== void 0) {
                        if (c.setX(Math.max(Math.abs(f[0]), Math.abs(_[0]))), c.setY(Math.max(Math.abs(f[1]), Math.abs(_[1]))), c.setZ(Math.max(Math.abs(f[2]), Math.abs(_[2]))), d.normalized) {
                            const g = pl(Es[d.componentType]);
                            c.multiplyScalar(g);
                        }
                        o.max(c);
                    } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                }
            }
            s.expandByVector(o);
        }
        i.boundingBox = s;
        const a = new Fn;
        s.getCenter(a.center), a.radius = s.min.distanceTo(s.max) / 2, i.boundingSphere = a;
    }
    function cd(i, e, t) {
        const n = e.attributes, s = [];
        function r(a, o) {
            return t.getDependency("accessor", a).then(function(c) {
                i.setAttribute(o, c);
            });
        }
        for(const a in n){
            const o = fl[a] || a.toLowerCase();
            o in i.attributes || s.push(r(n[a], o));
        }
        if (e.indices !== void 0 && !i.index) {
            const a = t.getDependency("accessor", e.indices).then(function(o) {
                i.setIndex(o);
            });
            s.push(a);
        }
        return $e.workingColorSpace !== $t && "COLOR_0" in n && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${$e.workingColorSpace}" not supported.`), $n(i, e), pM(i, e, t), Promise.all(s).then(function() {
            return e.targets !== void 0 ? cM(i, e.targets, t) : i;
        });
    }
    class Wi {
        static _instance = new Wi;
        static get instance() {
            return this._instance;
        }
        constructor(){}
        _models = new Map;
        _textures = new Map;
        getModel(e) {
            const t = this._models.get(e);
            if (!t) throw new Error(`Model ${e} not found`);
            return t;
        }
        getTexture(e) {
            const t = this._textures.get(e);
            if (!t) throw new Error(`Texture ${e} not found`);
            return t;
        }
        load = async ()=>{
            new sd().load("assets/models/cibus_ninja.glb", (n)=>{
                this._models.set("ninja", n);
            }, (n)=>{
                console.log(n.loaded / n.total * 100 + "% loaded");
            }, (n)=>{
                console.error("Error loading GLB:", n);
            });
            const e = new ul, t = (n, s)=>{
                const r = e.load(n);
                this._textures.set(s, r);
            };
            t("assets/textures/ninja.png", "ninja"), t("assets/textures/sand.jpg", "ground"), t("assets/textures/brick.png", "wall");
        };
        loadAsync = async ()=>{
            await this.loadModels(), await this.loadTextures();
        };
        loadModels = async ()=>{
            const e = new sd;
            (async (n, s)=>{
                e.load(n, (r)=>{
                    this._models.set(s, r);
                });
            })("assets/models/cibus_ninja.glb", "ninja");
        };
        loadTextures = async ()=>{
            const e = new ul, t = async (n, s)=>{
                const r = await e.loadAsync(n);
                this._textures.set(s, r);
            };
            await t("assets/textures/ninja.png", "ninja"), await t("assets/textures/sand.jpg", "ground"), await t("assets/textures/brick.png", "wall");
        };
    }
    class mM {
        _renderer;
        _width;
        _height;
        constructor(e){
            this._renderer = new US({
                canvas: e,
                antialias: !0,
                stencil: !0
            }), this._width = window.innerWidth, this._height = window.innerHeight, this._renderer.shadowMap.enabled = !0, this._renderer.setSize(this._width, this._height), this._renderer.setClearColor(14540253, 1);
        }
        get renderer() {
            return this._renderer;
        }
        get width() {
            return this._width;
        }
        get height() {
            return this._height;
        }
        render(e) {
            if (!e) {
                console.warn("No game scene provided for rendering.");
                return;
            }
            this._renderer.resetState(), e.entities3D.forEach((t)=>{
                this._renderer.render(t, e.camera3D);
            });
        }
        resize = (e, t)=>{
            this._renderer.setSize(e, t);
        };
    }
    const _M = "modulepreload", gM = function(i, e) {
        return new URL(i, e).href;
    }, ld = {}, lp = function(e, t, n) {
        let s = Promise.resolve();
        if (t && t.length > 0) {
            const a = document.getElementsByTagName("link"), o = document.querySelector("meta[property=csp-nonce]"), c = o?.nonce || o?.getAttribute("nonce");
            s = Promise.allSettled(t.map((l)=>{
                if (l = gM(l, n), l in ld) return;
                ld[l] = !0;
                const h = l.endsWith(".css"), u = h ? '[rel="stylesheet"]' : "";
                if (!!n) for(let _ = a.length - 1; _ >= 0; _--){
                    const g = a[_];
                    if (g.href === l && (!h || g.rel === "stylesheet")) return;
                }
                else if (document.querySelector(`link[href="${l}"]${u}`)) return;
                const f = document.createElement("link");
                if (f.rel = h ? "stylesheet" : _M, h || (f.as = "script"), f.crossOrigin = "", f.href = l, c && f.setAttribute("nonce", c), document.head.appendChild(f), h) return new Promise((_, g)=>{
                    f.addEventListener("load", _), f.addEventListener("error", ()=>g(new Error(`Unable to preload CSS for ${l}`)));
                });
            }));
        }
        function r(a) {
            const o = new Event("vite:preloadError", {
                cancelable: !0
            });
            if (o.payload = a, window.dispatchEvent(o), !o.defaultPrevented) throw a;
        }
        return s.then((a)=>{
            for (const o of a || [])o.status === "rejected" && r(o.reason);
            return e().catch(r);
        });
    };
    se = ((i)=>(i.Application = "application", i.WebGLPipes = "webgl-pipes", i.WebGLPipesAdaptor = "webgl-pipes-adaptor", i.WebGLSystem = "webgl-system", i.WebGPUPipes = "webgpu-pipes", i.WebGPUPipesAdaptor = "webgpu-pipes-adaptor", i.WebGPUSystem = "webgpu-system", i.CanvasSystem = "canvas-system", i.CanvasPipesAdaptor = "canvas-pipes-adaptor", i.CanvasPipes = "canvas-pipes", i.Asset = "asset", i.LoadParser = "load-parser", i.ResolveParser = "resolve-parser", i.CacheParser = "cache-parser", i.DetectionParser = "detection-parser", i.MaskEffect = "mask-effect", i.BlendMode = "blend-mode", i.TextureSource = "texture-source", i.Environment = "environment", i.ShapeBuilder = "shape-builder", i.Batcher = "batcher", i))(se || {});
    let ml, fa, xM, vM;
    ml = (i)=>{
        if (typeof i == "function" || typeof i == "object" && i.extension) {
            if (!i.extension) throw new Error("Extension class must have an extension object");
            i = {
                ...typeof i.extension != "object" ? {
                    type: i.extension
                } : i.extension,
                ref: i
            };
        }
        if (typeof i == "object") i = {
            ...i
        };
        else throw new Error("Invalid extension type");
        return typeof i.type == "string" && (i.type = [
            i.type
        ]), i;
    };
    fa = (i, e)=>ml(i).priority ?? e;
    Nt = {
        _addHandlers: {},
        _removeHandlers: {},
        _queue: {},
        remove (...i) {
            return i.map(ml).forEach((e)=>{
                e.type.forEach((t)=>this._removeHandlers[t]?.(e));
            }), this;
        },
        add (...i) {
            return i.map(ml).forEach((e)=>{
                e.type.forEach((t)=>{
                    const n = this._addHandlers, s = this._queue;
                    n[t] ? n[t]?.(e) : (s[t] = s[t] || [], s[t]?.push(e));
                });
            }), this;
        },
        handle (i, e, t) {
            const n = this._addHandlers, s = this._removeHandlers;
            if (n[i] || s[i]) throw new Error(`Extension type ${i} already has a handler`);
            n[i] = e, s[i] = t;
            const r = this._queue;
            return r[i] && (r[i]?.forEach((a)=>e(a)), delete r[i]), this;
        },
        handleByMap (i, e) {
            return this.handle(i, (t)=>{
                t.name && (e[t.name] = t.ref);
            }, (t)=>{
                t.name && delete e[t.name];
            });
        },
        handleByNamedList (i, e, t = -1) {
            return this.handle(i, (n)=>{
                e.findIndex((r)=>r.name === n.name) >= 0 || (e.push({
                    name: n.name,
                    value: n.ref
                }), e.sort((r, a)=>fa(a.value, t) - fa(r.value, t)));
            }, (n)=>{
                const s = e.findIndex((r)=>r.name === n.name);
                s !== -1 && e.splice(s, 1);
            });
        },
        handleByList (i, e, t = -1) {
            return this.handle(i, (n)=>{
                e.includes(n.ref) || (e.push(n.ref), e.sort((s, r)=>fa(r, t) - fa(s, t)));
            }, (n)=>{
                const s = e.indexOf(n.ref);
                s !== -1 && e.splice(s, 1);
            });
        },
        mixin (i, ...e) {
            for (const t of e)Object.defineProperties(i.prototype, Object.getOwnPropertyDescriptors(t));
        }
    };
    xM = {
        extension: {
            type: se.Environment,
            name: "browser",
            priority: -1
        },
        test: ()=>!0,
        load: async ()=>{
            await lp(()=>import("./browserAll-naxp-0GG.js").then(async (m)=>{
                    await m.__tla;
                    return m;
                }), __vite__mapDeps([0,1]), import.meta.url);
        }
    };
    vM = {
        extension: {
            type: se.Environment,
            name: "webworker",
            priority: 0
        },
        test: ()=>typeof self < "u" && self.WorkerGlobalScope !== void 0,
        load: async ()=>{
            await lp(()=>import("./webworkerAll-Dv38b-0_.js").then(async (m)=>{
                    await m.__tla;
                    return m;
                }), [], import.meta.url);
        }
    };
    class Zt {
        constructor(e, t, n){
            this._x = t || 0, this._y = n || 0, this._observer = e;
        }
        clone(e) {
            return new Zt(e ?? this._observer, this._x, this._y);
        }
        set(e = 0, t = e) {
            return (this._x !== e || this._y !== t) && (this._x = e, this._y = t, this._observer._onUpdate(this)), this;
        }
        copyFrom(e) {
            return (this._x !== e.x || this._y !== e.y) && (this._x = e.x, this._y = e.y, this._observer._onUpdate(this)), this;
        }
        copyTo(e) {
            return e.set(this._x, this._y), e;
        }
        equals(e) {
            return e.x === this._x && e.y === this._y;
        }
        toString() {
            return `[pixi.js/math:ObservablePoint x=0 y=0 scope=${this._observer}]`;
        }
        get x() {
            return this._x;
        }
        set x(e) {
            this._x !== e && (this._x = e, this._observer._onUpdate(this));
        }
        get y() {
            return this._y;
        }
        set y(e) {
            this._y !== e && (this._y = e, this._observer._onUpdate(this));
        }
    }
    function sh(i) {
        return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
    }
    var Ho = {
        exports: {}
    }, hd;
    function yM() {
        return hd || (hd = 1, function(i) {
            var e = Object.prototype.hasOwnProperty, t = "~";
            function n() {}
            Object.create && (n.prototype = Object.create(null), new n().__proto__ || (t = !1));
            function s(c, l, h) {
                this.fn = c, this.context = l, this.once = h || !1;
            }
            function r(c, l, h, u, d) {
                if (typeof h != "function") throw new TypeError("The listener must be a function");
                var f = new s(h, u || c, d), _ = t ? t + l : l;
                return c._events[_] ? c._events[_].fn ? c._events[_] = [
                    c._events[_],
                    f
                ] : c._events[_].push(f) : (c._events[_] = f, c._eventsCount++), c;
            }
            function a(c, l) {
                --c._eventsCount === 0 ? c._events = new n : delete c._events[l];
            }
            function o() {
                this._events = new n, this._eventsCount = 0;
            }
            o.prototype.eventNames = function() {
                var l = [], h, u;
                if (this._eventsCount === 0) return l;
                for(u in h = this._events)e.call(h, u) && l.push(t ? u.slice(1) : u);
                return Object.getOwnPropertySymbols ? l.concat(Object.getOwnPropertySymbols(h)) : l;
            }, o.prototype.listeners = function(l) {
                var h = t ? t + l : l, u = this._events[h];
                if (!u) return [];
                if (u.fn) return [
                    u.fn
                ];
                for(var d = 0, f = u.length, _ = new Array(f); d < f; d++)_[d] = u[d].fn;
                return _;
            }, o.prototype.listenerCount = function(l) {
                var h = t ? t + l : l, u = this._events[h];
                return u ? u.fn ? 1 : u.length : 0;
            }, o.prototype.emit = function(l, h, u, d, f, _) {
                var g = t ? t + l : l;
                if (!this._events[g]) return !1;
                var p = this._events[g], m = arguments.length, v, y;
                if (p.fn) {
                    switch(p.once && this.removeListener(l, p.fn, void 0, !0), m){
                        case 1:
                            return p.fn.call(p.context), !0;
                        case 2:
                            return p.fn.call(p.context, h), !0;
                        case 3:
                            return p.fn.call(p.context, h, u), !0;
                        case 4:
                            return p.fn.call(p.context, h, u, d), !0;
                        case 5:
                            return p.fn.call(p.context, h, u, d, f), !0;
                        case 6:
                            return p.fn.call(p.context, h, u, d, f, _), !0;
                    }
                    for(y = 1, v = new Array(m - 1); y < m; y++)v[y - 1] = arguments[y];
                    p.fn.apply(p.context, v);
                } else {
                    var x = p.length, I;
                    for(y = 0; y < x; y++)switch(p[y].once && this.removeListener(l, p[y].fn, void 0, !0), m){
                        case 1:
                            p[y].fn.call(p[y].context);
                            break;
                        case 2:
                            p[y].fn.call(p[y].context, h);
                            break;
                        case 3:
                            p[y].fn.call(p[y].context, h, u);
                            break;
                        case 4:
                            p[y].fn.call(p[y].context, h, u, d);
                            break;
                        default:
                            if (!v) for(I = 1, v = new Array(m - 1); I < m; I++)v[I - 1] = arguments[I];
                            p[y].fn.apply(p[y].context, v);
                    }
                }
                return !0;
            }, o.prototype.on = function(l, h, u) {
                return r(this, l, h, u, !1);
            }, o.prototype.once = function(l, h, u) {
                return r(this, l, h, u, !0);
            }, o.prototype.removeListener = function(l, h, u, d) {
                var f = t ? t + l : l;
                if (!this._events[f]) return this;
                if (!h) return a(this, f), this;
                var _ = this._events[f];
                if (_.fn) _.fn === h && (!d || _.once) && (!u || _.context === u) && a(this, f);
                else {
                    for(var g = 0, p = [], m = _.length; g < m; g++)(_[g].fn !== h || d && !_[g].once || u && _[g].context !== u) && p.push(_[g]);
                    p.length ? this._events[f] = p.length === 1 ? p[0] : p : a(this, f);
                }
                return this;
            }, o.prototype.removeAllListeners = function(l) {
                var h;
                return l ? (h = t ? t + l : l, this._events[h] && a(this, h)) : (this._events = new n, this._eventsCount = 0), this;
            }, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prefixed = t, o.EventEmitter = o, i.exports = o;
        }(Ho)), Ho.exports;
    }
    var bM = yM();
    let SM, MM, TM;
    Cn = sh(bM);
    SM = Math.PI * 2;
    MM = 180 / Math.PI;
    TM = Math.PI / 180;
    Lt = class {
        constructor(e = 0, t = 0){
            this.x = 0, this.y = 0, this.x = e, this.y = t;
        }
        clone() {
            return new Lt(this.x, this.y);
        }
        copyFrom(e) {
            return this.set(e.x, e.y), this;
        }
        copyTo(e) {
            return e.set(this.x, this.y), e;
        }
        equals(e) {
            return e.x === this.x && e.y === this.y;
        }
        set(e = 0, t = e) {
            return this.x = e, this.y = t, this;
        }
        toString() {
            return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;
        }
        static get shared() {
            return zo.x = 0, zo.y = 0, zo;
        }
    };
    const zo = new Lt;
    Fe = class {
        constructor(e = 1, t = 0, n = 0, s = 1, r = 0, a = 0){
            this.array = null, this.a = e, this.b = t, this.c = n, this.d = s, this.tx = r, this.ty = a;
        }
        fromArray(e) {
            this.a = e[0], this.b = e[1], this.c = e[3], this.d = e[4], this.tx = e[2], this.ty = e[5];
        }
        set(e, t, n, s, r, a) {
            return this.a = e, this.b = t, this.c = n, this.d = s, this.tx = r, this.ty = a, this;
        }
        toArray(e, t) {
            this.array || (this.array = new Float32Array(9));
            const n = t || this.array;
            return e ? (n[0] = this.a, n[1] = this.b, n[2] = 0, n[3] = this.c, n[4] = this.d, n[5] = 0, n[6] = this.tx, n[7] = this.ty, n[8] = 1) : (n[0] = this.a, n[1] = this.c, n[2] = this.tx, n[3] = this.b, n[4] = this.d, n[5] = this.ty, n[6] = 0, n[7] = 0, n[8] = 1), n;
        }
        apply(e, t) {
            t = t || new Lt;
            const n = e.x, s = e.y;
            return t.x = this.a * n + this.c * s + this.tx, t.y = this.b * n + this.d * s + this.ty, t;
        }
        applyInverse(e, t) {
            t = t || new Lt;
            const n = this.a, s = this.b, r = this.c, a = this.d, o = this.tx, c = this.ty, l = 1 / (n * a + r * -s), h = e.x, u = e.y;
            return t.x = a * l * h + -r * l * u + (c * r - o * a) * l, t.y = n * l * u + -s * l * h + (-c * n + o * s) * l, t;
        }
        translate(e, t) {
            return this.tx += e, this.ty += t, this;
        }
        scale(e, t) {
            return this.a *= e, this.d *= t, this.c *= e, this.b *= t, this.tx *= e, this.ty *= t, this;
        }
        rotate(e) {
            const t = Math.cos(e), n = Math.sin(e), s = this.a, r = this.c, a = this.tx;
            return this.a = s * t - this.b * n, this.b = s * n + this.b * t, this.c = r * t - this.d * n, this.d = r * n + this.d * t, this.tx = a * t - this.ty * n, this.ty = a * n + this.ty * t, this;
        }
        append(e) {
            const t = this.a, n = this.b, s = this.c, r = this.d;
            return this.a = e.a * t + e.b * s, this.b = e.a * n + e.b * r, this.c = e.c * t + e.d * s, this.d = e.c * n + e.d * r, this.tx = e.tx * t + e.ty * s + this.tx, this.ty = e.tx * n + e.ty * r + this.ty, this;
        }
        appendFrom(e, t) {
            const n = e.a, s = e.b, r = e.c, a = e.d, o = e.tx, c = e.ty, l = t.a, h = t.b, u = t.c, d = t.d;
            return this.a = n * l + s * u, this.b = n * h + s * d, this.c = r * l + a * u, this.d = r * h + a * d, this.tx = o * l + c * u + t.tx, this.ty = o * h + c * d + t.ty, this;
        }
        setTransform(e, t, n, s, r, a, o, c, l) {
            return this.a = Math.cos(o + l) * r, this.b = Math.sin(o + l) * r, this.c = -Math.sin(o - c) * a, this.d = Math.cos(o - c) * a, this.tx = e - (n * this.a + s * this.c), this.ty = t - (n * this.b + s * this.d), this;
        }
        prepend(e) {
            const t = this.tx;
            if (e.a !== 1 || e.b !== 0 || e.c !== 0 || e.d !== 1) {
                const n = this.a, s = this.c;
                this.a = n * e.a + this.b * e.c, this.b = n * e.b + this.b * e.d, this.c = s * e.a + this.d * e.c, this.d = s * e.b + this.d * e.d;
            }
            return this.tx = t * e.a + this.ty * e.c + e.tx, this.ty = t * e.b + this.ty * e.d + e.ty, this;
        }
        decompose(e) {
            const t = this.a, n = this.b, s = this.c, r = this.d, a = e.pivot, o = -Math.atan2(-s, r), c = Math.atan2(n, t), l = Math.abs(o + c);
            return l < 1e-5 || Math.abs(SM - l) < 1e-5 ? (e.rotation = c, e.skew.x = e.skew.y = 0) : (e.rotation = 0, e.skew.x = o, e.skew.y = c), e.scale.x = Math.sqrt(t * t + n * n), e.scale.y = Math.sqrt(s * s + r * r), e.position.x = this.tx + (a.x * t + a.y * s), e.position.y = this.ty + (a.x * n + a.y * r), e;
        }
        invert() {
            const e = this.a, t = this.b, n = this.c, s = this.d, r = this.tx, a = e * s - t * n;
            return this.a = s / a, this.b = -t / a, this.c = -n / a, this.d = e / a, this.tx = (n * this.ty - s * r) / a, this.ty = -(e * this.ty - t * r) / a, this;
        }
        isIdentity() {
            return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;
        }
        identity() {
            return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;
        }
        clone() {
            const e = new Fe;
            return e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty, e;
        }
        copyTo(e) {
            return e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty, e;
        }
        copyFrom(e) {
            return this.a = e.a, this.b = e.b, this.c = e.c, this.d = e.d, this.tx = e.tx, this.ty = e.ty, this;
        }
        equals(e) {
            return e.a === this.a && e.b === this.b && e.c === this.c && e.d === this.d && e.tx === this.tx && e.ty === this.ty;
        }
        toString() {
            return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
        }
        static get IDENTITY() {
            return AM.identity();
        }
        static get shared() {
            return EM.identity();
        }
    };
    const EM = new Fe, AM = new Fe, Ii = [
        1,
        1,
        0,
        -1,
        -1,
        -1,
        0,
        1,
        1,
        1,
        0,
        -1,
        -1,
        -1,
        0,
        1
    ], Di = [
        0,
        1,
        1,
        1,
        0,
        -1,
        -1,
        -1,
        0,
        1,
        1,
        1,
        0,
        -1,
        -1,
        -1
    ], Li = [
        0,
        -1,
        -1,
        -1,
        0,
        1,
        1,
        1,
        0,
        1,
        1,
        1,
        0,
        -1,
        -1,
        -1
    ], Ui = [
        1,
        1,
        0,
        -1,
        -1,
        -1,
        0,
        1,
        -1,
        -1,
        0,
        1,
        1,
        1,
        0,
        -1
    ], _l = [], hp = [], pa = Math.sign;
    function wM() {
        for(let i = 0; i < 16; i++){
            const e = [];
            _l.push(e);
            for(let t = 0; t < 16; t++){
                const n = pa(Ii[i] * Ii[t] + Li[i] * Di[t]), s = pa(Di[i] * Ii[t] + Ui[i] * Di[t]), r = pa(Ii[i] * Li[t] + Li[i] * Ui[t]), a = pa(Di[i] * Li[t] + Ui[i] * Ui[t]);
                for(let o = 0; o < 16; o++)if (Ii[o] === n && Di[o] === s && Li[o] === r && Ui[o] === a) {
                    e.push(o);
                    break;
                }
            }
        }
        for(let i = 0; i < 16; i++){
            const e = new Fe;
            e.set(Ii[i], Di[i], Li[i], Ui[i], 0, 0), hp.push(e);
        }
    }
    wM();
    const mt = {
        E: 0,
        SE: 1,
        S: 2,
        SW: 3,
        W: 4,
        NW: 5,
        N: 6,
        NE: 7,
        MIRROR_VERTICAL: 8,
        MAIN_DIAGONAL: 10,
        MIRROR_HORIZONTAL: 12,
        REVERSE_DIAGONAL: 14,
        uX: (i)=>Ii[i],
        uY: (i)=>Di[i],
        vX: (i)=>Li[i],
        vY: (i)=>Ui[i],
        inv: (i)=>i & 8 ? i & 15 : -i & 7,
        add: (i, e)=>_l[i][e],
        sub: (i, e)=>_l[i][mt.inv(e)],
        rotate180: (i)=>i ^ 4,
        isVertical: (i)=>(i & 3) === 2,
        byDirection: (i, e)=>Math.abs(i) * 2 <= Math.abs(e) ? e >= 0 ? mt.S : mt.N : Math.abs(e) * 2 <= Math.abs(i) ? i > 0 ? mt.E : mt.W : e > 0 ? i > 0 ? mt.SE : mt.SW : i > 0 ? mt.NE : mt.NW,
        matrixAppendRotationInv: (i, e, t = 0, n = 0)=>{
            const s = hp[mt.inv(e)];
            s.tx = t, s.ty = n, i.append(s);
        }
    }, ma = [
        new Lt,
        new Lt,
        new Lt,
        new Lt
    ];
    ft = class {
        constructor(e = 0, t = 0, n = 0, s = 0){
            this.type = "rectangle", this.x = Number(e), this.y = Number(t), this.width = Number(n), this.height = Number(s);
        }
        get left() {
            return this.x;
        }
        get right() {
            return this.x + this.width;
        }
        get top() {
            return this.y;
        }
        get bottom() {
            return this.y + this.height;
        }
        isEmpty() {
            return this.left === this.right || this.top === this.bottom;
        }
        static get EMPTY() {
            return new ft(0, 0, 0, 0);
        }
        clone() {
            return new ft(this.x, this.y, this.width, this.height);
        }
        copyFromBounds(e) {
            return this.x = e.minX, this.y = e.minY, this.width = e.maxX - e.minX, this.height = e.maxY - e.minY, this;
        }
        copyFrom(e) {
            return this.x = e.x, this.y = e.y, this.width = e.width, this.height = e.height, this;
        }
        copyTo(e) {
            return e.copyFrom(this), e;
        }
        contains(e, t) {
            return this.width <= 0 || this.height <= 0 ? !1 : e >= this.x && e < this.x + this.width && t >= this.y && t < this.y + this.height;
        }
        strokeContains(e, t, n, s = .5) {
            const { width: r, height: a } = this;
            if (r <= 0 || a <= 0) return !1;
            const o = this.x, c = this.y, l = n * (1 - s), h = n - l, u = o - l, d = o + r + l, f = c - l, _ = c + a + l, g = o + h, p = o + r - h, m = c + h, v = c + a - h;
            return e >= u && e <= d && t >= f && t <= _ && !(e > g && e < p && t > m && t < v);
        }
        intersects(e, t) {
            if (!t) {
                const N = this.x < e.x ? e.x : this.x;
                if ((this.right > e.right ? e.right : this.right) <= N) return !1;
                const S = this.y < e.y ? e.y : this.y;
                return (this.bottom > e.bottom ? e.bottom : this.bottom) > S;
            }
            const n = this.left, s = this.right, r = this.top, a = this.bottom;
            if (s <= n || a <= r) return !1;
            const o = ma[0].set(e.left, e.top), c = ma[1].set(e.left, e.bottom), l = ma[2].set(e.right, e.top), h = ma[3].set(e.right, e.bottom);
            if (l.x <= o.x || c.y <= o.y) return !1;
            const u = Math.sign(t.a * t.d - t.b * t.c);
            if (u === 0 || (t.apply(o, o), t.apply(c, c), t.apply(l, l), t.apply(h, h), Math.max(o.x, c.x, l.x, h.x) <= n || Math.min(o.x, c.x, l.x, h.x) >= s || Math.max(o.y, c.y, l.y, h.y) <= r || Math.min(o.y, c.y, l.y, h.y) >= a)) return !1;
            const d = u * (c.y - o.y), f = u * (o.x - c.x), _ = d * n + f * r, g = d * s + f * r, p = d * n + f * a, m = d * s + f * a;
            if (Math.max(_, g, p, m) <= d * o.x + f * o.y || Math.min(_, g, p, m) >= d * h.x + f * h.y) return !1;
            const v = u * (o.y - l.y), y = u * (l.x - o.x), x = v * n + y * r, I = v * s + y * r, w = v * n + y * a, R = v * s + y * a;
            return !(Math.max(x, I, w, R) <= v * o.x + y * o.y || Math.min(x, I, w, R) >= v * h.x + y * h.y);
        }
        pad(e = 0, t = e) {
            return this.x -= e, this.y -= t, this.width += e * 2, this.height += t * 2, this;
        }
        fit(e) {
            const t = Math.max(this.x, e.x), n = Math.min(this.x + this.width, e.x + e.width), s = Math.max(this.y, e.y), r = Math.min(this.y + this.height, e.y + e.height);
            return this.x = t, this.width = Math.max(n - t, 0), this.y = s, this.height = Math.max(r - s, 0), this;
        }
        ceil(e = 1, t = .001) {
            const n = Math.ceil((this.x + this.width - t) * e) / e, s = Math.ceil((this.y + this.height - t) * e) / e;
            return this.x = Math.floor((this.x + t) * e) / e, this.y = Math.floor((this.y + t) * e) / e, this.width = n - this.x, this.height = s - this.y, this;
        }
        enlarge(e) {
            const t = Math.min(this.x, e.x), n = Math.max(this.x + this.width, e.x + e.width), s = Math.min(this.y, e.y), r = Math.max(this.y + this.height, e.y + e.height);
            return this.x = t, this.width = n - t, this.y = s, this.height = r - s, this;
        }
        getBounds(e) {
            return e || (e = new ft), e.copyFrom(this), e;
        }
        containsRect(e) {
            if (this.width <= 0 || this.height <= 0) return !1;
            const t = e.x, n = e.y, s = e.x + e.width, r = e.y + e.height;
            return t >= this.x && t < this.x + this.width && n >= this.y && n < this.y + this.height && s >= this.x && s < this.x + this.width && r >= this.y && r < this.y + this.height;
        }
        toString() {
            return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
        }
    };
    const Vo = {
        default: -1
    };
    function pt(i = "default") {
        return Vo[i] === void 0 && (Vo[i] = -1), ++Vo[i];
    }
    let ud, RM;
    ud = {};
    bt = "8.0.0";
    RM = "8.3.4";
    ut = function(i, e, t = 3) {
        if (ud[e]) return;
        let n = new Error().stack;
        typeof n > "u" ? console.warn("PixiJS Deprecation Warning: ", `${e}
Deprecated since v${i}`) : (n = n.split(`
`).splice(t).join(`
`), console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", `${e}
Deprecated since v${i}`), console.warn(n), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", `${e}
Deprecated since v${i}`), console.warn(n))), ud[e] = !0;
    };
    const up = ()=>{};
    dd = function(i) {
        return i += i === 0 ? 1 : 0, --i, i |= i >>> 1, i |= i >>> 2, i |= i >>> 4, i |= i >>> 8, i |= i >>> 16, i + 1;
    };
    function fd(i) {
        return !(i & i - 1) && !!i;
    }
    function dp(i) {
        const e = {};
        for(const t in i)i[t] !== void 0 && (e[t] = i[t]);
        return e;
    }
    const pd = Object.create(null);
    function CM(i) {
        const e = pd[i];
        return e === void 0 && (pd[i] = pt("resource")), e;
    }
    const fp = class pp extends Cn {
        constructor(e = {}){
            super(), this._resourceType = "textureSampler", this._touched = 0, this._maxAnisotropy = 1, this.destroyed = !1, e = {
                ...pp.defaultOptions,
                ...e
            }, this.addressMode = e.addressMode, this.addressModeU = e.addressModeU ?? this.addressModeU, this.addressModeV = e.addressModeV ?? this.addressModeV, this.addressModeW = e.addressModeW ?? this.addressModeW, this.scaleMode = e.scaleMode, this.magFilter = e.magFilter ?? this.magFilter, this.minFilter = e.minFilter ?? this.minFilter, this.mipmapFilter = e.mipmapFilter ?? this.mipmapFilter, this.lodMinClamp = e.lodMinClamp, this.lodMaxClamp = e.lodMaxClamp, this.compare = e.compare, this.maxAnisotropy = e.maxAnisotropy ?? 1;
        }
        set addressMode(e) {
            this.addressModeU = e, this.addressModeV = e, this.addressModeW = e;
        }
        get addressMode() {
            return this.addressModeU;
        }
        set wrapMode(e) {
            ut(bt, "TextureStyle.wrapMode is now TextureStyle.addressMode"), this.addressMode = e;
        }
        get wrapMode() {
            return this.addressMode;
        }
        set scaleMode(e) {
            this.magFilter = e, this.minFilter = e, this.mipmapFilter = e;
        }
        get scaleMode() {
            return this.magFilter;
        }
        set maxAnisotropy(e) {
            this._maxAnisotropy = Math.min(e, 16), this._maxAnisotropy > 1 && (this.scaleMode = "linear");
        }
        get maxAnisotropy() {
            return this._maxAnisotropy;
        }
        get _resourceId() {
            return this._sharedResourceId || this._generateResourceId();
        }
        update() {
            this.emit("change", this), this._sharedResourceId = null;
        }
        _generateResourceId() {
            const e = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
            return this._sharedResourceId = CM(e), this._resourceId;
        }
        destroy() {
            this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this.removeAllListeners();
        }
    };
    fp.defaultOptions = {
        addressMode: "clamp-to-edge",
        scaleMode: "linear"
    };
    PM = fp;
    const mp = class _p extends Cn {
        constructor(e = {}){
            super(), this.options = e, this.uid = pt("textureSource"), this._resourceType = "textureSource", this._resourceId = pt("resource"), this.uploadMethodId = "unknown", this._resolution = 1, this.pixelWidth = 1, this.pixelHeight = 1, this.width = 1, this.height = 1, this.sampleCount = 1, this.mipLevelCount = 1, this.autoGenerateMipmaps = !1, this.format = "rgba8unorm", this.dimension = "2d", this.antialias = !1, this._touched = 0, this._batchTick = -1, this._textureBindLocation = -1, e = {
                ..._p.defaultOptions,
                ...e
            }, this.label = e.label ?? "", this.resource = e.resource, this.autoGarbageCollect = e.autoGarbageCollect, this._resolution = e.resolution, e.width ? this.pixelWidth = e.width * this._resolution : this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1, e.height ? this.pixelHeight = e.height * this._resolution : this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1, this.width = this.pixelWidth / this._resolution, this.height = this.pixelHeight / this._resolution, this.format = e.format, this.dimension = e.dimensions, this.mipLevelCount = e.mipLevelCount, this.autoGenerateMipmaps = e.autoGenerateMipmaps, this.sampleCount = e.sampleCount, this.antialias = e.antialias, this.alphaMode = e.alphaMode, this.style = new PM(dp(e)), this.destroyed = !1, this._refreshPOT();
        }
        get source() {
            return this;
        }
        get style() {
            return this._style;
        }
        set style(e) {
            this.style !== e && (this._style?.off("change", this._onStyleChange, this), this._style = e, this._style?.on("change", this._onStyleChange, this), this._onStyleChange());
        }
        get addressMode() {
            return this._style.addressMode;
        }
        set addressMode(e) {
            this._style.addressMode = e;
        }
        get repeatMode() {
            return this._style.addressMode;
        }
        set repeatMode(e) {
            this._style.addressMode = e;
        }
        get magFilter() {
            return this._style.magFilter;
        }
        set magFilter(e) {
            this._style.magFilter = e;
        }
        get minFilter() {
            return this._style.minFilter;
        }
        set minFilter(e) {
            this._style.minFilter = e;
        }
        get mipmapFilter() {
            return this._style.mipmapFilter;
        }
        set mipmapFilter(e) {
            this._style.mipmapFilter = e;
        }
        get lodMinClamp() {
            return this._style.lodMinClamp;
        }
        set lodMinClamp(e) {
            this._style.lodMinClamp = e;
        }
        get lodMaxClamp() {
            return this._style.lodMaxClamp;
        }
        set lodMaxClamp(e) {
            this._style.lodMaxClamp = e;
        }
        _onStyleChange() {
            this.emit("styleChange", this);
        }
        update() {
            if (this.resource) {
                const e = this._resolution;
                if (this.resize(this.resourceWidth / e, this.resourceHeight / e)) return;
            }
            this.emit("update", this);
        }
        destroy() {
            this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this._style && (this._style.destroy(), this._style = null), this.uploadMethodId = null, this.resource = null, this.removeAllListeners();
        }
        unload() {
            this._resourceId = pt("resource"), this.emit("change", this), this.emit("unload", this);
        }
        get resourceWidth() {
            const { resource: e } = this;
            return e.naturalWidth || e.videoWidth || e.displayWidth || e.width;
        }
        get resourceHeight() {
            const { resource: e } = this;
            return e.naturalHeight || e.videoHeight || e.displayHeight || e.height;
        }
        get resolution() {
            return this._resolution;
        }
        set resolution(e) {
            this._resolution !== e && (this._resolution = e, this.width = this.pixelWidth / e, this.height = this.pixelHeight / e);
        }
        resize(e, t, n) {
            n || (n = this._resolution), e || (e = this.width), t || (t = this.height);
            const s = Math.round(e * n), r = Math.round(t * n);
            return this.width = s / n, this.height = r / n, this._resolution = n, this.pixelWidth === s && this.pixelHeight === r ? !1 : (this._refreshPOT(), this.pixelWidth = s, this.pixelHeight = r, this.emit("resize", this), this._resourceId = pt("resource"), this.emit("change", this), !0);
        }
        updateMipmaps() {
            this.autoGenerateMipmaps && this.mipLevelCount > 1 && this.emit("updateMipmaps", this);
        }
        set wrapMode(e) {
            this._style.wrapMode = e;
        }
        get wrapMode() {
            return this._style.wrapMode;
        }
        set scaleMode(e) {
            this._style.scaleMode = e;
        }
        get scaleMode() {
            return this._style.scaleMode;
        }
        _refreshPOT() {
            this.isPowerOfTwo = fd(this.pixelWidth) && fd(this.pixelHeight);
        }
        static test(e) {
            throw new Error("Unimplemented");
        }
    };
    mp.defaultOptions = {
        resolution: 1,
        format: "bgra8unorm",
        alphaMode: "premultiply-alpha-on-upload",
        dimensions: "2d",
        mipLevelCount: 1,
        autoGenerateMipmaps: !1,
        sampleCount: 1,
        antialias: !1,
        autoGarbageCollect: !1
    };
    let Ut = mp;
    class rh extends Ut {
        constructor(e){
            const t = e.resource || new Float32Array(e.width * e.height * 4);
            let n = e.format;
            n || (t instanceof Float32Array ? n = "rgba32float" : t instanceof Int32Array || t instanceof Uint32Array ? n = "rgba32uint" : t instanceof Int16Array || t instanceof Uint16Array ? n = "rgba16uint" : (t instanceof Int8Array, n = "bgra8unorm")), super({
                ...e,
                resource: t,
                format: n
            }), this.uploadMethodId = "buffer";
        }
        static test(e) {
            return e instanceof Int8Array || e instanceof Uint8Array || e instanceof Uint8ClampedArray || e instanceof Int16Array || e instanceof Uint16Array || e instanceof Int32Array || e instanceof Uint32Array || e instanceof Float32Array;
        }
    }
    rh.extension = se.TextureSource;
    const md = new Fe;
    class gp {
        constructor(e, t){
            this.mapCoord = new Fe, this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, typeof t > "u" ? this.clampMargin = e.width < 10 ? 0 : .5 : this.clampMargin = t, this.isSimple = !1, this.texture = e;
        }
        get texture() {
            return this._texture;
        }
        set texture(e) {
            this.texture !== e && (this._texture?.removeListener("update", this.update, this), this._texture = e, this._texture.addListener("update", this.update, this), this.update());
        }
        multiplyUvs(e, t) {
            t === void 0 && (t = e);
            const n = this.mapCoord;
            for(let s = 0; s < e.length; s += 2){
                const r = e[s], a = e[s + 1];
                t[s] = r * n.a + a * n.c + n.tx, t[s + 1] = r * n.b + a * n.d + n.ty;
            }
            return t;
        }
        update() {
            const e = this._texture;
            this._updateID++;
            const t = e.uvs;
            this.mapCoord.set(t.x1 - t.x0, t.y1 - t.y0, t.x3 - t.x0, t.y3 - t.y0, t.x0, t.y0);
            const n = e.orig, s = e.trim;
            s && (md.set(n.width / s.width, 0, 0, n.height / s.height, -s.x / s.width, -s.y / s.height), this.mapCoord.append(md));
            const r = e.source, a = this.uClampFrame, o = this.clampMargin / r._resolution, c = this.clampOffset / r._resolution;
            return a[0] = (e.frame.x + o + c) / r.width, a[1] = (e.frame.y + o + c) / r.height, a[2] = (e.frame.x + e.frame.width - o + c) / r.width, a[3] = (e.frame.y + e.frame.height - o + c) / r.height, this.uClampOffset[0] = this.clampOffset / r.pixelWidth, this.uClampOffset[1] = this.clampOffset / r.pixelHeight, this.isSimple = e.frame.width === r.width && e.frame.height === r.height && e.rotate === 0, !0;
        }
    }
    Oe = class extends Cn {
        constructor({ source: e, label: t, frame: n, orig: s, trim: r, defaultAnchor: a, defaultBorders: o, rotate: c, dynamic: l } = {}){
            if (super(), this.uid = pt("texture"), this.uvs = {
                x0: 0,
                y0: 0,
                x1: 0,
                y1: 0,
                x2: 0,
                y2: 0,
                x3: 0,
                y3: 0
            }, this.frame = new ft, this.noFrame = !1, this.dynamic = !1, this.isTexture = !0, this.label = t, this.source = e?.source ?? new Ut, this.noFrame = !n, n) this.frame.copyFrom(n);
            else {
                const { width: h, height: u } = this._source;
                this.frame.width = h, this.frame.height = u;
            }
            this.orig = s || this.frame, this.trim = r, this.rotate = c ?? 0, this.defaultAnchor = a, this.defaultBorders = o, this.destroyed = !1, this.dynamic = l || !1, this.updateUvs();
        }
        set source(e) {
            this._source && this._source.off("resize", this.update, this), this._source = e, e.on("resize", this.update, this), this.emit("update", this);
        }
        get source() {
            return this._source;
        }
        get textureMatrix() {
            return this._textureMatrix || (this._textureMatrix = new gp(this)), this._textureMatrix;
        }
        get width() {
            return this.orig.width;
        }
        get height() {
            return this.orig.height;
        }
        updateUvs() {
            const { uvs: e, frame: t } = this, { width: n, height: s } = this._source, r = t.x / n, a = t.y / s, o = t.width / n, c = t.height / s;
            let l = this.rotate;
            if (l) {
                const h = o / 2, u = c / 2, d = r + h, f = a + u;
                l = mt.add(l, mt.NW), e.x0 = d + h * mt.uX(l), e.y0 = f + u * mt.uY(l), l = mt.add(l, 2), e.x1 = d + h * mt.uX(l), e.y1 = f + u * mt.uY(l), l = mt.add(l, 2), e.x2 = d + h * mt.uX(l), e.y2 = f + u * mt.uY(l), l = mt.add(l, 2), e.x3 = d + h * mt.uX(l), e.y3 = f + u * mt.uY(l);
            } else e.x0 = r, e.y0 = a, e.x1 = r + o, e.y1 = a, e.x2 = r + o, e.y2 = a + c, e.x3 = r, e.y3 = a + c;
        }
        destroy(e = !1) {
            this._source && e && (this._source.destroy(), this._source = null), this._textureMatrix = null, this.destroyed = !0, this.emit("destroy", this), this.removeAllListeners();
        }
        update() {
            this.noFrame && (this.frame.width = this._source.width, this.frame.height = this._source.height), this.updateUvs(), this.emit("update", this);
        }
        get baseTexture() {
            return ut(bt, "Texture.baseTexture is now Texture.source"), this._source;
        }
    };
    Oe.EMPTY = new Oe({
        label: "EMPTY",
        source: new Ut({
            label: "EMPTY"
        })
    });
    Oe.EMPTY.destroy = up;
    Oe.WHITE = new Oe({
        source: new rh({
            resource: new Uint8Array([
                255,
                255,
                255,
                255
            ]),
            width: 1,
            height: 1,
            alphaMode: "premultiply-alpha-on-upload",
            label: "WHITE"
        }),
        label: "WHITE"
    });
    Oe.WHITE.destroy = up;
    IM = function(i, e, t) {
        const { width: n, height: s } = t.orig, r = t.trim;
        if (r) {
            const a = r.width, o = r.height;
            i.minX = r.x - e._x * n, i.maxX = i.minX + a, i.minY = r.y - e._y * s, i.maxY = i.minY + o;
        } else i.minX = -e._x * n, i.maxX = i.minX + n, i.minY = -e._y * s, i.maxY = i.minY + s;
    };
    const _d = new Fe;
    en = class {
        constructor(e = 1 / 0, t = 1 / 0, n = -1 / 0, s = -1 / 0){
            this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = _d, this.minX = e, this.minY = t, this.maxX = n, this.maxY = s;
        }
        isEmpty() {
            return this.minX > this.maxX || this.minY > this.maxY;
        }
        get rectangle() {
            this._rectangle || (this._rectangle = new ft);
            const e = this._rectangle;
            return this.minX > this.maxX || this.minY > this.maxY ? (e.x = 0, e.y = 0, e.width = 0, e.height = 0) : e.copyFromBounds(this), e;
        }
        clear() {
            return this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = _d, this;
        }
        set(e, t, n, s) {
            this.minX = e, this.minY = t, this.maxX = n, this.maxY = s;
        }
        addFrame(e, t, n, s, r) {
            r || (r = this.matrix);
            const a = r.a, o = r.b, c = r.c, l = r.d, h = r.tx, u = r.ty;
            let d = this.minX, f = this.minY, _ = this.maxX, g = this.maxY, p = a * e + c * t + h, m = o * e + l * t + u;
            p < d && (d = p), m < f && (f = m), p > _ && (_ = p), m > g && (g = m), p = a * n + c * t + h, m = o * n + l * t + u, p < d && (d = p), m < f && (f = m), p > _ && (_ = p), m > g && (g = m), p = a * e + c * s + h, m = o * e + l * s + u, p < d && (d = p), m < f && (f = m), p > _ && (_ = p), m > g && (g = m), p = a * n + c * s + h, m = o * n + l * s + u, p < d && (d = p), m < f && (f = m), p > _ && (_ = p), m > g && (g = m), this.minX = d, this.minY = f, this.maxX = _, this.maxY = g;
        }
        addRect(e, t) {
            this.addFrame(e.x, e.y, e.x + e.width, e.y + e.height, t);
        }
        addBounds(e, t) {
            this.addFrame(e.minX, e.minY, e.maxX, e.maxY, t);
        }
        addBoundsMask(e) {
            this.minX = this.minX > e.minX ? this.minX : e.minX, this.minY = this.minY > e.minY ? this.minY : e.minY, this.maxX = this.maxX < e.maxX ? this.maxX : e.maxX, this.maxY = this.maxY < e.maxY ? this.maxY : e.maxY;
        }
        applyMatrix(e) {
            const t = this.minX, n = this.minY, s = this.maxX, r = this.maxY, { a, b: o, c, d: l, tx: h, ty: u } = e;
            let d = a * t + c * n + h, f = o * t + l * n + u;
            this.minX = d, this.minY = f, this.maxX = d, this.maxY = f, d = a * s + c * n + h, f = o * s + l * n + u, this.minX = d < this.minX ? d : this.minX, this.minY = f < this.minY ? f : this.minY, this.maxX = d > this.maxX ? d : this.maxX, this.maxY = f > this.maxY ? f : this.maxY, d = a * t + c * r + h, f = o * t + l * r + u, this.minX = d < this.minX ? d : this.minX, this.minY = f < this.minY ? f : this.minY, this.maxX = d > this.maxX ? d : this.maxX, this.maxY = f > this.maxY ? f : this.maxY, d = a * s + c * r + h, f = o * s + l * r + u, this.minX = d < this.minX ? d : this.minX, this.minY = f < this.minY ? f : this.minY, this.maxX = d > this.maxX ? d : this.maxX, this.maxY = f > this.maxY ? f : this.maxY;
        }
        fit(e) {
            return this.minX < e.left && (this.minX = e.left), this.maxX > e.right && (this.maxX = e.right), this.minY < e.top && (this.minY = e.top), this.maxY > e.bottom && (this.maxY = e.bottom), this;
        }
        fitBounds(e, t, n, s) {
            return this.minX < e && (this.minX = e), this.maxX > t && (this.maxX = t), this.minY < n && (this.minY = n), this.maxY > s && (this.maxY = s), this;
        }
        pad(e, t = e) {
            return this.minX -= e, this.maxX += e, this.minY -= t, this.maxY += t, this;
        }
        ceil() {
            return this.minX = Math.floor(this.minX), this.minY = Math.floor(this.minY), this.maxX = Math.ceil(this.maxX), this.maxY = Math.ceil(this.maxY), this;
        }
        clone() {
            return new en(this.minX, this.minY, this.maxX, this.maxY);
        }
        scale(e, t = e) {
            return this.minX *= e, this.minY *= t, this.maxX *= e, this.maxY *= t, this;
        }
        get x() {
            return this.minX;
        }
        set x(e) {
            const t = this.maxX - this.minX;
            this.minX = e, this.maxX = e + t;
        }
        get y() {
            return this.minY;
        }
        set y(e) {
            const t = this.maxY - this.minY;
            this.minY = e, this.maxY = e + t;
        }
        get width() {
            return this.maxX - this.minX;
        }
        set width(e) {
            this.maxX = this.minX + e;
        }
        get height() {
            return this.maxY - this.minY;
        }
        set height(e) {
            this.maxY = this.minY + e;
        }
        get left() {
            return this.minX;
        }
        get right() {
            return this.maxX;
        }
        get top() {
            return this.minY;
        }
        get bottom() {
            return this.maxY;
        }
        get isPositive() {
            return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;
        }
        get isValid() {
            return this.minX + this.minY !== 1 / 0;
        }
        addVertexData(e, t, n, s) {
            let r = this.minX, a = this.minY, o = this.maxX, c = this.maxY;
            s || (s = this.matrix);
            const l = s.a, h = s.b, u = s.c, d = s.d, f = s.tx, _ = s.ty;
            for(let g = t; g < n; g += 2){
                const p = e[g], m = e[g + 1], v = l * p + u * m + f, y = h * p + d * m + _;
                r = v < r ? v : r, a = y < a ? y : a, o = v > o ? v : o, c = y > c ? y : c;
            }
            this.minX = r, this.minY = a, this.maxX = o, this.maxY = c;
        }
        containsPoint(e, t) {
            return this.minX <= e && this.minY <= t && this.maxX >= e && this.maxY >= t;
        }
        toString() {
            return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;
        }
        copyFrom(e) {
            return this.minX = e.minX, this.minY = e.minY, this.maxX = e.maxX, this.maxY = e.maxY, this;
        }
    };
    var DM = {
        grad: .9,
        turn: 360,
        rad: 360 / (2 * Math.PI)
    }, qn = function(i) {
        return typeof i == "string" ? i.length > 0 : typeof i == "number";
    }, Rt = function(i, e, t) {
        return e === void 0 && (e = 0), t === void 0 && (t = Math.pow(10, e)), Math.round(t * i) / t + 0;
    }, dn = function(i, e, t) {
        return e === void 0 && (e = 0), t === void 0 && (t = 1), i > t ? t : i > e ? i : e;
    }, xp = function(i) {
        return (i = isFinite(i) ? i % 360 : 0) > 0 ? i : i + 360;
    }, gd = function(i) {
        return {
            r: dn(i.r, 0, 255),
            g: dn(i.g, 0, 255),
            b: dn(i.b, 0, 255),
            a: dn(i.a)
        };
    }, Wo = function(i) {
        return {
            r: Rt(i.r),
            g: Rt(i.g),
            b: Rt(i.b),
            a: Rt(i.a, 3)
        };
    }, LM = /^#([0-9a-f]{3,8})$/i, _a = function(i) {
        var e = i.toString(16);
        return e.length < 2 ? "0" + e : e;
    }, vp = function(i) {
        var e = i.r, t = i.g, n = i.b, s = i.a, r = Math.max(e, t, n), a = r - Math.min(e, t, n), o = a ? r === e ? (t - n) / a : r === t ? 2 + (n - e) / a : 4 + (e - t) / a : 0;
        return {
            h: 60 * (o < 0 ? o + 6 : o),
            s: r ? a / r * 100 : 0,
            v: r / 255 * 100,
            a: s
        };
    }, yp = function(i) {
        var e = i.h, t = i.s, n = i.v, s = i.a;
        e = e / 360 * 6, t /= 100, n /= 100;
        var r = Math.floor(e), a = n * (1 - t), o = n * (1 - (e - r) * t), c = n * (1 - (1 - e + r) * t), l = r % 6;
        return {
            r: 255 * [
                n,
                o,
                a,
                a,
                c,
                n
            ][l],
            g: 255 * [
                c,
                n,
                n,
                o,
                a,
                a
            ][l],
            b: 255 * [
                a,
                a,
                c,
                n,
                n,
                o
            ][l],
            a: s
        };
    }, xd = function(i) {
        return {
            h: xp(i.h),
            s: dn(i.s, 0, 100),
            l: dn(i.l, 0, 100),
            a: dn(i.a)
        };
    }, vd = function(i) {
        return {
            h: Rt(i.h),
            s: Rt(i.s),
            l: Rt(i.l),
            a: Rt(i.a, 3)
        };
    }, yd = function(i) {
        return yp((t = (e = i).s, {
            h: e.h,
            s: (t *= ((n = e.l) < 50 ? n : 100 - n) / 100) > 0 ? 2 * t / (n + t) * 100 : 0,
            v: n + t,
            a: e.a
        }));
        var e, t, n;
    }, mr = function(i) {
        return {
            h: (e = vp(i)).h,
            s: (s = (200 - (t = e.s)) * (n = e.v) / 100) > 0 && s < 200 ? t * n / 100 / (s <= 100 ? s : 200 - s) * 100 : 0,
            l: s / 2,
            a: e.a
        };
        var e, t, n, s;
    }, UM = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, NM = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, BM = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, FM = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, gl = {
        string: [
            [
                function(i) {
                    var e = LM.exec(i);
                    return e ? (i = e[1]).length <= 4 ? {
                        r: parseInt(i[0] + i[0], 16),
                        g: parseInt(i[1] + i[1], 16),
                        b: parseInt(i[2] + i[2], 16),
                        a: i.length === 4 ? Rt(parseInt(i[3] + i[3], 16) / 255, 2) : 1
                    } : i.length === 6 || i.length === 8 ? {
                        r: parseInt(i.substr(0, 2), 16),
                        g: parseInt(i.substr(2, 2), 16),
                        b: parseInt(i.substr(4, 2), 16),
                        a: i.length === 8 ? Rt(parseInt(i.substr(6, 2), 16) / 255, 2) : 1
                    } : null : null;
                },
                "hex"
            ],
            [
                function(i) {
                    var e = BM.exec(i) || FM.exec(i);
                    return e ? e[2] !== e[4] || e[4] !== e[6] ? null : gd({
                        r: Number(e[1]) / (e[2] ? 100 / 255 : 1),
                        g: Number(e[3]) / (e[4] ? 100 / 255 : 1),
                        b: Number(e[5]) / (e[6] ? 100 / 255 : 1),
                        a: e[7] === void 0 ? 1 : Number(e[7]) / (e[8] ? 100 : 1)
                    }) : null;
                },
                "rgb"
            ],
            [
                function(i) {
                    var e = UM.exec(i) || NM.exec(i);
                    if (!e) return null;
                    var t, n, s = xd({
                        h: (t = e[1], n = e[2], n === void 0 && (n = "deg"), Number(t) * (DM[n] || 1)),
                        s: Number(e[3]),
                        l: Number(e[4]),
                        a: e[5] === void 0 ? 1 : Number(e[5]) / (e[6] ? 100 : 1)
                    });
                    return yd(s);
                },
                "hsl"
            ]
        ],
        object: [
            [
                function(i) {
                    var e = i.r, t = i.g, n = i.b, s = i.a, r = s === void 0 ? 1 : s;
                    return qn(e) && qn(t) && qn(n) ? gd({
                        r: Number(e),
                        g: Number(t),
                        b: Number(n),
                        a: Number(r)
                    }) : null;
                },
                "rgb"
            ],
            [
                function(i) {
                    var e = i.h, t = i.s, n = i.l, s = i.a, r = s === void 0 ? 1 : s;
                    if (!qn(e) || !qn(t) || !qn(n)) return null;
                    var a = xd({
                        h: Number(e),
                        s: Number(t),
                        l: Number(n),
                        a: Number(r)
                    });
                    return yd(a);
                },
                "hsl"
            ],
            [
                function(i) {
                    var e = i.h, t = i.s, n = i.v, s = i.a, r = s === void 0 ? 1 : s;
                    if (!qn(e) || !qn(t) || !qn(n)) return null;
                    var a = function(o) {
                        return {
                            h: xp(o.h),
                            s: dn(o.s, 0, 100),
                            v: dn(o.v, 0, 100),
                            a: dn(o.a)
                        };
                    }({
                        h: Number(e),
                        s: Number(t),
                        v: Number(n),
                        a: Number(r)
                    });
                    return yp(a);
                },
                "hsv"
            ]
        ]
    }, bd = function(i, e) {
        for(var t = 0; t < e.length; t++){
            var n = e[t][0](i);
            if (n) return [
                n,
                e[t][1]
            ];
        }
        return [
            null,
            void 0
        ];
    }, OM = function(i) {
        return typeof i == "string" ? bd(i.trim(), gl.string) : typeof i == "object" && i !== null ? bd(i, gl.object) : [
            null,
            void 0
        ];
    }, Xo = function(i, e) {
        var t = mr(i);
        return {
            h: t.h,
            s: dn(t.s + 100 * e, 0, 100),
            l: t.l,
            a: t.a
        };
    }, Yo = function(i) {
        return (299 * i.r + 587 * i.g + 114 * i.b) / 1e3 / 255;
    }, Sd = function(i, e) {
        var t = mr(i);
        return {
            h: t.h,
            s: t.s,
            l: dn(t.l + 100 * e, 0, 100),
            a: t.a
        };
    }, xl = function() {
        function i(e) {
            this.parsed = OM(e)[0], this.rgba = this.parsed || {
                r: 0,
                g: 0,
                b: 0,
                a: 1
            };
        }
        return i.prototype.isValid = function() {
            return this.parsed !== null;
        }, i.prototype.brightness = function() {
            return Rt(Yo(this.rgba), 2);
        }, i.prototype.isDark = function() {
            return Yo(this.rgba) < .5;
        }, i.prototype.isLight = function() {
            return Yo(this.rgba) >= .5;
        }, i.prototype.toHex = function() {
            return e = Wo(this.rgba), t = e.r, n = e.g, s = e.b, a = (r = e.a) < 1 ? _a(Rt(255 * r)) : "", "#" + _a(t) + _a(n) + _a(s) + a;
            var e, t, n, s, r, a;
        }, i.prototype.toRgb = function() {
            return Wo(this.rgba);
        }, i.prototype.toRgbString = function() {
            return e = Wo(this.rgba), t = e.r, n = e.g, s = e.b, (r = e.a) < 1 ? "rgba(" + t + ", " + n + ", " + s + ", " + r + ")" : "rgb(" + t + ", " + n + ", " + s + ")";
            var e, t, n, s, r;
        }, i.prototype.toHsl = function() {
            return vd(mr(this.rgba));
        }, i.prototype.toHslString = function() {
            return e = vd(mr(this.rgba)), t = e.h, n = e.s, s = e.l, (r = e.a) < 1 ? "hsla(" + t + ", " + n + "%, " + s + "%, " + r + ")" : "hsl(" + t + ", " + n + "%, " + s + "%)";
            var e, t, n, s, r;
        }, i.prototype.toHsv = function() {
            return e = vp(this.rgba), {
                h: Rt(e.h),
                s: Rt(e.s),
                v: Rt(e.v),
                a: Rt(e.a, 3)
            };
            var e;
        }, i.prototype.invert = function() {
            return In({
                r: 255 - (e = this.rgba).r,
                g: 255 - e.g,
                b: 255 - e.b,
                a: e.a
            });
            var e;
        }, i.prototype.saturate = function(e) {
            return e === void 0 && (e = .1), In(Xo(this.rgba, e));
        }, i.prototype.desaturate = function(e) {
            return e === void 0 && (e = .1), In(Xo(this.rgba, -e));
        }, i.prototype.grayscale = function() {
            return In(Xo(this.rgba, -1));
        }, i.prototype.lighten = function(e) {
            return e === void 0 && (e = .1), In(Sd(this.rgba, e));
        }, i.prototype.darken = function(e) {
            return e === void 0 && (e = .1), In(Sd(this.rgba, -e));
        }, i.prototype.rotate = function(e) {
            return e === void 0 && (e = 15), this.hue(this.hue() + e);
        }, i.prototype.alpha = function(e) {
            return typeof e == "number" ? In({
                r: (t = this.rgba).r,
                g: t.g,
                b: t.b,
                a: e
            }) : Rt(this.rgba.a, 3);
            var t;
        }, i.prototype.hue = function(e) {
            var t = mr(this.rgba);
            return typeof e == "number" ? In({
                h: e,
                s: t.s,
                l: t.l,
                a: t.a
            }) : Rt(t.h);
        }, i.prototype.isEqual = function(e) {
            return this.toHex() === In(e).toHex();
        }, i;
    }(), In = function(i) {
        return i instanceof xl ? i : new xl(i);
    }, Md = [], kM = function(i) {
        i.forEach(function(e) {
            Md.indexOf(e) < 0 && (e(xl, gl), Md.push(e));
        });
    };
    function GM(i, e) {
        var t = {
            white: "#ffffff",
            bisque: "#ffe4c4",
            blue: "#0000ff",
            cadetblue: "#5f9ea0",
            chartreuse: "#7fff00",
            chocolate: "#d2691e",
            coral: "#ff7f50",
            antiquewhite: "#faebd7",
            aqua: "#00ffff",
            azure: "#f0ffff",
            whitesmoke: "#f5f5f5",
            papayawhip: "#ffefd5",
            plum: "#dda0dd",
            blanchedalmond: "#ffebcd",
            black: "#000000",
            gold: "#ffd700",
            goldenrod: "#daa520",
            gainsboro: "#dcdcdc",
            cornsilk: "#fff8dc",
            cornflowerblue: "#6495ed",
            burlywood: "#deb887",
            aquamarine: "#7fffd4",
            beige: "#f5f5dc",
            crimson: "#dc143c",
            cyan: "#00ffff",
            darkblue: "#00008b",
            darkcyan: "#008b8b",
            darkgoldenrod: "#b8860b",
            darkkhaki: "#bdb76b",
            darkgray: "#a9a9a9",
            darkgreen: "#006400",
            darkgrey: "#a9a9a9",
            peachpuff: "#ffdab9",
            darkmagenta: "#8b008b",
            darkred: "#8b0000",
            darkorchid: "#9932cc",
            darkorange: "#ff8c00",
            darkslateblue: "#483d8b",
            gray: "#808080",
            darkslategray: "#2f4f4f",
            darkslategrey: "#2f4f4f",
            deeppink: "#ff1493",
            deepskyblue: "#00bfff",
            wheat: "#f5deb3",
            firebrick: "#b22222",
            floralwhite: "#fffaf0",
            ghostwhite: "#f8f8ff",
            darkviolet: "#9400d3",
            magenta: "#ff00ff",
            green: "#008000",
            dodgerblue: "#1e90ff",
            grey: "#808080",
            honeydew: "#f0fff0",
            hotpink: "#ff69b4",
            blueviolet: "#8a2be2",
            forestgreen: "#228b22",
            lawngreen: "#7cfc00",
            indianred: "#cd5c5c",
            indigo: "#4b0082",
            fuchsia: "#ff00ff",
            brown: "#a52a2a",
            maroon: "#800000",
            mediumblue: "#0000cd",
            lightcoral: "#f08080",
            darkturquoise: "#00ced1",
            lightcyan: "#e0ffff",
            ivory: "#fffff0",
            lightyellow: "#ffffe0",
            lightsalmon: "#ffa07a",
            lightseagreen: "#20b2aa",
            linen: "#faf0e6",
            mediumaquamarine: "#66cdaa",
            lemonchiffon: "#fffacd",
            lime: "#00ff00",
            khaki: "#f0e68c",
            mediumseagreen: "#3cb371",
            limegreen: "#32cd32",
            mediumspringgreen: "#00fa9a",
            lightskyblue: "#87cefa",
            lightblue: "#add8e6",
            midnightblue: "#191970",
            lightpink: "#ffb6c1",
            mistyrose: "#ffe4e1",
            moccasin: "#ffe4b5",
            mintcream: "#f5fffa",
            lightslategray: "#778899",
            lightslategrey: "#778899",
            navajowhite: "#ffdead",
            navy: "#000080",
            mediumvioletred: "#c71585",
            powderblue: "#b0e0e6",
            palegoldenrod: "#eee8aa",
            oldlace: "#fdf5e6",
            paleturquoise: "#afeeee",
            mediumturquoise: "#48d1cc",
            mediumorchid: "#ba55d3",
            rebeccapurple: "#663399",
            lightsteelblue: "#b0c4de",
            mediumslateblue: "#7b68ee",
            thistle: "#d8bfd8",
            tan: "#d2b48c",
            orchid: "#da70d6",
            mediumpurple: "#9370db",
            purple: "#800080",
            pink: "#ffc0cb",
            skyblue: "#87ceeb",
            springgreen: "#00ff7f",
            palegreen: "#98fb98",
            red: "#ff0000",
            yellow: "#ffff00",
            slateblue: "#6a5acd",
            lavenderblush: "#fff0f5",
            peru: "#cd853f",
            palevioletred: "#db7093",
            violet: "#ee82ee",
            teal: "#008080",
            slategray: "#708090",
            slategrey: "#708090",
            aliceblue: "#f0f8ff",
            darkseagreen: "#8fbc8f",
            darkolivegreen: "#556b2f",
            greenyellow: "#adff2f",
            seagreen: "#2e8b57",
            seashell: "#fff5ee",
            tomato: "#ff6347",
            silver: "#c0c0c0",
            sienna: "#a0522d",
            lavender: "#e6e6fa",
            lightgreen: "#90ee90",
            orange: "#ffa500",
            orangered: "#ff4500",
            steelblue: "#4682b4",
            royalblue: "#4169e1",
            turquoise: "#40e0d0",
            yellowgreen: "#9acd32",
            salmon: "#fa8072",
            saddlebrown: "#8b4513",
            sandybrown: "#f4a460",
            rosybrown: "#bc8f8f",
            darksalmon: "#e9967a",
            lightgoldenrodyellow: "#fafad2",
            snow: "#fffafa",
            lightgrey: "#d3d3d3",
            lightgray: "#d3d3d3",
            dimgray: "#696969",
            dimgrey: "#696969",
            olivedrab: "#6b8e23",
            olive: "#808000"
        }, n = {};
        for(var s in t)n[t[s]] = s;
        var r = {};
        i.prototype.toName = function(a) {
            if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent";
            var o, c, l = n[this.toHex()];
            if (l) return l;
            if (a?.closest) {
                var h = this.toRgb(), u = 1 / 0, d = "black";
                if (!r.length) for(var f in t)r[f] = new i(t[f]).toRgb();
                for(var _ in t){
                    var g = (o = h, c = r[_], Math.pow(o.r - c.r, 2) + Math.pow(o.g - c.g, 2) + Math.pow(o.b - c.b, 2));
                    g < u && (u = g, d = _);
                }
                return d;
            }
        }, e.string.push([
            function(a) {
                var o = a.toLowerCase(), c = o === "transparent" ? "#0000" : t[o];
                return c ? new i(c).toRgb() : null;
            },
            "name"
        ]);
    }
    kM([
        GM
    ]);
    const Bs = class lr {
        constructor(e = 16777215){
            this._value = null, this._components = new Float32Array(4), this._components.fill(1), this._int = 16777215, this.value = e;
        }
        get red() {
            return this._components[0];
        }
        get green() {
            return this._components[1];
        }
        get blue() {
            return this._components[2];
        }
        get alpha() {
            return this._components[3];
        }
        setValue(e) {
            return this.value = e, this;
        }
        set value(e) {
            if (e instanceof lr) this._value = this._cloneSource(e._value), this._int = e._int, this._components.set(e._components);
            else {
                if (e === null) throw new Error("Cannot set Color#value to null");
                (this._value === null || !this._isSourceEqual(this._value, e)) && (this._value = this._cloneSource(e), this._normalize(this._value));
            }
        }
        get value() {
            return this._value;
        }
        _cloneSource(e) {
            return typeof e == "string" || typeof e == "number" || e instanceof Number || e === null ? e : Array.isArray(e) || ArrayBuffer.isView(e) ? e.slice(0) : typeof e == "object" && e !== null ? {
                ...e
            } : e;
        }
        _isSourceEqual(e, t) {
            const n = typeof e;
            if (n !== typeof t) return !1;
            if (n === "number" || n === "string" || e instanceof Number) return e === t;
            if (Array.isArray(e) && Array.isArray(t) || ArrayBuffer.isView(e) && ArrayBuffer.isView(t)) return e.length !== t.length ? !1 : e.every((r, a)=>r === t[a]);
            if (e !== null && t !== null) {
                const r = Object.keys(e), a = Object.keys(t);
                return r.length !== a.length ? !1 : r.every((o)=>e[o] === t[o]);
            }
            return e === t;
        }
        toRgba() {
            const [e, t, n, s] = this._components;
            return {
                r: e,
                g: t,
                b: n,
                a: s
            };
        }
        toRgb() {
            const [e, t, n] = this._components;
            return {
                r: e,
                g: t,
                b: n
            };
        }
        toRgbaString() {
            const [e, t, n] = this.toUint8RgbArray();
            return `rgba(${e},${t},${n},${this.alpha})`;
        }
        toUint8RgbArray(e) {
            const [t, n, s] = this._components;
            return this._arrayRgb || (this._arrayRgb = []), e || (e = this._arrayRgb), e[0] = Math.round(t * 255), e[1] = Math.round(n * 255), e[2] = Math.round(s * 255), e;
        }
        toArray(e) {
            this._arrayRgba || (this._arrayRgba = []), e || (e = this._arrayRgba);
            const [t, n, s, r] = this._components;
            return e[0] = t, e[1] = n, e[2] = s, e[3] = r, e;
        }
        toRgbArray(e) {
            this._arrayRgb || (this._arrayRgb = []), e || (e = this._arrayRgb);
            const [t, n, s] = this._components;
            return e[0] = t, e[1] = n, e[2] = s, e;
        }
        toNumber() {
            return this._int;
        }
        toBgrNumber() {
            const [e, t, n] = this.toUint8RgbArray();
            return (n << 16) + (t << 8) + e;
        }
        toLittleEndianNumber() {
            const e = this._int;
            return (e >> 16) + (e & 65280) + ((e & 255) << 16);
        }
        multiply(e) {
            const [t, n, s, r] = lr._temp.setValue(e)._components;
            return this._components[0] *= t, this._components[1] *= n, this._components[2] *= s, this._components[3] *= r, this._refreshInt(), this._value = null, this;
        }
        premultiply(e, t = !0) {
            return t && (this._components[0] *= e, this._components[1] *= e, this._components[2] *= e), this._components[3] = e, this._refreshInt(), this._value = null, this;
        }
        toPremultiplied(e, t = !0) {
            if (e === 1) return (255 << 24) + this._int;
            if (e === 0) return t ? 0 : this._int;
            let n = this._int >> 16 & 255, s = this._int >> 8 & 255, r = this._int & 255;
            return t && (n = n * e + .5 | 0, s = s * e + .5 | 0, r = r * e + .5 | 0), (e * 255 << 24) + (n << 16) + (s << 8) + r;
        }
        toHex() {
            const e = this._int.toString(16);
            return `#${"000000".substring(0, 6 - e.length) + e}`;
        }
        toHexa() {
            const t = Math.round(this._components[3] * 255).toString(16);
            return this.toHex() + "00".substring(0, 2 - t.length) + t;
        }
        setAlpha(e) {
            return this._components[3] = this._clamp(e), this;
        }
        _normalize(e) {
            let t, n, s, r;
            if ((typeof e == "number" || e instanceof Number) && e >= 0 && e <= 16777215) {
                const a = e;
                t = (a >> 16 & 255) / 255, n = (a >> 8 & 255) / 255, s = (a & 255) / 255, r = 1;
            } else if ((Array.isArray(e) || e instanceof Float32Array) && e.length >= 3 && e.length <= 4) e = this._clamp(e), [t, n, s, r = 1] = e;
            else if ((e instanceof Uint8Array || e instanceof Uint8ClampedArray) && e.length >= 3 && e.length <= 4) e = this._clamp(e, 0, 255), [t, n, s, r = 255] = e, t /= 255, n /= 255, s /= 255, r /= 255;
            else if (typeof e == "string" || typeof e == "object") {
                if (typeof e == "string") {
                    const o = lr.HEX_PATTERN.exec(e);
                    o && (e = `#${o[2]}`);
                }
                const a = In(e);
                a.isValid() && ({ r: t, g: n, b: s, a: r } = a.rgba, t /= 255, n /= 255, s /= 255);
            }
            if (t !== void 0) this._components[0] = t, this._components[1] = n, this._components[2] = s, this._components[3] = r, this._refreshInt();
            else throw new Error(`Unable to convert color ${e}`);
        }
        _refreshInt() {
            this._clamp(this._components);
            const [e, t, n] = this._components;
            this._int = (e * 255 << 16) + (t * 255 << 8) + (n * 255 | 0);
        }
        _clamp(e, t = 0, n = 1) {
            return typeof e == "number" ? Math.min(Math.max(e, t), n) : (e.forEach((s, r)=>{
                e[r] = Math.min(Math.max(s, t), n);
            }), e);
        }
        static isColorLike(e) {
            return typeof e == "number" || typeof e == "string" || e instanceof Number || e instanceof lr || Array.isArray(e) || e instanceof Uint8Array || e instanceof Uint8ClampedArray || e instanceof Float32Array || e.r !== void 0 && e.g !== void 0 && e.b !== void 0 || e.r !== void 0 && e.g !== void 0 && e.b !== void 0 && e.a !== void 0 || e.h !== void 0 && e.s !== void 0 && e.l !== void 0 || e.h !== void 0 && e.s !== void 0 && e.l !== void 0 && e.a !== void 0 || e.h !== void 0 && e.s !== void 0 && e.v !== void 0 || e.h !== void 0 && e.s !== void 0 && e.v !== void 0 && e.a !== void 0;
        }
    };
    Bs.shared = new Bs;
    Bs._temp = new Bs;
    Bs.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
    Pt = Bs;
    const HM = {
        cullArea: null,
        cullable: !1,
        cullableChildren: !0
    };
    class ah {
        constructor(e, t){
            this._pool = [], this._count = 0, this._index = 0, this._classType = e, t && this.prepopulate(t);
        }
        prepopulate(e) {
            for(let t = 0; t < e; t++)this._pool[this._index++] = new this._classType;
            this._count += e;
        }
        get(e) {
            let t;
            return this._index > 0 ? t = this._pool[--this._index] : t = new this._classType, t.init?.(e), t;
        }
        return(e) {
            e.reset?.(), this._pool[this._index++] = e;
        }
        get totalSize() {
            return this._count;
        }
        get totalFree() {
            return this._index;
        }
        get totalUsed() {
            return this._count - this._index;
        }
        clear() {
            this._pool.length = 0, this._index = 0;
        }
    }
    class zM {
        constructor(){
            this._poolsByClass = new Map;
        }
        prepopulate(e, t) {
            this.getPool(e).prepopulate(t);
        }
        get(e, t) {
            return this.getPool(e).get(t);
        }
        return(e) {
            this.getPool(e.constructor).return(e);
        }
        getPool(e) {
            return this._poolsByClass.has(e) || this._poolsByClass.set(e, new ah(e)), this._poolsByClass.get(e);
        }
        stats() {
            const e = {};
            return this._poolsByClass.forEach((t)=>{
                const n = e[t._classType.name] ? t._classType.name + t._classType.ID : t._classType.name;
                e[n] = {
                    free: t.totalFree,
                    used: t.totalUsed,
                    size: t.totalSize
                };
            }), e;
        }
    }
    let VM;
    Gt = new zM;
    VM = {
        get isCachedAsTexture () {
            return !!this.renderGroup?.isCachedAsTexture;
        },
        cacheAsTexture (i) {
            typeof i == "boolean" && i === !1 ? this.disableRenderGroup() : (this.enableRenderGroup(), this.renderGroup.enableCacheAsTexture(i === !0 ? {} : i));
        },
        updateCacheTexture () {
            this.renderGroup?.updateCacheTexture();
        },
        get cacheAsBitmap () {
            return this.isCachedAsTexture;
        },
        set cacheAsBitmap (i){
            ut("v8.6.0", "cacheAsBitmap is deprecated, use cacheAsTexture instead."), this.cacheAsTexture(i);
        }
    };
    WM = function(i, e, t) {
        const n = i.length;
        let s;
        if (e >= n || t === 0) return;
        t = e + t > n ? n - e : t;
        const r = n - t;
        for(s = e; s < r; ++s)i[s] = i[s + t];
        i.length = r;
    };
    const XM = {
        allowChildren: !0,
        removeChildren (i = 0, e) {
            const t = e ?? this.children.length, n = t - i, s = [];
            if (n > 0 && n <= t) {
                for(let a = t - 1; a >= i; a--){
                    const o = this.children[a];
                    o && (s.push(o), o.parent = null);
                }
                WM(this.children, i, t);
                const r = this.renderGroup || this.parentRenderGroup;
                r && r.removeChildren(s);
                for(let a = 0; a < s.length; ++a)this.emit("childRemoved", s[a], this, a), s[a].emit("removed", this);
                return s.length > 0 && this._didViewChangeTick++, s;
            } else if (n === 0 && this.children.length === 0) return s;
            throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
        },
        removeChildAt (i) {
            const e = this.getChildAt(i);
            return this.removeChild(e);
        },
        getChildAt (i) {
            if (i < 0 || i >= this.children.length) throw new Error(`getChildAt: Index (${i}) does not exist.`);
            return this.children[i];
        },
        setChildIndex (i, e) {
            if (e < 0 || e >= this.children.length) throw new Error(`The index ${e} supplied is out of bounds ${this.children.length}`);
            this.getChildIndex(i), this.addChildAt(i, e);
        },
        getChildIndex (i) {
            const e = this.children.indexOf(i);
            if (e === -1) throw new Error("The supplied Container must be a child of the caller");
            return e;
        },
        addChildAt (i, e) {
            this.allowChildren || ut(bt, "addChildAt: Only Containers will be allowed to add children in v8.0.0");
            const { children: t } = this;
            if (e < 0 || e > t.length) throw new Error(`${i}addChildAt: The index ${e} supplied is out of bounds ${t.length}`);
            if (i.parent) {
                const s = i.parent.children.indexOf(i);
                if (i.parent === this && s === e) return i;
                s !== -1 && i.parent.children.splice(s, 1);
            }
            e === t.length ? t.push(i) : t.splice(e, 0, i), i.parent = this, i.didChange = !0, i._updateFlags = 15;
            const n = this.renderGroup || this.parentRenderGroup;
            return n && n.addChild(i), this.sortableChildren && (this.sortDirty = !0), this.emit("childAdded", i, this, e), i.emit("added", this), i;
        },
        swapChildren (i, e) {
            if (i === e) return;
            const t = this.getChildIndex(i), n = this.getChildIndex(e);
            this.children[t] = e, this.children[n] = i;
            const s = this.renderGroup || this.parentRenderGroup;
            s && (s.structureDidChange = !0), this._didContainerChangeTick++;
        },
        removeFromParent () {
            this.parent?.removeChild(this);
        },
        reparentChild (...i) {
            return i.length === 1 ? this.reparentChildAt(i[0], this.children.length) : (i.forEach((e)=>this.reparentChildAt(e, this.children.length)), i[0]);
        },
        reparentChildAt (i, e) {
            if (i.parent === this) return this.setChildIndex(i, e), i;
            const t = i.worldTransform.clone();
            i.removeFromParent(), this.addChildAt(i, e);
            const n = this.worldTransform.clone();
            return n.invert(), t.prepend(n), i.setFromMatrix(t), i;
        }
    }, YM = {
        collectRenderables (i, e, t) {
            this.parentRenderLayer && this.parentRenderLayer !== t || this.globalDisplayStatus < 7 || !this.includeInBuild || (this.sortableChildren && this.sortChildren(), this.isSimple ? this.collectRenderablesSimple(i, e, t) : this.renderGroup ? e.renderPipes.renderGroup.addRenderGroup(this.renderGroup, i) : this.collectRenderablesWithEffects(i, e, t));
        },
        collectRenderablesSimple (i, e, t) {
            const n = this.children, s = n.length;
            for(let r = 0; r < s; r++)n[r].collectRenderables(i, e, t);
        },
        collectRenderablesWithEffects (i, e, t) {
            const { renderPipes: n } = e;
            for(let s = 0; s < this.effects.length; s++){
                const r = this.effects[s];
                n[r.pipe].push(r, this, i);
            }
            this.collectRenderablesSimple(i, e, t);
            for(let s = this.effects.length - 1; s >= 0; s--){
                const r = this.effects[s];
                n[r.pipe].pop(r, this, i);
            }
        }
    };
    class Va {
        constructor(){
            this.pipe = "filter", this.priority = 1;
        }
        destroy() {
            for(let e = 0; e < this.filters.length; e++)this.filters[e].destroy();
            this.filters = null, this.filterArea = null;
        }
    }
    class qM {
        constructor(){
            this._effectClasses = [], this._tests = [], this._initialized = !1;
        }
        init() {
            this._initialized || (this._initialized = !0, this._effectClasses.forEach((e)=>{
                this.add({
                    test: e.test,
                    maskClass: e
                });
            }));
        }
        add(e) {
            this._tests.push(e);
        }
        getMaskEffect(e) {
            this._initialized || this.init();
            for(let t = 0; t < this._tests.length; t++){
                const n = this._tests[t];
                if (n.test(e)) return Gt.get(n.maskClass, e);
            }
            return e;
        }
        returnMaskEffect(e) {
            Gt.return(e);
        }
    }
    const vl = new qM;
    Nt.handleByList(se.MaskEffect, vl._effectClasses);
    const jM = {
        _maskEffect: null,
        _maskOptions: {
            inverse: !1
        },
        _filterEffect: null,
        effects: [],
        _markStructureAsChanged () {
            const i = this.renderGroup || this.parentRenderGroup;
            i && (i.structureDidChange = !0);
        },
        addEffect (i) {
            this.effects.indexOf(i) === -1 && (this.effects.push(i), this.effects.sort((t, n)=>t.priority - n.priority), this._markStructureAsChanged(), this._updateIsSimple());
        },
        removeEffect (i) {
            const e = this.effects.indexOf(i);
            e !== -1 && (this.effects.splice(e, 1), this._markStructureAsChanged(), this._updateIsSimple());
        },
        set mask (i){
            const e = this._maskEffect;
            e?.mask !== i && (e && (this.removeEffect(e), vl.returnMaskEffect(e), this._maskEffect = null), i != null && (this._maskEffect = vl.getMaskEffect(i), this.addEffect(this._maskEffect)));
        },
        setMask (i) {
            this._maskOptions = {
                ...this._maskOptions,
                ...i
            }, i.mask && (this.mask = i.mask), this._markStructureAsChanged();
        },
        get mask () {
            return this._maskEffect?.mask;
        },
        set filters (i){
            !Array.isArray(i) && i && (i = [
                i
            ]);
            const e = this._filterEffect || (this._filterEffect = new Va);
            i = i;
            const t = i?.length > 0, n = e.filters?.length > 0, s = t !== n;
            i = Array.isArray(i) ? i.slice(0) : i, e.filters = Object.freeze(i), s && (t ? this.addEffect(e) : (this.removeEffect(e), e.filters = i ?? null));
        },
        get filters () {
            return this._filterEffect?.filters;
        },
        set filterArea (i){
            this._filterEffect || (this._filterEffect = new Va), this._filterEffect.filterArea = i;
        },
        get filterArea () {
            return this._filterEffect?.filterArea;
        }
    }, $M = {
        label: null,
        get name () {
            return ut(bt, "Container.name property has been removed, use Container.label instead"), this.label;
        },
        set name (i){
            ut(bt, "Container.name property has been removed, use Container.label instead"), this.label = i;
        },
        getChildByName (i, e = !1) {
            return this.getChildByLabel(i, e);
        },
        getChildByLabel (i, e = !1) {
            const t = this.children;
            for(let n = 0; n < t.length; n++){
                const s = t[n];
                if (s.label === i || i instanceof RegExp && i.test(s.label)) return s;
            }
            if (e) for(let n = 0; n < t.length; n++){
                const r = t[n].getChildByLabel(i, !0);
                if (r) return r;
            }
            return null;
        },
        getChildrenByLabel (i, e = !1, t = []) {
            const n = this.children;
            for(let s = 0; s < n.length; s++){
                const r = n[s];
                (r.label === i || i instanceof RegExp && i.test(r.label)) && t.push(r);
            }
            if (e) for(let s = 0; s < n.length; s++)n[s].getChildrenByLabel(i, !0, t);
            return t;
        }
    }, Xt = new ah(Fe), ei = new ah(en), KM = new Fe, ZM = {
        getFastGlobalBounds (i, e) {
            e || (e = new en), e.clear(), this._getGlobalBoundsRecursive(!!i, e, this.parentRenderLayer), e.isValid || e.set(0, 0, 0, 0);
            const t = this.renderGroup || this.parentRenderGroup;
            return e.applyMatrix(t.worldTransform), e;
        },
        _getGlobalBoundsRecursive (i, e, t) {
            let n = e;
            if (i && this.parentRenderLayer && this.parentRenderLayer !== t || this.localDisplayStatus !== 7 || !this.measurable) return;
            const s = !!this.effects.length;
            if ((this.renderGroup || s) && (n = ei.get().clear()), this.boundsArea) e.addRect(this.boundsArea, this.worldTransform);
            else {
                if (this.renderPipeId) {
                    const a = this.bounds;
                    n.addFrame(a.minX, a.minY, a.maxX, a.maxY, this.groupTransform);
                }
                const r = this.children;
                for(let a = 0; a < r.length; a++)r[a]._getGlobalBoundsRecursive(i, n, t);
            }
            if (s) {
                let r = !1;
                const a = this.renderGroup || this.parentRenderGroup;
                for(let o = 0; o < this.effects.length; o++)this.effects[o].addBounds && (r || (r = !0, n.applyMatrix(a.worldTransform)), this.effects[o].addBounds(n, !0));
                r && (n.applyMatrix(a.worldTransform.copyTo(KM).invert()), e.addBounds(n, this.relativeGroupTransform)), e.addBounds(n), ei.return(n);
            } else this.renderGroup && (e.addBounds(n, this.relativeGroupTransform), ei.return(n));
        }
    };
    function oh(i, e, t) {
        t.clear();
        let n, s;
        return i.parent ? e ? n = i.parent.worldTransform : (s = Xt.get().identity(), n = ch(i, s)) : n = Fe.IDENTITY, bp(i, t, n, e), s && Xt.return(s), t.isValid || t.set(0, 0, 0, 0), t;
    }
    function bp(i, e, t, n) {
        if (!i.visible || !i.measurable) return;
        let s;
        n ? s = i.worldTransform : (i.updateLocalTransform(), s = Xt.get(), s.appendFrom(i.localTransform, t));
        const r = e, a = !!i.effects.length;
        if (a && (e = ei.get().clear()), i.boundsArea) e.addRect(i.boundsArea, s);
        else {
            i.bounds && (e.matrix = s, e.addBounds(i.bounds));
            for(let o = 0; o < i.children.length; o++)bp(i.children[o], e, s, n);
        }
        if (a) {
            for(let o = 0; o < i.effects.length; o++)i.effects[o].addBounds?.(e);
            r.addBounds(e, Fe.IDENTITY), ei.return(e);
        }
        n || Xt.return(s);
    }
    function ch(i, e) {
        const t = i.parent;
        return t && (ch(t, e), t.updateLocalTransform(), e.append(t.localTransform)), e;
    }
    function Sp(i, e) {
        if (i === 16777215 || !e) return e;
        if (e === 16777215 || !i) return i;
        const t = i >> 16 & 255, n = i >> 8 & 255, s = i & 255, r = e >> 16 & 255, a = e >> 8 & 255, o = e & 255, c = t * r / 255 | 0, l = n * a / 255 | 0, h = s * o / 255 | 0;
        return (c << 16) + (l << 8) + h;
    }
    const Td = 16777215;
    function Wa(i, e) {
        return i === Td ? e : e === Td ? i : Sp(i, e);
    }
    function Ua(i) {
        return ((i & 255) << 16) + (i & 65280) + (i >> 16 & 255);
    }
    const JM = {
        getGlobalAlpha (i) {
            if (i) return this.renderGroup ? this.renderGroup.worldAlpha : this.parentRenderGroup ? this.parentRenderGroup.worldAlpha * this.alpha : this.alpha;
            let e = this.alpha, t = this.parent;
            for(; t;)e *= t.alpha, t = t.parent;
            return e;
        },
        getGlobalTransform (i, e) {
            if (e) return i.copyFrom(this.worldTransform);
            this.updateLocalTransform();
            const t = ch(this, Xt.get().identity());
            return i.appendFrom(this.localTransform, t), Xt.return(t), i;
        },
        getGlobalTint (i) {
            if (i) return this.renderGroup ? Ua(this.renderGroup.worldColor) : this.parentRenderGroup ? Ua(Wa(this.localColor, this.parentRenderGroup.worldColor)) : this.tint;
            let e = this.localColor, t = this.parent;
            for(; t;)e = Wa(e, t.localColor), t = t.parent;
            return Ua(e);
        }
    };
    let qo = 0;
    const Ed = 500;
    _t = function(...i) {
        qo !== Ed && (qo++, qo === Ed ? console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.") : console.warn("PixiJS Warning: ", ...i));
    };
    function lh(i, e, t) {
        return e.clear(), t || (t = Fe.IDENTITY), Mp(i, e, t, i, !0), e.isValid || e.set(0, 0, 0, 0), e;
    }
    function Mp(i, e, t, n, s) {
        let r;
        if (s) r = Xt.get(), r = t.copyTo(r);
        else {
            if (!i.visible || !i.measurable) return;
            i.updateLocalTransform();
            const c = i.localTransform;
            r = Xt.get(), r.appendFrom(c, t);
        }
        const a = e, o = !!i.effects.length;
        if (o && (e = ei.get().clear()), i.boundsArea) e.addRect(i.boundsArea, r);
        else {
            i.renderPipeId && (e.matrix = r, e.addBounds(i.bounds));
            const c = i.children;
            for(let l = 0; l < c.length; l++)Mp(c[l], e, r, n, !1);
        }
        if (o) {
            for(let c = 0; c < i.effects.length; c++)i.effects[c].addLocalBounds?.(e, n);
            a.addBounds(e, Fe.IDENTITY), ei.return(e);
        }
        Xt.return(r);
    }
    function Tp(i, e) {
        const t = i.children;
        for(let n = 0; n < t.length; n++){
            const s = t[n], r = s.uid, a = (s._didViewChangeTick & 65535) << 16 | s._didContainerChangeTick & 65535, o = e.index;
            (e.data[o] !== r || e.data[o + 1] !== a) && (e.data[e.index] = r, e.data[e.index + 1] = a, e.didChange = !0), e.index = o + 2, s.children.length && Tp(s, e);
        }
        return e.didChange;
    }
    const QM = new Fe, eT = {
        _localBoundsCacheId: -1,
        _localBoundsCacheData: null,
        _setWidth (i, e) {
            const t = Math.sign(this.scale.x) || 1;
            e !== 0 ? this.scale.x = i / e * t : this.scale.x = t;
        },
        _setHeight (i, e) {
            const t = Math.sign(this.scale.y) || 1;
            e !== 0 ? this.scale.y = i / e * t : this.scale.y = t;
        },
        getLocalBounds () {
            this._localBoundsCacheData || (this._localBoundsCacheData = {
                data: [],
                index: 1,
                didChange: !1,
                localBounds: new en
            });
            const i = this._localBoundsCacheData;
            return i.index = 1, i.didChange = !1, i.data[0] !== this._didViewChangeTick && (i.didChange = !0, i.data[0] = this._didViewChangeTick), Tp(this, i), i.didChange && lh(this, i.localBounds, QM), i.localBounds;
        },
        getBounds (i, e) {
            return oh(this, i, e || new en);
        }
    }, tT = {
        _onRender: null,
        set onRender (i){
            const e = this.renderGroup || this.parentRenderGroup;
            if (!i) {
                this._onRender && e?.removeOnRender(this), this._onRender = null;
                return;
            }
            this._onRender || e?.addOnRender(this), this._onRender = i;
        },
        get onRender () {
            return this._onRender;
        }
    }, nT = {
        _zIndex: 0,
        sortDirty: !1,
        sortableChildren: !1,
        get zIndex () {
            return this._zIndex;
        },
        set zIndex (i){
            this._zIndex !== i && (this._zIndex = i, this.depthOfChildModified());
        },
        depthOfChildModified () {
            this.parent && (this.parent.sortableChildren = !0, this.parent.sortDirty = !0), this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0);
        },
        sortChildren () {
            this.sortDirty && (this.sortDirty = !1, this.children.sort(iT));
        }
    };
    function iT(i, e) {
        return i._zIndex - e._zIndex;
    }
    const sT = {
        getGlobalPosition (i = new Lt, e = !1) {
            return this.parent ? this.parent.toGlobal(this._position, i, e) : (i.x = this._position.x, i.y = this._position.y), i;
        },
        toGlobal (i, e, t = !1) {
            const n = this.getGlobalTransform(Xt.get(), t);
            return e = n.apply(i, e), Xt.return(n), e;
        },
        toLocal (i, e, t, n) {
            e && (i = e.toGlobal(i, t, n));
            const s = this.getGlobalTransform(Xt.get(), n);
            return t = s.applyInverse(i, t), Xt.return(s), t;
        }
    };
    class Ep {
        constructor(){
            this.uid = pt("instructionSet"), this.instructions = [], this.instructionSize = 0, this.renderables = [], this.gcTick = 0;
        }
        reset() {
            this.instructionSize = 0;
        }
        add(e) {
            this.instructions[this.instructionSize++] = e;
        }
        log() {
            this.instructions.length = this.instructionSize, console.table(this.instructions, [
                "type",
                "action"
            ]);
        }
    }
    let rT = 0;
    class aT {
        constructor(e){
            this._poolKeyHash = Object.create(null), this._texturePool = {}, this.textureOptions = e || {}, this.enableFullScreen = !1;
        }
        createTexture(e, t, n) {
            const s = new Ut({
                ...this.textureOptions,
                width: e,
                height: t,
                resolution: 1,
                antialias: n,
                autoGarbageCollect: !1
            });
            return new Oe({
                source: s,
                label: `texturePool_${rT++}`
            });
        }
        getOptimalTexture(e, t, n = 1, s) {
            let r = Math.ceil(e * n - 1e-6), a = Math.ceil(t * n - 1e-6);
            r = dd(r), a = dd(a);
            const o = (r << 17) + (a << 1) + (s ? 1 : 0);
            this._texturePool[o] || (this._texturePool[o] = []);
            let c = this._texturePool[o].pop();
            return c || (c = this.createTexture(r, a, s)), c.source._resolution = n, c.source.width = r / n, c.source.height = a / n, c.source.pixelWidth = r, c.source.pixelHeight = a, c.frame.x = 0, c.frame.y = 0, c.frame.width = e, c.frame.height = t, c.updateUvs(), this._poolKeyHash[c.uid] = o, c;
        }
        getSameSizeTexture(e, t = !1) {
            const n = e.source;
            return this.getOptimalTexture(e.width, e.height, n._resolution, t);
        }
        returnTexture(e) {
            const t = this._poolKeyHash[e.uid];
            this._texturePool[t].push(e);
        }
        clear(e) {
            if (e = e !== !1, e) for(const t in this._texturePool){
                const n = this._texturePool[t];
                if (n) for(let s = 0; s < n.length; s++)n[s].destroy(!0);
            }
            this._texturePool = {};
        }
    }
    As = new aT;
    class oT {
        constructor(){
            this.renderPipeId = "renderGroup", this.root = null, this.canBundle = !1, this.renderGroupParent = null, this.renderGroupChildren = [], this.worldTransform = new Fe, this.worldColorAlpha = 4294967295, this.worldColor = 16777215, this.worldAlpha = 1, this.childrenToUpdate = Object.create(null), this.updateTick = 0, this.gcTick = 0, this.childrenRenderablesToUpdate = {
                list: [],
                index: 0
            }, this.structureDidChange = !0, this.instructionSet = new Ep, this._onRenderContainers = [], this.textureNeedsUpdate = !0, this.isCachedAsTexture = !1, this._matrixDirty = 7;
        }
        init(e) {
            this.root = e, e._onRender && this.addOnRender(e), e.didChange = !0;
            const t = e.children;
            for(let n = 0; n < t.length; n++){
                const s = t[n];
                s._updateFlags = 15, this.addChild(s);
            }
        }
        enableCacheAsTexture(e = {}) {
            this.textureOptions = e, this.isCachedAsTexture = !0, this.textureNeedsUpdate = !0;
        }
        disableCacheAsTexture() {
            this.isCachedAsTexture = !1, this.texture && (As.returnTexture(this.texture), this.texture = null);
        }
        updateCacheTexture() {
            this.textureNeedsUpdate = !0;
        }
        reset() {
            this.renderGroupChildren.length = 0;
            for(const e in this.childrenToUpdate){
                const t = this.childrenToUpdate[e];
                t.list.fill(null), t.index = 0;
            }
            this.childrenRenderablesToUpdate.index = 0, this.childrenRenderablesToUpdate.list.fill(null), this.root = null, this.updateTick = 0, this.structureDidChange = !0, this._onRenderContainers.length = 0, this.renderGroupParent = null, this.disableCacheAsTexture();
        }
        get localTransform() {
            return this.root.localTransform;
        }
        addRenderGroupChild(e) {
            e.renderGroupParent && e.renderGroupParent._removeRenderGroupChild(e), e.renderGroupParent = this, this.renderGroupChildren.push(e);
        }
        _removeRenderGroupChild(e) {
            const t = this.renderGroupChildren.indexOf(e);
            t > -1 && this.renderGroupChildren.splice(t, 1), e.renderGroupParent = null;
        }
        addChild(e) {
            if (this.structureDidChange = !0, e.parentRenderGroup = this, e.updateTick = -1, e.parent === this.root ? e.relativeRenderGroupDepth = 1 : e.relativeRenderGroupDepth = e.parent.relativeRenderGroupDepth + 1, e.didChange = !0, this.onChildUpdate(e), e.renderGroup) {
                this.addRenderGroupChild(e.renderGroup);
                return;
            }
            e._onRender && this.addOnRender(e);
            const t = e.children;
            for(let n = 0; n < t.length; n++)this.addChild(t[n]);
        }
        removeChild(e) {
            if (this.structureDidChange = !0, e._onRender && (e.renderGroup || this.removeOnRender(e)), e.parentRenderGroup = null, e.renderGroup) {
                this._removeRenderGroupChild(e.renderGroup);
                return;
            }
            const t = e.children;
            for(let n = 0; n < t.length; n++)this.removeChild(t[n]);
        }
        removeChildren(e) {
            for(let t = 0; t < e.length; t++)this.removeChild(e[t]);
        }
        onChildUpdate(e) {
            let t = this.childrenToUpdate[e.relativeRenderGroupDepth];
            t || (t = this.childrenToUpdate[e.relativeRenderGroupDepth] = {
                index: 0,
                list: []
            }), t.list[t.index++] = e;
        }
        updateRenderable(e) {
            e.globalDisplayStatus < 7 || (this.instructionSet.renderPipes[e.renderPipeId].updateRenderable(e), e.didViewUpdate = !1);
        }
        onChildViewUpdate(e) {
            this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = e;
        }
        get isRenderable() {
            return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;
        }
        addOnRender(e) {
            this._onRenderContainers.push(e);
        }
        removeOnRender(e) {
            this._onRenderContainers.splice(this._onRenderContainers.indexOf(e), 1);
        }
        runOnRender(e) {
            for(let t = 0; t < this._onRenderContainers.length; t++)this._onRenderContainers[t]._onRender(e);
        }
        destroy() {
            this.disableCacheAsTexture(), this.renderGroupParent = null, this.root = null, this.childrenRenderablesToUpdate = null, this.childrenToUpdate = null, this.renderGroupChildren = null, this._onRenderContainers = null, this.instructionSet = null;
        }
        getChildren(e = []) {
            const t = this.root.children;
            for(let n = 0; n < t.length; n++)this._getChildren(t[n], e);
            return e;
        }
        _getChildren(e, t = []) {
            if (t.push(e), e.renderGroup) return t;
            const n = e.children;
            for(let s = 0; s < n.length; s++)this._getChildren(n[s], t);
            return t;
        }
        invalidateMatrices() {
            this._matrixDirty = 7;
        }
        get inverseWorldTransform() {
            return (this._matrixDirty & 1) === 0 ? this._inverseWorldTransform : (this._matrixDirty &= -2, this._inverseWorldTransform || (this._inverseWorldTransform = new Fe), this._inverseWorldTransform.copyFrom(this.worldTransform).invert());
        }
        get textureOffsetInverseTransform() {
            return (this._matrixDirty & 2) === 0 ? this._textureOffsetInverseTransform : (this._matrixDirty &= -3, this._textureOffsetInverseTransform || (this._textureOffsetInverseTransform = new Fe), this._textureOffsetInverseTransform.copyFrom(this.inverseWorldTransform).translate(-this._textureBounds.x, -this._textureBounds.y));
        }
        get inverseParentTextureTransform() {
            if ((this._matrixDirty & 4) === 0) return this._inverseParentTextureTransform;
            this._matrixDirty &= -5;
            const e = this._parentCacheAsTextureRenderGroup;
            return e ? (this._inverseParentTextureTransform || (this._inverseParentTextureTransform = new Fe), this._inverseParentTextureTransform.copyFrom(this.worldTransform).prepend(e.inverseWorldTransform).translate(-e._textureBounds.x, -e._textureBounds.y)) : this.worldTransform;
        }
        get cacheToLocalTransform() {
            return this._parentCacheAsTextureRenderGroup ? this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform : null;
        }
    }
    function cT(i, e, t = {}) {
        for(const n in e)!t[n] && e[n] !== void 0 && (i[n] = e[n]);
    }
    const jo = new Zt(null), $o = new Zt(null), Ko = new Zt(null, 1, 1), Xa = 1, hh = 2, _r = 4;
    wn = class extends Cn {
        constructor(e = {}){
            super(), this.uid = pt("renderable"), this._updateFlags = 15, this.renderGroup = null, this.parentRenderGroup = null, this.parentRenderGroupIndex = 0, this.didChange = !1, this.didViewUpdate = !1, this.relativeRenderGroupDepth = 0, this.children = [], this.parent = null, this.includeInBuild = !0, this.measurable = !0, this.isSimple = !0, this.updateTick = -1, this.localTransform = new Fe, this.relativeGroupTransform = new Fe, this.groupTransform = this.relativeGroupTransform, this.destroyed = !1, this._position = new Zt(this, 0, 0), this._scale = Ko, this._pivot = $o, this._skew = jo, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._rotation = 0, this.localColor = 16777215, this.localAlpha = 1, this.groupAlpha = 1, this.groupColor = 16777215, this.groupColorAlpha = 4294967295, this.localBlendMode = "inherit", this.groupBlendMode = "normal", this.localDisplayStatus = 7, this.globalDisplayStatus = 7, this._didContainerChangeTick = 0, this._didViewChangeTick = 0, this._didLocalTransformChangeId = -1, this.effects = [], cT(this, e, {
                children: !0,
                parent: !0,
                effects: !0
            }), e.children?.forEach((t)=>this.addChild(t)), e.parent?.addChild(this);
        }
        static mixin(e) {
            ut("8.8.0", "Container.mixin is deprecated, please use extensions.mixin instead."), Nt.mixin(wn, e);
        }
        set _didChangeId(e) {
            this._didViewChangeTick = e >> 12 & 4095, this._didContainerChangeTick = e & 4095;
        }
        get _didChangeId() {
            return this._didContainerChangeTick & 4095 | (this._didViewChangeTick & 4095) << 12;
        }
        addChild(...e) {
            if (this.allowChildren || ut(bt, "addChild: Only Containers will be allowed to add children in v8.0.0"), e.length > 1) {
                for(let s = 0; s < e.length; s++)this.addChild(e[s]);
                return e[0];
            }
            const t = e[0], n = this.renderGroup || this.parentRenderGroup;
            return t.parent === this ? (this.children.splice(this.children.indexOf(t), 1), this.children.push(t), n && (n.structureDidChange = !0), t) : (t.parent && t.parent.removeChild(t), this.children.push(t), this.sortableChildren && (this.sortDirty = !0), t.parent = this, t.didChange = !0, t._updateFlags = 15, n && n.addChild(t), this.emit("childAdded", t, this, this.children.length - 1), t.emit("added", this), this._didViewChangeTick++, t._zIndex !== 0 && t.depthOfChildModified(), t);
        }
        removeChild(...e) {
            if (e.length > 1) {
                for(let s = 0; s < e.length; s++)this.removeChild(e[s]);
                return e[0];
            }
            const t = e[0], n = this.children.indexOf(t);
            return n > -1 && (this._didViewChangeTick++, this.children.splice(n, 1), this.renderGroup ? this.renderGroup.removeChild(t) : this.parentRenderGroup && this.parentRenderGroup.removeChild(t), t.parentRenderLayer && t.parentRenderLayer.detach(t), t.parent = null, this.emit("childRemoved", t, this, n), t.emit("removed", this)), t;
        }
        _onUpdate(e) {
            e && e === this._skew && this._updateSkew(), this._didContainerChangeTick++, !this.didChange && (this.didChange = !0, this.parentRenderGroup && this.parentRenderGroup.onChildUpdate(this));
        }
        set isRenderGroup(e) {
            !!this.renderGroup !== e && (e ? this.enableRenderGroup() : this.disableRenderGroup());
        }
        get isRenderGroup() {
            return !!this.renderGroup;
        }
        enableRenderGroup() {
            if (this.renderGroup) return;
            const e = this.parentRenderGroup;
            e?.removeChild(this), this.renderGroup = Gt.get(oT, this), this.groupTransform = Fe.IDENTITY, e?.addChild(this), this._updateIsSimple();
        }
        disableRenderGroup() {
            if (!this.renderGroup) return;
            const e = this.parentRenderGroup;
            e?.removeChild(this), Gt.return(this.renderGroup), this.renderGroup = null, this.groupTransform = this.relativeGroupTransform, e?.addChild(this), this._updateIsSimple();
        }
        _updateIsSimple() {
            this.isSimple = !this.renderGroup && this.effects.length === 0;
        }
        get worldTransform() {
            return this._worldTransform || (this._worldTransform = new Fe), this.renderGroup ? this._worldTransform.copyFrom(this.renderGroup.worldTransform) : this.parentRenderGroup && this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform), this._worldTransform;
        }
        get x() {
            return this._position.x;
        }
        set x(e) {
            this._position.x = e;
        }
        get y() {
            return this._position.y;
        }
        set y(e) {
            this._position.y = e;
        }
        get position() {
            return this._position;
        }
        set position(e) {
            this._position.copyFrom(e);
        }
        get rotation() {
            return this._rotation;
        }
        set rotation(e) {
            this._rotation !== e && (this._rotation = e, this._onUpdate(this._skew));
        }
        get angle() {
            return this.rotation * MM;
        }
        set angle(e) {
            this.rotation = e * TM;
        }
        get pivot() {
            return this._pivot === $o && (this._pivot = new Zt(this, 0, 0)), this._pivot;
        }
        set pivot(e) {
            this._pivot === $o && (this._pivot = new Zt(this, 0, 0)), typeof e == "number" ? this._pivot.set(e) : this._pivot.copyFrom(e);
        }
        get skew() {
            return this._skew === jo && (this._skew = new Zt(this, 0, 0)), this._skew;
        }
        set skew(e) {
            this._skew === jo && (this._skew = new Zt(this, 0, 0)), this._skew.copyFrom(e);
        }
        get scale() {
            return this._scale === Ko && (this._scale = new Zt(this, 1, 1)), this._scale;
        }
        set scale(e) {
            this._scale === Ko && (this._scale = new Zt(this, 0, 0)), typeof e == "number" ? this._scale.set(e) : this._scale.copyFrom(e);
        }
        get width() {
            return Math.abs(this.scale.x * this.getLocalBounds().width);
        }
        set width(e) {
            const t = this.getLocalBounds().width;
            this._setWidth(e, t);
        }
        get height() {
            return Math.abs(this.scale.y * this.getLocalBounds().height);
        }
        set height(e) {
            const t = this.getLocalBounds().height;
            this._setHeight(e, t);
        }
        getSize(e) {
            e || (e = {});
            const t = this.getLocalBounds();
            return e.width = Math.abs(this.scale.x * t.width), e.height = Math.abs(this.scale.y * t.height), e;
        }
        setSize(e, t) {
            const n = this.getLocalBounds();
            typeof e == "object" ? (t = e.height ?? e.width, e = e.width) : t ?? (t = e), e !== void 0 && this._setWidth(e, n.width), t !== void 0 && this._setHeight(t, n.height);
        }
        _updateSkew() {
            const e = this._rotation, t = this._skew;
            this._cx = Math.cos(e + t._y), this._sx = Math.sin(e + t._y), this._cy = -Math.sin(e - t._x), this._sy = Math.cos(e - t._x);
        }
        updateTransform(e) {
            return this.position.set(typeof e.x == "number" ? e.x : this.position.x, typeof e.y == "number" ? e.y : this.position.y), this.scale.set(typeof e.scaleX == "number" ? e.scaleX || 1 : this.scale.x, typeof e.scaleY == "number" ? e.scaleY || 1 : this.scale.y), this.rotation = typeof e.rotation == "number" ? e.rotation : this.rotation, this.skew.set(typeof e.skewX == "number" ? e.skewX : this.skew.x, typeof e.skewY == "number" ? e.skewY : this.skew.y), this.pivot.set(typeof e.pivotX == "number" ? e.pivotX : this.pivot.x, typeof e.pivotY == "number" ? e.pivotY : this.pivot.y), this;
        }
        setFromMatrix(e) {
            e.decompose(this);
        }
        updateLocalTransform() {
            const e = this._didContainerChangeTick;
            if (this._didLocalTransformChangeId === e) return;
            this._didLocalTransformChangeId = e;
            const t = this.localTransform, n = this._scale, s = this._pivot, r = this._position, a = n._x, o = n._y, c = s._x, l = s._y;
            t.a = this._cx * a, t.b = this._sx * a, t.c = this._cy * o, t.d = this._sy * o, t.tx = r._x - (c * t.a + l * t.c), t.ty = r._y - (c * t.b + l * t.d);
        }
        set alpha(e) {
            e !== this.localAlpha && (this.localAlpha = e, this._updateFlags |= Xa, this._onUpdate());
        }
        get alpha() {
            return this.localAlpha;
        }
        set tint(e) {
            const n = Pt.shared.setValue(e ?? 16777215).toBgrNumber();
            n !== this.localColor && (this.localColor = n, this._updateFlags |= Xa, this._onUpdate());
        }
        get tint() {
            return Ua(this.localColor);
        }
        set blendMode(e) {
            this.localBlendMode !== e && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._updateFlags |= hh, this.localBlendMode = e, this._onUpdate());
        }
        get blendMode() {
            return this.localBlendMode;
        }
        get visible() {
            return !!(this.localDisplayStatus & 2);
        }
        set visible(e) {
            const t = e ? 2 : 0;
            (this.localDisplayStatus & 2) !== t && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._updateFlags |= _r, this.localDisplayStatus ^= 2, this._onUpdate());
        }
        get culled() {
            return !(this.localDisplayStatus & 4);
        }
        set culled(e) {
            const t = e ? 0 : 4;
            (this.localDisplayStatus & 4) !== t && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._updateFlags |= _r, this.localDisplayStatus ^= 4, this._onUpdate());
        }
        get renderable() {
            return !!(this.localDisplayStatus & 1);
        }
        set renderable(e) {
            const t = e ? 1 : 0;
            (this.localDisplayStatus & 1) !== t && (this._updateFlags |= _r, this.localDisplayStatus ^= 1, this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._onUpdate());
        }
        get isRenderable() {
            return this.localDisplayStatus === 7 && this.groupAlpha > 0;
        }
        destroy(e = !1) {
            if (this.destroyed) return;
            this.destroyed = !0;
            let t;
            if (this.children.length && (t = this.removeChildren(0, this.children.length)), this.removeFromParent(), this.parent = null, this._maskEffect = null, this._filterEffect = null, this.effects = null, this._position = null, this._scale = null, this._pivot = null, this._skew = null, this.emit("destroyed", this), this.removeAllListeners(), (typeof e == "boolean" ? e : e?.children) && t) for(let s = 0; s < t.length; ++s)t[s].destroy(e);
            this.renderGroup?.destroy(), this.renderGroup = null;
        }
    };
    Nt.mixin(wn, XM, ZM, sT, tT, eT, jM, $M, nT, HM, VM, JM, YM);
    class uh extends wn {
        constructor(e){
            super(e), this.canBundle = !0, this.allowChildren = !1, this._roundPixels = 0, this._lastUsed = -1, this._bounds = new en(0, 1, 0, 0), this._boundsDirty = !0;
        }
        get bounds() {
            return this._boundsDirty ? (this.updateBounds(), this._boundsDirty = !1, this._bounds) : this._bounds;
        }
        get roundPixels() {
            return !!this._roundPixels;
        }
        set roundPixels(e) {
            this._roundPixels = e ? 1 : 0;
        }
        containsPoint(e) {
            const t = this.bounds, { x: n, y: s } = e;
            return n >= t.minX && n <= t.maxX && s >= t.minY && s <= t.maxY;
        }
        onViewUpdate() {
            if (this._didViewChangeTick++, this._boundsDirty = !0, this.didViewUpdate) return;
            this.didViewUpdate = !0;
            const e = this.renderGroup || this.parentRenderGroup;
            e && e.onChildViewUpdate(this);
        }
        destroy(e) {
            super.destroy(e), this._bounds = null;
        }
        collectRenderablesSimple(e, t, n) {
            const { renderPipes: s, renderableGC: r } = t;
            s.blendMode.setBlendMode(this, this.groupBlendMode, e), s[this.renderPipeId].addRenderable(this, e), r.addRenderable(this), this.didViewUpdate = !1;
            const o = this.children, c = o.length;
            for(let l = 0; l < c; l++)o[l].collectRenderables(e, t, n);
        }
    }
    class Fs extends uh {
        constructor(e = Oe.EMPTY){
            e instanceof Oe && (e = {
                texture: e
            });
            const { texture: t = Oe.EMPTY, anchor: n, roundPixels: s, width: r, height: a, ...o } = e;
            super({
                label: "Sprite",
                ...o
            }), this.renderPipeId = "sprite", this.batched = !0, this._visualBounds = {
                minX: 0,
                maxX: 1,
                minY: 0,
                maxY: 0
            }, this._anchor = new Zt({
                _onUpdate: ()=>{
                    this.onViewUpdate();
                }
            }), n ? this.anchor = n : t.defaultAnchor && (this.anchor = t.defaultAnchor), this.texture = t, this.allowChildren = !1, this.roundPixels = s ?? !1, r !== void 0 && (this.width = r), a !== void 0 && (this.height = a);
        }
        static from(e, t = !1) {
            return e instanceof Oe ? new Fs(e) : new Fs(Oe.from(e, t));
        }
        set texture(e) {
            e || (e = Oe.EMPTY);
            const t = this._texture;
            t !== e && (t && t.dynamic && t.off("update", this.onViewUpdate, this), e.dynamic && e.on("update", this.onViewUpdate, this), this._texture = e, this._width && this._setWidth(this._width, this._texture.orig.width), this._height && this._setHeight(this._height, this._texture.orig.height), this.onViewUpdate());
        }
        get texture() {
            return this._texture;
        }
        get visualBounds() {
            return IM(this._visualBounds, this._anchor, this._texture), this._visualBounds;
        }
        get sourceBounds() {
            return ut("8.6.1", "Sprite.sourceBounds is deprecated, use visualBounds instead."), this.visualBounds;
        }
        updateBounds() {
            const e = this._anchor, t = this._texture, n = this._bounds, { width: s, height: r } = t.orig;
            n.minX = -e._x * s, n.maxX = n.minX + s, n.minY = -e._y * r, n.maxY = n.minY + r;
        }
        destroy(e = !1) {
            if (super.destroy(e), typeof e == "boolean" ? e : e?.texture) {
                const n = typeof e == "boolean" ? e : e?.textureSource;
                this._texture.destroy(n);
            }
            this._texture = null, this._visualBounds = null, this._bounds = null, this._anchor = null;
        }
        get anchor() {
            return this._anchor;
        }
        set anchor(e) {
            typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e);
        }
        get width() {
            return Math.abs(this.scale.x) * this._texture.orig.width;
        }
        set width(e) {
            this._setWidth(e, this._texture.orig.width), this._width = e;
        }
        get height() {
            return Math.abs(this.scale.y) * this._texture.orig.height;
        }
        set height(e) {
            this._setHeight(e, this._texture.orig.height), this._height = e;
        }
        getSize(e) {
            return e || (e = {}), e.width = Math.abs(this.scale.x) * this._texture.orig.width, e.height = Math.abs(this.scale.y) * this._texture.orig.height, e;
        }
        setSize(e, t) {
            typeof e == "object" ? (t = e.height ?? e.width, e = e.width) : t ?? (t = e), e !== void 0 && this._setWidth(e, this._texture.orig.width), t !== void 0 && this._setHeight(t, this._texture.orig.height);
        }
    }
    const lT = new en;
    function Ap(i, e, t) {
        const n = lT;
        i.measurable = !0, oh(i, t, n), e.addBoundsMask(n), i.measurable = !1;
    }
    function wp(i, e, t) {
        const n = ei.get();
        i.measurable = !0;
        const s = Xt.get().identity(), r = Rp(i, t, s);
        lh(i, n, r), i.measurable = !1, e.addBoundsMask(n), Xt.return(s), ei.return(n);
    }
    function Rp(i, e, t) {
        return i ? (i !== e && (Rp(i.parent, e, t), i.updateLocalTransform(), t.append(i.localTransform)), t) : (_t("Mask bounds, renderable is not inside the root container"), t);
    }
    class Cp {
        constructor(e){
            this.priority = 0, this.inverse = !1, this.pipe = "alphaMask", e?.mask && this.init(e.mask);
        }
        init(e) {
            this.mask = e, this.renderMaskToTexture = !(e instanceof Fs), this.mask.renderable = this.renderMaskToTexture, this.mask.includeInBuild = !this.renderMaskToTexture, this.mask.measurable = !1;
        }
        reset() {
            this.mask.measurable = !0, this.mask = null;
        }
        addBounds(e, t) {
            this.inverse || Ap(this.mask, e, t);
        }
        addLocalBounds(e, t) {
            wp(this.mask, e, t);
        }
        containsPoint(e, t) {
            const n = this.mask;
            return t(n, e);
        }
        destroy() {
            this.reset();
        }
        static test(e) {
            return e instanceof Fs;
        }
    }
    Cp.extension = se.MaskEffect;
    class Pp {
        constructor(e){
            this.priority = 0, this.pipe = "colorMask", e?.mask && this.init(e.mask);
        }
        init(e) {
            this.mask = e;
        }
        destroy() {}
        static test(e) {
            return typeof e == "number";
        }
    }
    Pp.extension = se.MaskEffect;
    class Ip {
        constructor(e){
            this.priority = 0, this.pipe = "stencilMask", e?.mask && this.init(e.mask);
        }
        init(e) {
            this.mask = e, this.mask.includeInBuild = !1, this.mask.measurable = !1;
        }
        reset() {
            this.mask.measurable = !0, this.mask.includeInBuild = !0, this.mask = null;
        }
        addBounds(e, t) {
            Ap(this.mask, e, t);
        }
        addLocalBounds(e, t) {
            wp(this.mask, e, t);
        }
        containsPoint(e, t) {
            const n = this.mask;
            return t(n, e);
        }
        destroy() {
            this.reset();
        }
        static test(e) {
            return e instanceof wn;
        }
    }
    Ip.extension = se.MaskEffect;
    const hT = {
        createCanvas: (i, e)=>{
            const t = document.createElement("canvas");
            return t.width = i, t.height = e, t;
        },
        getCanvasRenderingContext2D: ()=>CanvasRenderingContext2D,
        getWebGLRenderingContext: ()=>WebGLRenderingContext,
        getNavigator: ()=>navigator,
        getBaseUrl: ()=>document.baseURI ?? window.location.href,
        getFontFaceSet: ()=>document.fonts,
        fetch: (i, e)=>fetch(i, e),
        parseXML: (i)=>new DOMParser().parseFromString(i, "text/xml")
    };
    let Ad = hT;
    jt = {
        get () {
            return Ad;
        },
        set (i) {
            Ad = i;
        }
    };
    class _i extends Ut {
        constructor(e){
            e.resource || (e.resource = jt.get().createCanvas()), e.width || (e.width = e.resource.width, e.autoDensity || (e.width /= e.resolution)), e.height || (e.height = e.resource.height, e.autoDensity || (e.height /= e.resolution)), super(e), this.uploadMethodId = "image", this.autoDensity = e.autoDensity, this.resizeCanvas(), this.transparent = !!e.transparent;
        }
        resizeCanvas() {
            this.autoDensity && "style" in this.resource && (this.resource.style.width = `${this.width}px`, this.resource.style.height = `${this.height}px`), (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) && (this.resource.width = this.pixelWidth, this.resource.height = this.pixelHeight);
        }
        resize(e = this.width, t = this.height, n = this._resolution) {
            const s = super.resize(e, t, n);
            return s && this.resizeCanvas(), s;
        }
        static test(e) {
            return globalThis.HTMLCanvasElement && e instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && e instanceof OffscreenCanvas;
        }
        get context2D() {
            return this._context2D || (this._context2D = this.resource.getContext("2d"));
        }
    }
    _i.extension = se.TextureSource;
    Ya = class extends Ut {
        constructor(e){
            if (e.resource && globalThis.HTMLImageElement && e.resource instanceof HTMLImageElement) {
                const t = jt.get().createCanvas(e.resource.width, e.resource.height);
                t.getContext("2d").drawImage(e.resource, 0, 0, e.resource.width, e.resource.height), e.resource = t, _t("ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.");
            }
            super(e), this.uploadMethodId = "image", this.autoGarbageCollect = !0;
        }
        static test(e) {
            return globalThis.HTMLImageElement && e instanceof HTMLImageElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap || globalThis.VideoFrame && e instanceof VideoFrame;
        }
    };
    Ya.extension = se.TextureSource;
    yl = ((i)=>(i[i.INTERACTION = 50] = "INTERACTION", i[i.HIGH = 25] = "HIGH", i[i.NORMAL = 0] = "NORMAL", i[i.LOW = -25] = "LOW", i[i.UTILITY = -50] = "UTILITY", i))(yl || {});
    class Zo {
        constructor(e, t = null, n = 0, s = !1){
            this.next = null, this.previous = null, this._destroyed = !1, this._fn = e, this._context = t, this.priority = n, this._once = s;
        }
        match(e, t = null) {
            return this._fn === e && this._context === t;
        }
        emit(e) {
            this._fn && (this._context ? this._fn.call(this._context, e) : this._fn(e));
            const t = this.next;
            return this._once && this.destroy(!0), this._destroyed && (this.next = null), t;
        }
        connect(e) {
            this.previous = e, e.next && (e.next.previous = this), this.next = e.next, e.next = this;
        }
        destroy(e = !1) {
            this._destroyed = !0, this._fn = null, this._context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
            const t = this.next;
            return this.next = e ? null : t, this.previous = null, t;
        }
    }
    const Dp = class rn {
        constructor(){
            this.autoStart = !1, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = !1, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = !1, this._lastFrame = -1, this._head = new Zo(null, null, 1 / 0), this.deltaMS = 1 / rn.targetFPMS, this.elapsedMS = 1 / rn.targetFPMS, this._tick = (e)=>{
                this._requestId = null, this.started && (this.update(e), this.started && this._requestId === null && this._head.next && (this._requestId = requestAnimationFrame(this._tick)));
            };
        }
        _requestIfNeeded() {
            this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));
        }
        _cancelIfNeeded() {
            this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null);
        }
        _startIfPossible() {
            this.started ? this._requestIfNeeded() : this.autoStart && this.start();
        }
        add(e, t, n = yl.NORMAL) {
            return this._addListener(new Zo(e, t, n));
        }
        addOnce(e, t, n = yl.NORMAL) {
            return this._addListener(new Zo(e, t, n, !0));
        }
        _addListener(e) {
            let t = this._head.next, n = this._head;
            if (!t) e.connect(n);
            else {
                for(; t;){
                    if (e.priority > t.priority) {
                        e.connect(n);
                        break;
                    }
                    n = t, t = t.next;
                }
                e.previous || e.connect(n);
            }
            return this._startIfPossible(), this;
        }
        remove(e, t) {
            let n = this._head.next;
            for(; n;)n.match(e, t) ? n = n.destroy() : n = n.next;
            return this._head.next || this._cancelIfNeeded(), this;
        }
        get count() {
            if (!this._head) return 0;
            let e = 0, t = this._head;
            for(; t = t.next;)e++;
            return e;
        }
        start() {
            this.started || (this.started = !0, this._requestIfNeeded());
        }
        stop() {
            this.started && (this.started = !1, this._cancelIfNeeded());
        }
        destroy() {
            if (!this._protected) {
                this.stop();
                let e = this._head.next;
                for(; e;)e = e.destroy(!0);
                this._head.destroy(), this._head = null;
            }
        }
        update(e = performance.now()) {
            let t;
            if (e > this.lastTime) {
                if (t = this.elapsedMS = e - this.lastTime, t > this._maxElapsedMS && (t = this._maxElapsedMS), t *= this.speed, this._minElapsedMS) {
                    const r = e - this._lastFrame | 0;
                    if (r < this._minElapsedMS) return;
                    this._lastFrame = e - r % this._minElapsedMS;
                }
                this.deltaMS = t, this.deltaTime = this.deltaMS * rn.targetFPMS;
                const n = this._head;
                let s = n.next;
                for(; s;)s = s.emit(this);
                n.next || this._cancelIfNeeded();
            } else this.deltaTime = this.deltaMS = this.elapsedMS = 0;
            this.lastTime = e;
        }
        get FPS() {
            return 1e3 / this.elapsedMS;
        }
        get minFPS() {
            return 1e3 / this._maxElapsedMS;
        }
        set minFPS(e) {
            const t = Math.min(this.maxFPS, e), n = Math.min(Math.max(0, t) / 1e3, rn.targetFPMS);
            this._maxElapsedMS = 1 / n;
        }
        get maxFPS() {
            return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;
        }
        set maxFPS(e) {
            if (e === 0) this._minElapsedMS = 0;
            else {
                const t = Math.max(this.minFPS, e);
                this._minElapsedMS = 1 / (t / 1e3);
            }
        }
        static get shared() {
            if (!rn._shared) {
                const e = rn._shared = new rn;
                e.autoStart = !0, e._protected = !0;
            }
            return rn._shared;
        }
        static get system() {
            if (!rn._system) {
                const e = rn._system = new rn;
                e.autoStart = !0, e._protected = !0;
            }
            return rn._system;
        }
    };
    Dp.targetFPMS = .06;
    let Jo;
    Ss = Dp;
    async function uT() {
        return Jo ?? (Jo = (async ()=>{
            const e = document.createElement("canvas").getContext("webgl");
            if (!e) return "premultiply-alpha-on-upload";
            const t = await new Promise((a)=>{
                const o = document.createElement("video");
                o.onloadeddata = ()=>a(o), o.onerror = ()=>a(null), o.autoplay = !1, o.crossOrigin = "anonymous", o.preload = "auto", o.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=", o.load();
            });
            if (!t) return "premultiply-alpha-on-upload";
            const n = e.createTexture();
            e.bindTexture(e.TEXTURE_2D, n);
            const s = e.createFramebuffer();
            e.bindFramebuffer(e.FRAMEBUFFER, s), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, n, 0), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, e.NONE), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, t);
            const r = new Uint8Array(4);
            return e.readPixels(0, 0, 1, 1, e.RGBA, e.UNSIGNED_BYTE, r), e.deleteFramebuffer(s), e.deleteTexture(n), e.getExtension("WEBGL_lose_context")?.loseContext(), r[0] <= r[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload";
        })()), Jo;
    }
    const Qa = class Lp extends Ut {
        constructor(e){
            super(e), this.isReady = !1, this.uploadMethodId = "video", e = {
                ...Lp.defaultOptions,
                ...e
            }, this._autoUpdate = !0, this._isConnectedToTicker = !1, this._updateFPS = e.updateFPS || 0, this._msToNextUpdate = 0, this.autoPlay = e.autoPlay !== !1, this.alphaMode = e.alphaMode ?? "premultiply-alpha-on-upload", this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this), this._videoFrameRequestCallbackHandle = null, this._load = null, this._resolve = null, this._reject = null, this._onCanPlay = this._onCanPlay.bind(this), this._onCanPlayThrough = this._onCanPlayThrough.bind(this), this._onError = this._onError.bind(this), this._onPlayStart = this._onPlayStart.bind(this), this._onPlayStop = this._onPlayStop.bind(this), this._onSeeked = this._onSeeked.bind(this), e.autoLoad !== !1 && this.load();
        }
        updateFrame() {
            if (!this.destroyed) {
                if (this._updateFPS) {
                    const e = Ss.shared.elapsedMS * this.resource.playbackRate;
                    this._msToNextUpdate = Math.floor(this._msToNextUpdate - e);
                }
                (!this._updateFPS || this._msToNextUpdate <= 0) && (this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0), this.isValid && this.update();
            }
        }
        _videoFrameRequestCallback() {
            this.updateFrame(), this.destroyed ? this._videoFrameRequestCallbackHandle = null : this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback);
        }
        get isValid() {
            return !!this.resource.videoWidth && !!this.resource.videoHeight;
        }
        async load() {
            if (this._load) return this._load;
            const e = this.resource, t = this.options;
            return (e.readyState === e.HAVE_ENOUGH_DATA || e.readyState === e.HAVE_FUTURE_DATA) && e.width && e.height && (e.complete = !0), e.addEventListener("play", this._onPlayStart), e.addEventListener("pause", this._onPlayStop), e.addEventListener("seeked", this._onSeeked), this._isSourceReady() ? this._mediaReady() : (t.preload || e.addEventListener("canplay", this._onCanPlay), e.addEventListener("canplaythrough", this._onCanPlayThrough), e.addEventListener("error", this._onError, !0)), this.alphaMode = await uT(), this._load = new Promise((n, s)=>{
                this.isValid ? n(this) : (this._resolve = n, this._reject = s, t.preloadTimeoutMs !== void 0 && (this._preloadTimeout = setTimeout(()=>{
                    this._onError(new ErrorEvent(`Preload exceeded timeout of ${t.preloadTimeoutMs}ms`));
                })), e.load());
            }), this._load;
        }
        _onError(e) {
            this.resource.removeEventListener("error", this._onError, !0), this.emit("error", e), this._reject && (this._reject(e), this._reject = null, this._resolve = null);
        }
        _isSourcePlaying() {
            const e = this.resource;
            return !e.paused && !e.ended;
        }
        _isSourceReady() {
            return this.resource.readyState > 2;
        }
        _onPlayStart() {
            this.isValid || this._mediaReady(), this._configureAutoUpdate();
        }
        _onPlayStop() {
            this._configureAutoUpdate();
        }
        _onSeeked() {
            this._autoUpdate && !this._isSourcePlaying() && (this._msToNextUpdate = 0, this.updateFrame(), this._msToNextUpdate = 0);
        }
        _onCanPlay() {
            this.resource.removeEventListener("canplay", this._onCanPlay), this._mediaReady();
        }
        _onCanPlayThrough() {
            this.resource.removeEventListener("canplaythrough", this._onCanPlay), this._preloadTimeout && (clearTimeout(this._preloadTimeout), this._preloadTimeout = void 0), this._mediaReady();
        }
        _mediaReady() {
            const e = this.resource;
            this.isValid && (this.isReady = !0, this.resize(e.videoWidth, e.videoHeight)), this._msToNextUpdate = 0, this.updateFrame(), this._msToNextUpdate = 0, this._resolve && (this._resolve(this), this._resolve = null, this._reject = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && this.resource.play();
        }
        destroy() {
            this._configureAutoUpdate();
            const e = this.resource;
            e && (e.removeEventListener("play", this._onPlayStart), e.removeEventListener("pause", this._onPlayStop), e.removeEventListener("seeked", this._onSeeked), e.removeEventListener("canplay", this._onCanPlay), e.removeEventListener("canplaythrough", this._onCanPlayThrough), e.removeEventListener("error", this._onError, !0), e.pause(), e.src = "", e.load()), super.destroy();
        }
        get autoUpdate() {
            return this._autoUpdate;
        }
        set autoUpdate(e) {
            e !== this._autoUpdate && (this._autoUpdate = e, this._configureAutoUpdate());
        }
        get updateFPS() {
            return this._updateFPS;
        }
        set updateFPS(e) {
            e !== this._updateFPS && (this._updateFPS = e, this._configureAutoUpdate());
        }
        _configureAutoUpdate() {
            this._autoUpdate && this._isSourcePlaying() ? !this._updateFPS && this.resource.requestVideoFrameCallback ? (this._isConnectedToTicker && (Ss.shared.remove(this.updateFrame, this), this._isConnectedToTicker = !1, this._msToNextUpdate = 0), this._videoFrameRequestCallbackHandle === null && (this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback))) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker || (Ss.shared.add(this.updateFrame, this), this._isConnectedToTicker = !0, this._msToNextUpdate = 0)) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker && (Ss.shared.remove(this.updateFrame, this), this._isConnectedToTicker = !1, this._msToNextUpdate = 0));
        }
        static test(e) {
            return globalThis.HTMLVideoElement && e instanceof HTMLVideoElement;
        }
    };
    Qa.extension = se.TextureSource;
    Qa.defaultOptions = {
        ...Ut.defaultOptions,
        autoLoad: !0,
        autoPlay: !0,
        updateFPS: 0,
        crossorigin: !0,
        loop: !1,
        muted: !0,
        playsinline: !0,
        preload: !1
    };
    Qa.MIME_TYPES = {
        ogv: "video/ogg",
        mov: "video/quicktime",
        m4v: "video/mp4"
    };
    let dT = Qa;
    const _s = (i, e, t = !1)=>(Array.isArray(i) || (i = [
            i
        ]), e ? i.map((n)=>typeof n == "string" || t ? e(n) : n) : i);
    class fT {
        constructor(){
            this._parsers = [], this._cache = new Map, this._cacheMap = new Map;
        }
        reset() {
            this._cacheMap.clear(), this._cache.clear();
        }
        has(e) {
            return this._cache.has(e);
        }
        get(e) {
            const t = this._cache.get(e);
            return t || _t(`[Assets] Asset id ${e} was not found in the Cache`), t;
        }
        set(e, t) {
            const n = _s(e);
            let s;
            for(let c = 0; c < this.parsers.length; c++){
                const l = this.parsers[c];
                if (l.test(t)) {
                    s = l.getCacheableAssets(n, t);
                    break;
                }
            }
            const r = new Map(Object.entries(s || {}));
            s || n.forEach((c)=>{
                r.set(c, t);
            });
            const a = [
                ...r.keys()
            ], o = {
                cacheKeys: a,
                keys: n
            };
            n.forEach((c)=>{
                this._cacheMap.set(c, o);
            }), a.forEach((c)=>{
                const l = s ? s[c] : t;
                this._cache.has(c) && this._cache.get(c) !== l && _t("[Cache] already has key:", c), this._cache.set(c, r.get(c));
            });
        }
        remove(e) {
            if (!this._cacheMap.has(e)) {
                _t(`[Assets] Asset id ${e} was not found in the Cache`);
                return;
            }
            const t = this._cacheMap.get(e);
            t.cacheKeys.forEach((s)=>{
                this._cache.delete(s);
            }), t.keys.forEach((s)=>{
                this._cacheMap.delete(s);
            });
        }
        get parsers() {
            return this._parsers;
        }
    }
    let bl;
    gs = new fT;
    bl = [];
    Nt.handleByList(se.TextureSource, bl);
    function Up(i = {}) {
        const e = i && i.resource, t = e ? i.resource : i, n = e ? i : {
            resource: i
        };
        for(let s = 0; s < bl.length; s++){
            const r = bl[s];
            if (r.test(t)) return new r(n);
        }
        throw new Error(`Could not find a source type for resource: ${n.resource}`);
    }
    function pT(i = {}, e = !1) {
        const t = i && i.resource, n = t ? i.resource : i, s = t ? i : {
            resource: i
        };
        if (!e && gs.has(n)) return gs.get(n);
        const r = new Oe({
            source: Up(s)
        });
        return r.on("destroy", ()=>{
            gs.has(n) && gs.remove(n);
        }), e || gs.set(n, r), r;
    }
    function mT(i, e = !1) {
        return typeof i == "string" ? gs.get(i) : i instanceof Ut ? new Oe({
            source: i
        }) : pT(i, e);
    }
    Oe.from = mT;
    Ut.from = Up;
    Nt.add(Cp, Pp, Ip, dT, Ya, _i, rh);
    var Np = ((i)=>(i[i.Low = 0] = "Low", i[i.Normal = 1] = "Normal", i[i.High = 2] = "High", i))(Np || {});
    function vn(i) {
        if (typeof i != "string") throw new TypeError(`Path must be a string. Received ${JSON.stringify(i)}`);
    }
    function tr(i) {
        return i.split("?")[0].split("#")[0];
    }
    function _T(i) {
        return i.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function gT(i, e, t) {
        return i.replace(new RegExp(_T(e), "g"), t);
    }
    function xT(i, e) {
        let t = "", n = 0, s = -1, r = 0, a = -1;
        for(let o = 0; o <= i.length; ++o){
            if (o < i.length) a = i.charCodeAt(o);
            else {
                if (a === 47) break;
                a = 47;
            }
            if (a === 47) {
                if (!(s === o - 1 || r === 1)) if (s !== o - 1 && r === 2) {
                    if (t.length < 2 || n !== 2 || t.charCodeAt(t.length - 1) !== 46 || t.charCodeAt(t.length - 2) !== 46) {
                        if (t.length > 2) {
                            const c = t.lastIndexOf("/");
                            if (c !== t.length - 1) {
                                c === -1 ? (t = "", n = 0) : (t = t.slice(0, c), n = t.length - 1 - t.lastIndexOf("/")), s = o, r = 0;
                                continue;
                            }
                        } else if (t.length === 2 || t.length === 1) {
                            t = "", n = 0, s = o, r = 0;
                            continue;
                        }
                    }
                } else t.length > 0 ? t += `/${i.slice(s + 1, o)}` : t = i.slice(s + 1, o), n = o - s - 1;
                s = o, r = 0;
            } else a === 46 && r !== -1 ? ++r : r = -1;
        }
        return t;
    }
    const Cr = {
        toPosix (i) {
            return gT(i, "\\", "/");
        },
        isUrl (i) {
            return /^https?:/.test(this.toPosix(i));
        },
        isDataUrl (i) {
            return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(i);
        },
        isBlobUrl (i) {
            return i.startsWith("blob:");
        },
        hasProtocol (i) {
            return /^[^/:]+:/.test(this.toPosix(i));
        },
        getProtocol (i) {
            vn(i), i = this.toPosix(i);
            const e = /^file:\/\/\//.exec(i);
            if (e) return e[0];
            const t = /^[^/:]+:\/{0,2}/.exec(i);
            return t ? t[0] : "";
        },
        toAbsolute (i, e, t) {
            if (vn(i), this.isDataUrl(i) || this.isBlobUrl(i)) return i;
            const n = tr(this.toPosix(e ?? jt.get().getBaseUrl())), s = tr(this.toPosix(t ?? this.rootname(n)));
            return i = this.toPosix(i), i.startsWith("/") ? Cr.join(s, i.slice(1)) : this.isAbsolute(i) ? i : this.join(n, i);
        },
        normalize (i) {
            if (vn(i), i.length === 0) return ".";
            if (this.isDataUrl(i) || this.isBlobUrl(i)) return i;
            i = this.toPosix(i);
            let e = "";
            const t = i.startsWith("/");
            this.hasProtocol(i) && (e = this.rootname(i), i = i.slice(e.length));
            const n = i.endsWith("/");
            return i = xT(i), i.length > 0 && n && (i += "/"), t ? `/${i}` : e + i;
        },
        isAbsolute (i) {
            return vn(i), i = this.toPosix(i), this.hasProtocol(i) ? !0 : i.startsWith("/");
        },
        join (...i) {
            if (i.length === 0) return ".";
            let e;
            for(let t = 0; t < i.length; ++t){
                const n = i[t];
                if (vn(n), n.length > 0) if (e === void 0) e = n;
                else {
                    const s = i[t - 1] ?? "";
                    this.joinExtensions.includes(this.extname(s).toLowerCase()) ? e += `/../${n}` : e += `/${n}`;
                }
            }
            return e === void 0 ? "." : this.normalize(e);
        },
        dirname (i) {
            if (vn(i), i.length === 0) return ".";
            i = this.toPosix(i);
            let e = i.charCodeAt(0);
            const t = e === 47;
            let n = -1, s = !0;
            const r = this.getProtocol(i), a = i;
            i = i.slice(r.length);
            for(let o = i.length - 1; o >= 1; --o)if (e = i.charCodeAt(o), e === 47) {
                if (!s) {
                    n = o;
                    break;
                }
            } else s = !1;
            return n === -1 ? t ? "/" : this.isUrl(a) ? r + i : r : t && n === 1 ? "//" : r + i.slice(0, n);
        },
        rootname (i) {
            vn(i), i = this.toPosix(i);
            let e = "";
            if (i.startsWith("/") ? e = "/" : e = this.getProtocol(i), this.isUrl(i)) {
                const t = i.indexOf("/", e.length);
                t !== -1 ? e = i.slice(0, t) : e = i, e.endsWith("/") || (e += "/");
            }
            return e;
        },
        basename (i, e) {
            vn(i), e && vn(e), i = tr(this.toPosix(i));
            let t = 0, n = -1, s = !0, r;
            if (e !== void 0 && e.length > 0 && e.length <= i.length) {
                if (e.length === i.length && e === i) return "";
                let a = e.length - 1, o = -1;
                for(r = i.length - 1; r >= 0; --r){
                    const c = i.charCodeAt(r);
                    if (c === 47) {
                        if (!s) {
                            t = r + 1;
                            break;
                        }
                    } else o === -1 && (s = !1, o = r + 1), a >= 0 && (c === e.charCodeAt(a) ? --a === -1 && (n = r) : (a = -1, n = o));
                }
                return t === n ? n = o : n === -1 && (n = i.length), i.slice(t, n);
            }
            for(r = i.length - 1; r >= 0; --r)if (i.charCodeAt(r) === 47) {
                if (!s) {
                    t = r + 1;
                    break;
                }
            } else n === -1 && (s = !1, n = r + 1);
            return n === -1 ? "" : i.slice(t, n);
        },
        extname (i) {
            vn(i), i = tr(this.toPosix(i));
            let e = -1, t = 0, n = -1, s = !0, r = 0;
            for(let a = i.length - 1; a >= 0; --a){
                const o = i.charCodeAt(a);
                if (o === 47) {
                    if (!s) {
                        t = a + 1;
                        break;
                    }
                    continue;
                }
                n === -1 && (s = !1, n = a + 1), o === 46 ? e === -1 ? e = a : r !== 1 && (r = 1) : e !== -1 && (r = -1);
            }
            return e === -1 || n === -1 || r === 0 || r === 1 && e === n - 1 && e === t + 1 ? "" : i.slice(e, n);
        },
        parse (i) {
            vn(i);
            const e = {
                root: "",
                dir: "",
                base: "",
                ext: "",
                name: ""
            };
            if (i.length === 0) return e;
            i = tr(this.toPosix(i));
            let t = i.charCodeAt(0);
            const n = this.isAbsolute(i);
            let s;
            e.root = this.rootname(i), n || this.hasProtocol(i) ? s = 1 : s = 0;
            let r = -1, a = 0, o = -1, c = !0, l = i.length - 1, h = 0;
            for(; l >= s; --l){
                if (t = i.charCodeAt(l), t === 47) {
                    if (!c) {
                        a = l + 1;
                        break;
                    }
                    continue;
                }
                o === -1 && (c = !1, o = l + 1), t === 46 ? r === -1 ? r = l : h !== 1 && (h = 1) : r !== -1 && (h = -1);
            }
            return r === -1 || o === -1 || h === 0 || h === 1 && r === o - 1 && r === a + 1 ? o !== -1 && (a === 0 && n ? e.base = e.name = i.slice(1, o) : e.base = e.name = i.slice(a, o)) : (a === 0 && n ? (e.name = i.slice(1, r), e.base = i.slice(1, o)) : (e.name = i.slice(a, r), e.base = i.slice(a, o)), e.ext = i.slice(r, o)), e.dir = this.dirname(i), e;
        },
        sep: "/",
        delimiter: ":",
        joinExtensions: [
            ".html"
        ]
    };
    function Bp(i, e, t, n, s) {
        const r = e[t];
        for(let a = 0; a < r.length; a++){
            const o = r[a];
            t < e.length - 1 ? Bp(i.replace(n[t], o), e, t + 1, n, s) : s.push(i.replace(n[t], o));
        }
    }
    function vT(i) {
        const e = /\{(.*?)\}/g, t = i.match(e), n = [];
        if (t) {
            const s = [];
            t.forEach((r)=>{
                const a = r.substring(1, r.length - 1).split(",");
                s.push(a);
            }), Bp(i, s, 0, t, n);
        } else n.push(i);
        return n;
    }
    const wd = (i)=>!Array.isArray(i);
    class Fp {
        constructor(){
            this._defaultBundleIdentifierOptions = {
                connector: "-",
                createBundleAssetId: (e, t)=>`${e}${this._bundleIdConnector}${t}`,
                extractAssetIdFromBundle: (e, t)=>t.replace(`${e}${this._bundleIdConnector}`, "")
            }, this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector, this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId, this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle, this._assetMap = {}, this._preferredOrder = [], this._parsers = [], this._resolverHash = {}, this._bundles = {};
        }
        setBundleIdentifier(e) {
            if (this._bundleIdConnector = e.connector ?? this._bundleIdConnector, this._createBundleAssetId = e.createBundleAssetId ?? this._createBundleAssetId, this._extractAssetIdFromBundle = e.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle, this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
        }
        prefer(...e) {
            e.forEach((t)=>{
                this._preferredOrder.push(t), t.priority || (t.priority = Object.keys(t.params));
            }), this._resolverHash = {};
        }
        set basePath(e) {
            this._basePath = e;
        }
        get basePath() {
            return this._basePath;
        }
        set rootPath(e) {
            this._rootPath = e;
        }
        get rootPath() {
            return this._rootPath;
        }
        get parsers() {
            return this._parsers;
        }
        reset() {
            this.setBundleIdentifier(this._defaultBundleIdentifierOptions), this._assetMap = {}, this._preferredOrder = [], this._resolverHash = {}, this._rootPath = null, this._basePath = null, this._manifest = null, this._bundles = {}, this._defaultSearchParams = null;
        }
        setDefaultSearchParams(e) {
            if (typeof e == "string") this._defaultSearchParams = e;
            else {
                const t = e;
                this._defaultSearchParams = Object.keys(t).map((n)=>`${encodeURIComponent(n)}=${encodeURIComponent(t[n])}`).join("&");
            }
        }
        getAlias(e) {
            const { alias: t, src: n } = e;
            return _s(t || n, (r)=>typeof r == "string" ? r : Array.isArray(r) ? r.map((a)=>a?.src ?? a) : r?.src ? r.src : r, !0);
        }
        addManifest(e) {
            this._manifest && _t("[Resolver] Manifest already exists, this will be overwritten"), this._manifest = e, e.bundles.forEach((t)=>{
                this.addBundle(t.name, t.assets);
            });
        }
        addBundle(e, t) {
            const n = [];
            let s = t;
            Array.isArray(t) || (s = Object.entries(t).map(([r, a])=>typeof a == "string" || Array.isArray(a) ? {
                    alias: r,
                    src: a
                } : {
                    alias: r,
                    ...a
                })), s.forEach((r)=>{
                const a = r.src, o = r.alias;
                let c;
                if (typeof o == "string") {
                    const l = this._createBundleAssetId(e, o);
                    n.push(l), c = [
                        o,
                        l
                    ];
                } else {
                    const l = o.map((h)=>this._createBundleAssetId(e, h));
                    n.push(...l), c = [
                        ...o,
                        ...l
                    ];
                }
                this.add({
                    ...r,
                    alias: c,
                    src: a
                });
            }), this._bundles[e] = n;
        }
        add(e) {
            const t = [];
            Array.isArray(e) ? t.push(...e) : t.push(e);
            let n;
            n = (r)=>{
                this.hasKey(r) && _t(`[Resolver] already has key: ${r} overwriting`);
            }, _s(t).forEach((r)=>{
                const { src: a } = r;
                let { data: o, format: c, loadParser: l } = r;
                const h = _s(a).map((f)=>typeof f == "string" ? vT(f) : Array.isArray(f) ? f : [
                        f
                    ]), u = this.getAlias(r);
                Array.isArray(u) ? u.forEach(n) : n(u);
                const d = [];
                h.forEach((f)=>{
                    f.forEach((_)=>{
                        let g = {};
                        if (typeof _ != "object") {
                            g.src = _;
                            for(let p = 0; p < this._parsers.length; p++){
                                const m = this._parsers[p];
                                if (m.test(_)) {
                                    g = m.parse(_);
                                    break;
                                }
                            }
                        } else o = _.data ?? o, c = _.format ?? c, l = _.loadParser ?? l, g = {
                            ...g,
                            ..._
                        };
                        if (!u) throw new Error(`[Resolver] alias is undefined for this asset: ${g.src}`);
                        g = this._buildResolvedAsset(g, {
                            aliases: u,
                            data: o,
                            format: c,
                            loadParser: l
                        }), d.push(g);
                    });
                }), u.forEach((f)=>{
                    this._assetMap[f] = d;
                });
            });
        }
        resolveBundle(e) {
            const t = wd(e);
            e = _s(e);
            const n = {};
            return e.forEach((s)=>{
                const r = this._bundles[s];
                if (r) {
                    const a = this.resolve(r), o = {};
                    for(const c in a){
                        const l = a[c];
                        o[this._extractAssetIdFromBundle(s, c)] = l;
                    }
                    n[s] = o;
                }
            }), t ? n[e[0]] : n;
        }
        resolveUrl(e) {
            const t = this.resolve(e);
            if (typeof e != "string") {
                const n = {};
                for(const s in t)n[s] = t[s].src;
                return n;
            }
            return t.src;
        }
        resolve(e) {
            const t = wd(e);
            e = _s(e);
            const n = {};
            return e.forEach((s)=>{
                if (!this._resolverHash[s]) if (this._assetMap[s]) {
                    let r = this._assetMap[s];
                    const a = this._getPreferredOrder(r);
                    a?.priority.forEach((o)=>{
                        a.params[o].forEach((c)=>{
                            const l = r.filter((h)=>h[o] ? h[o] === c : !1);
                            l.length && (r = l);
                        });
                    }), this._resolverHash[s] = r[0];
                } else this._resolverHash[s] = this._buildResolvedAsset({
                    alias: [
                        s
                    ],
                    src: s
                }, {});
                n[s] = this._resolverHash[s];
            }), t ? n[e[0]] : n;
        }
        hasKey(e) {
            return !!this._assetMap[e];
        }
        hasBundle(e) {
            return !!this._bundles[e];
        }
        _getPreferredOrder(e) {
            for(let t = 0; t < e.length; t++){
                const n = e[t], s = this._preferredOrder.find((r)=>r.params.format.includes(n.format));
                if (s) return s;
            }
            return this._preferredOrder[0];
        }
        _appendDefaultSearchParams(e) {
            if (!this._defaultSearchParams) return e;
            const t = /\?/.test(e) ? "&" : "?";
            return `${e}${t}${this._defaultSearchParams}`;
        }
        _buildResolvedAsset(e, t) {
            const { aliases: n, data: s, loadParser: r, format: a } = t;
            return (this._basePath || this._rootPath) && (e.src = Cr.toAbsolute(e.src, this._basePath, this._rootPath)), e.alias = n ?? e.alias ?? [
                e.src
            ], e.src = this._appendDefaultSearchParams(e.src), e.data = {
                ...s || {},
                ...e.data
            }, e.loadParser = r ?? e.loadParser, e.format = a ?? e.format ?? yT(e.src), e;
        }
    }
    Fp.RETINA_PREFIX = /@([0-9\.]+)x/;
    function yT(i) {
        return i.split(".").pop().split("?").shift().split("#").shift();
    }
    const Rd = (i, e)=>{
        const t = e.split("?")[1];
        return t && (i += `?${t}`), i;
    }, Op = class hr {
        constructor(e, t){
            this.linkedSheets = [], this._texture = e instanceof Oe ? e : null, this.textureSource = e.source, this.textures = {}, this.animations = {}, this.data = t;
            const n = parseFloat(t.meta.scale);
            n ? (this.resolution = n, e.source.resolution = this.resolution) : this.resolution = e.source._resolution, this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null;
        }
        parse() {
            return new Promise((e)=>{
                this._callback = e, this._batchIndex = 0, this._frameKeys.length <= hr.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch();
            });
        }
        _processFrames(e) {
            let t = e;
            const n = hr.BATCH_SIZE;
            for(; t - e < n && t < this._frameKeys.length;){
                const s = this._frameKeys[t], r = this._frames[s], a = r.frame;
                if (a) {
                    let o = null, c = null;
                    const l = r.trimmed !== !1 && r.sourceSize ? r.sourceSize : r.frame, h = new ft(0, 0, Math.floor(l.w) / this.resolution, Math.floor(l.h) / this.resolution);
                    r.rotated ? o = new ft(Math.floor(a.x) / this.resolution, Math.floor(a.y) / this.resolution, Math.floor(a.h) / this.resolution, Math.floor(a.w) / this.resolution) : o = new ft(Math.floor(a.x) / this.resolution, Math.floor(a.y) / this.resolution, Math.floor(a.w) / this.resolution, Math.floor(a.h) / this.resolution), r.trimmed !== !1 && r.spriteSourceSize && (c = new ft(Math.floor(r.spriteSourceSize.x) / this.resolution, Math.floor(r.spriteSourceSize.y) / this.resolution, Math.floor(a.w) / this.resolution, Math.floor(a.h) / this.resolution)), this.textures[s] = new Oe({
                        source: this.textureSource,
                        frame: o,
                        orig: h,
                        trim: c,
                        rotate: r.rotated ? 2 : 0,
                        defaultAnchor: r.anchor,
                        defaultBorders: r.borders,
                        label: s.toString()
                    });
                }
                t++;
            }
        }
        _processAnimations() {
            const e = this.data.animations || {};
            for(const t in e){
                this.animations[t] = [];
                for(let n = 0; n < e[t].length; n++){
                    const s = e[t][n];
                    this.animations[t].push(this.textures[s]);
                }
            }
        }
        _parseComplete() {
            const e = this._callback;
            this._callback = null, this._batchIndex = 0, e.call(this, this.textures);
        }
        _nextBatch() {
            this._processFrames(this._batchIndex * hr.BATCH_SIZE), this._batchIndex++, setTimeout(()=>{
                this._batchIndex * hr.BATCH_SIZE < this._frameKeys.length ? this._nextBatch() : (this._processAnimations(), this._parseComplete());
            }, 0);
        }
        destroy(e = !1) {
            for(const t in this.textures)this.textures[t].destroy();
            this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, e && (this._texture?.destroy(), this.textureSource.destroy()), this._texture = null, this.textureSource = null, this.linkedSheets = [];
        }
    };
    Op.BATCH_SIZE = 1e3;
    let Cd = Op;
    const bT = [
        "jpg",
        "png",
        "jpeg",
        "avif",
        "webp",
        "basis",
        "etc2",
        "bc7",
        "bc6h",
        "bc5",
        "bc4",
        "bc3",
        "bc2",
        "bc1",
        "eac",
        "astc"
    ];
    function kp(i, e, t) {
        const n = {};
        if (i.forEach((s)=>{
            n[s] = e;
        }), Object.keys(e.textures).forEach((s)=>{
            n[s] = e.textures[s];
        }), !t) {
            const s = Cr.dirname(i[0]);
            e.linkedSheets.forEach((r, a)=>{
                const o = kp([
                    `${s}/${e.data.meta.related_multi_packs[a]}`
                ], r, !0);
                Object.assign(n, o);
            });
        }
        return n;
    }
    const ST = {
        extension: se.Asset,
        cache: {
            test: (i)=>i instanceof Cd,
            getCacheableAssets: (i, e)=>kp(i, e, !1)
        },
        resolver: {
            extension: {
                type: se.ResolveParser,
                name: "resolveSpritesheet"
            },
            test: (i)=>{
                const t = i.split("?")[0].split("."), n = t.pop(), s = t.pop();
                return n === "json" && bT.includes(s);
            },
            parse: (i)=>{
                const e = i.split(".");
                return {
                    resolution: parseFloat(Fp.RETINA_PREFIX.exec(i)?.[1] ?? "1"),
                    format: e[e.length - 2],
                    src: i
                };
            }
        },
        loader: {
            name: "spritesheetLoader",
            extension: {
                type: se.LoadParser,
                priority: Np.Normal,
                name: "spritesheetLoader"
            },
            async testParse (i, e) {
                return Cr.extname(e.src).toLowerCase() === ".json" && !!i.frames;
            },
            async parse (i, e, t) {
                const { texture: n, imageFilename: s, textureOptions: r } = e?.data ?? {};
                let a = Cr.dirname(e.src);
                a && a.lastIndexOf("/") !== a.length - 1 && (a += "/");
                let o;
                if (n instanceof Oe) o = n;
                else {
                    const h = Rd(a + (s ?? i.meta.image), e.src);
                    o = (await t.load([
                        {
                            src: h,
                            data: r
                        }
                    ]))[h];
                }
                const c = new Cd(o.source, i);
                await c.parse();
                const l = i?.meta?.related_multi_packs;
                if (Array.isArray(l)) {
                    const h = [];
                    for (const d of l){
                        if (typeof d != "string") continue;
                        let f = a + d;
                        e.data?.ignoreMultiPack || (f = Rd(f, e.src), h.push(t.load({
                            src: f,
                            data: {
                                textureOptions: r,
                                ignoreMultiPack: !0
                            }
                        })));
                    }
                    const u = await Promise.all(h);
                    c.linkedSheets = u, u.forEach((d)=>{
                        d.linkedSheets = [
                            c
                        ].concat(c.linkedSheets.filter((f)=>f !== d));
                    });
                }
                return c;
            },
            async unload (i, e, t) {
                await t.unload(i.textureSource._sourceOrigin), i.destroy(!1);
            }
        }
    };
    Nt.add(ST);
    const Qo = Object.create(null), Pd = Object.create(null);
    function dh(i, e) {
        let t = Pd[i];
        return t === void 0 && (Qo[e] === void 0 && (Qo[e] = 1), Pd[i] = t = Qo[e]++), t;
    }
    let ga;
    function Gp() {
        return (!ga || ga?.isContextLost()) && (ga = jt.get().createCanvas().getContext("webgl", {})), ga;
    }
    let xa;
    function MT() {
        if (!xa) {
            xa = "mediump";
            const i = Gp();
            i && i.getShaderPrecisionFormat && (xa = i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.HIGH_FLOAT).precision ? "highp" : "mediump");
        }
        return xa;
    }
    function TT(i, e, t) {
        return e ? i : t ? (i = i.replace("out vec4 finalColor;", ""), `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${i}
        `) : `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${i}
        `;
    }
    function ET(i, e, t) {
        const n = t ? e.maxSupportedFragmentPrecision : e.maxSupportedVertexPrecision;
        if (i.substring(0, 9) !== "precision") {
            let s = t ? e.requestedFragmentPrecision : e.requestedVertexPrecision;
            return s === "highp" && n !== "highp" && (s = "mediump"), `precision ${s} float;
${i}`;
        } else if (n !== "highp" && i.substring(0, 15) === "precision highp") return i.replace("precision highp", "precision mediump");
        return i;
    }
    function AT(i, e) {
        return e ? `#version 300 es
${i}` : i;
    }
    const wT = {}, RT = {};
    function CT(i, { name: e = "pixi-program" }, t = !0) {
        e = e.replace(/\s+/g, "-"), e += t ? "-fragment" : "-vertex";
        const n = t ? wT : RT;
        return n[e] ? (n[e]++, e += `-${n[e]}`) : n[e] = 1, i.indexOf("#define SHADER_NAME") !== -1 ? i : `${`#define SHADER_NAME ${e}`}
${i}`;
    }
    function PT(i, e) {
        return e ? i.replace("#version 300 es", "") : i;
    }
    const ec = {
        stripVersion: PT,
        ensurePrecision: ET,
        addProgramDefines: TT,
        setProgramName: CT,
        insertVersion: AT
    }, tc = Object.create(null), Hp = class Sl {
        constructor(e){
            e = {
                ...Sl.defaultOptions,
                ...e
            };
            const t = e.fragment.indexOf("#version 300 es") !== -1, n = {
                stripVersion: t,
                ensurePrecision: {
                    requestedFragmentPrecision: e.preferredFragmentPrecision,
                    requestedVertexPrecision: e.preferredVertexPrecision,
                    maxSupportedVertexPrecision: "highp",
                    maxSupportedFragmentPrecision: MT()
                },
                setProgramName: {
                    name: e.name
                },
                addProgramDefines: t,
                insertVersion: t
            };
            let s = e.fragment, r = e.vertex;
            Object.keys(ec).forEach((a)=>{
                const o = n[a];
                s = ec[a](s, o, !0), r = ec[a](r, o, !1);
            }), this.fragment = s, this.vertex = r, this.transformFeedbackVaryings = e.transformFeedbackVaryings, this._key = dh(`${this.vertex}:${this.fragment}`, "gl-program");
        }
        destroy() {
            this.fragment = null, this.vertex = null, this._attributeData = null, this._uniformData = null, this._uniformBlockData = null, this.transformFeedbackVaryings = null;
        }
        static from(e) {
            const t = `${e.vertex}:${e.fragment}`;
            return tc[t] || (tc[t] = new Sl(e)), tc[t];
        }
    };
    Hp.defaultOptions = {
        preferredVertexPrecision: "highp",
        preferredFragmentPrecision: "mediump"
    };
    Br = Hp;
    const Id = {
        uint8x2: {
            size: 2,
            stride: 2,
            normalised: !1
        },
        uint8x4: {
            size: 4,
            stride: 4,
            normalised: !1
        },
        sint8x2: {
            size: 2,
            stride: 2,
            normalised: !1
        },
        sint8x4: {
            size: 4,
            stride: 4,
            normalised: !1
        },
        unorm8x2: {
            size: 2,
            stride: 2,
            normalised: !0
        },
        unorm8x4: {
            size: 4,
            stride: 4,
            normalised: !0
        },
        snorm8x2: {
            size: 2,
            stride: 2,
            normalised: !0
        },
        snorm8x4: {
            size: 4,
            stride: 4,
            normalised: !0
        },
        uint16x2: {
            size: 2,
            stride: 4,
            normalised: !1
        },
        uint16x4: {
            size: 4,
            stride: 8,
            normalised: !1
        },
        sint16x2: {
            size: 2,
            stride: 4,
            normalised: !1
        },
        sint16x4: {
            size: 4,
            stride: 8,
            normalised: !1
        },
        unorm16x2: {
            size: 2,
            stride: 4,
            normalised: !0
        },
        unorm16x4: {
            size: 4,
            stride: 8,
            normalised: !0
        },
        snorm16x2: {
            size: 2,
            stride: 4,
            normalised: !0
        },
        snorm16x4: {
            size: 4,
            stride: 8,
            normalised: !0
        },
        float16x2: {
            size: 2,
            stride: 4,
            normalised: !1
        },
        float16x4: {
            size: 4,
            stride: 8,
            normalised: !1
        },
        float32: {
            size: 1,
            stride: 4,
            normalised: !1
        },
        float32x2: {
            size: 2,
            stride: 8,
            normalised: !1
        },
        float32x3: {
            size: 3,
            stride: 12,
            normalised: !1
        },
        float32x4: {
            size: 4,
            stride: 16,
            normalised: !1
        },
        uint32: {
            size: 1,
            stride: 4,
            normalised: !1
        },
        uint32x2: {
            size: 2,
            stride: 8,
            normalised: !1
        },
        uint32x3: {
            size: 3,
            stride: 12,
            normalised: !1
        },
        uint32x4: {
            size: 4,
            stride: 16,
            normalised: !1
        },
        sint32: {
            size: 1,
            stride: 4,
            normalised: !1
        },
        sint32x2: {
            size: 2,
            stride: 8,
            normalised: !1
        },
        sint32x3: {
            size: 3,
            stride: 12,
            normalised: !1
        },
        sint32x4: {
            size: 4,
            stride: 16,
            normalised: !1
        }
    };
    Pr = function(i) {
        return Id[i] ?? Id.float32;
    };
    const IT = {
        f32: "float32",
        "vec2<f32>": "float32x2",
        "vec3<f32>": "float32x3",
        "vec4<f32>": "float32x4",
        vec2f: "float32x2",
        vec3f: "float32x3",
        vec4f: "float32x4",
        i32: "sint32",
        "vec2<i32>": "sint32x2",
        "vec3<i32>": "sint32x3",
        "vec4<i32>": "sint32x4",
        u32: "uint32",
        "vec2<u32>": "uint32x2",
        "vec3<u32>": "uint32x3",
        "vec4<u32>": "uint32x4",
        bool: "uint32",
        "vec2<bool>": "uint32x2",
        "vec3<bool>": "uint32x3",
        "vec4<bool>": "uint32x4"
    };
    function DT({ source: i, entryPoint: e }) {
        const t = {}, n = i.indexOf(`fn ${e}`);
        if (n !== -1) {
            const s = i.indexOf("->", n);
            if (s !== -1) {
                const r = i.substring(n, s), a = /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;
                let o;
                for(; (o = a.exec(r)) !== null;){
                    const c = IT[o[3]] ?? "float32";
                    t[o[2]] = {
                        location: parseInt(o[1], 10),
                        format: c,
                        stride: Pr(c).stride,
                        offset: 0,
                        instance: !1,
                        start: 0
                    };
                }
            }
        }
        return t;
    }
    function nc(i) {
        const e = /(^|[^/])@(group|binding)\(\d+\)[^;]+;/g, t = /@group\((\d+)\)/, n = /@binding\((\d+)\)/, s = /var(<[^>]+>)? (\w+)/, r = /:\s*(\w+)/, a = /struct\s+(\w+)\s*{([^}]+)}/g, o = /(\w+)\s*:\s*([\w\<\>]+)/g, c = /struct\s+(\w+)/, l = i.match(e)?.map((u)=>({
                group: parseInt(u.match(t)[1], 10),
                binding: parseInt(u.match(n)[1], 10),
                name: u.match(s)[2],
                isUniform: u.match(s)[1] === "<uniform>",
                type: u.match(r)[1]
            }));
        if (!l) return {
            groups: [],
            structs: []
        };
        const h = i.match(a)?.map((u)=>{
            const d = u.match(c)[1], f = u.match(o).reduce((_, g)=>{
                const [p, m] = g.split(":");
                return _[p.trim()] = m.trim(), _;
            }, {});
            return f ? {
                name: d,
                members: f
            } : null;
        }).filter(({ name: u })=>l.some((d)=>d.type === u)) ?? [];
        return {
            groups: l,
            structs: h
        };
    }
    var ur = ((i)=>(i[i.VERTEX = 1] = "VERTEX", i[i.FRAGMENT = 2] = "FRAGMENT", i[i.COMPUTE = 4] = "COMPUTE", i))(ur || {});
    function LT({ groups: i }) {
        const e = [];
        for(let t = 0; t < i.length; t++){
            const n = i[t];
            e[n.group] || (e[n.group] = []), n.isUniform ? e[n.group].push({
                binding: n.binding,
                visibility: ur.VERTEX | ur.FRAGMENT,
                buffer: {
                    type: "uniform"
                }
            }) : n.type === "sampler" ? e[n.group].push({
                binding: n.binding,
                visibility: ur.FRAGMENT,
                sampler: {
                    type: "filtering"
                }
            }) : n.type === "texture_2d" && e[n.group].push({
                binding: n.binding,
                visibility: ur.FRAGMENT,
                texture: {
                    sampleType: "float",
                    viewDimension: "2d",
                    multisampled: !1
                }
            });
        }
        return e;
    }
    function UT({ groups: i }) {
        const e = [];
        for(let t = 0; t < i.length; t++){
            const n = i[t];
            e[n.group] || (e[n.group] = {}), e[n.group][n.name] = n.binding;
        }
        return e;
    }
    function NT(i, e) {
        const t = new Set, n = new Set, s = [
            ...i.structs,
            ...e.structs
        ].filter((a)=>t.has(a.name) ? !1 : (t.add(a.name), !0)), r = [
            ...i.groups,
            ...e.groups
        ].filter((a)=>{
            const o = `${a.name}-${a.binding}`;
            return n.has(o) ? !1 : (n.add(o), !0);
        });
        return {
            structs: s,
            groups: r
        };
    }
    const ic = Object.create(null);
    Ws = class {
        constructor(e){
            this._layoutKey = 0, this._attributeLocationsKey = 0;
            const { fragment: t, vertex: n, layout: s, gpuLayout: r, name: a } = e;
            if (this.name = a, this.fragment = t, this.vertex = n, t.source === n.source) {
                const o = nc(t.source);
                this.structsAndGroups = o;
            } else {
                const o = nc(n.source), c = nc(t.source);
                this.structsAndGroups = NT(o, c);
            }
            this.layout = s ?? UT(this.structsAndGroups), this.gpuLayout = r ?? LT(this.structsAndGroups), this.autoAssignGlobalUniforms = this.layout[0]?.globalUniforms !== void 0, this.autoAssignLocalUniforms = this.layout[1]?.localUniforms !== void 0, this._generateProgramKey();
        }
        _generateProgramKey() {
            const { vertex: e, fragment: t } = this, n = e.source + t.source + e.entryPoint + t.entryPoint;
            this._layoutKey = dh(n, "program");
        }
        get attributeData() {
            return this._attributeData ?? (this._attributeData = DT(this.vertex)), this._attributeData;
        }
        destroy() {
            this.gpuLayout = null, this.layout = null, this.structsAndGroups = null, this.fragment = null, this.vertex = null;
        }
        static from(e) {
            const t = `${e.vertex.source}:${e.fragment.source}:${e.fragment.entryPoint}:${e.vertex.entryPoint}`;
            return ic[t] || (ic[t] = new Ws(e)), ic[t];
        }
    };
    const zp = [
        "f32",
        "i32",
        "vec2<f32>",
        "vec3<f32>",
        "vec4<f32>",
        "mat2x2<f32>",
        "mat3x3<f32>",
        "mat4x4<f32>",
        "mat3x2<f32>",
        "mat4x2<f32>",
        "mat2x3<f32>",
        "mat4x3<f32>",
        "mat2x4<f32>",
        "mat3x4<f32>",
        "vec2<i32>",
        "vec3<i32>",
        "vec4<i32>"
    ], BT = zp.reduce((i, e)=>(i[e] = !0, i), {});
    function FT(i, e) {
        switch(i){
            case "f32":
                return 0;
            case "vec2<f32>":
                return new Float32Array(2 * e);
            case "vec3<f32>":
                return new Float32Array(3 * e);
            case "vec4<f32>":
                return new Float32Array(4 * e);
            case "mat2x2<f32>":
                return new Float32Array([
                    1,
                    0,
                    0,
                    1
                ]);
            case "mat3x3<f32>":
                return new Float32Array([
                    1,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    1
                ]);
            case "mat4x4<f32>":
                return new Float32Array([
                    1,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    1
                ]);
        }
        return null;
    }
    const Vp = class Wp {
        constructor(e, t){
            this._touched = 0, this.uid = pt("uniform"), this._resourceType = "uniformGroup", this._resourceId = pt("resource"), this.isUniformGroup = !0, this._dirtyId = 0, this.destroyed = !1, t = {
                ...Wp.defaultOptions,
                ...t
            }, this.uniformStructures = e;
            const n = {};
            for(const s in e){
                const r = e[s];
                if (r.name = s, r.size = r.size ?? 1, !BT[r.type]) throw new Error(`Uniform type ${r.type} is not supported. Supported uniform types are: ${zp.join(", ")}`);
                r.value ?? (r.value = FT(r.type, r.size)), n[s] = r.value;
            }
            this.uniforms = n, this._dirtyId = 1, this.ubo = t.ubo, this.isStatic = t.isStatic, this._signature = dh(Object.keys(n).map((s)=>`${s}-${e[s].type}`).join("-"), "uniform-group");
        }
        update() {
            this._dirtyId++;
        }
    };
    Vp.defaultOptions = {
        ubo: !1,
        isStatic: !1
    };
    $i = Vp;
    gr = class {
        constructor(e){
            this.resources = Object.create(null), this._dirty = !0;
            let t = 0;
            for(const n in e){
                const s = e[n];
                this.setResource(s, t++);
            }
            this._updateKey();
        }
        _updateKey() {
            if (!this._dirty) return;
            this._dirty = !1;
            const e = [];
            let t = 0;
            for(const n in this.resources)e[t++] = this.resources[n]._resourceId;
            this._key = e.join("|");
        }
        setResource(e, t) {
            const n = this.resources[t];
            e !== n && (n && e.off?.("change", this.onResourceChange, this), e.on?.("change", this.onResourceChange, this), this.resources[t] = e, this._dirty = !0);
        }
        getResource(e) {
            return this.resources[e];
        }
        _touch(e) {
            const t = this.resources;
            for(const n in t)t[n]._touched = e;
        }
        destroy() {
            const e = this.resources;
            for(const t in e)e[t].off?.("change", this.onResourceChange, this);
            this.resources = null;
        }
        onResourceChange(e) {
            if (this._dirty = !0, e.destroyed) {
                const t = this.resources;
                for(const n in t)t[n] === e && (t[n] = null);
            } else this._updateKey();
        }
    };
    Xi = ((i)=>(i[i.WEBGL = 1] = "WEBGL", i[i.WEBGPU = 2] = "WEBGPU", i[i.BOTH = 3] = "BOTH", i))(Xi || {});
    Ki = class extends Cn {
        constructor(e){
            super(), this.uid = pt("shader"), this._uniformBindMap = Object.create(null), this._ownedBindGroups = [];
            let { gpuProgram: t, glProgram: n, groups: s, resources: r, compatibleRenderers: a, groupMap: o } = e;
            this.gpuProgram = t, this.glProgram = n, a === void 0 && (a = 0, t && (a |= Xi.WEBGPU), n && (a |= Xi.WEBGL)), this.compatibleRenderers = a;
            const c = {};
            if (!r && !s && (r = {}), r && s) throw new Error("[Shader] Cannot have both resources and groups");
            if (!t && s && !o) throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");
            if (!t && s && o) for(const l in o)for(const h in o[l]){
                const u = o[l][h];
                c[u] = {
                    group: l,
                    binding: h,
                    name: u
                };
            }
            else if (t && s && !o) {
                const l = t.structsAndGroups.groups;
                o = {}, l.forEach((h)=>{
                    o[h.group] = o[h.group] || {}, o[h.group][h.binding] = h.name, c[h.name] = h;
                });
            } else if (r) {
                s = {}, o = {}, t && t.structsAndGroups.groups.forEach((u)=>{
                    o[u.group] = o[u.group] || {}, o[u.group][u.binding] = u.name, c[u.name] = u;
                });
                let l = 0;
                for(const h in r)c[h] || (s[99] || (s[99] = new gr, this._ownedBindGroups.push(s[99])), c[h] = {
                    group: 99,
                    binding: l,
                    name: h
                }, o[99] = o[99] || {}, o[99][l] = h, l++);
                for(const h in r){
                    const u = h;
                    let d = r[h];
                    !d.source && !d._resourceType && (d = new $i(d));
                    const f = c[u];
                    f && (s[f.group] || (s[f.group] = new gr, this._ownedBindGroups.push(s[f.group])), s[f.group].setResource(d, f.binding));
                }
            }
            this.groups = s, this._uniformBindMap = o, this.resources = this._buildResourceAccessor(s, c);
        }
        addResource(e, t, n) {
            var s, r;
            (s = this._uniformBindMap)[t] || (s[t] = {}), (r = this._uniformBindMap[t])[n] || (r[n] = e), this.groups[t] || (this.groups[t] = new gr, this._ownedBindGroups.push(this.groups[t]));
        }
        _buildResourceAccessor(e, t) {
            const n = {};
            for(const s in t){
                const r = t[s];
                Object.defineProperty(n, r.name, {
                    get () {
                        return e[r.group].getResource(r.binding);
                    },
                    set (a) {
                        e[r.group].setResource(a, r.binding);
                    }
                });
            }
            return n;
        }
        destroy(e = !1) {
            this.emit("destroy", this), e && (this.gpuProgram?.destroy(), this.glProgram?.destroy()), this.gpuProgram = null, this.glProgram = null, this.removeAllListeners(), this._uniformBindMap = null, this._ownedBindGroups.forEach((t)=>{
                t.destroy();
            }), this._ownedBindGroups = null, this.resources = null, this.groups = null;
        }
        static from(e) {
            const { gpu: t, gl: n, ...s } = e;
            let r, a;
            return t && (r = Ws.from(t)), n && (a = Br.from(n)), new Ki({
                gpuProgram: r,
                glProgram: a,
                ...s
            });
        }
    };
    const OT = {
        normal: 0,
        add: 1,
        multiply: 2,
        screen: 3,
        overlay: 4,
        erase: 5,
        "normal-npm": 6,
        "add-npm": 7,
        "screen-npm": 8,
        min: 9,
        max: 10
    }, sc = 0, rc = 1, ac = 2, oc = 3, cc = 4, lc = 5, Ml = class Xp {
        constructor(){
            this.data = 0, this.blendMode = "normal", this.polygonOffset = 0, this.blend = !0, this.depthMask = !0;
        }
        get blend() {
            return !!(this.data & 1 << sc);
        }
        set blend(e) {
            !!(this.data & 1 << sc) !== e && (this.data ^= 1 << sc);
        }
        get offsets() {
            return !!(this.data & 1 << rc);
        }
        set offsets(e) {
            !!(this.data & 1 << rc) !== e && (this.data ^= 1 << rc);
        }
        set cullMode(e) {
            if (e === "none") {
                this.culling = !1;
                return;
            }
            this.culling = !0, this.clockwiseFrontFace = e === "front";
        }
        get cullMode() {
            return this.culling ? this.clockwiseFrontFace ? "front" : "back" : "none";
        }
        get culling() {
            return !!(this.data & 1 << ac);
        }
        set culling(e) {
            !!(this.data & 1 << ac) !== e && (this.data ^= 1 << ac);
        }
        get depthTest() {
            return !!(this.data & 1 << oc);
        }
        set depthTest(e) {
            !!(this.data & 1 << oc) !== e && (this.data ^= 1 << oc);
        }
        get depthMask() {
            return !!(this.data & 1 << lc);
        }
        set depthMask(e) {
            !!(this.data & 1 << lc) !== e && (this.data ^= 1 << lc);
        }
        get clockwiseFrontFace() {
            return !!(this.data & 1 << cc);
        }
        set clockwiseFrontFace(e) {
            !!(this.data & 1 << cc) !== e && (this.data ^= 1 << cc);
        }
        get blendMode() {
            return this._blendMode;
        }
        set blendMode(e) {
            this.blend = e !== "none", this._blendMode = e, this._blendModeId = OT[e] || 0;
        }
        get polygonOffset() {
            return this._polygonOffset;
        }
        set polygonOffset(e) {
            this.offsets = !!e, this._polygonOffset = e;
        }
        toString() {
            return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
        }
        static for2d() {
            const e = new Xp;
            return e.depthTest = !1, e.blend = !0, e;
        }
    };
    Ml.default2d = Ml.for2d();
    Fr = Ml;
    const Yp = class Tl extends Ki {
        constructor(e){
            e = {
                ...Tl.defaultOptions,
                ...e
            }, super(e), this.enabled = !0, this._state = Fr.for2d(), this.blendMode = e.blendMode, this.padding = e.padding, typeof e.antialias == "boolean" ? this.antialias = e.antialias ? "on" : "off" : this.antialias = e.antialias, this.resolution = e.resolution, this.blendRequired = e.blendRequired, this.clipToViewport = e.clipToViewport, this.addResource("uTexture", 0, 1);
        }
        apply(e, t, n, s) {
            e.applyFilter(this, t, n, s);
        }
        get blendMode() {
            return this._state.blendMode;
        }
        set blendMode(e) {
            this._state.blendMode = e;
        }
        static from(e) {
            const { gpu: t, gl: n, ...s } = e;
            let r, a;
            return t && (r = Ws.from(t)), n && (a = Br.from(n)), new Tl({
                gpuProgram: r,
                glProgram: a,
                ...s
            });
        }
    };
    Yp.defaultOptions = {
        blendMode: "normal",
        resolution: 1,
        padding: 0,
        antialias: "off",
        blendRequired: !1,
        clipToViewport: !0
    };
    let kT = Yp;
    const El = [];
    Nt.handleByNamedList(se.Environment, El);
    async function GT(i) {
        if (!i) for(let e = 0; e < El.length; e++){
            const t = El[e];
            if (t.value.test()) {
                await t.value.load();
                return;
            }
        }
    }
    let nr;
    function qp() {
        if (typeof nr == "boolean") return nr;
        try {
            nr = new Function("param1", "param2", "param3", "return param1[param2] === param3;")({
                a: "b"
            }, "a", "b") === !0;
        } catch  {
            nr = !1;
        }
        return nr;
    }
    var va = {
        exports: {}
    }, Dd;
    function HT() {
        if (Dd) return va.exports;
        Dd = 1, va.exports = i, va.exports.default = i;
        function i(b, C, A) {
            A = A || 2;
            var U = C && C.length, B = U ? C[0] * A : b.length, V = e(b, 0, B, A, !0), q = [];
            if (!V || V.next === V.prev) return q;
            var te, H, $, oe, ie, le, we;
            if (U && (V = c(b, C, V, A)), b.length > 80 * A) {
                te = $ = b[0], H = oe = b[1];
                for(var he = A; he < B; he += A)ie = b[he], le = b[he + 1], ie < te && (te = ie), le < H && (H = le), ie > $ && ($ = ie), le > oe && (oe = le);
                we = Math.max($ - te, oe - H), we = we !== 0 ? 32767 / we : 0;
            }
            return n(V, q, A, te, H, we, 0), q;
        }
        function e(b, C, A, U, B) {
            var V, q;
            if (B === ne(b, C, A, U) > 0) for(V = C; V < A; V += U)q = j(V, b[V], b[V + 1], q);
            else for(V = A - U; V >= C; V -= U)q = j(V, b[V], b[V + 1], q);
            return q && x(q, q.next) && (z(q), q = q.next), q;
        }
        function t(b, C) {
            if (!b) return b;
            C || (C = b);
            var A = b, U;
            do if (U = !1, !A.steiner && (x(A, A.next) || y(A.prev, A, A.next) === 0)) {
                if (z(A), A = C = A.prev, A === A.next) break;
                U = !0;
            } else A = A.next;
            while (U || A !== C);
            return C;
        }
        function n(b, C, A, U, B, V, q) {
            if (b) {
                !q && V && f(b, U, B, V);
                for(var te = b, H, $; b.prev !== b.next;){
                    if (H = b.prev, $ = b.next, V ? r(b, U, B, V) : s(b)) {
                        C.push(H.i / A | 0), C.push(b.i / A | 0), C.push($.i / A | 0), z(b), b = $.next, te = $.next;
                        continue;
                    }
                    if (b = $, b === te) {
                        q ? q === 1 ? (b = a(t(b), C, A), n(b, C, A, U, B, V, 2)) : q === 2 && o(b, C, A, U, B, V) : n(t(b), C, A, U, B, V, 1);
                        break;
                    }
                }
            }
        }
        function s(b) {
            var C = b.prev, A = b, U = b.next;
            if (y(C, A, U) >= 0) return !1;
            for(var B = C.x, V = A.x, q = U.x, te = C.y, H = A.y, $ = U.y, oe = B < V ? B < q ? B : q : V < q ? V : q, ie = te < H ? te < $ ? te : $ : H < $ ? H : $, le = B > V ? B > q ? B : q : V > q ? V : q, we = te > H ? te > $ ? te : $ : H > $ ? H : $, he = U.next; he !== C;){
                if (he.x >= oe && he.x <= le && he.y >= ie && he.y <= we && m(B, te, V, H, q, $, he.x, he.y) && y(he.prev, he, he.next) >= 0) return !1;
                he = he.next;
            }
            return !0;
        }
        function r(b, C, A, U) {
            var B = b.prev, V = b, q = b.next;
            if (y(B, V, q) >= 0) return !1;
            for(var te = B.x, H = V.x, $ = q.x, oe = B.y, ie = V.y, le = q.y, we = te < H ? te < $ ? te : $ : H < $ ? H : $, he = oe < ie ? oe < le ? oe : le : ie < le ? ie : le, tt = te > H ? te > $ ? te : $ : H > $ ? H : $, We = oe > ie ? oe > le ? oe : le : ie > le ? ie : le, Le = g(we, he, C, A, U), L = g(tt, We, C, A, U), Ce = b.prevZ, ge = b.nextZ; Ce && Ce.z >= Le && ge && ge.z <= L;){
                if (Ce.x >= we && Ce.x <= tt && Ce.y >= he && Ce.y <= We && Ce !== B && Ce !== q && m(te, oe, H, ie, $, le, Ce.x, Ce.y) && y(Ce.prev, Ce, Ce.next) >= 0 || (Ce = Ce.prevZ, ge.x >= we && ge.x <= tt && ge.y >= he && ge.y <= We && ge !== B && ge !== q && m(te, oe, H, ie, $, le, ge.x, ge.y) && y(ge.prev, ge, ge.next) >= 0)) return !1;
                ge = ge.nextZ;
            }
            for(; Ce && Ce.z >= Le;){
                if (Ce.x >= we && Ce.x <= tt && Ce.y >= he && Ce.y <= We && Ce !== B && Ce !== q && m(te, oe, H, ie, $, le, Ce.x, Ce.y) && y(Ce.prev, Ce, Ce.next) >= 0) return !1;
                Ce = Ce.prevZ;
            }
            for(; ge && ge.z <= L;){
                if (ge.x >= we && ge.x <= tt && ge.y >= he && ge.y <= We && ge !== B && ge !== q && m(te, oe, H, ie, $, le, ge.x, ge.y) && y(ge.prev, ge, ge.next) >= 0) return !1;
                ge = ge.nextZ;
            }
            return !0;
        }
        function a(b, C, A) {
            var U = b;
            do {
                var B = U.prev, V = U.next.next;
                !x(B, V) && I(B, U, U.next, V) && E(B, V) && E(V, B) && (C.push(B.i / A | 0), C.push(U.i / A | 0), C.push(V.i / A | 0), z(U), z(U.next), U = b = V), U = U.next;
            }while (U !== b);
            return t(U);
        }
        function o(b, C, A, U, B, V) {
            var q = b;
            do {
                for(var te = q.next.next; te !== q.prev;){
                    if (q.i !== te.i && v(q, te)) {
                        var H = D(q, te);
                        q = t(q, q.next), H = t(H, H.next), n(q, C, A, U, B, V, 0), n(H, C, A, U, B, V, 0);
                        return;
                    }
                    te = te.next;
                }
                q = q.next;
            }while (q !== b);
        }
        function c(b, C, A, U) {
            var B = [], V, q, te, H, $;
            for(V = 0, q = C.length; V < q; V++)te = C[V] * U, H = V < q - 1 ? C[V + 1] * U : b.length, $ = e(b, te, H, U, !1), $ === $.next && ($.steiner = !0), B.push(p($));
            for(B.sort(l), V = 0; V < B.length; V++)A = h(B[V], A);
            return A;
        }
        function l(b, C) {
            return b.x - C.x;
        }
        function h(b, C) {
            var A = u(b, C);
            if (!A) return C;
            var U = D(A, b);
            return t(U, U.next), t(A, A.next);
        }
        function u(b, C) {
            var A = C, U = b.x, B = b.y, V = -1 / 0, q;
            do {
                if (B <= A.y && B >= A.next.y && A.next.y !== A.y) {
                    var te = A.x + (B - A.y) * (A.next.x - A.x) / (A.next.y - A.y);
                    if (te <= U && te > V && (V = te, q = A.x < A.next.x ? A : A.next, te === U)) return q;
                }
                A = A.next;
            }while (A !== C);
            if (!q) return null;
            var H = q, $ = q.x, oe = q.y, ie = 1 / 0, le;
            A = q;
            do U >= A.x && A.x >= $ && U !== A.x && m(B < oe ? U : V, B, $, oe, B < oe ? V : U, B, A.x, A.y) && (le = Math.abs(B - A.y) / (U - A.x), E(A, b) && (le < ie || le === ie && (A.x > q.x || A.x === q.x && d(q, A))) && (q = A, ie = le)), A = A.next;
            while (A !== H);
            return q;
        }
        function d(b, C) {
            return y(b.prev, b, C.prev) < 0 && y(C.next, b, b.next) < 0;
        }
        function f(b, C, A, U) {
            var B = b;
            do B.z === 0 && (B.z = g(B.x, B.y, C, A, U)), B.prevZ = B.prev, B.nextZ = B.next, B = B.next;
            while (B !== b);
            B.prevZ.nextZ = null, B.prevZ = null, _(B);
        }
        function _(b) {
            var C, A, U, B, V, q, te, H, $ = 1;
            do {
                for(A = b, b = null, V = null, q = 0; A;){
                    for(q++, U = A, te = 0, C = 0; C < $ && (te++, U = U.nextZ, !!U); C++);
                    for(H = $; te > 0 || H > 0 && U;)te !== 0 && (H === 0 || !U || A.z <= U.z) ? (B = A, A = A.nextZ, te--) : (B = U, U = U.nextZ, H--), V ? V.nextZ = B : b = B, B.prevZ = V, V = B;
                    A = U;
                }
                V.nextZ = null, $ *= 2;
            }while (q > 1);
            return b;
        }
        function g(b, C, A, U, B) {
            return b = (b - A) * B | 0, C = (C - U) * B | 0, b = (b | b << 8) & 16711935, b = (b | b << 4) & 252645135, b = (b | b << 2) & 858993459, b = (b | b << 1) & 1431655765, C = (C | C << 8) & 16711935, C = (C | C << 4) & 252645135, C = (C | C << 2) & 858993459, C = (C | C << 1) & 1431655765, b | C << 1;
        }
        function p(b) {
            var C = b, A = b;
            do (C.x < A.x || C.x === A.x && C.y < A.y) && (A = C), C = C.next;
            while (C !== b);
            return A;
        }
        function m(b, C, A, U, B, V, q, te) {
            return (B - q) * (C - te) >= (b - q) * (V - te) && (b - q) * (U - te) >= (A - q) * (C - te) && (A - q) * (V - te) >= (B - q) * (U - te);
        }
        function v(b, C) {
            return b.next.i !== C.i && b.prev.i !== C.i && !N(b, C) && (E(b, C) && E(C, b) && S(b, C) && (y(b.prev, b, C.prev) || y(b, C.prev, C)) || x(b, C) && y(b.prev, b, b.next) > 0 && y(C.prev, C, C.next) > 0);
        }
        function y(b, C, A) {
            return (C.y - b.y) * (A.x - C.x) - (C.x - b.x) * (A.y - C.y);
        }
        function x(b, C) {
            return b.x === C.x && b.y === C.y;
        }
        function I(b, C, A, U) {
            var B = R(y(b, C, A)), V = R(y(b, C, U)), q = R(y(A, U, b)), te = R(y(A, U, C));
            return !!(B !== V && q !== te || B === 0 && w(b, A, C) || V === 0 && w(b, U, C) || q === 0 && w(A, b, U) || te === 0 && w(A, C, U));
        }
        function w(b, C, A) {
            return C.x <= Math.max(b.x, A.x) && C.x >= Math.min(b.x, A.x) && C.y <= Math.max(b.y, A.y) && C.y >= Math.min(b.y, A.y);
        }
        function R(b) {
            return b > 0 ? 1 : b < 0 ? -1 : 0;
        }
        function N(b, C) {
            var A = b;
            do {
                if (A.i !== b.i && A.next.i !== b.i && A.i !== C.i && A.next.i !== C.i && I(A, A.next, b, C)) return !0;
                A = A.next;
            }while (A !== b);
            return !1;
        }
        function E(b, C) {
            return y(b.prev, b, b.next) < 0 ? y(b, C, b.next) >= 0 && y(b, b.prev, C) >= 0 : y(b, C, b.prev) < 0 || y(b, b.next, C) < 0;
        }
        function S(b, C) {
            var A = b, U = !1, B = (b.x + C.x) / 2, V = (b.y + C.y) / 2;
            do A.y > V != A.next.y > V && A.next.y !== A.y && B < (A.next.x - A.x) * (V - A.y) / (A.next.y - A.y) + A.x && (U = !U), A = A.next;
            while (A !== b);
            return U;
        }
        function D(b, C) {
            var A = new K(b.i, b.x, b.y), U = new K(C.i, C.x, C.y), B = b.next, V = C.prev;
            return b.next = C, C.prev = b, A.next = B, B.prev = A, U.next = A, A.prev = U, V.next = U, U.prev = V, U;
        }
        function j(b, C, A, U) {
            var B = new K(b, C, A);
            return U ? (B.next = U.next, B.prev = U, U.next.prev = B, U.next = B) : (B.prev = B, B.next = B), B;
        }
        function z(b) {
            b.next.prev = b.prev, b.prev.next = b.next, b.prevZ && (b.prevZ.nextZ = b.nextZ), b.nextZ && (b.nextZ.prevZ = b.prevZ);
        }
        function K(b, C, A) {
            this.i = b, this.x = C, this.y = A, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
        }
        i.deviation = function(b, C, A, U) {
            var B = C && C.length, V = B ? C[0] * A : b.length, q = Math.abs(ne(b, 0, V, A));
            if (B) for(var te = 0, H = C.length; te < H; te++){
                var $ = C[te] * A, oe = te < H - 1 ? C[te + 1] * A : b.length;
                q -= Math.abs(ne(b, $, oe, A));
            }
            var ie = 0;
            for(te = 0; te < U.length; te += 3){
                var le = U[te] * A, we = U[te + 1] * A, he = U[te + 2] * A;
                ie += Math.abs((b[le] - b[he]) * (b[we + 1] - b[le + 1]) - (b[le] - b[we]) * (b[he + 1] - b[le + 1]));
            }
            return q === 0 && ie === 0 ? 0 : Math.abs((ie - q) / q);
        };
        function ne(b, C, A, U) {
            for(var B = 0, V = C, q = A - U; V < A; V += U)B += (b[q] - b[V]) * (b[V + 1] + b[q + 1]), q = V;
            return B;
        }
        return i.flatten = function(b) {
            for(var C = b[0][0].length, A = {
                vertices: [],
                holes: [],
                dimensions: C
            }, U = 0, B = 0; B < b.length; B++){
                for(var V = 0; V < b[B].length; V++)for(var q = 0; q < C; q++)A.vertices.push(b[B][V][q]);
                B > 0 && (U += b[B - 1].length, A.holes.push(U));
            }
            return A;
        }, va.exports;
    }
    var zT = HT();
    const VT = sh(zT);
    var gi = ((i)=>(i[i.NONE = 0] = "NONE", i[i.COLOR = 16384] = "COLOR", i[i.STENCIL = 1024] = "STENCIL", i[i.DEPTH = 256] = "DEPTH", i[i.COLOR_DEPTH = 16640] = "COLOR_DEPTH", i[i.COLOR_STENCIL = 17408] = "COLOR_STENCIL", i[i.DEPTH_STENCIL = 1280] = "DEPTH_STENCIL", i[i.ALL = 17664] = "ALL", i))(gi || {});
    class jp {
        constructor(e){
            this.items = [], this._name = e;
        }
        emit(e, t, n, s, r, a, o, c) {
            const { name: l, items: h } = this;
            for(let u = 0, d = h.length; u < d; u++)h[u][l](e, t, n, s, r, a, o, c);
            return this;
        }
        add(e) {
            return e[this._name] && (this.remove(e), this.items.push(e)), this;
        }
        remove(e) {
            const t = this.items.indexOf(e);
            return t !== -1 && this.items.splice(t, 1), this;
        }
        contains(e) {
            return this.items.indexOf(e) !== -1;
        }
        removeAll() {
            return this.items.length = 0, this;
        }
        destroy() {
            this.removeAll(), this.items = null, this._name = null;
        }
        get empty() {
            return this.items.length === 0;
        }
        get name() {
            return this._name;
        }
    }
    const WT = [
        "init",
        "destroy",
        "contextChange",
        "resolutionChange",
        "resetState",
        "renderEnd",
        "renderStart",
        "render",
        "update",
        "postrender",
        "prerender"
    ], $p = class Kp extends Cn {
        constructor(e){
            super(), this.runners = Object.create(null), this.renderPipes = Object.create(null), this._initOptions = {}, this._systemsHash = Object.create(null), this.type = e.type, this.name = e.name, this.config = e;
            const t = [
                ...WT,
                ...this.config.runners ?? []
            ];
            this._addRunners(...t), this._unsafeEvalCheck();
        }
        async init(e = {}) {
            const t = e.skipExtensionImports === !0 ? !0 : e.manageImports === !1;
            await GT(t), this._addSystems(this.config.systems), this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);
            for(const n in this._systemsHash)e = {
                ...this._systemsHash[n].constructor.defaultOptions,
                ...e
            };
            e = {
                ...Kp.defaultOptions,
                ...e
            }, this._roundPixels = e.roundPixels ? 1 : 0;
            for(let n = 0; n < this.runners.init.items.length; n++)await this.runners.init.items[n].init(e);
            this._initOptions = e;
        }
        render(e, t) {
            let n = e;
            if (n instanceof wn && (n = {
                container: n
            }, t && (ut(bt, "passing a second argument is deprecated, please use render options instead"), n.target = t.renderTexture)), n.target || (n.target = this.view.renderTarget), n.target === this.view.renderTarget && (this._lastObjectRendered = n.container, n.clearColor ?? (n.clearColor = this.background.colorRgba), n.clear ?? (n.clear = this.background.clearBeforeRender)), n.clearColor) {
                const s = Array.isArray(n.clearColor) && n.clearColor.length === 4;
                n.clearColor = s ? n.clearColor : Pt.shared.setValue(n.clearColor).toArray();
            }
            n.transform || (n.container.updateLocalTransform(), n.transform = n.container.localTransform), n.container.enableRenderGroup(), this.runners.prerender.emit(n), this.runners.renderStart.emit(n), this.runners.render.emit(n), this.runners.renderEnd.emit(n), this.runners.postrender.emit(n);
        }
        resize(e, t, n) {
            const s = this.view.resolution;
            this.view.resize(e, t, n), this.emit("resize", this.view.screen.width, this.view.screen.height, this.view.resolution), n !== void 0 && n !== s && this.runners.resolutionChange.emit(n);
        }
        clear(e = {}) {
            const t = this;
            e.target || (e.target = t.renderTarget.renderTarget), e.clearColor || (e.clearColor = this.background.colorRgba), e.clear ?? (e.clear = gi.ALL);
            const { clear: n, clearColor: s, target: r } = e;
            Pt.shared.setValue(s ?? this.background.colorRgba), t.renderTarget.clear(r, n, Pt.shared.toArray());
        }
        get resolution() {
            return this.view.resolution;
        }
        set resolution(e) {
            this.view.resolution = e, this.runners.resolutionChange.emit(e);
        }
        get width() {
            return this.view.texture.frame.width;
        }
        get height() {
            return this.view.texture.frame.height;
        }
        get canvas() {
            return this.view.canvas;
        }
        get lastObjectRendered() {
            return this._lastObjectRendered;
        }
        get renderingToScreen() {
            return this.renderTarget.renderingToScreen;
        }
        get screen() {
            return this.view.screen;
        }
        _addRunners(...e) {
            e.forEach((t)=>{
                this.runners[t] = new jp(t);
            });
        }
        _addSystems(e) {
            let t;
            for(t in e){
                const n = e[t];
                this._addSystem(n.value, n.name);
            }
        }
        _addSystem(e, t) {
            const n = new e(this);
            if (this[t]) throw new Error(`Whoops! The name "${t}" is already in use`);
            this[t] = n, this._systemsHash[t] = n;
            for(const s in this.runners)this.runners[s].add(n);
            return this;
        }
        _addPipes(e, t) {
            const n = t.reduce((s, r)=>(s[r.name] = r.value, s), {});
            e.forEach((s)=>{
                const r = s.value, a = s.name, o = n[a];
                this.renderPipes[a] = new r(this, o ? new o : null);
            });
        }
        destroy(e = !1) {
            this.runners.destroy.items.reverse(), this.runners.destroy.emit(e), Object.values(this.runners).forEach((t)=>{
                t.destroy();
            }), this._systemsHash = null, this.renderPipes = null;
        }
        generateTexture(e) {
            return this.textureGenerator.generateTexture(e);
        }
        get roundPixels() {
            return !!this._roundPixels;
        }
        _unsafeEvalCheck() {
            if (!qp()) throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
        }
        resetState() {
            this.runners.resetState.emit();
        }
    };
    $p.defaultOptions = {
        resolution: 1,
        failIfMajorPerformanceCaveat: !1,
        roundPixels: !1
    };
    let XT = $p;
    const Al = "8.9.1";
    se.Application;
    class Zp {
        constructor(e){
            this._renderer = e;
        }
        init() {
            globalThis.__PIXI_RENDERER_INIT__?.(this._renderer, Al);
        }
        destroy() {
            this._renderer = null;
        }
    }
    Zp.extension = {
        type: [
            se.WebGLSystem,
            se.WebGPUSystem
        ],
        name: "initHook",
        priority: -10
    };
    const Ld = [
        {
            offset: 0,
            color: "white"
        },
        {
            offset: 1,
            color: "black"
        }
    ], fh = class wl {
        constructor(...e){
            this.uid = pt("fillGradient"), this.type = "linear", this.colorStops = [];
            let t = YT(e);
            t = {
                ...t.type === "radial" ? wl.defaultRadialOptions : wl.defaultLinearOptions,
                ...dp(t)
            }, this._textureSize = t.textureSize, t.type === "radial" ? (this.center = t.center, this.outerCenter = t.outerCenter ?? this.center, this.innerRadius = t.innerRadius, this.outerRadius = t.outerRadius, this.scale = t.scale, this.rotation = t.rotation) : (this.start = t.start, this.end = t.end), this.textureSpace = t.textureSpace, this.type = t.type, t.colorStops.forEach((s)=>{
                this.addColorStop(s.offset, s.color);
            });
        }
        addColorStop(e, t) {
            return this.colorStops.push({
                offset: e,
                color: Pt.shared.setValue(t).toHexa()
            }), this;
        }
        buildLinearGradient() {
            if (this.texture) return;
            const e = this.colorStops.length ? this.colorStops : Ld, t = this._textureSize, { canvas: n, context: s } = Nd(t, 1), r = s.createLinearGradient(0, 0, this._textureSize, 0);
            Ud(r, e), s.fillStyle = r, s.fillRect(0, 0, t, 1), this.texture = new Oe({
                source: new Ya({
                    resource: n
                })
            });
            const { x: a, y: o } = this.start, { x: c, y: l } = this.end, h = new Fe, u = c - a, d = l - o, f = Math.sqrt(u * u + d * d), _ = Math.atan2(d, u);
            h.scale(f / t, 1), h.rotate(_), h.translate(a, o), this.textureSpace === "local" && h.scale(t, t), this.transform = h;
        }
        buildGradient() {
            this.type === "linear" ? this.buildLinearGradient() : this.buildRadialGradient();
        }
        buildRadialGradient() {
            if (this.texture) return;
            const e = this.colorStops.length ? this.colorStops : Ld, t = this._textureSize, { canvas: n, context: s } = Nd(t, t), { x: r, y: a } = this.center, { x: o, y: c } = this.outerCenter, l = this.innerRadius, h = this.outerRadius, u = o - h, d = c - h, f = t / (h * 2), _ = (r - u) * f, g = (a - d) * f, p = s.createRadialGradient(_, g, l * f, (o - u) * f, (c - d) * f, h * f);
            Ud(p, e), s.fillStyle = e[e.length - 1].color, s.fillRect(0, 0, t, t), s.fillStyle = p, s.translate(_, g), s.rotate(this.rotation), s.scale(1, this.scale), s.translate(-_, -g), s.fillRect(0, 0, t, t), this.texture = new Oe({
                source: new Ya({
                    resource: n,
                    addressModeU: "clamp-to-edge",
                    addressModeV: "clamp-to-edge"
                })
            });
            const m = new Fe;
            m.scale(1 / f, 1 / f), m.translate(u, d), this.textureSpace === "local" && m.scale(t, t), this.transform = m;
        }
        get styleKey() {
            return this.uid;
        }
        destroy() {
            this.texture?.destroy(!0), this.texture = null;
        }
    };
    fh.defaultLinearOptions = {
        start: {
            x: 0,
            y: 0
        },
        end: {
            x: 0,
            y: 1
        },
        colorStops: [],
        textureSpace: "local",
        type: "linear",
        textureSize: 256
    };
    fh.defaultRadialOptions = {
        center: {
            x: .5,
            y: .5
        },
        innerRadius: 0,
        outerRadius: .5,
        colorStops: [],
        scale: 1,
        textureSpace: "local",
        type: "radial",
        textureSize: 256
    };
    Yi = fh;
    function Ud(i, e) {
        for(let t = 0; t < e.length; t++){
            const n = e[t];
            i.addColorStop(n.offset, n.color);
        }
    }
    function Nd(i, e) {
        const t = jt.get().createCanvas(i, e), n = t.getContext("2d");
        return {
            canvas: t,
            context: n
        };
    }
    function YT(i) {
        let e = i[0] ?? {};
        return (typeof e == "number" || i[1]) && (ut("8.5.2", "use options object instead"), e = {
            type: "linear",
            start: {
                x: i[0],
                y: i[1]
            },
            end: {
                x: i[2],
                y: i[3]
            },
            textureSpace: i[4],
            textureSize: i[5] ?? Yi.defaultLinearOptions.textureSize
        }), e;
    }
    const Bd = {
        repeat: {
            addressModeU: "repeat",
            addressModeV: "repeat"
        },
        "repeat-x": {
            addressModeU: "repeat",
            addressModeV: "clamp-to-edge"
        },
        "repeat-y": {
            addressModeU: "clamp-to-edge",
            addressModeV: "repeat"
        },
        "no-repeat": {
            addressModeU: "clamp-to-edge",
            addressModeV: "clamp-to-edge"
        }
    };
    ph = class {
        constructor(e, t){
            this.uid = pt("fillPattern"), this.transform = new Fe, this._styleKey = null, this.texture = e, this.transform.scale(1 / e.frame.width, 1 / e.frame.height), t && (e.source.style.addressModeU = Bd[t].addressModeU, e.source.style.addressModeV = Bd[t].addressModeV);
        }
        setTransform(e) {
            const t = this.texture;
            this.transform.copyFrom(e), this.transform.invert(), this.transform.scale(1 / t.frame.width, 1 / t.frame.height), this._styleKey = null;
        }
        get styleKey() {
            return this._styleKey ? this._styleKey : (this._styleKey = `fill-pattern-${this.uid}-${this.texture.uid}-${this.transform.toArray().join("-")}`, this._styleKey);
        }
    };
    var hc, Fd;
    function qT() {
        if (Fd) return hc;
        Fd = 1, hc = t;
        var i = {
            a: 7,
            c: 6,
            h: 1,
            l: 2,
            m: 2,
            q: 4,
            s: 4,
            t: 2,
            v: 1,
            z: 0
        }, e = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
        function t(r) {
            var a = [];
            return r.replace(e, function(o, c, l) {
                var h = c.toLowerCase();
                for(l = s(l), h == "m" && l.length > 2 && (a.push([
                    c
                ].concat(l.splice(0, 2))), h = "l", c = c == "m" ? "l" : "L");;){
                    if (l.length == i[h]) return l.unshift(c), a.push(l);
                    if (l.length < i[h]) throw new Error("malformed path data");
                    a.push([
                        c
                    ].concat(l.splice(0, i[h])));
                }
            }), a;
        }
        var n = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
        function s(r) {
            var a = r.match(n);
            return a ? a.map(Number) : [];
        }
        return hc;
    }
    var jT = qT();
    const $T = sh(jT);
    function KT(i, e) {
        const t = $T(i), n = [];
        let s = null, r = 0, a = 0;
        for(let o = 0; o < t.length; o++){
            const c = t[o], l = c[0], h = c;
            switch(l){
                case "M":
                    r = h[1], a = h[2], e.moveTo(r, a);
                    break;
                case "m":
                    r += h[1], a += h[2], e.moveTo(r, a);
                    break;
                case "H":
                    r = h[1], e.lineTo(r, a);
                    break;
                case "h":
                    r += h[1], e.lineTo(r, a);
                    break;
                case "V":
                    a = h[1], e.lineTo(r, a);
                    break;
                case "v":
                    a += h[1], e.lineTo(r, a);
                    break;
                case "L":
                    r = h[1], a = h[2], e.lineTo(r, a);
                    break;
                case "l":
                    r += h[1], a += h[2], e.lineTo(r, a);
                    break;
                case "C":
                    r = h[5], a = h[6], e.bezierCurveTo(h[1], h[2], h[3], h[4], r, a);
                    break;
                case "c":
                    e.bezierCurveTo(r + h[1], a + h[2], r + h[3], a + h[4], r + h[5], a + h[6]), r += h[5], a += h[6];
                    break;
                case "S":
                    r = h[3], a = h[4], e.bezierCurveToShort(h[1], h[2], r, a);
                    break;
                case "s":
                    e.bezierCurveToShort(r + h[1], a + h[2], r + h[3], a + h[4]), r += h[3], a += h[4];
                    break;
                case "Q":
                    r = h[3], a = h[4], e.quadraticCurveTo(h[1], h[2], r, a);
                    break;
                case "q":
                    e.quadraticCurveTo(r + h[1], a + h[2], r + h[3], a + h[4]), r += h[3], a += h[4];
                    break;
                case "T":
                    r = h[1], a = h[2], e.quadraticCurveToShort(r, a);
                    break;
                case "t":
                    r += h[1], a += h[2], e.quadraticCurveToShort(r, a);
                    break;
                case "A":
                    r = h[6], a = h[7], e.arcToSvg(h[1], h[2], h[3], h[4], h[5], r, a);
                    break;
                case "a":
                    r += h[6], a += h[7], e.arcToSvg(h[1], h[2], h[3], h[4], h[5], r, a);
                    break;
                case "Z":
                case "z":
                    e.closePath(), n.length > 0 && (s = n.pop(), s ? (r = s.startX, a = s.startY) : (r = 0, a = 0)), s = null;
                    break;
                default:
                    _t(`Unknown SVG path command: ${l}`);
            }
            l !== "Z" && l !== "z" && s === null && (s = {
                startX: r,
                startY: a
            }, n.push(s));
        }
        return e;
    }
    class mh {
        constructor(e = 0, t = 0, n = 0){
            this.type = "circle", this.x = e, this.y = t, this.radius = n;
        }
        clone() {
            return new mh(this.x, this.y, this.radius);
        }
        contains(e, t) {
            if (this.radius <= 0) return !1;
            const n = this.radius * this.radius;
            let s = this.x - e, r = this.y - t;
            return s *= s, r *= r, s + r <= n;
        }
        strokeContains(e, t, n, s = .5) {
            if (this.radius === 0) return !1;
            const r = this.x - e, a = this.y - t, o = this.radius, c = (1 - s) * n, l = Math.sqrt(r * r + a * a);
            return l <= o + c && l > o - (n - c);
        }
        getBounds(e) {
            return e || (e = new ft), e.x = this.x - this.radius, e.y = this.y - this.radius, e.width = this.radius * 2, e.height = this.radius * 2, e;
        }
        copyFrom(e) {
            return this.x = e.x, this.y = e.y, this.radius = e.radius, this;
        }
        copyTo(e) {
            return e.copyFrom(this), e;
        }
        toString() {
            return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
        }
    }
    class _h {
        constructor(e = 0, t = 0, n = 0, s = 0){
            this.type = "ellipse", this.x = e, this.y = t, this.halfWidth = n, this.halfHeight = s;
        }
        clone() {
            return new _h(this.x, this.y, this.halfWidth, this.halfHeight);
        }
        contains(e, t) {
            if (this.halfWidth <= 0 || this.halfHeight <= 0) return !1;
            let n = (e - this.x) / this.halfWidth, s = (t - this.y) / this.halfHeight;
            return n *= n, s *= s, n + s <= 1;
        }
        strokeContains(e, t, n, s = .5) {
            const { halfWidth: r, halfHeight: a } = this;
            if (r <= 0 || a <= 0) return !1;
            const o = n * (1 - s), c = n - o, l = r - c, h = a - c, u = r + o, d = a + o, f = e - this.x, _ = t - this.y, g = f * f / (l * l) + _ * _ / (h * h), p = f * f / (u * u) + _ * _ / (d * d);
            return g > 1 && p <= 1;
        }
        getBounds(e) {
            return e || (e = new ft), e.x = this.x - this.halfWidth, e.y = this.y - this.halfHeight, e.width = this.halfWidth * 2, e.height = this.halfHeight * 2, e;
        }
        copyFrom(e) {
            return this.x = e.x, this.y = e.y, this.halfWidth = e.halfWidth, this.halfHeight = e.halfHeight, this;
        }
        copyTo(e) {
            return e.copyFrom(this), e;
        }
        toString() {
            return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;
        }
    }
    function ZT(i, e, t, n, s, r) {
        const a = i - t, o = e - n, c = s - t, l = r - n, h = a * c + o * l, u = c * c + l * l;
        let d = -1;
        u !== 0 && (d = h / u);
        let f, _;
        d < 0 ? (f = t, _ = n) : d > 1 ? (f = s, _ = r) : (f = t + d * c, _ = n + d * l);
        const g = i - f, p = e - _;
        return g * g + p * p;
    }
    let JT, QT;
    class xr {
        constructor(...e){
            this.type = "polygon";
            let t = Array.isArray(e[0]) ? e[0] : e;
            if (typeof t[0] != "number") {
                const n = [];
                for(let s = 0, r = t.length; s < r; s++)n.push(t[s].x, t[s].y);
                t = n;
            }
            this.points = t, this.closePath = !0;
        }
        isClockwise() {
            let e = 0;
            const t = this.points, n = t.length;
            for(let s = 0; s < n; s += 2){
                const r = t[s], a = t[s + 1], o = t[(s + 2) % n], c = t[(s + 3) % n];
                e += (o - r) * (c + a);
            }
            return e < 0;
        }
        containsPolygon(e) {
            const t = this.getBounds(JT), n = e.getBounds(QT);
            if (!t.containsRect(n)) return !1;
            const s = e.points;
            for(let r = 0; r < s.length; r += 2){
                const a = s[r], o = s[r + 1];
                if (!this.contains(a, o)) return !1;
            }
            return !0;
        }
        clone() {
            const e = this.points.slice(), t = new xr(e);
            return t.closePath = this.closePath, t;
        }
        contains(e, t) {
            let n = !1;
            const s = this.points.length / 2;
            for(let r = 0, a = s - 1; r < s; a = r++){
                const o = this.points[r * 2], c = this.points[r * 2 + 1], l = this.points[a * 2], h = this.points[a * 2 + 1];
                c > t != h > t && e < (l - o) * ((t - c) / (h - c)) + o && (n = !n);
            }
            return n;
        }
        strokeContains(e, t, n, s = .5) {
            const r = n * n, a = r * (1 - s), o = r - a, { points: c } = this, l = c.length - (this.closePath ? 0 : 2);
            for(let h = 0; h < l; h += 2){
                const u = c[h], d = c[h + 1], f = c[(h + 2) % c.length], _ = c[(h + 3) % c.length], g = ZT(e, t, u, d, f, _), p = Math.sign((f - u) * (t - d) - (_ - d) * (e - u));
                if (g <= (p < 0 ? o : a)) return !0;
            }
            return !1;
        }
        getBounds(e) {
            e || (e = new ft);
            const t = this.points;
            let n = 1 / 0, s = -1 / 0, r = 1 / 0, a = -1 / 0;
            for(let o = 0, c = t.length; o < c; o += 2){
                const l = t[o], h = t[o + 1];
                n = l < n ? l : n, s = l > s ? l : s, r = h < r ? h : r, a = h > a ? h : a;
            }
            return e.x = n, e.width = s - n, e.y = r, e.height = a - r, e;
        }
        copyFrom(e) {
            return this.points = e.points.slice(), this.closePath = e.closePath, this;
        }
        copyTo(e) {
            return e.copyFrom(this), e;
        }
        toString() {
            return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((e, t)=>`${e}, ${t}`, "")}]`;
        }
        get lastX() {
            return this.points[this.points.length - 2];
        }
        get lastY() {
            return this.points[this.points.length - 1];
        }
        get x() {
            return this.points[this.points.length - 2];
        }
        get y() {
            return this.points[this.points.length - 1];
        }
    }
    const ya = (i, e, t, n, s, r, a)=>{
        const o = i - t, c = e - n, l = Math.sqrt(o * o + c * c);
        return l >= s - r && l <= s + a;
    };
    class gh {
        constructor(e = 0, t = 0, n = 0, s = 0, r = 20){
            this.type = "roundedRectangle", this.x = e, this.y = t, this.width = n, this.height = s, this.radius = r;
        }
        getBounds(e) {
            return e || (e = new ft), e.x = this.x, e.y = this.y, e.width = this.width, e.height = this.height, e;
        }
        clone() {
            return new gh(this.x, this.y, this.width, this.height, this.radius);
        }
        copyFrom(e) {
            return this.x = e.x, this.y = e.y, this.width = e.width, this.height = e.height, this;
        }
        copyTo(e) {
            return e.copyFrom(this), e;
        }
        contains(e, t) {
            if (this.width <= 0 || this.height <= 0) return !1;
            if (e >= this.x && e <= this.x + this.width && t >= this.y && t <= this.y + this.height) {
                const n = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
                if (t >= this.y + n && t <= this.y + this.height - n || e >= this.x + n && e <= this.x + this.width - n) return !0;
                let s = e - (this.x + n), r = t - (this.y + n);
                const a = n * n;
                if (s * s + r * r <= a || (s = e - (this.x + this.width - n), s * s + r * r <= a) || (r = t - (this.y + this.height - n), s * s + r * r <= a) || (s = e - (this.x + n), s * s + r * r <= a)) return !0;
            }
            return !1;
        }
        strokeContains(e, t, n, s = .5) {
            const { x: r, y: a, width: o, height: c, radius: l } = this, h = n * (1 - s), u = n - h, d = r + l, f = a + l, _ = o - l * 2, g = c - l * 2, p = r + o, m = a + c;
            return (e >= r - h && e <= r + u || e >= p - u && e <= p + h) && t >= f && t <= f + g || (t >= a - h && t <= a + u || t >= m - u && t <= m + h) && e >= d && e <= d + _ ? !0 : e < d && t < f && ya(e, t, d, f, l, u, h) || e > p - l && t < f && ya(e, t, p - l, f, l, u, h) || e > p - l && t > m - l && ya(e, t, p - l, m - l, l, u, h) || e < d && t > m - l && ya(e, t, d, m - l, l, u, h);
        }
        toString() {
            return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
        }
    }
    const eE = [
        "precision mediump float;",
        "void main(void){",
        "float test = 0.1;",
        "%forloop%",
        "gl_FragColor = vec4(0.0);",
        "}"
    ].join(`
`);
    function tE(i) {
        let e = "";
        for(let t = 0; t < i; ++t)t > 0 && (e += `
else `), t < i - 1 && (e += `if(test == ${t}.0){}`);
        return e;
    }
    function nE(i, e) {
        if (i === 0) throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
        const t = e.createShader(e.FRAGMENT_SHADER);
        try {
            for(;;){
                const n = eE.replace(/%forloop%/gi, tE(i));
                if (e.shaderSource(t, n), e.compileShader(t), !e.getShaderParameter(t, e.COMPILE_STATUS)) i = i / 2 | 0;
                else break;
            }
        } finally{
            e.deleteShader(t);
        }
        return i;
    }
    let ps = null;
    eo = function() {
        if (ps) return ps;
        const i = Gp();
        return ps = i.getParameter(i.MAX_TEXTURE_IMAGE_UNITS), ps = nE(ps, i), i.getExtension("WEBGL_lose_context")?.loseContext(), ps;
    };
    const Jp = {};
    function iE(i, e) {
        let t = 2166136261;
        for(let n = 0; n < e; n++)t ^= i[n].uid, t = Math.imul(t, 16777619), t >>>= 0;
        return Jp[t] || sE(i, e, t);
    }
    let uc = 0;
    function sE(i, e, t) {
        const n = {};
        let s = 0;
        uc || (uc = eo());
        for(let a = 0; a < uc; a++){
            const o = a < e ? i[a] : Oe.EMPTY.source;
            n[s++] = o.source, n[s++] = o.style;
        }
        const r = new gr(n);
        return Jp[t] = r, r;
    }
    Od = class {
        constructor(e){
            typeof e == "number" ? this.rawBinaryData = new ArrayBuffer(e) : e instanceof Uint8Array ? this.rawBinaryData = e.buffer : this.rawBinaryData = e, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData), this.size = this.rawBinaryData.byteLength;
        }
        get int8View() {
            return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;
        }
        get uint8View() {
            return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;
        }
        get int16View() {
            return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;
        }
        get int32View() {
            return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;
        }
        get float64View() {
            return this._float64Array || (this._float64Array = new Float64Array(this.rawBinaryData)), this._float64Array;
        }
        get bigUint64View() {
            return this._bigUint64Array || (this._bigUint64Array = new BigUint64Array(this.rawBinaryData)), this._bigUint64Array;
        }
        view(e) {
            return this[`${e}View`];
        }
        destroy() {
            this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this.uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null;
        }
        static sizeOf(e) {
            switch(e){
                case "int8":
                case "uint8":
                    return 1;
                case "int16":
                case "uint16":
                    return 2;
                case "int32":
                case "uint32":
                case "float32":
                    return 4;
                default:
                    throw new Error(`${e} isn't a valid view type`);
            }
        }
    };
    function kd(i, e) {
        const t = i.byteLength / 8 | 0, n = new Float64Array(i, 0, t);
        new Float64Array(e, 0, t).set(n);
        const r = i.byteLength - t * 8;
        if (r > 0) {
            const a = new Uint8Array(i, t * 8, r);
            new Uint8Array(e, t * 8, r).set(a);
        }
    }
    const rE = {
        normal: "normal-npm",
        add: "add-npm",
        screen: "screen-npm"
    };
    var Ct = ((i)=>(i[i.DISABLED = 0] = "DISABLED", i[i.RENDERING_MASK_ADD = 1] = "RENDERING_MASK_ADD", i[i.MASK_ACTIVE = 2] = "MASK_ACTIVE", i[i.INVERSE_MASK_ACTIVE = 3] = "INVERSE_MASK_ACTIVE", i[i.RENDERING_MASK_REMOVE = 4] = "RENDERING_MASK_REMOVE", i[i.NONE = 5] = "NONE", i))(Ct || {});
    Gd = function(i, e) {
        return e.alphaMode === "no-premultiply-alpha" && rE[i] || i;
    };
    class aE {
        constructor(){
            this.ids = Object.create(null), this.textures = [], this.count = 0;
        }
        clear() {
            for(let e = 0; e < this.count; e++){
                const t = this.textures[e];
                this.textures[e] = null, this.ids[t.uid] = null;
            }
            this.count = 0;
        }
    }
    class oE {
        constructor(){
            this.renderPipeId = "batch", this.action = "startBatch", this.start = 0, this.size = 0, this.textures = new aE, this.blendMode = "normal", this.topology = "triangle-strip", this.canBundle = !0;
        }
        destroy() {
            this.textures = null, this.gpuBindGroup = null, this.bindGroup = null, this.batcher = null;
        }
    }
    const Qp = [];
    let Rl = 0;
    function Hd() {
        return Rl > 0 ? Qp[--Rl] : new oE;
    }
    function zd(i) {
        Qp[Rl++] = i;
    }
    let ir = 0;
    const em = class Na {
        constructor(e = {}){
            this.uid = pt("batcher"), this.dirty = !0, this.batchIndex = 0, this.batches = [], this._elements = [], Na.defaultOptions.maxTextures = Na.defaultOptions.maxTextures ?? eo(), e = {
                ...Na.defaultOptions,
                ...e
            };
            const { maxTextures: t, attributesInitialSize: n, indicesInitialSize: s } = e;
            this.attributeBuffer = new Od(n * 4), this.indexBuffer = new Uint16Array(s), this.maxTextures = t;
        }
        begin() {
            this.elementSize = 0, this.elementStart = 0, this.indexSize = 0, this.attributeSize = 0;
            for(let e = 0; e < this.batchIndex; e++)zd(this.batches[e]);
            this.batchIndex = 0, this._batchIndexStart = 0, this._batchIndexSize = 0, this.dirty = !0;
        }
        add(e) {
            this._elements[this.elementSize++] = e, e._indexStart = this.indexSize, e._attributeStart = this.attributeSize, e._batcher = this, this.indexSize += e.indexSize, this.attributeSize += e.attributeSize * this.vertexSize;
        }
        checkAndUpdateTexture(e, t) {
            const n = e._batch.textures.ids[t._source.uid];
            return !n && n !== 0 ? !1 : (e._textureId = n, e.texture = t, !0);
        }
        updateElement(e) {
            this.dirty = !0;
            const t = this.attributeBuffer;
            e.packAsQuad ? this.packQuadAttributes(e, t.float32View, t.uint32View, e._attributeStart, e._textureId) : this.packAttributes(e, t.float32View, t.uint32View, e._attributeStart, e._textureId);
        }
        break(e) {
            const t = this._elements;
            if (!t[this.elementStart]) return;
            let n = Hd(), s = n.textures;
            s.clear();
            const r = t[this.elementStart];
            let a = Gd(r.blendMode, r.texture._source), o = r.topology;
            this.attributeSize * 4 > this.attributeBuffer.size && this._resizeAttributeBuffer(this.attributeSize * 4), this.indexSize > this.indexBuffer.length && this._resizeIndexBuffer(this.indexSize);
            const c = this.attributeBuffer.float32View, l = this.attributeBuffer.uint32View, h = this.indexBuffer;
            let u = this._batchIndexSize, d = this._batchIndexStart, f = "startBatch";
            const _ = this.maxTextures;
            for(let g = this.elementStart; g < this.elementSize; ++g){
                const p = t[g];
                t[g] = null;
                const v = p.texture._source, y = Gd(p.blendMode, v), x = a !== y || o !== p.topology;
                if (v._batchTick === ir && !x) {
                    p._textureId = v._textureBindLocation, u += p.indexSize, p.packAsQuad ? (this.packQuadAttributes(p, c, l, p._attributeStart, p._textureId), this.packQuadIndex(h, p._indexStart, p._attributeStart / this.vertexSize)) : (this.packAttributes(p, c, l, p._attributeStart, p._textureId), this.packIndex(p, h, p._indexStart, p._attributeStart / this.vertexSize)), p._batch = n;
                    continue;
                }
                v._batchTick = ir, (s.count >= _ || x) && (this._finishBatch(n, d, u - d, s, a, o, e, f), f = "renderBatch", d = u, a = y, o = p.topology, n = Hd(), s = n.textures, s.clear(), ++ir), p._textureId = v._textureBindLocation = s.count, s.ids[v.uid] = s.count, s.textures[s.count++] = v, p._batch = n, u += p.indexSize, p.packAsQuad ? (this.packQuadAttributes(p, c, l, p._attributeStart, p._textureId), this.packQuadIndex(h, p._indexStart, p._attributeStart / this.vertexSize)) : (this.packAttributes(p, c, l, p._attributeStart, p._textureId), this.packIndex(p, h, p._indexStart, p._attributeStart / this.vertexSize));
            }
            s.count > 0 && (this._finishBatch(n, d, u - d, s, a, o, e, f), d = u, ++ir), this.elementStart = this.elementSize, this._batchIndexStart = d, this._batchIndexSize = u;
        }
        _finishBatch(e, t, n, s, r, a, o, c) {
            e.gpuBindGroup = null, e.bindGroup = null, e.action = c, e.batcher = this, e.textures = s, e.blendMode = r, e.topology = a, e.start = t, e.size = n, ++ir, this.batches[this.batchIndex++] = e, o.add(e);
        }
        finish(e) {
            this.break(e);
        }
        ensureAttributeBuffer(e) {
            e * 4 <= this.attributeBuffer.size || this._resizeAttributeBuffer(e * 4);
        }
        ensureIndexBuffer(e) {
            e <= this.indexBuffer.length || this._resizeIndexBuffer(e);
        }
        _resizeAttributeBuffer(e) {
            const t = Math.max(e, this.attributeBuffer.size * 2), n = new Od(t);
            kd(this.attributeBuffer.rawBinaryData, n.rawBinaryData), this.attributeBuffer = n;
        }
        _resizeIndexBuffer(e) {
            const t = this.indexBuffer;
            let n = Math.max(e, t.length * 1.5);
            n += n % 2;
            const s = n > 65535 ? new Uint32Array(n) : new Uint16Array(n);
            if (s.BYTES_PER_ELEMENT !== t.BYTES_PER_ELEMENT) for(let r = 0; r < t.length; r++)s[r] = t[r];
            else kd(t.buffer, s.buffer);
            this.indexBuffer = s;
        }
        packQuadIndex(e, t, n) {
            e[t] = n + 0, e[t + 1] = n + 1, e[t + 2] = n + 2, e[t + 3] = n + 0, e[t + 4] = n + 2, e[t + 5] = n + 3;
        }
        packIndex(e, t, n, s) {
            const r = e.indices, a = e.indexSize, o = e.indexOffset, c = e.attributeOffset;
            for(let l = 0; l < a; l++)t[n++] = s + r[l + o] - c;
        }
        destroy() {
            for(let e = 0; e < this.batches.length; e++)zd(this.batches[e]);
            this.batches = null;
            for(let e = 0; e < this._elements.length; e++)this._elements[e]._batch = null;
            this._elements = null, this.indexBuffer = null, this.attributeBuffer.destroy(), this.attributeBuffer = null;
        }
    };
    em.defaultOptions = {
        maxTextures: null,
        attributesInitialSize: 4,
        indicesInitialSize: 6
    };
    let cE = em;
    St = ((i)=>(i[i.MAP_READ = 1] = "MAP_READ", i[i.MAP_WRITE = 2] = "MAP_WRITE", i[i.COPY_SRC = 4] = "COPY_SRC", i[i.COPY_DST = 8] = "COPY_DST", i[i.INDEX = 16] = "INDEX", i[i.VERTEX = 32] = "VERTEX", i[i.UNIFORM = 64] = "UNIFORM", i[i.STORAGE = 128] = "STORAGE", i[i.INDIRECT = 256] = "INDIRECT", i[i.QUERY_RESOLVE = 512] = "QUERY_RESOLVE", i[i.STATIC = 1024] = "STATIC", i))(St || {});
    qi = class extends Cn {
        constructor(e){
            let { data: t, size: n } = e;
            const { usage: s, label: r, shrinkToFit: a } = e;
            super(), this.uid = pt("buffer"), this._resourceType = "buffer", this._resourceId = pt("resource"), this._touched = 0, this._updateID = 1, this._dataInt32 = null, this.shrinkToFit = !0, this.destroyed = !1, t instanceof Array && (t = new Float32Array(t)), this._data = t, n ?? (n = t?.byteLength);
            const o = !!t;
            this.descriptor = {
                size: n,
                usage: s,
                mappedAtCreation: o,
                label: r
            }, this.shrinkToFit = a ?? !0;
        }
        get data() {
            return this._data;
        }
        set data(e) {
            this.setDataWithSize(e, e.length, !0);
        }
        get dataInt32() {
            return this._dataInt32 || (this._dataInt32 = new Int32Array(this.data.buffer)), this._dataInt32;
        }
        get static() {
            return !!(this.descriptor.usage & St.STATIC);
        }
        set static(e) {
            e ? this.descriptor.usage |= St.STATIC : this.descriptor.usage &= ~St.STATIC;
        }
        setDataWithSize(e, t, n) {
            if (this._updateID++, this._updateSize = t * e.BYTES_PER_ELEMENT, this._data === e) {
                n && this.emit("update", this);
                return;
            }
            const s = this._data;
            if (this._data = e, this._dataInt32 = null, !s || s.length !== e.length) {
                !this.shrinkToFit && s && e.byteLength < s.byteLength ? n && this.emit("update", this) : (this.descriptor.size = e.byteLength, this._resourceId = pt("resource"), this.emit("change", this));
                return;
            }
            n && this.emit("update", this);
        }
        update(e) {
            this._updateSize = e ?? this._updateSize, this._updateID++, this.emit("update", this);
        }
        destroy() {
            this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this._data = null, this.descriptor = null, this.removeAllListeners();
        }
    };
    function tm(i, e) {
        if (!(i instanceof qi)) {
            let t = e ? St.INDEX : St.VERTEX;
            i instanceof Array && (e ? (i = new Uint32Array(i), t = St.INDEX | St.COPY_DST) : (i = new Float32Array(i), t = St.VERTEX | St.COPY_DST)), i = new qi({
                data: i,
                label: e ? "index-mesh-buffer" : "vertex-mesh-buffer",
                usage: t
            });
        }
        return i;
    }
    function lE(i, e, t) {
        const n = i.getAttribute(e);
        if (!n) return t.minX = 0, t.minY = 0, t.maxX = 0, t.maxY = 0, t;
        const s = n.buffer.data;
        let r = 1 / 0, a = 1 / 0, o = -1 / 0, c = -1 / 0;
        const l = s.BYTES_PER_ELEMENT, h = (n.offset || 0) / l, u = (n.stride || 2 * 4) / l;
        for(let d = h; d < s.length; d += u){
            const f = s[d], _ = s[d + 1];
            f > o && (o = f), _ > c && (c = _), f < r && (r = f), _ < a && (a = _);
        }
        return t.minX = r, t.minY = a, t.maxX = o, t.maxY = c, t;
    }
    function hE(i) {
        return (i instanceof qi || Array.isArray(i) || i.BYTES_PER_ELEMENT) && (i = {
            buffer: i
        }), i.buffer = tm(i.buffer, !1), i;
    }
    nm = class extends Cn {
        constructor(e = {}){
            super(), this.uid = pt("geometry"), this._layoutKey = 0, this.instanceCount = 1, this._bounds = new en, this._boundsDirty = !0;
            const { attributes: t, indexBuffer: n, topology: s } = e;
            if (this.buffers = [], this.attributes = {}, t) for(const r in t)this.addAttribute(r, t[r]);
            this.instanceCount = e.instanceCount ?? 1, n && this.addIndex(n), this.topology = s || "triangle-list";
        }
        onBufferUpdate() {
            this._boundsDirty = !0, this.emit("update", this);
        }
        getAttribute(e) {
            return this.attributes[e];
        }
        getIndex() {
            return this.indexBuffer;
        }
        getBuffer(e) {
            return this.getAttribute(e).buffer;
        }
        getSize() {
            for(const e in this.attributes){
                const t = this.attributes[e];
                return t.buffer.data.length / (t.stride / 4 || t.size);
            }
            return 0;
        }
        addAttribute(e, t) {
            const n = hE(t);
            this.buffers.indexOf(n.buffer) === -1 && (this.buffers.push(n.buffer), n.buffer.on("update", this.onBufferUpdate, this), n.buffer.on("change", this.onBufferUpdate, this)), this.attributes[e] = n;
        }
        addIndex(e) {
            this.indexBuffer = tm(e, !0), this.buffers.push(this.indexBuffer);
        }
        get bounds() {
            return this._boundsDirty ? (this._boundsDirty = !1, lE(this, "aPosition", this._bounds)) : this._bounds;
        }
        destroy(e = !1) {
            this.emit("destroy", this), this.removeAllListeners(), e && this.buffers.forEach((t)=>t.destroy()), this.attributes = null, this.buffers = null, this.indexBuffer = null, this._bounds = null;
        }
    };
    const uE = new Float32Array(1), dE = new Uint32Array(1);
    class fE extends nm {
        constructor(){
            const t = new qi({
                data: uE,
                label: "attribute-batch-buffer",
                usage: St.VERTEX | St.COPY_DST,
                shrinkToFit: !1
            }), n = new qi({
                data: dE,
                label: "index-batch-buffer",
                usage: St.INDEX | St.COPY_DST,
                shrinkToFit: !1
            }), s = 6 * 4;
            super({
                attributes: {
                    aPosition: {
                        buffer: t,
                        format: "float32x2",
                        stride: s,
                        offset: 0
                    },
                    aUV: {
                        buffer: t,
                        format: "float32x2",
                        stride: s,
                        offset: 2 * 4
                    },
                    aColor: {
                        buffer: t,
                        format: "unorm8x4",
                        stride: s,
                        offset: 4 * 4
                    },
                    aTextureIdAndRound: {
                        buffer: t,
                        format: "uint16x2",
                        stride: s,
                        offset: 5 * 4
                    }
                },
                indexBuffer: n
            });
        }
    }
    function Vd(i, e, t) {
        if (i) for(const n in i){
            const s = n.toLocaleLowerCase(), r = e[s];
            if (r) {
                let a = i[n];
                n === "header" && (a = a.replace(/@in\s+[^;]+;\s*/g, "").replace(/@out\s+[^;]+;\s*/g, "")), t && r.push(`//----${t}----//`), r.push(a);
            } else _t(`${n} placement hook does not exist in shader`);
        }
    }
    const pE = /\{\{(.*?)\}\}/g;
    function Wd(i) {
        const e = {};
        return (i.match(pE)?.map((n)=>n.replace(/[{()}]/g, "")) ?? []).forEach((n)=>{
            e[n] = [];
        }), e;
    }
    function Xd(i, e) {
        let t;
        const n = /@in\s+([^;]+);/g;
        for(; (t = n.exec(i)) !== null;)e.push(t[1]);
    }
    function Yd(i, e, t = !1) {
        const n = [];
        Xd(e, n), i.forEach((o)=>{
            o.header && Xd(o.header, n);
        });
        const s = n;
        t && s.sort();
        const r = s.map((o, c)=>`       @location(${c}) ${o},`).join(`
`);
        let a = e.replace(/@in\s+[^;]+;\s*/g, "");
        return a = a.replace("{{in}}", `
${r}
`), a;
    }
    function qd(i, e) {
        let t;
        const n = /@out\s+([^;]+);/g;
        for(; (t = n.exec(i)) !== null;)e.push(t[1]);
    }
    function mE(i) {
        const t = /\b(\w+)\s*:/g.exec(i);
        return t ? t[1] : "";
    }
    function _E(i) {
        const e = /@.*?\s+/g;
        return i.replace(e, "");
    }
    function gE(i, e) {
        const t = [];
        qd(e, t), i.forEach((c)=>{
            c.header && qd(c.header, t);
        });
        let n = 0;
        const s = t.sort().map((c)=>c.indexOf("builtin") > -1 ? c : `@location(${n++}) ${c}`).join(`,
`), r = t.sort().map((c)=>`       var ${_E(c)};`).join(`
`), a = `return VSOutput(
            ${t.sort().map((c)=>` ${mE(c)}`).join(`,
`)});`;
        let o = e.replace(/@out\s+[^;]+;\s*/g, "");
        return o = o.replace("{{struct}}", `
${s}
`), o = o.replace("{{start}}", `
${r}
`), o = o.replace("{{return}}", `
${a}
`), o;
    }
    function jd(i, e) {
        let t = i;
        for(const n in e){
            const s = e[n];
            s.join(`
`).length ? t = t.replace(`{{${n}}}`, `//-----${n} START-----//
${s.join(`
`)}
//----${n} FINISH----//`) : t = t.replace(`{{${n}}}`, "");
        }
        return t;
    }
    const fi = Object.create(null), dc = new Map;
    let xE = 0;
    function vE({ template: i, bits: e }) {
        const t = im(i, e);
        if (fi[t]) return fi[t];
        const { vertex: n, fragment: s } = bE(i, e);
        return fi[t] = sm(n, s, e), fi[t];
    }
    function yE({ template: i, bits: e }) {
        const t = im(i, e);
        return fi[t] || (fi[t] = sm(i.vertex, i.fragment, e)), fi[t];
    }
    function bE(i, e) {
        const t = e.map((a)=>a.vertex).filter((a)=>!!a), n = e.map((a)=>a.fragment).filter((a)=>!!a);
        let s = Yd(t, i.vertex, !0);
        s = gE(t, s);
        const r = Yd(n, i.fragment, !0);
        return {
            vertex: s,
            fragment: r
        };
    }
    function im(i, e) {
        return e.map((t)=>(dc.has(t) || dc.set(t, xE++), dc.get(t))).sort((t, n)=>t - n).join("-") + i.vertex + i.fragment;
    }
    function sm(i, e, t) {
        const n = Wd(i), s = Wd(e);
        return t.forEach((r)=>{
            Vd(r.vertex, n, r.name), Vd(r.fragment, s, r.name);
        }), {
            vertex: jd(i, n),
            fragment: jd(e, s)
        };
    }
    const SE = `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}
        
        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);
       
        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`, ME = `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;
   
    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {
        
        {{start}}

        var outColor:vec4<f32>;
      
        {{main}}
        
        var finalColor:vec4<f32> = outColor * vColor;

        {{end}}

        return finalColor;
      };
`, TE = `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;
        
        {{start}}
        
        vColor = vec4(1.);
        
        {{main}}
        
        vUV = uv;
        
        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`, EE = `
   
    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {
        
        {{start}}

        vec4 outColor;
      
        {{main}}
        
        finalColor = outColor * vColor;
        
        {{end}}
    }
`, AE = {
        name: "global-uniforms-bit",
        vertex: {
            header: `
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `
        }
    }, wE = {
        name: "global-uniforms-bit",
        vertex: {
            header: `
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `
        }
    };
    RE = function({ bits: i, name: e }) {
        const t = vE({
            template: {
                fragment: ME,
                vertex: SE
            },
            bits: [
                AE,
                ...i
            ]
        });
        return Ws.from({
            name: e,
            vertex: {
                source: t.vertex,
                entryPoint: "main"
            },
            fragment: {
                source: t.fragment,
                entryPoint: "main"
            }
        });
    };
    xh = function({ bits: i, name: e }) {
        return new Br({
            name: e,
            ...yE({
                template: {
                    vertex: TE,
                    fragment: EE
                },
                bits: [
                    wE,
                    ...i
                ]
            })
        });
    };
    let fc;
    CE = {
        name: "color-bit",
        vertex: {
            header: `
            @in aColor: vec4<f32>;
        `,
            main: `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `
        }
    };
    rm = {
        name: "color-bit",
        vertex: {
            header: `
            in vec4 aColor;
        `,
            main: `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `
        }
    };
    fc = {};
    function PE(i) {
        const e = [];
        if (i === 1) e.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"), e.push("@group(1) @binding(1) var textureSampler1: sampler;");
        else {
            let t = 0;
            for(let n = 0; n < i; n++)e.push(`@group(1) @binding(${t++}) var textureSource${n + 1}: texture_2d<f32>;`), e.push(`@group(1) @binding(${t++}) var textureSampler${n + 1}: sampler;`);
        }
        return e.join(`
`);
    }
    function IE(i) {
        const e = [];
        if (i === 1) e.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");
        else {
            e.push("switch vTextureId {");
            for(let t = 0; t < i; t++)t === i - 1 ? e.push("  default:{") : e.push(`  case ${t}:{`), e.push(`      outColor = textureSampleGrad(textureSource${t + 1}, textureSampler${t + 1}, vUV, uvDx, uvDy);`), e.push("      break;}");
            e.push("}");
        }
        return e.join(`
`);
    }
    DE = function(i) {
        return fc[i] || (fc[i] = {
            name: "texture-batch-bit",
            vertex: {
                header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,
                main: `
                vTextureId = aTextureIdAndRound.y;
            `,
                end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `
            },
            fragment: {
                header: `
                @in @interpolate(flat) vTextureId: u32;

                ${PE(i)}
            `,
                main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${IE(i)}
            `
            }
        }), fc[i];
    };
    const pc = {};
    function LE(i) {
        const e = [];
        for(let t = 0; t < i; t++)t > 0 && e.push("else"), t < i - 1 && e.push(`if(vTextureId < ${t}.5)`), e.push("{"), e.push(`	outColor = texture(uTextures[${t}], vUV);`), e.push("}");
        return e.join(`
`);
    }
    am = function(i) {
        return pc[i] || (pc[i] = {
            name: "texture-batch-bit",
            vertex: {
                header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `,
                main: `
                vTextureId = aTextureIdAndRound.y;
            `,
                end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `
            },
            fragment: {
                header: `
                in float vTextureId;

                uniform sampler2D uTextures[${i}];

            `,
                main: `

                ${LE(i)}
            `
            }
        }), pc[i];
    };
    let $d;
    UE = {
        name: "round-pixels-bit",
        vertex: {
            header: `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> 
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
        }
    };
    vh = {
        name: "round-pixels-bit",
        vertex: {
            header: `   
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {       
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
        }
    };
    $d = {};
    om = function(i) {
        let e = $d[i];
        if (e) return e;
        const t = new Int32Array(i);
        for(let n = 0; n < i; n++)t[n] = n;
        return e = $d[i] = new $i({
            uTextures: {
                value: t,
                type: "i32",
                size: i
            }
        }, {
            isStatic: !0
        }), e;
    };
    class NE extends Ki {
        constructor(e){
            const t = xh({
                name: "batch",
                bits: [
                    rm,
                    am(e),
                    vh
                ]
            }), n = RE({
                name: "batch",
                bits: [
                    CE,
                    DE(e),
                    UE
                ]
            });
            super({
                glProgram: t,
                gpuProgram: n,
                resources: {
                    batchSamplers: om(e)
                }
            });
        }
    }
    let Kd = null;
    const cm = class lm extends cE {
        constructor(){
            super(...arguments), this.geometry = new fE, this.shader = Kd || (Kd = new NE(this.maxTextures)), this.name = lm.extension.name, this.vertexSize = 6;
        }
        packAttributes(e, t, n, s, r) {
            const a = r << 16 | e.roundPixels & 65535, o = e.transform, c = o.a, l = o.b, h = o.c, u = o.d, d = o.tx, f = o.ty, { positions: _, uvs: g } = e, p = e.color, m = e.attributeOffset, v = m + e.attributeSize;
            for(let y = m; y < v; y++){
                const x = y * 2, I = _[x], w = _[x + 1];
                t[s++] = c * I + h * w + d, t[s++] = u * w + l * I + f, t[s++] = g[x], t[s++] = g[x + 1], n[s++] = p, n[s++] = a;
            }
        }
        packQuadAttributes(e, t, n, s, r) {
            const a = e.texture, o = e.transform, c = o.a, l = o.b, h = o.c, u = o.d, d = o.tx, f = o.ty, _ = e.bounds, g = _.maxX, p = _.minX, m = _.maxY, v = _.minY, y = a.uvs, x = e.color, I = r << 16 | e.roundPixels & 65535;
            t[s + 0] = c * p + h * v + d, t[s + 1] = u * v + l * p + f, t[s + 2] = y.x0, t[s + 3] = y.y0, n[s + 4] = x, n[s + 5] = I, t[s + 6] = c * g + h * v + d, t[s + 7] = u * v + l * g + f, t[s + 8] = y.x1, t[s + 9] = y.y1, n[s + 10] = x, n[s + 11] = I, t[s + 12] = c * g + h * m + d, t[s + 13] = u * m + l * g + f, t[s + 14] = y.x2, t[s + 15] = y.y2, n[s + 16] = x, n[s + 17] = I, t[s + 18] = c * p + h * m + d, t[s + 19] = u * m + l * p + f, t[s + 20] = y.x3, t[s + 21] = y.y3, n[s + 22] = x, n[s + 23] = I;
        }
    };
    cm.extension = {
        type: [
            se.Batcher
        ],
        name: "default"
    };
    let yh = cm;
    function BE(i, e, t, n, s, r, a, o = null) {
        let c = 0;
        t *= e, s *= r;
        const l = o.a, h = o.b, u = o.c, d = o.d, f = o.tx, _ = o.ty;
        for(; c < a;){
            const g = i[t], p = i[t + 1];
            n[s] = l * g + u * p + f, n[s + 1] = h * g + d * p + _, s += r, t += e, c++;
        }
    }
    function FE(i, e, t, n) {
        let s = 0;
        for(e *= t; s < n;)i[e] = 0, i[e + 1] = 0, e += t, s++;
    }
    function hm(i, e, t, n, s) {
        const r = e.a, a = e.b, o = e.c, c = e.d, l = e.tx, h = e.ty;
        t || (t = 0), n || (n = 2), s || (s = i.length / n - t);
        let u = t * n;
        for(let d = 0; d < s; d++){
            const f = i[u], _ = i[u + 1];
            i[u] = r * f + o * _ + l, i[u + 1] = a * f + c * _ + h, u += n;
        }
    }
    const OE = new Fe;
    um = class {
        constructor(){
            this.packAsQuad = !1, this.batcherName = "default", this.topology = "triangle-list", this.applyTransform = !0, this.roundPixels = 0, this._batcher = null, this._batch = null;
        }
        get uvs() {
            return this.geometryData.uvs;
        }
        get positions() {
            return this.geometryData.vertices;
        }
        get indices() {
            return this.geometryData.indices;
        }
        get blendMode() {
            return this.applyTransform ? this.renderable.groupBlendMode : "normal";
        }
        get color() {
            const e = this.baseColor, t = e >> 16 | e & 65280 | (e & 255) << 16, n = this.renderable;
            return n ? Sp(t, n.groupColor) + (this.alpha * n.groupAlpha * 255 << 24) : t + (this.alpha * 255 << 24);
        }
        get transform() {
            return this.renderable?.groupTransform || OE;
        }
        copyTo(e) {
            e.indexOffset = this.indexOffset, e.indexSize = this.indexSize, e.attributeOffset = this.attributeOffset, e.attributeSize = this.attributeSize, e.baseColor = this.baseColor, e.alpha = this.alpha, e.texture = this.texture, e.geometryData = this.geometryData, e.topology = this.topology;
        }
        reset() {
            this.applyTransform = !0, this.renderable = null, this.topology = "triangle-list";
        }
    };
    const Ir = {
        extension: {
            type: se.ShapeBuilder,
            name: "circle"
        },
        build (i, e) {
            let t, n, s, r, a, o;
            if (i.type === "circle") {
                const x = i;
                t = x.x, n = x.y, a = o = x.radius, s = r = 0;
            } else if (i.type === "ellipse") {
                const x = i;
                t = x.x, n = x.y, a = x.halfWidth, o = x.halfHeight, s = r = 0;
            } else {
                const x = i, I = x.width / 2, w = x.height / 2;
                t = x.x + I, n = x.y + w, a = o = Math.max(0, Math.min(x.radius, Math.min(I, w))), s = I - a, r = w - o;
            }
            if (!(a >= 0 && o >= 0 && s >= 0 && r >= 0)) return e;
            const c = Math.ceil(2.3 * Math.sqrt(a + o)), l = c * 8 + (s ? 4 : 0) + (r ? 4 : 0);
            if (l === 0) return e;
            if (c === 0) return e[0] = e[6] = t + s, e[1] = e[3] = n + r, e[2] = e[4] = t - s, e[5] = e[7] = n - r, e;
            let h = 0, u = c * 4 + (s ? 2 : 0) + 2, d = u, f = l, _ = s + a, g = r, p = t + _, m = t - _, v = n + g;
            if (e[h++] = p, e[h++] = v, e[--u] = v, e[--u] = m, r) {
                const x = n - g;
                e[d++] = m, e[d++] = x, e[--f] = x, e[--f] = p;
            }
            for(let x = 1; x < c; x++){
                const I = Math.PI / 2 * (x / c), w = s + Math.cos(I) * a, R = r + Math.sin(I) * o, N = t + w, E = t - w, S = n + R, D = n - R;
                e[h++] = N, e[h++] = S, e[--u] = S, e[--u] = E, e[d++] = E, e[d++] = D, e[--f] = D, e[--f] = N;
            }
            _ = s, g = r + o, p = t + _, m = t - _, v = n + g;
            const y = n - g;
            return e[h++] = p, e[h++] = v, e[--f] = y, e[--f] = p, s && (e[h++] = m, e[h++] = v, e[--f] = y, e[--f] = m), e;
        },
        triangulate (i, e, t, n, s, r) {
            if (i.length === 0) return;
            let a = 0, o = 0;
            for(let h = 0; h < i.length; h += 2)a += i[h], o += i[h + 1];
            a /= i.length / 2, o /= i.length / 2;
            let c = n;
            e[c * t] = a, e[c * t + 1] = o;
            const l = c++;
            for(let h = 0; h < i.length; h += 2)e[c * t] = i[h], e[c * t + 1] = i[h + 1], h > 0 && (s[r++] = c, s[r++] = l, s[r++] = c - 1), c++;
            s[r++] = l + 1, s[r++] = l, s[r++] = c - 1;
        }
    }, kE = {
        ...Ir,
        extension: {
            ...Ir.extension,
            name: "ellipse"
        }
    }, GE = {
        ...Ir,
        extension: {
            ...Ir.extension,
            name: "roundedRectangle"
        }
    }, dm = 1e-4, Zd = 1e-4;
    function HE(i) {
        const e = i.length;
        if (e < 6) return 1;
        let t = 0;
        for(let n = 0, s = i[e - 2], r = i[e - 1]; n < e; n += 2){
            const a = i[n], o = i[n + 1];
            t += (a - s) * (o + r), s = a, r = o;
        }
        return t < 0 ? -1 : 1;
    }
    function Jd(i, e, t, n, s, r, a, o) {
        const c = i - t * s, l = e - n * s, h = i + t * r, u = e + n * r;
        let d, f;
        a ? (d = n, f = -t) : (d = -n, f = t);
        const _ = c + d, g = l + f, p = h + d, m = u + f;
        return o.push(_, g), o.push(p, m), 2;
    }
    function Ri(i, e, t, n, s, r, a, o) {
        const c = t - i, l = n - e;
        let h = Math.atan2(c, l), u = Math.atan2(s - i, r - e);
        o && h < u ? h += Math.PI * 2 : !o && h > u && (u += Math.PI * 2);
        let d = h;
        const f = u - h, _ = Math.abs(f), g = Math.sqrt(c * c + l * l), p = (15 * _ * Math.sqrt(g) / Math.PI >> 0) + 1, m = f / p;
        if (d += m, o) {
            a.push(i, e), a.push(t, n);
            for(let v = 1, y = d; v < p; v++, y += m)a.push(i, e), a.push(i + Math.sin(y) * g, e + Math.cos(y) * g);
            a.push(i, e), a.push(s, r);
        } else {
            a.push(t, n), a.push(i, e);
            for(let v = 1, y = d; v < p; v++, y += m)a.push(i + Math.sin(y) * g, e + Math.cos(y) * g), a.push(i, e);
            a.push(s, r), a.push(i, e);
        }
        return p * 2;
    }
    function zE(i, e, t, n, s, r) {
        const a = dm;
        if (i.length === 0) return;
        const o = e;
        let c = o.alignment;
        if (e.alignment !== .5) {
            let U = HE(i);
            c = (c - .5) * U + .5;
        }
        const l = new Lt(i[0], i[1]), h = new Lt(i[i.length - 2], i[i.length - 1]), u = n, d = Math.abs(l.x - h.x) < a && Math.abs(l.y - h.y) < a;
        if (u) {
            i = i.slice(), d && (i.pop(), i.pop(), h.set(i[i.length - 2], i[i.length - 1]));
            const U = (l.x + h.x) * .5, B = (h.y + l.y) * .5;
            i.unshift(U, B), i.push(U, B);
        }
        const f = s, _ = i.length / 2;
        let g = i.length;
        const p = f.length / 2, m = o.width / 2, v = m * m, y = o.miterLimit * o.miterLimit;
        let x = i[0], I = i[1], w = i[2], R = i[3], N = 0, E = 0, S = -(I - R), D = x - w, j = 0, z = 0, K = Math.sqrt(S * S + D * D);
        S /= K, D /= K, S *= m, D *= m;
        const ne = c, b = (1 - ne) * 2, C = ne * 2;
        u || (o.cap === "round" ? g += Ri(x - S * (b - C) * .5, I - D * (b - C) * .5, x - S * b, I - D * b, x + S * C, I + D * C, f, !0) + 2 : o.cap === "square" && (g += Jd(x, I, S, D, b, C, !0, f))), f.push(x - S * b, I - D * b), f.push(x + S * C, I + D * C);
        for(let U = 1; U < _ - 1; ++U){
            x = i[(U - 1) * 2], I = i[(U - 1) * 2 + 1], w = i[U * 2], R = i[U * 2 + 1], N = i[(U + 1) * 2], E = i[(U + 1) * 2 + 1], S = -(I - R), D = x - w, K = Math.sqrt(S * S + D * D), S /= K, D /= K, S *= m, D *= m, j = -(R - E), z = w - N, K = Math.sqrt(j * j + z * z), j /= K, z /= K, j *= m, z *= m;
            const B = w - x, V = I - R, q = w - N, te = E - R, H = B * q + V * te, $ = V * q - te * B, oe = $ < 0;
            if (Math.abs($) < .001 * Math.abs(H)) {
                f.push(w - S * b, R - D * b), f.push(w + S * C, R + D * C), H >= 0 && (o.join === "round" ? g += Ri(w, R, w - S * b, R - D * b, w - j * b, R - z * b, f, !1) + 4 : g += 2, f.push(w - j * C, R - z * C), f.push(w + j * b, R + z * b));
                continue;
            }
            const ie = (-S + x) * (-D + R) - (-S + w) * (-D + I), le = (-j + N) * (-z + R) - (-j + w) * (-z + E), we = (B * le - q * ie) / $, he = (te * ie - V * le) / $, tt = (we - w) * (we - w) + (he - R) * (he - R), We = w + (we - w) * b, Le = R + (he - R) * b, L = w - (we - w) * C, Ce = R - (he - R) * C, ge = Math.min(B * B + V * V, q * q + te * te), Xe = oe ? b : C, Ee = ge + Xe * Xe * v;
            tt <= Ee ? o.join === "bevel" || tt / v > y ? (oe ? (f.push(We, Le), f.push(w + S * C, R + D * C), f.push(We, Le), f.push(w + j * C, R + z * C)) : (f.push(w - S * b, R - D * b), f.push(L, Ce), f.push(w - j * b, R - z * b), f.push(L, Ce)), g += 2) : o.join === "round" ? oe ? (f.push(We, Le), f.push(w + S * C, R + D * C), g += Ri(w, R, w + S * C, R + D * C, w + j * C, R + z * C, f, !0) + 4, f.push(We, Le), f.push(w + j * C, R + z * C)) : (f.push(w - S * b, R - D * b), f.push(L, Ce), g += Ri(w, R, w - S * b, R - D * b, w - j * b, R - z * b, f, !1) + 4, f.push(w - j * b, R - z * b), f.push(L, Ce)) : (f.push(We, Le), f.push(L, Ce)) : (f.push(w - S * b, R - D * b), f.push(w + S * C, R + D * C), o.join === "round" ? oe ? g += Ri(w, R, w + S * C, R + D * C, w + j * C, R + z * C, f, !0) + 2 : g += Ri(w, R, w - S * b, R - D * b, w - j * b, R - z * b, f, !1) + 2 : o.join === "miter" && tt / v <= y && (oe ? (f.push(L, Ce), f.push(L, Ce)) : (f.push(We, Le), f.push(We, Le)), g += 2), f.push(w - j * b, R - z * b), f.push(w + j * C, R + z * C), g += 2);
        }
        x = i[(_ - 2) * 2], I = i[(_ - 2) * 2 + 1], w = i[(_ - 1) * 2], R = i[(_ - 1) * 2 + 1], S = -(I - R), D = x - w, K = Math.sqrt(S * S + D * D), S /= K, D /= K, S *= m, D *= m, f.push(w - S * b, R - D * b), f.push(w + S * C, R + D * C), u || (o.cap === "round" ? g += Ri(w - S * (b - C) * .5, R - D * (b - C) * .5, w - S * b, R - D * b, w + S * C, R + D * C, f, !1) + 2 : o.cap === "square" && (g += Jd(w, R, S, D, b, C, !1, f)));
        const A = Zd * Zd;
        for(let U = p; U < g + p - 2; ++U)x = f[U * 2], I = f[U * 2 + 1], w = f[(U + 1) * 2], R = f[(U + 1) * 2 + 1], N = f[(U + 2) * 2], E = f[(U + 2) * 2 + 1], !(Math.abs(x * (R - E) + w * (E - I) + N * (I - R)) < A) && r.push(U, U + 1, U + 2);
    }
    function VE(i, e, t, n) {
        const s = dm;
        if (i.length === 0) return;
        const r = i[0], a = i[1], o = i[i.length - 2], c = i[i.length - 1], l = e || Math.abs(r - o) < s && Math.abs(a - c) < s, h = t, u = i.length / 2, d = h.length / 2;
        for(let f = 0; f < u; f++)h.push(i[f * 2]), h.push(i[f * 2 + 1]);
        for(let f = 0; f < u - 1; f++)n.push(d + f, d + f + 1);
        l && n.push(d + u - 1, d);
    }
    function fm(i, e, t, n, s, r, a) {
        const o = VT(i, e, 2);
        if (!o) return;
        for(let l = 0; l < o.length; l += 3)r[a++] = o[l] + s, r[a++] = o[l + 1] + s, r[a++] = o[l + 2] + s;
        let c = s * n;
        for(let l = 0; l < i.length; l += 2)t[c] = i[l], t[c + 1] = i[l + 1], c += n;
    }
    const WE = [], XE = {
        extension: {
            type: se.ShapeBuilder,
            name: "polygon"
        },
        build (i, e) {
            for(let t = 0; t < i.points.length; t++)e[t] = i.points[t];
            return e;
        },
        triangulate (i, e, t, n, s, r) {
            fm(i, WE, e, t, n, s, r);
        }
    }, YE = {
        extension: {
            type: se.ShapeBuilder,
            name: "rectangle"
        },
        build (i, e) {
            const t = i, n = t.x, s = t.y, r = t.width, a = t.height;
            return r >= 0 && a >= 0 && (e[0] = n, e[1] = s, e[2] = n + r, e[3] = s, e[4] = n + r, e[5] = s + a, e[6] = n, e[7] = s + a), e;
        },
        triangulate (i, e, t, n, s, r) {
            let a = 0;
            n *= t, e[n + a] = i[0], e[n + a + 1] = i[1], a += t, e[n + a] = i[2], e[n + a + 1] = i[3], a += t, e[n + a] = i[6], e[n + a + 1] = i[7], a += t, e[n + a] = i[4], e[n + a + 1] = i[5], a += t;
            const o = n / t;
            s[r++] = o, s[r++] = o + 1, s[r++] = o + 2, s[r++] = o + 1, s[r++] = o + 3, s[r++] = o + 2;
        }
    }, qE = {
        extension: {
            type: se.ShapeBuilder,
            name: "triangle"
        },
        build (i, e) {
            return e[0] = i.x, e[1] = i.y, e[2] = i.x2, e[3] = i.y2, e[4] = i.x3, e[5] = i.y3, e;
        },
        triangulate (i, e, t, n, s, r) {
            let a = 0;
            n *= t, e[n + a] = i[0], e[n + a + 1] = i[1], a += t, e[n + a] = i[2], e[n + a + 1] = i[3], a += t, e[n + a] = i[4], e[n + a + 1] = i[5];
            const o = n / t;
            s[r++] = o, s[r++] = o + 1, s[r++] = o + 2;
        }
    }, jE = new Fe, $E = new ft;
    function KE(i, e, t, n) {
        const s = e.matrix ? i.copyFrom(e.matrix).invert() : i.identity();
        if (e.textureSpace === "local") {
            const r = t.getBounds($E);
            s.translate(-r.x, -r.y), s.scale(1 / r.width, 1 / r.height);
        } else {
            s.translate(e.texture.frame.x, e.texture.frame.y), s.scale(1 / e.texture.source.width, 1 / e.texture.source.height);
            const r = e.texture.source.style;
            r.addressMode === "clamp-to-edge" && (r.addressMode = "repeat", r.update());
        }
        return n && s.append(jE.copyFrom(n).invert()), s;
    }
    const to = {};
    Nt.handleByMap(se.ShapeBuilder, to);
    Nt.add(YE, XE, qE, Ir, kE, GE);
    const ZE = new ft, JE = new Fe;
    function QE(i, e) {
        const { geometryData: t, batches: n } = e;
        n.length = 0, t.indices.length = 0, t.vertices.length = 0, t.uvs.length = 0;
        for(let s = 0; s < i.instructions.length; s++){
            const r = i.instructions[s];
            if (r.action === "texture") eA(r.data, n, t);
            else if (r.action === "fill" || r.action === "stroke") {
                const a = r.action === "stroke", o = r.data.path.shapePath, c = r.data.style, l = r.data.hole;
                a && l && Qd(l.shapePath, c, !0, n, t), l && (o.shapePrimitives[o.shapePrimitives.length - 1].holes = l.shapePath.shapePrimitives), Qd(o, c, a, n, t);
            }
        }
    }
    function eA(i, e, t) {
        const { vertices: n, uvs: s, indices: r } = t, a = r.length, o = n.length / 2, c = [], l = to.rectangle, h = ZE, u = i.image;
        h.x = i.dx, h.y = i.dy, h.width = i.dw, h.height = i.dh;
        const d = i.transform;
        l.build(h, c), d && hm(c, d), l.triangulate(c, n, 2, o, r, a);
        const f = u.uvs;
        s.push(f.x0, f.y0, f.x1, f.y1, f.x3, f.y3, f.x2, f.y2);
        const _ = Gt.get(um);
        _.indexOffset = a, _.indexSize = r.length - a, _.attributeOffset = o, _.attributeSize = n.length / 2 - o, _.baseColor = i.style, _.alpha = i.alpha, _.texture = u, _.geometryData = t, e.push(_);
    }
    function Qd(i, e, t, n, s) {
        const { vertices: r, uvs: a, indices: o } = s;
        i.shapePrimitives.forEach(({ shape: c, transform: l, holes: h })=>{
            const u = o.length, d = r.length / 2, f = [], _ = to[c.type];
            let g = "triangle-list";
            if (_.build(c, f), l && hm(f, l), t) {
                const y = c.closePath ?? !0, x = e;
                x.pixelLine ? (VE(f, y, r, o), g = "line-list") : zE(f, x, !1, y, r, o);
            } else if (h) {
                const y = [], x = f.slice();
                tA(h).forEach((w)=>{
                    y.push(x.length / 2), x.push(...w);
                }), fm(x, y, r, 2, d, o, u);
            } else _.triangulate(f, r, 2, d, o, u);
            const p = a.length / 2, m = e.texture;
            if (m !== Oe.WHITE) {
                const y = KE(JE, e, c, l);
                BE(r, 2, d, a, p, 2, r.length / 2 - d, y);
            } else FE(a, p, 2, r.length / 2 - d);
            const v = Gt.get(um);
            v.indexOffset = u, v.indexSize = o.length - u, v.attributeOffset = d, v.attributeSize = r.length / 2 - d, v.baseColor = e.color, v.alpha = e.alpha, v.texture = m, v.geometryData = s, v.topology = g, n.push(v);
        });
    }
    function tA(i) {
        const e = [];
        for(let t = 0; t < i.length; t++){
            const n = i[t].shape, s = [];
            to[n.type].build(n, s), e.push(s);
        }
        return e;
    }
    class nA {
        constructor(){
            this.batches = [], this.geometryData = {
                vertices: [],
                uvs: [],
                indices: []
            };
        }
    }
    class iA {
        constructor(){
            this.batcher = new yh, this.instructions = new Ep;
        }
        init() {
            this.instructions.reset();
        }
        get geometry() {
            return ut(RM, "GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead."), this.batcher.geometry;
        }
    }
    const bh = class Cl {
        constructor(e){
            this._gpuContextHash = {}, this._graphicsDataContextHash = Object.create(null), e.renderableGC.addManagedHash(this, "_gpuContextHash"), e.renderableGC.addManagedHash(this, "_graphicsDataContextHash");
        }
        init(e) {
            Cl.defaultOptions.bezierSmoothness = e?.bezierSmoothness ?? Cl.defaultOptions.bezierSmoothness;
        }
        getContextRenderData(e) {
            return this._graphicsDataContextHash[e.uid] || this._initContextRenderData(e);
        }
        updateGpuContext(e) {
            let t = this._gpuContextHash[e.uid] || this._initContext(e);
            if (e.dirty) {
                t ? this._cleanGraphicsContextData(e) : t = this._initContext(e), QE(e, t);
                const n = e.batchMode;
                e.customShader || n === "no-batch" ? t.isBatchable = !1 : n === "auto" && (t.isBatchable = t.geometryData.vertices.length < 400), e.dirty = !1;
            }
            return t;
        }
        getGpuContext(e) {
            return this._gpuContextHash[e.uid] || this._initContext(e);
        }
        _initContextRenderData(e) {
            const t = Gt.get(iA), { batches: n, geometryData: s } = this._gpuContextHash[e.uid], r = s.vertices.length, a = s.indices.length;
            for(let h = 0; h < n.length; h++)n[h].applyTransform = !1;
            const o = t.batcher;
            o.ensureAttributeBuffer(r), o.ensureIndexBuffer(a), o.begin();
            for(let h = 0; h < n.length; h++){
                const u = n[h];
                o.add(u);
            }
            o.finish(t.instructions);
            const c = o.geometry;
            c.indexBuffer.setDataWithSize(o.indexBuffer, o.indexSize, !0), c.buffers[0].setDataWithSize(o.attributeBuffer.float32View, o.attributeSize, !0);
            const l = o.batches;
            for(let h = 0; h < l.length; h++){
                const u = l[h];
                u.bindGroup = iE(u.textures.textures, u.textures.count);
            }
            return this._graphicsDataContextHash[e.uid] = t, t;
        }
        _initContext(e) {
            const t = new nA;
            return t.context = e, this._gpuContextHash[e.uid] = t, e.on("destroy", this.onGraphicsContextDestroy, this), this._gpuContextHash[e.uid];
        }
        onGraphicsContextDestroy(e) {
            this._cleanGraphicsContextData(e), e.off("destroy", this.onGraphicsContextDestroy, this), this._gpuContextHash[e.uid] = null;
        }
        _cleanGraphicsContextData(e) {
            const t = this._gpuContextHash[e.uid];
            t.isBatchable || this._graphicsDataContextHash[e.uid] && (Gt.return(this.getContextRenderData(e)), this._graphicsDataContextHash[e.uid] = null), t.batches && t.batches.forEach((n)=>{
                Gt.return(n);
            });
        }
        destroy() {
            for(const e in this._gpuContextHash)this._gpuContextHash[e] && this.onGraphicsContextDestroy(this._gpuContextHash[e].context);
        }
    };
    bh.extension = {
        type: [
            se.WebGLSystem,
            se.WebGPUSystem,
            se.CanvasSystem
        ],
        name: "graphicsContext"
    };
    bh.defaultOptions = {
        bezierSmoothness: .5
    };
    pm = bh;
    const sA = 8, ba = 11920929e-14, rA = 1;
    function mm(i, e, t, n, s, r, a, o, c, l) {
        const u = Math.min(.99, Math.max(0, l ?? pm.defaultOptions.bezierSmoothness));
        let d = (rA - u) / 1;
        return d *= d, aA(e, t, n, s, r, a, o, c, i, d), i;
    }
    function aA(i, e, t, n, s, r, a, o, c, l) {
        Pl(i, e, t, n, s, r, a, o, c, l, 0), c.push(a, o);
    }
    function Pl(i, e, t, n, s, r, a, o, c, l, h) {
        if (h > sA) return;
        const u = (i + t) / 2, d = (e + n) / 2, f = (t + s) / 2, _ = (n + r) / 2, g = (s + a) / 2, p = (r + o) / 2, m = (u + f) / 2, v = (d + _) / 2, y = (f + g) / 2, x = (_ + p) / 2, I = (m + y) / 2, w = (v + x) / 2;
        if (h > 0) {
            let R = a - i, N = o - e;
            const E = Math.abs((t - a) * N - (n - o) * R), S = Math.abs((s - a) * N - (r - o) * R);
            if (E > ba && S > ba) {
                if ((E + S) * (E + S) <= l * (R * R + N * N)) {
                    c.push(I, w);
                    return;
                }
            } else if (E > ba) {
                if (E * E <= l * (R * R + N * N)) {
                    c.push(I, w);
                    return;
                }
            } else if (S > ba) {
                if (S * S <= l * (R * R + N * N)) {
                    c.push(I, w);
                    return;
                }
            } else if (R = I - (i + a) / 2, N = w - (e + o) / 2, R * R + N * N <= l) {
                c.push(I, w);
                return;
            }
        }
        Pl(i, e, u, d, m, v, I, w, c, l, h + 1), Pl(I, w, y, x, g, p, a, o, c, l, h + 1);
    }
    const oA = 8, cA = 11920929e-14, lA = 1;
    function hA(i, e, t, n, s, r, a, o) {
        const l = Math.min(.99, Math.max(0, o ?? pm.defaultOptions.bezierSmoothness));
        let h = (lA - l) / 1;
        return h *= h, uA(e, t, n, s, r, a, i, h), i;
    }
    function uA(i, e, t, n, s, r, a, o) {
        Il(a, i, e, t, n, s, r, o, 0), a.push(s, r);
    }
    function Il(i, e, t, n, s, r, a, o, c) {
        if (c > oA) return;
        const l = (e + n) / 2, h = (t + s) / 2, u = (n + r) / 2, d = (s + a) / 2, f = (l + u) / 2, _ = (h + d) / 2;
        let g = r - e, p = a - t;
        const m = Math.abs((n - r) * p - (s - a) * g);
        if (m > cA) {
            if (m * m <= o * (g * g + p * p)) {
                i.push(f, _);
                return;
            }
        } else if (g = f - (e + r) / 2, p = _ - (t + a) / 2, g * g + p * p <= o) {
            i.push(f, _);
            return;
        }
        Il(i, e, t, l, h, f, _, o, c + 1), Il(i, f, _, u, d, r, a, o, c + 1);
    }
    function _m(i, e, t, n, s, r, a, o) {
        let c = Math.abs(s - r);
        (!a && s > r || a && r > s) && (c = 2 * Math.PI - c), o || (o = Math.max(6, Math.floor(6 * Math.pow(n, 1 / 3) * (c / Math.PI)))), o = Math.max(o, 3);
        let l = c / o, h = s;
        l *= a ? -1 : 1;
        for(let u = 0; u < o + 1; u++){
            const d = Math.cos(h), f = Math.sin(h), _ = e + d * n, g = t + f * n;
            i.push(_, g), h += l;
        }
    }
    function dA(i, e, t, n, s, r) {
        const a = i[i.length - 2], c = i[i.length - 1] - t, l = a - e, h = s - t, u = n - e, d = Math.abs(c * u - l * h);
        if (d < 1e-8 || r === 0) {
            (i[i.length - 2] !== e || i[i.length - 1] !== t) && i.push(e, t);
            return;
        }
        const f = c * c + l * l, _ = h * h + u * u, g = c * h + l * u, p = r * Math.sqrt(f) / d, m = r * Math.sqrt(_) / d, v = p * g / f, y = m * g / _, x = p * u + m * l, I = p * h + m * c, w = l * (m + v), R = c * (m + v), N = u * (p + y), E = h * (p + y), S = Math.atan2(R - I, w - x), D = Math.atan2(E - I, N - x);
        _m(i, x + e, I + t, r, S, D, l * h > u * c);
    }
    const vr = Math.PI * 2, mc = {
        centerX: 0,
        centerY: 0,
        ang1: 0,
        ang2: 0
    }, _c = ({ x: i, y: e }, t, n, s, r, a, o, c)=>{
        i *= t, e *= n;
        const l = s * i - r * e, h = r * i + s * e;
        return c.x = l + a, c.y = h + o, c;
    };
    function fA(i, e) {
        const t = e === -1.5707963267948966 ? -.551915024494 : 1.3333333333333333 * Math.tan(e / 4), n = e === 1.5707963267948966 ? .551915024494 : t, s = Math.cos(i), r = Math.sin(i), a = Math.cos(i + e), o = Math.sin(i + e);
        return [
            {
                x: s - r * n,
                y: r + s * n
            },
            {
                x: a + o * n,
                y: o - a * n
            },
            {
                x: a,
                y: o
            }
        ];
    }
    const ef = (i, e, t, n)=>{
        const s = i * n - e * t < 0 ? -1 : 1;
        let r = i * t + e * n;
        return r > 1 && (r = 1), r < -1 && (r = -1), s * Math.acos(r);
    }, pA = (i, e, t, n, s, r, a, o, c, l, h, u, d)=>{
        const f = Math.pow(s, 2), _ = Math.pow(r, 2), g = Math.pow(h, 2), p = Math.pow(u, 2);
        let m = f * _ - f * p - _ * g;
        m < 0 && (m = 0), m /= f * p + _ * g, m = Math.sqrt(m) * (a === o ? -1 : 1);
        const v = m * s / r * u, y = m * -r / s * h, x = l * v - c * y + (i + t) / 2, I = c * v + l * y + (e + n) / 2, w = (h - v) / s, R = (u - y) / r, N = (-h - v) / s, E = (-u - y) / r, S = ef(1, 0, w, R);
        let D = ef(w, R, N, E);
        o === 0 && D > 0 && (D -= vr), o === 1 && D < 0 && (D += vr), d.centerX = x, d.centerY = I, d.ang1 = S, d.ang2 = D;
    };
    function mA(i, e, t, n, s, r, a, o = 0, c = 0, l = 0) {
        if (r === 0 || a === 0) return;
        const h = Math.sin(o * vr / 360), u = Math.cos(o * vr / 360), d = u * (e - n) / 2 + h * (t - s) / 2, f = -h * (e - n) / 2 + u * (t - s) / 2;
        if (d === 0 && f === 0) return;
        r = Math.abs(r), a = Math.abs(a);
        const _ = Math.pow(d, 2) / Math.pow(r, 2) + Math.pow(f, 2) / Math.pow(a, 2);
        _ > 1 && (r *= Math.sqrt(_), a *= Math.sqrt(_)), pA(e, t, n, s, r, a, c, l, h, u, d, f, mc);
        let { ang1: g, ang2: p } = mc;
        const { centerX: m, centerY: v } = mc;
        let y = Math.abs(p) / (vr / 4);
        Math.abs(1 - y) < 1e-7 && (y = 1);
        const x = Math.max(Math.ceil(y), 1);
        p /= x;
        let I = i[i.length - 2], w = i[i.length - 1];
        const R = {
            x: 0,
            y: 0
        };
        for(let N = 0; N < x; N++){
            const E = fA(g, p), { x: S, y: D } = _c(E[0], r, a, u, h, m, v, R), { x: j, y: z } = _c(E[1], r, a, u, h, m, v, R), { x: K, y: ne } = _c(E[2], r, a, u, h, m, v, R);
            mm(i, I, w, S, D, j, z, K, ne), I = K, w = ne, g += p;
        }
    }
    function _A(i, e, t) {
        const n = (a, o)=>{
            const c = o.x - a.x, l = o.y - a.y, h = Math.sqrt(c * c + l * l), u = c / h, d = l / h;
            return {
                len: h,
                nx: u,
                ny: d
            };
        }, s = (a, o)=>{
            a === 0 ? i.moveTo(o.x, o.y) : i.lineTo(o.x, o.y);
        };
        let r = e[e.length - 1];
        for(let a = 0; a < e.length; a++){
            const o = e[a % e.length], c = o.radius ?? t;
            if (c <= 0) {
                s(a, o), r = o;
                continue;
            }
            const l = e[(a + 1) % e.length], h = n(o, r), u = n(o, l);
            if (h.len < 1e-4 || u.len < 1e-4) {
                s(a, o), r = o;
                continue;
            }
            let d = Math.asin(h.nx * u.ny - h.ny * u.nx), f = 1, _ = !1;
            h.nx * u.nx - h.ny * -u.ny < 0 ? d < 0 ? d = Math.PI + d : (d = Math.PI - d, f = -1, _ = !0) : d > 0 && (f = -1, _ = !0);
            const g = d / 2;
            let p, m = Math.abs(Math.cos(g) * c / Math.sin(g));
            m > Math.min(h.len / 2, u.len / 2) ? (m = Math.min(h.len / 2, u.len / 2), p = Math.abs(m * Math.sin(g) / Math.cos(g))) : p = c;
            const v = o.x + u.nx * m + -u.ny * p * f, y = o.y + u.ny * m + u.nx * p * f, x = Math.atan2(h.ny, h.nx) + Math.PI / 2 * f, I = Math.atan2(u.ny, u.nx) - Math.PI / 2 * f;
            a === 0 && i.moveTo(v + Math.cos(x) * p, y + Math.sin(x) * p), i.arc(v, y, p, x, I, _), r = o;
        }
    }
    function gA(i, e, t, n) {
        const s = (o, c)=>Math.sqrt((o.x - c.x) ** 2 + (o.y - c.y) ** 2), r = (o, c, l)=>({
                x: o.x + (c.x - o.x) * l,
                y: o.y + (c.y - o.y) * l
            }), a = e.length;
        for(let o = 0; o < a; o++){
            const c = e[(o + 1) % a], l = c.radius ?? t;
            if (l <= 0) {
                o === 0 ? i.moveTo(c.x, c.y) : i.lineTo(c.x, c.y);
                continue;
            }
            const h = e[o], u = e[(o + 2) % a], d = s(h, c);
            let f;
            if (d < 1e-4) f = c;
            else {
                const p = Math.min(d / 2, l);
                f = r(c, h, p / d);
            }
            const _ = s(u, c);
            let g;
            if (_ < 1e-4) g = c;
            else {
                const p = Math.min(_ / 2, l);
                g = r(c, u, p / _);
            }
            o === 0 ? i.moveTo(f.x, f.y) : i.lineTo(f.x, f.y), i.quadraticCurveTo(c.x, c.y, g.x, g.y, n);
        }
    }
    const xA = new ft;
    class vA {
        constructor(e){
            this.shapePrimitives = [], this._currentPoly = null, this._bounds = new en, this._graphicsPath2D = e, this.signed = e.checkForHoles;
        }
        moveTo(e, t) {
            return this.startPoly(e, t), this;
        }
        lineTo(e, t) {
            this._ensurePoly();
            const n = this._currentPoly.points, s = n[n.length - 2], r = n[n.length - 1];
            return (s !== e || r !== t) && n.push(e, t), this;
        }
        arc(e, t, n, s, r, a) {
            this._ensurePoly(!1);
            const o = this._currentPoly.points;
            return _m(o, e, t, n, s, r, a), this;
        }
        arcTo(e, t, n, s, r) {
            this._ensurePoly();
            const a = this._currentPoly.points;
            return dA(a, e, t, n, s, r), this;
        }
        arcToSvg(e, t, n, s, r, a, o) {
            const c = this._currentPoly.points;
            return mA(c, this._currentPoly.lastX, this._currentPoly.lastY, a, o, e, t, n, s, r), this;
        }
        bezierCurveTo(e, t, n, s, r, a, o) {
            this._ensurePoly();
            const c = this._currentPoly;
            return mm(this._currentPoly.points, c.lastX, c.lastY, e, t, n, s, r, a, o), this;
        }
        quadraticCurveTo(e, t, n, s, r) {
            this._ensurePoly();
            const a = this._currentPoly;
            return hA(this._currentPoly.points, a.lastX, a.lastY, e, t, n, s, r), this;
        }
        closePath() {
            return this.endPoly(!0), this;
        }
        addPath(e, t) {
            this.endPoly(), t && !t.isIdentity() && (e = e.clone(!0), e.transform(t));
            const n = this.shapePrimitives, s = n.length;
            for(let r = 0; r < e.instructions.length; r++){
                const a = e.instructions[r];
                this[a.action](...a.data);
            }
            if (e.checkForHoles && n.length - s > 1) {
                let r = null;
                for(let a = s; a < n.length; a++){
                    const o = n[a];
                    if (o.shape.type === "polygon") {
                        const c = o.shape, l = r?.shape;
                        l && l.containsPolygon(c) ? (r.holes || (r.holes = []), r.holes.push(o), n.copyWithin(a, a + 1), n.length--, a--) : r = o;
                    }
                }
            }
            return this;
        }
        finish(e = !1) {
            this.endPoly(e);
        }
        rect(e, t, n, s, r) {
            return this.drawShape(new ft(e, t, n, s), r), this;
        }
        circle(e, t, n, s) {
            return this.drawShape(new mh(e, t, n), s), this;
        }
        poly(e, t, n) {
            const s = new xr(e);
            return s.closePath = t, this.drawShape(s, n), this;
        }
        regularPoly(e, t, n, s, r = 0, a) {
            s = Math.max(s | 0, 3);
            const o = -1 * Math.PI / 2 + r, c = Math.PI * 2 / s, l = [];
            for(let h = 0; h < s; h++){
                const u = o - h * c;
                l.push(e + n * Math.cos(u), t + n * Math.sin(u));
            }
            return this.poly(l, !0, a), this;
        }
        roundPoly(e, t, n, s, r, a = 0, o) {
            if (s = Math.max(s | 0, 3), r <= 0) return this.regularPoly(e, t, n, s, a);
            const c = n * Math.sin(Math.PI / s) - .001;
            r = Math.min(r, c);
            const l = -1 * Math.PI / 2 + a, h = Math.PI * 2 / s, u = (s - 2) * Math.PI / s / 2;
            for(let d = 0; d < s; d++){
                const f = d * h + l, _ = e + n * Math.cos(f), g = t + n * Math.sin(f), p = f + Math.PI + u, m = f - Math.PI - u, v = _ + r * Math.cos(p), y = g + r * Math.sin(p), x = _ + r * Math.cos(m), I = g + r * Math.sin(m);
                d === 0 ? this.moveTo(v, y) : this.lineTo(v, y), this.quadraticCurveTo(_, g, x, I, o);
            }
            return this.closePath();
        }
        roundShape(e, t, n = !1, s) {
            return e.length < 3 ? this : (n ? gA(this, e, t, s) : _A(this, e, t), this.closePath());
        }
        filletRect(e, t, n, s, r) {
            if (r === 0) return this.rect(e, t, n, s);
            const a = Math.min(n, s) / 2, o = Math.min(a, Math.max(-a, r)), c = e + n, l = t + s, h = o < 0 ? -o : 0, u = Math.abs(o);
            return this.moveTo(e, t + u).arcTo(e + h, t + h, e + u, t, u).lineTo(c - u, t).arcTo(c - h, t + h, c, t + u, u).lineTo(c, l - u).arcTo(c - h, l - h, e + n - u, l, u).lineTo(e + u, l).arcTo(e + h, l - h, e, l - u, u).closePath();
        }
        chamferRect(e, t, n, s, r, a) {
            if (r <= 0) return this.rect(e, t, n, s);
            const o = Math.min(r, Math.min(n, s) / 2), c = e + n, l = t + s, h = [
                e + o,
                t,
                c - o,
                t,
                c,
                t + o,
                c,
                l - o,
                c - o,
                l,
                e + o,
                l,
                e,
                l - o,
                e,
                t + o
            ];
            for(let u = h.length - 1; u >= 2; u -= 2)h[u] === h[u - 2] && h[u - 1] === h[u - 3] && h.splice(u - 1, 2);
            return this.poly(h, !0, a);
        }
        ellipse(e, t, n, s, r) {
            return this.drawShape(new _h(e, t, n, s), r), this;
        }
        roundRect(e, t, n, s, r, a) {
            return this.drawShape(new gh(e, t, n, s, r), a), this;
        }
        drawShape(e, t) {
            return this.endPoly(), this.shapePrimitives.push({
                shape: e,
                transform: t
            }), this;
        }
        startPoly(e, t) {
            let n = this._currentPoly;
            return n && this.endPoly(), n = new xr, n.points.push(e, t), this._currentPoly = n, this;
        }
        endPoly(e = !1) {
            const t = this._currentPoly;
            return t && t.points.length > 2 && (t.closePath = e, this.shapePrimitives.push({
                shape: t
            })), this._currentPoly = null, this;
        }
        _ensurePoly(e = !0) {
            if (!this._currentPoly && (this._currentPoly = new xr, e)) {
                const t = this.shapePrimitives[this.shapePrimitives.length - 1];
                if (t) {
                    let n = t.shape.x, s = t.shape.y;
                    if (t.transform && !t.transform.isIdentity()) {
                        const r = t.transform, a = n;
                        n = r.a * n + r.c * s + r.tx, s = r.b * a + r.d * s + r.ty;
                    }
                    this._currentPoly.points.push(n, s);
                } else this._currentPoly.points.push(0, 0);
            }
        }
        buildPath() {
            const e = this._graphicsPath2D;
            this.shapePrimitives.length = 0, this._currentPoly = null;
            for(let t = 0; t < e.instructions.length; t++){
                const n = e.instructions[t];
                this[n.action](...n.data);
            }
            this.finish();
        }
        get bounds() {
            const e = this._bounds;
            e.clear();
            const t = this.shapePrimitives;
            for(let n = 0; n < t.length; n++){
                const s = t[n], r = s.shape.getBounds(xA);
                s.transform ? e.addRect(r, s.transform) : e.addRect(r);
            }
            return e;
        }
    }
    class Os {
        constructor(e, t = !1){
            this.instructions = [], this.uid = pt("graphicsPath"), this._dirty = !0, this.checkForHoles = t, typeof e == "string" ? KT(e, this) : this.instructions = e?.slice() ?? [];
        }
        get shapePath() {
            return this._shapePath || (this._shapePath = new vA(this)), this._dirty && (this._dirty = !1, this._shapePath.buildPath()), this._shapePath;
        }
        addPath(e, t) {
            return e = e.clone(), this.instructions.push({
                action: "addPath",
                data: [
                    e,
                    t
                ]
            }), this._dirty = !0, this;
        }
        arc(...e) {
            return this.instructions.push({
                action: "arc",
                data: e
            }), this._dirty = !0, this;
        }
        arcTo(...e) {
            return this.instructions.push({
                action: "arcTo",
                data: e
            }), this._dirty = !0, this;
        }
        arcToSvg(...e) {
            return this.instructions.push({
                action: "arcToSvg",
                data: e
            }), this._dirty = !0, this;
        }
        bezierCurveTo(...e) {
            return this.instructions.push({
                action: "bezierCurveTo",
                data: e
            }), this._dirty = !0, this;
        }
        bezierCurveToShort(e, t, n, s, r) {
            const a = this.instructions[this.instructions.length - 1], o = this.getLastPoint(Lt.shared);
            let c = 0, l = 0;
            if (!a || a.action !== "bezierCurveTo") c = o.x, l = o.y;
            else {
                c = a.data[2], l = a.data[3];
                const h = o.x, u = o.y;
                c = h + (h - c), l = u + (u - l);
            }
            return this.instructions.push({
                action: "bezierCurveTo",
                data: [
                    c,
                    l,
                    e,
                    t,
                    n,
                    s,
                    r
                ]
            }), this._dirty = !0, this;
        }
        closePath() {
            return this.instructions.push({
                action: "closePath",
                data: []
            }), this._dirty = !0, this;
        }
        ellipse(...e) {
            return this.instructions.push({
                action: "ellipse",
                data: e
            }), this._dirty = !0, this;
        }
        lineTo(...e) {
            return this.instructions.push({
                action: "lineTo",
                data: e
            }), this._dirty = !0, this;
        }
        moveTo(...e) {
            return this.instructions.push({
                action: "moveTo",
                data: e
            }), this;
        }
        quadraticCurveTo(...e) {
            return this.instructions.push({
                action: "quadraticCurveTo",
                data: e
            }), this._dirty = !0, this;
        }
        quadraticCurveToShort(e, t, n) {
            const s = this.instructions[this.instructions.length - 1], r = this.getLastPoint(Lt.shared);
            let a = 0, o = 0;
            if (!s || s.action !== "quadraticCurveTo") a = r.x, o = r.y;
            else {
                a = s.data[0], o = s.data[1];
                const c = r.x, l = r.y;
                a = c + (c - a), o = l + (l - o);
            }
            return this.instructions.push({
                action: "quadraticCurveTo",
                data: [
                    a,
                    o,
                    e,
                    t,
                    n
                ]
            }), this._dirty = !0, this;
        }
        rect(e, t, n, s, r) {
            return this.instructions.push({
                action: "rect",
                data: [
                    e,
                    t,
                    n,
                    s,
                    r
                ]
            }), this._dirty = !0, this;
        }
        circle(e, t, n, s) {
            return this.instructions.push({
                action: "circle",
                data: [
                    e,
                    t,
                    n,
                    s
                ]
            }), this._dirty = !0, this;
        }
        roundRect(...e) {
            return this.instructions.push({
                action: "roundRect",
                data: e
            }), this._dirty = !0, this;
        }
        poly(...e) {
            return this.instructions.push({
                action: "poly",
                data: e
            }), this._dirty = !0, this;
        }
        regularPoly(...e) {
            return this.instructions.push({
                action: "regularPoly",
                data: e
            }), this._dirty = !0, this;
        }
        roundPoly(...e) {
            return this.instructions.push({
                action: "roundPoly",
                data: e
            }), this._dirty = !0, this;
        }
        roundShape(...e) {
            return this.instructions.push({
                action: "roundShape",
                data: e
            }), this._dirty = !0, this;
        }
        filletRect(...e) {
            return this.instructions.push({
                action: "filletRect",
                data: e
            }), this._dirty = !0, this;
        }
        chamferRect(...e) {
            return this.instructions.push({
                action: "chamferRect",
                data: e
            }), this._dirty = !0, this;
        }
        star(e, t, n, s, r, a, o) {
            r || (r = s / 2);
            const c = -1 * Math.PI / 2 + a, l = n * 2, h = Math.PI * 2 / l, u = [];
            for(let d = 0; d < l; d++){
                const f = d % 2 ? r : s, _ = d * h + c;
                u.push(e + f * Math.cos(_), t + f * Math.sin(_));
            }
            return this.poly(u, !0, o), this;
        }
        clone(e = !1) {
            const t = new Os;
            if (t.checkForHoles = this.checkForHoles, !e) t.instructions = this.instructions.slice();
            else for(let n = 0; n < this.instructions.length; n++){
                const s = this.instructions[n];
                t.instructions.push({
                    action: s.action,
                    data: s.data.slice()
                });
            }
            return t;
        }
        clear() {
            return this.instructions.length = 0, this._dirty = !0, this;
        }
        transform(e) {
            if (e.isIdentity()) return this;
            const t = e.a, n = e.b, s = e.c, r = e.d, a = e.tx, o = e.ty;
            let c = 0, l = 0, h = 0, u = 0, d = 0, f = 0, _ = 0, g = 0;
            for(let p = 0; p < this.instructions.length; p++){
                const m = this.instructions[p], v = m.data;
                switch(m.action){
                    case "moveTo":
                    case "lineTo":
                        c = v[0], l = v[1], v[0] = t * c + s * l + a, v[1] = n * c + r * l + o;
                        break;
                    case "bezierCurveTo":
                        h = v[0], u = v[1], d = v[2], f = v[3], c = v[4], l = v[5], v[0] = t * h + s * u + a, v[1] = n * h + r * u + o, v[2] = t * d + s * f + a, v[3] = n * d + r * f + o, v[4] = t * c + s * l + a, v[5] = n * c + r * l + o;
                        break;
                    case "quadraticCurveTo":
                        h = v[0], u = v[1], c = v[2], l = v[3], v[0] = t * h + s * u + a, v[1] = n * h + r * u + o, v[2] = t * c + s * l + a, v[3] = n * c + r * l + o;
                        break;
                    case "arcToSvg":
                        c = v[5], l = v[6], _ = v[0], g = v[1], v[0] = t * _ + s * g, v[1] = n * _ + r * g, v[5] = t * c + s * l + a, v[6] = n * c + r * l + o;
                        break;
                    case "circle":
                        v[4] = sr(v[3], e);
                        break;
                    case "rect":
                        v[4] = sr(v[4], e);
                        break;
                    case "ellipse":
                        v[8] = sr(v[8], e);
                        break;
                    case "roundRect":
                        v[5] = sr(v[5], e);
                        break;
                    case "addPath":
                        v[0].transform(e);
                        break;
                    case "poly":
                        v[2] = sr(v[2], e);
                        break;
                    default:
                        _t("unknown transform action", m.action);
                        break;
                }
            }
            return this._dirty = !0, this;
        }
        get bounds() {
            return this.shapePath.bounds;
        }
        getLastPoint(e) {
            let t = this.instructions.length - 1, n = this.instructions[t];
            if (!n) return e.x = 0, e.y = 0, e;
            for(; n.action === "closePath";){
                if (t--, t < 0) return e.x = 0, e.y = 0, e;
                n = this.instructions[t];
            }
            switch(n.action){
                case "moveTo":
                case "lineTo":
                    e.x = n.data[0], e.y = n.data[1];
                    break;
                case "quadraticCurveTo":
                    e.x = n.data[2], e.y = n.data[3];
                    break;
                case "bezierCurveTo":
                    e.x = n.data[4], e.y = n.data[5];
                    break;
                case "arc":
                case "arcToSvg":
                    e.x = n.data[5], e.y = n.data[6];
                    break;
                case "addPath":
                    n.data[0].getLastPoint(e);
                    break;
            }
            return e;
        }
    }
    function sr(i, e) {
        return i ? i.prepend(e) : e.clone();
    }
    function yt(i, e, t) {
        const n = i.getAttribute(e);
        return n ? Number(n) : t;
    }
    function yA(i, e) {
        const t = i.querySelectorAll("defs");
        for(let n = 0; n < t.length; n++){
            const s = t[n];
            for(let r = 0; r < s.children.length; r++){
                const a = s.children[r];
                switch(a.nodeName.toLowerCase()){
                    case "lineargradient":
                        e.defs[a.id] = bA(a);
                        break;
                    case "radialgradient":
                        e.defs[a.id] = SA();
                        break;
                }
            }
        }
    }
    function bA(i) {
        const e = yt(i, "x1", 0), t = yt(i, "y1", 0), n = yt(i, "x2", 1), s = yt(i, "y2", 0), r = i.getAttribute("gradientUnits") || "objectBoundingBox", a = new Yi(e, t, n, s, r === "objectBoundingBox" ? "local" : "global");
        for(let o = 0; o < i.children.length; o++){
            const c = i.children[o], l = yt(c, "offset", 0), h = Pt.shared.setValue(c.getAttribute("stop-color")).toNumber();
            a.addColorStop(l, h);
        }
        return a;
    }
    function SA(i) {
        return _t("[SVG Parser] Radial gradients are not yet supported"), new Yi(0, 0, 1, 0);
    }
    function tf(i) {
        const e = i.match(/url\s*\(\s*['"]?\s*#([^'"\s)]+)\s*['"]?\s*\)/i);
        return e ? e[1] : "";
    }
    const nf = {
        fill: {
            type: "paint",
            default: 0
        },
        "fill-opacity": {
            type: "number",
            default: 1
        },
        stroke: {
            type: "paint",
            default: 0
        },
        "stroke-width": {
            type: "number",
            default: 1
        },
        "stroke-opacity": {
            type: "number",
            default: 1
        },
        "stroke-linecap": {
            type: "string",
            default: "butt"
        },
        "stroke-linejoin": {
            type: "string",
            default: "miter"
        },
        "stroke-miterlimit": {
            type: "number",
            default: 10
        },
        "stroke-dasharray": {
            type: "string",
            default: "none"
        },
        "stroke-dashoffset": {
            type: "number",
            default: 0
        },
        opacity: {
            type: "number",
            default: 1
        }
    };
    function gm(i, e) {
        const t = i.getAttribute("style"), n = {}, s = {}, r = {
            strokeStyle: n,
            fillStyle: s,
            useFill: !1,
            useStroke: !1
        };
        for(const a in nf){
            const o = i.getAttribute(a);
            o && sf(e, r, a, o.trim());
        }
        if (t) {
            const a = t.split(";");
            for(let o = 0; o < a.length; o++){
                const c = a[o].trim(), [l, h] = c.split(":");
                nf[l] && sf(e, r, l, h.trim());
            }
        }
        return {
            strokeStyle: r.useStroke ? n : null,
            fillStyle: r.useFill ? s : null,
            useFill: r.useFill,
            useStroke: r.useStroke
        };
    }
    function sf(i, e, t, n) {
        switch(t){
            case "stroke":
                if (n !== "none") {
                    if (n.startsWith("url(")) {
                        const s = tf(n);
                        e.strokeStyle.fill = i.defs[s];
                    } else e.strokeStyle.color = Pt.shared.setValue(n).toNumber();
                    e.useStroke = !0;
                }
                break;
            case "stroke-width":
                e.strokeStyle.width = Number(n);
                break;
            case "fill":
                if (n !== "none") {
                    if (n.startsWith("url(")) {
                        const s = tf(n);
                        e.fillStyle.fill = i.defs[s];
                    } else e.fillStyle.color = Pt.shared.setValue(n).toNumber();
                    e.useFill = !0;
                }
                break;
            case "fill-opacity":
                e.fillStyle.alpha = Number(n);
                break;
            case "stroke-opacity":
                e.strokeStyle.alpha = Number(n);
                break;
            case "opacity":
                e.fillStyle.alpha = Number(n), e.strokeStyle.alpha = Number(n);
                break;
        }
    }
    function MA(i, e) {
        if (typeof i == "string") {
            const a = document.createElement("div");
            a.innerHTML = i.trim(), i = a.querySelector("svg");
        }
        const t = {
            context: e,
            defs: {},
            path: new Os
        };
        yA(i, t);
        const n = i.children, { fillStyle: s, strokeStyle: r } = gm(i, t);
        for(let a = 0; a < n.length; a++){
            const o = n[a];
            o.nodeName.toLowerCase() !== "defs" && xm(o, t, s, r);
        }
        return e;
    }
    function xm(i, e, t, n) {
        const s = i.children, { fillStyle: r, strokeStyle: a } = gm(i, e);
        r && t ? t = {
            ...t,
            ...r
        } : r && (t = r), a && n ? n = {
            ...n,
            ...a
        } : a && (n = a);
        const o = !t && !n;
        o && (t = {
            color: 0
        });
        let c, l, h, u, d, f, _, g, p, m, v, y, x, I, w, R, N;
        switch(i.nodeName.toLowerCase()){
            case "path":
                I = i.getAttribute("d"), i.getAttribute("fill-rule") === "evenodd" && _t("SVG Evenodd fill rule not supported, your svg may render incorrectly"), w = new Os(I, !0), e.context.path(w), t && e.context.fill(t), n && e.context.stroke(n);
                break;
            case "circle":
                _ = yt(i, "cx", 0), g = yt(i, "cy", 0), p = yt(i, "r", 0), e.context.ellipse(_, g, p, p), t && e.context.fill(t), n && e.context.stroke(n);
                break;
            case "rect":
                c = yt(i, "x", 0), l = yt(i, "y", 0), R = yt(i, "width", 0), N = yt(i, "height", 0), m = yt(i, "rx", 0), v = yt(i, "ry", 0), m || v ? e.context.roundRect(c, l, R, N, m || v) : e.context.rect(c, l, R, N), t && e.context.fill(t), n && e.context.stroke(n);
                break;
            case "ellipse":
                _ = yt(i, "cx", 0), g = yt(i, "cy", 0), m = yt(i, "rx", 0), v = yt(i, "ry", 0), e.context.beginPath(), e.context.ellipse(_, g, m, v), t && e.context.fill(t), n && e.context.stroke(n);
                break;
            case "line":
                h = yt(i, "x1", 0), u = yt(i, "y1", 0), d = yt(i, "x2", 0), f = yt(i, "y2", 0), e.context.beginPath(), e.context.moveTo(h, u), e.context.lineTo(d, f), n && e.context.stroke(n);
                break;
            case "polygon":
                x = i.getAttribute("points"), y = x.match(/\d+/g).map((E)=>parseInt(E, 10)), e.context.poly(y, !0), t && e.context.fill(t), n && e.context.stroke(n);
                break;
            case "polyline":
                x = i.getAttribute("points"), y = x.match(/\d+/g).map((E)=>parseInt(E, 10)), e.context.poly(y, !1), n && e.context.stroke(n);
                break;
            case "g":
            case "svg":
                break;
            default:
                {
                    _t(`[SVG parser] <${i.nodeName}> elements unsupported`);
                    break;
                }
        }
        o && (t = null);
        for(let E = 0; E < s.length; E++)xm(s[E], e, t, n);
    }
    function TA(i) {
        return Pt.isColorLike(i);
    }
    function rf(i) {
        return i instanceof ph;
    }
    function af(i) {
        return i instanceof Yi;
    }
    function EA(i) {
        return i instanceof Oe;
    }
    function AA(i, e, t) {
        const n = Pt.shared.setValue(e ?? 0);
        return i.color = n.toNumber(), i.alpha = n.alpha === 1 ? t.alpha : n.alpha, i.texture = Oe.WHITE, {
            ...t,
            ...i
        };
    }
    function wA(i, e, t) {
        return i.texture = e, {
            ...t,
            ...i
        };
    }
    function of(i, e, t) {
        return i.fill = e, i.color = 16777215, i.texture = e.texture, i.matrix = e.transform, {
            ...t,
            ...i
        };
    }
    function cf(i, e, t) {
        return e.buildGradient(), i.fill = e, i.color = 16777215, i.texture = e.texture, i.matrix = e.transform, i.textureSpace = e.textureSpace, {
            ...t,
            ...i
        };
    }
    function RA(i, e) {
        const t = {
            ...e,
            ...i
        }, n = Pt.shared.setValue(t.color);
        return t.alpha *= n.alpha, t.color = n.toNumber(), t;
    }
    function ki(i, e) {
        if (i == null) return null;
        const t = {}, n = i;
        return TA(i) ? AA(t, i, e) : EA(i) ? wA(t, i, e) : rf(i) ? of(t, i, e) : af(i) ? cf(t, i, e) : n.fill && rf(n.fill) ? of(n, n.fill, e) : n.fill && af(n.fill) ? cf(n, n.fill, e) : RA(n, e);
    }
    function qa(i, e) {
        const { width: t, alignment: n, miterLimit: s, cap: r, join: a, pixelLine: o, ...c } = e, l = ki(i, c);
        return l ? {
            width: t,
            alignment: n,
            miterLimit: s,
            cap: r,
            join: a,
            pixelLine: o,
            ...l
        } : null;
    }
    const CA = new Lt, lf = new Fe, Sh = class Dn extends Cn {
        constructor(){
            super(...arguments), this.uid = pt("graphicsContext"), this.dirty = !0, this.batchMode = "auto", this.instructions = [], this._activePath = new Os, this._transform = new Fe, this._fillStyle = {
                ...Dn.defaultFillStyle
            }, this._strokeStyle = {
                ...Dn.defaultStrokeStyle
            }, this._stateStack = [], this._tick = 0, this._bounds = new en, this._boundsDirty = !0;
        }
        clone() {
            const e = new Dn;
            return e.batchMode = this.batchMode, e.instructions = this.instructions.slice(), e._activePath = this._activePath.clone(), e._transform = this._transform.clone(), e._fillStyle = {
                ...this._fillStyle
            }, e._strokeStyle = {
                ...this._strokeStyle
            }, e._stateStack = this._stateStack.slice(), e._bounds = this._bounds.clone(), e._boundsDirty = !0, e;
        }
        get fillStyle() {
            return this._fillStyle;
        }
        set fillStyle(e) {
            this._fillStyle = ki(e, Dn.defaultFillStyle);
        }
        get strokeStyle() {
            return this._strokeStyle;
        }
        set strokeStyle(e) {
            this._strokeStyle = qa(e, Dn.defaultStrokeStyle);
        }
        setFillStyle(e) {
            return this._fillStyle = ki(e, Dn.defaultFillStyle), this;
        }
        setStrokeStyle(e) {
            return this._strokeStyle = ki(e, Dn.defaultStrokeStyle), this;
        }
        texture(e, t, n, s, r, a) {
            return this.instructions.push({
                action: "texture",
                data: {
                    image: e,
                    dx: n || 0,
                    dy: s || 0,
                    dw: r || e.frame.width,
                    dh: a || e.frame.height,
                    transform: this._transform.clone(),
                    alpha: this._fillStyle.alpha,
                    style: t ? Pt.shared.setValue(t).toNumber() : 16777215
                }
            }), this.onUpdate(), this;
        }
        beginPath() {
            return this._activePath = new Os, this;
        }
        fill(e, t) {
            let n;
            const s = this.instructions[this.instructions.length - 1];
            return this._tick === 0 && s && s.action === "stroke" ? n = s.data.path : n = this._activePath.clone(), n ? (e != null && (t !== void 0 && typeof e == "number" && (ut(bt, "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead"), e = {
                color: e,
                alpha: t
            }), this._fillStyle = ki(e, Dn.defaultFillStyle)), this.instructions.push({
                action: "fill",
                data: {
                    style: this.fillStyle,
                    path: n
                }
            }), this.onUpdate(), this._initNextPathLocation(), this._tick = 0, this) : this;
        }
        _initNextPathLocation() {
            const { x: e, y: t } = this._activePath.getLastPoint(Lt.shared);
            this._activePath.clear(), this._activePath.moveTo(e, t);
        }
        stroke(e) {
            let t;
            const n = this.instructions[this.instructions.length - 1];
            return this._tick === 0 && n && n.action === "fill" ? t = n.data.path : t = this._activePath.clone(), t ? (e != null && (this._strokeStyle = qa(e, Dn.defaultStrokeStyle)), this.instructions.push({
                action: "stroke",
                data: {
                    style: this.strokeStyle,
                    path: t
                }
            }), this.onUpdate(), this._initNextPathLocation(), this._tick = 0, this) : this;
        }
        cut() {
            for(let e = 0; e < 2; e++){
                const t = this.instructions[this.instructions.length - 1 - e], n = this._activePath.clone();
                if (t && (t.action === "stroke" || t.action === "fill")) if (t.data.hole) t.data.hole.addPath(n);
                else {
                    t.data.hole = n;
                    break;
                }
            }
            return this._initNextPathLocation(), this;
        }
        arc(e, t, n, s, r, a) {
            this._tick++;
            const o = this._transform;
            return this._activePath.arc(o.a * e + o.c * t + o.tx, o.b * e + o.d * t + o.ty, n, s, r, a), this;
        }
        arcTo(e, t, n, s, r) {
            this._tick++;
            const a = this._transform;
            return this._activePath.arcTo(a.a * e + a.c * t + a.tx, a.b * e + a.d * t + a.ty, a.a * n + a.c * s + a.tx, a.b * n + a.d * s + a.ty, r), this;
        }
        arcToSvg(e, t, n, s, r, a, o) {
            this._tick++;
            const c = this._transform;
            return this._activePath.arcToSvg(e, t, n, s, r, c.a * a + c.c * o + c.tx, c.b * a + c.d * o + c.ty), this;
        }
        bezierCurveTo(e, t, n, s, r, a, o) {
            this._tick++;
            const c = this._transform;
            return this._activePath.bezierCurveTo(c.a * e + c.c * t + c.tx, c.b * e + c.d * t + c.ty, c.a * n + c.c * s + c.tx, c.b * n + c.d * s + c.ty, c.a * r + c.c * a + c.tx, c.b * r + c.d * a + c.ty, o), this;
        }
        closePath() {
            return this._tick++, this._activePath?.closePath(), this;
        }
        ellipse(e, t, n, s) {
            return this._tick++, this._activePath.ellipse(e, t, n, s, this._transform.clone()), this;
        }
        circle(e, t, n) {
            return this._tick++, this._activePath.circle(e, t, n, this._transform.clone()), this;
        }
        path(e) {
            return this._tick++, this._activePath.addPath(e, this._transform.clone()), this;
        }
        lineTo(e, t) {
            this._tick++;
            const n = this._transform;
            return this._activePath.lineTo(n.a * e + n.c * t + n.tx, n.b * e + n.d * t + n.ty), this;
        }
        moveTo(e, t) {
            this._tick++;
            const n = this._transform, s = this._activePath.instructions, r = n.a * e + n.c * t + n.tx, a = n.b * e + n.d * t + n.ty;
            return s.length === 1 && s[0].action === "moveTo" ? (s[0].data[0] = r, s[0].data[1] = a, this) : (this._activePath.moveTo(r, a), this);
        }
        quadraticCurveTo(e, t, n, s, r) {
            this._tick++;
            const a = this._transform;
            return this._activePath.quadraticCurveTo(a.a * e + a.c * t + a.tx, a.b * e + a.d * t + a.ty, a.a * n + a.c * s + a.tx, a.b * n + a.d * s + a.ty, r), this;
        }
        rect(e, t, n, s) {
            return this._tick++, this._activePath.rect(e, t, n, s, this._transform.clone()), this;
        }
        roundRect(e, t, n, s, r) {
            return this._tick++, this._activePath.roundRect(e, t, n, s, r, this._transform.clone()), this;
        }
        poly(e, t) {
            return this._tick++, this._activePath.poly(e, t, this._transform.clone()), this;
        }
        regularPoly(e, t, n, s, r = 0, a) {
            return this._tick++, this._activePath.regularPoly(e, t, n, s, r, a), this;
        }
        roundPoly(e, t, n, s, r, a) {
            return this._tick++, this._activePath.roundPoly(e, t, n, s, r, a), this;
        }
        roundShape(e, t, n, s) {
            return this._tick++, this._activePath.roundShape(e, t, n, s), this;
        }
        filletRect(e, t, n, s, r) {
            return this._tick++, this._activePath.filletRect(e, t, n, s, r), this;
        }
        chamferRect(e, t, n, s, r, a) {
            return this._tick++, this._activePath.chamferRect(e, t, n, s, r, a), this;
        }
        star(e, t, n, s, r = 0, a = 0) {
            return this._tick++, this._activePath.star(e, t, n, s, r, a, this._transform.clone()), this;
        }
        svg(e) {
            return this._tick++, MA(e, this), this;
        }
        restore() {
            const e = this._stateStack.pop();
            return e && (this._transform = e.transform, this._fillStyle = e.fillStyle, this._strokeStyle = e.strokeStyle), this;
        }
        save() {
            return this._stateStack.push({
                transform: this._transform.clone(),
                fillStyle: {
                    ...this._fillStyle
                },
                strokeStyle: {
                    ...this._strokeStyle
                }
            }), this;
        }
        getTransform() {
            return this._transform;
        }
        resetTransform() {
            return this._transform.identity(), this;
        }
        rotate(e) {
            return this._transform.rotate(e), this;
        }
        scale(e, t = e) {
            return this._transform.scale(e, t), this;
        }
        setTransform(e, t, n, s, r, a) {
            return e instanceof Fe ? (this._transform.set(e.a, e.b, e.c, e.d, e.tx, e.ty), this) : (this._transform.set(e, t, n, s, r, a), this);
        }
        transform(e, t, n, s, r, a) {
            return e instanceof Fe ? (this._transform.append(e), this) : (lf.set(e, t, n, s, r, a), this._transform.append(lf), this);
        }
        translate(e, t = e) {
            return this._transform.translate(e, t), this;
        }
        clear() {
            return this._activePath.clear(), this.instructions.length = 0, this.resetTransform(), this.onUpdate(), this;
        }
        onUpdate() {
            this.dirty || (this.emit("update", this, 16), this.dirty = !0, this._boundsDirty = !0);
        }
        get bounds() {
            if (!this._boundsDirty) return this._bounds;
            const e = this._bounds;
            e.clear();
            for(let t = 0; t < this.instructions.length; t++){
                const n = this.instructions[t], s = n.action;
                if (s === "fill") {
                    const r = n.data;
                    e.addBounds(r.path.bounds);
                } else if (s === "texture") {
                    const r = n.data;
                    e.addFrame(r.dx, r.dy, r.dx + r.dw, r.dy + r.dh, r.transform);
                }
                if (s === "stroke") {
                    const r = n.data, a = r.style.alignment, o = r.style.width * (1 - a), c = r.path.bounds;
                    e.addFrame(c.minX - o, c.minY - o, c.maxX + o, c.maxY + o);
                }
            }
            return e;
        }
        containsPoint(e) {
            if (!this.bounds.containsPoint(e.x, e.y)) return !1;
            const t = this.instructions;
            let n = !1;
            for(let s = 0; s < t.length; s++){
                const r = t[s], a = r.data, o = a.path;
                if (!r.action || !o) continue;
                const c = a.style, l = o.shapePath.shapePrimitives;
                for(let h = 0; h < l.length; h++){
                    const u = l[h].shape;
                    if (!c || !u) continue;
                    const d = l[h].transform, f = d ? d.applyInverse(e, CA) : e;
                    if (r.action === "fill") n = u.contains(f.x, f.y);
                    else {
                        const g = c;
                        n = u.strokeContains(f.x, f.y, g.width, g.alignment);
                    }
                    const _ = a.hole;
                    if (_) {
                        const g = _.shapePath?.shapePrimitives;
                        if (g) for(let p = 0; p < g.length; p++)g[p].shape.contains(f.x, f.y) && (n = !1);
                    }
                    if (n) return !0;
                }
            }
            return n;
        }
        destroy(e = !1) {
            if (this._stateStack.length = 0, this._transform = null, this.emit("destroy", this), this.removeAllListeners(), typeof e == "boolean" ? e : e?.texture) {
                const n = typeof e == "boolean" ? e : e?.textureSource;
                this._fillStyle.texture && this._fillStyle.texture.destroy(n), this._strokeStyle.texture && this._strokeStyle.texture.destroy(n);
            }
            this._fillStyle = null, this._strokeStyle = null, this.instructions = null, this._activePath = null, this._bounds = null, this._stateStack = null, this.customShader = null, this._transform = null;
        }
    };
    Sh.defaultFillStyle = {
        color: 16777215,
        alpha: 1,
        texture: Oe.WHITE,
        matrix: null,
        fill: null,
        textureSpace: "local"
    };
    Sh.defaultStrokeStyle = {
        width: 1,
        color: 16777215,
        alpha: 1,
        alignment: .5,
        miterLimit: 10,
        cap: "butt",
        join: "miter",
        texture: Oe.WHITE,
        matrix: null,
        fill: null,
        textureSpace: "local",
        pixelLine: !1
    };
    let yn = Sh;
    const hf = [
        "align",
        "breakWords",
        "cssOverrides",
        "fontVariant",
        "fontWeight",
        "leading",
        "letterSpacing",
        "lineHeight",
        "padding",
        "textBaseline",
        "trim",
        "whiteSpace",
        "wordWrap",
        "wordWrapWidth",
        "fontFamily",
        "fontStyle",
        "fontSize"
    ];
    PA = function(i) {
        const e = [];
        let t = 0;
        for(let n = 0; n < hf.length; n++){
            const s = `_${hf[n]}`;
            e[t++] = i[s];
        }
        return t = vm(i._fill, e, t), t = IA(i._stroke, e, t), t = DA(i.dropShadow, e, t), e.join("-");
    };
    function vm(i, e, t) {
        return i && (e[t++] = i.color, e[t++] = i.alpha, e[t++] = i.fill?.styleKey), t;
    }
    function IA(i, e, t) {
        return i && (t = vm(i, e, t), e[t++] = i.width, e[t++] = i.alignment, e[t++] = i.cap, e[t++] = i.join, e[t++] = i.miterLimit), t;
    }
    function DA(i, e, t) {
        return i && (e[t++] = i.alpha, e[t++] = i.angle, e[t++] = i.blur, e[t++] = i.distance, e[t++] = Pt.shared.setValue(i.color).toNumber()), t;
    }
    const Mh = class xs extends Cn {
        constructor(e = {}){
            super(), LA(e);
            const t = {
                ...xs.defaultTextStyle,
                ...e
            };
            for(const n in t){
                const s = n;
                this[s] = t[n];
            }
            this.update();
        }
        get align() {
            return this._align;
        }
        set align(e) {
            this._align = e, this.update();
        }
        get breakWords() {
            return this._breakWords;
        }
        set breakWords(e) {
            this._breakWords = e, this.update();
        }
        get dropShadow() {
            return this._dropShadow;
        }
        set dropShadow(e) {
            e !== null && typeof e == "object" ? this._dropShadow = this._createProxy({
                ...xs.defaultDropShadow,
                ...e
            }) : this._dropShadow = e ? this._createProxy({
                ...xs.defaultDropShadow
            }) : null, this.update();
        }
        get fontFamily() {
            return this._fontFamily;
        }
        set fontFamily(e) {
            this._fontFamily = e, this.update();
        }
        get fontSize() {
            return this._fontSize;
        }
        set fontSize(e) {
            typeof e == "string" ? this._fontSize = parseInt(e, 10) : this._fontSize = e, this.update();
        }
        get fontStyle() {
            return this._fontStyle;
        }
        set fontStyle(e) {
            this._fontStyle = e.toLowerCase(), this.update();
        }
        get fontVariant() {
            return this._fontVariant;
        }
        set fontVariant(e) {
            this._fontVariant = e, this.update();
        }
        get fontWeight() {
            return this._fontWeight;
        }
        set fontWeight(e) {
            this._fontWeight = e, this.update();
        }
        get leading() {
            return this._leading;
        }
        set leading(e) {
            this._leading = e, this.update();
        }
        get letterSpacing() {
            return this._letterSpacing;
        }
        set letterSpacing(e) {
            this._letterSpacing = e, this.update();
        }
        get lineHeight() {
            return this._lineHeight;
        }
        set lineHeight(e) {
            this._lineHeight = e, this.update();
        }
        get padding() {
            return this._padding;
        }
        set padding(e) {
            this._padding = e, this.update();
        }
        get trim() {
            return this._trim;
        }
        set trim(e) {
            this._trim = e, this.update();
        }
        get textBaseline() {
            return this._textBaseline;
        }
        set textBaseline(e) {
            this._textBaseline = e, this.update();
        }
        get whiteSpace() {
            return this._whiteSpace;
        }
        set whiteSpace(e) {
            this._whiteSpace = e, this.update();
        }
        get wordWrap() {
            return this._wordWrap;
        }
        set wordWrap(e) {
            this._wordWrap = e, this.update();
        }
        get wordWrapWidth() {
            return this._wordWrapWidth;
        }
        set wordWrapWidth(e) {
            this._wordWrapWidth = e, this.update();
        }
        get fill() {
            return this._originalFill;
        }
        set fill(e) {
            e !== this._originalFill && (this._originalFill = e, this._isFillStyle(e) && (this._originalFill = this._createProxy({
                ...yn.defaultFillStyle,
                ...e
            }, ()=>{
                this._fill = ki({
                    ...this._originalFill
                }, yn.defaultFillStyle);
            })), this._fill = ki(e === 0 ? "black" : e, yn.defaultFillStyle), this.update());
        }
        get stroke() {
            return this._originalStroke;
        }
        set stroke(e) {
            e !== this._originalStroke && (this._originalStroke = e, this._isFillStyle(e) && (this._originalStroke = this._createProxy({
                ...yn.defaultStrokeStyle,
                ...e
            }, ()=>{
                this._stroke = qa({
                    ...this._originalStroke
                }, yn.defaultStrokeStyle);
            })), this._stroke = qa(e, yn.defaultStrokeStyle), this.update());
        }
        _generateKey() {
            return this._styleKey = PA(this), this._styleKey;
        }
        update() {
            this._styleKey = null, this.emit("update", this);
        }
        reset() {
            const e = xs.defaultTextStyle;
            for(const t in e)this[t] = e[t];
        }
        get styleKey() {
            return this._styleKey || this._generateKey();
        }
        clone() {
            return new xs({
                align: this.align,
                breakWords: this.breakWords,
                dropShadow: this._dropShadow ? {
                    ...this._dropShadow
                } : null,
                fill: this._fill,
                fontFamily: this.fontFamily,
                fontSize: this.fontSize,
                fontStyle: this.fontStyle,
                fontVariant: this.fontVariant,
                fontWeight: this.fontWeight,
                leading: this.leading,
                letterSpacing: this.letterSpacing,
                lineHeight: this.lineHeight,
                padding: this.padding,
                stroke: this._stroke,
                textBaseline: this.textBaseline,
                whiteSpace: this.whiteSpace,
                wordWrap: this.wordWrap,
                wordWrapWidth: this.wordWrapWidth
            });
        }
        destroy(e = !1) {
            if (this.removeAllListeners(), typeof e == "boolean" ? e : e?.texture) {
                const n = typeof e == "boolean" ? e : e?.textureSource;
                this._fill?.texture && this._fill.texture.destroy(n), this._originalFill?.texture && this._originalFill.texture.destroy(n), this._stroke?.texture && this._stroke.texture.destroy(n), this._originalStroke?.texture && this._originalStroke.texture.destroy(n);
            }
            this._fill = null, this._stroke = null, this.dropShadow = null, this._originalStroke = null, this._originalFill = null;
        }
        _createProxy(e, t) {
            return new Proxy(e, {
                set: (n, s, r)=>(n[s] = r, t?.(s, r), this.update(), !0)
            });
        }
        _isFillStyle(e) {
            return (e ?? null) !== null && !(Pt.isColorLike(e) || e instanceof Yi || e instanceof ph);
        }
    };
    Mh.defaultDropShadow = {
        alpha: 1,
        angle: Math.PI / 6,
        blur: 0,
        color: "black",
        distance: 5
    };
    Mh.defaultTextStyle = {
        align: "left",
        breakWords: !1,
        dropShadow: null,
        fill: "black",
        fontFamily: "Arial",
        fontSize: 26,
        fontStyle: "normal",
        fontVariant: "normal",
        fontWeight: "normal",
        leading: 0,
        letterSpacing: 0,
        lineHeight: 0,
        padding: 0,
        stroke: null,
        textBaseline: "alphabetic",
        trim: !1,
        whiteSpace: "pre",
        wordWrap: !1,
        wordWrapWidth: 100
    };
    Dl = Mh;
    function LA(i) {
        const e = i;
        if (typeof e.dropShadow == "boolean" && e.dropShadow) {
            const t = Dl.defaultDropShadow;
            i.dropShadow = {
                alpha: e.dropShadowAlpha ?? t.alpha,
                angle: e.dropShadowAngle ?? t.angle,
                blur: e.dropShadowBlur ?? t.blur,
                color: e.dropShadowColor ?? t.color,
                distance: e.dropShadowDistance ?? t.distance
            };
        }
        if (e.strokeThickness !== void 0) {
            ut(bt, "strokeThickness is now a part of stroke");
            const t = e.stroke;
            let n = {};
            if (Pt.isColorLike(t)) n.color = t;
            else if (t instanceof Yi || t instanceof ph) n.fill = t;
            else if (Object.hasOwnProperty.call(t, "color") || Object.hasOwnProperty.call(t, "fill")) n = t;
            else throw new Error("Invalid stroke value.");
            i.stroke = {
                ...n,
                width: e.strokeThickness
            };
        }
        if (Array.isArray(e.fillGradientStops)) {
            ut(bt, "gradient fill is now a fill pattern: `new FillGradient(...)`");
            let t;
            i.fontSize == null ? i.fontSize = Dl.defaultTextStyle.fontSize : typeof i.fontSize == "string" ? t = parseInt(i.fontSize, 10) : t = i.fontSize;
            const n = new Yi({
                start: {
                    x: 0,
                    y: 0
                },
                end: {
                    x: 0,
                    y: (t || 0) * 1.7
                }
            }), s = e.fillGradientStops.map((r)=>Pt.shared.setValue(r).toNumber());
            s.forEach((r, a)=>{
                const o = a / (s.length - 1);
                n.addColorStop(o, r);
            }), i.fill = {
                fill: n
            };
        }
    }
    const UA = [
        "serif",
        "sans-serif",
        "monospace",
        "cursive",
        "fantasy",
        "system-ui"
    ];
    NA = function(i) {
        const e = typeof i.fontSize == "number" ? `${i.fontSize}px` : i.fontSize;
        let t = i.fontFamily;
        Array.isArray(i.fontFamily) || (t = i.fontFamily.split(","));
        for(let n = t.length - 1; n >= 0; n--){
            let s = t[n].trim();
            !/([\"\'])[^\'\"]+\1/.test(s) && !UA.includes(s) && (s = `"${s}"`), t[n] = s;
        }
        return `${i.fontStyle} ${i.fontVariant} ${i.fontWeight} ${e} ${t.join(",")}`;
    };
    const gc = {
        willReadFrequently: !0
    }, Pn = class Me {
        static get experimentalLetterSpacingSupported() {
            let e = Me._experimentalLetterSpacingSupported;
            if (e !== void 0) {
                const t = jt.get().getCanvasRenderingContext2D().prototype;
                e = Me._experimentalLetterSpacingSupported = "letterSpacing" in t || "textLetterSpacing" in t;
            }
            return e;
        }
        constructor(e, t, n, s, r, a, o, c, l){
            this.text = e, this.style = t, this.width = n, this.height = s, this.lines = r, this.lineWidths = a, this.lineHeight = o, this.maxLineWidth = c, this.fontProperties = l;
        }
        static measureText(e = " ", t, n = Me._canvas, s = t.wordWrap) {
            const r = `${e}:${t.styleKey}`;
            if (Me._measurementCache[r]) return Me._measurementCache[r];
            const a = NA(t), o = Me.measureFont(a);
            o.fontSize === 0 && (o.fontSize = t.fontSize, o.ascent = t.fontSize);
            const c = Me.__context;
            c.font = a;
            const h = (s ? Me._wordWrap(e, t, n) : e).split(/(?:\r\n|\r|\n)/), u = new Array(h.length);
            let d = 0;
            for(let v = 0; v < h.length; v++){
                const y = Me._measureText(h[v], t.letterSpacing, c);
                u[v] = y, d = Math.max(d, y);
            }
            const f = t._stroke?.width || 0;
            let _ = d + f;
            t.dropShadow && (_ += t.dropShadow.distance);
            const g = t.lineHeight || o.fontSize;
            let p = Math.max(g, o.fontSize + f) + (h.length - 1) * (g + t.leading);
            return t.dropShadow && (p += t.dropShadow.distance), new Me(e, t, _, p, h, u, g + t.leading, d, o);
        }
        static _measureText(e, t, n) {
            let s = !1;
            Me.experimentalLetterSpacingSupported && (Me.experimentalLetterSpacing ? (n.letterSpacing = `${t}px`, n.textLetterSpacing = `${t}px`, s = !0) : (n.letterSpacing = "0px", n.textLetterSpacing = "0px"));
            const r = n.measureText(e);
            let a = r.width;
            const o = -r.actualBoundingBoxLeft;
            let l = r.actualBoundingBoxRight - o;
            if (a > 0) if (s) a -= t, l -= t;
            else {
                const h = (Me.graphemeSegmenter(e).length - 1) * t;
                a += h, l += h;
            }
            return Math.max(a, l);
        }
        static _wordWrap(e, t, n = Me._canvas) {
            const s = n.getContext("2d", gc);
            let r = 0, a = "", o = "";
            const c = Object.create(null), { letterSpacing: l, whiteSpace: h } = t, u = Me._collapseSpaces(h), d = Me._collapseNewlines(h);
            let f = !u;
            const _ = t.wordWrapWidth + l, g = Me._tokenize(e);
            for(let p = 0; p < g.length; p++){
                let m = g[p];
                if (Me._isNewline(m)) {
                    if (!d) {
                        o += Me._addLine(a), f = !u, a = "", r = 0;
                        continue;
                    }
                    m = " ";
                }
                if (u) {
                    const y = Me.isBreakingSpace(m), x = Me.isBreakingSpace(a[a.length - 1]);
                    if (y && x) continue;
                }
                const v = Me._getFromCache(m, l, c, s);
                if (v > _) if (a !== "" && (o += Me._addLine(a), a = "", r = 0), Me.canBreakWords(m, t.breakWords)) {
                    const y = Me.wordWrapSplit(m);
                    for(let x = 0; x < y.length; x++){
                        let I = y[x], w = I, R = 1;
                        for(; y[x + R];){
                            const E = y[x + R];
                            if (!Me.canBreakChars(w, E, m, x, t.breakWords)) I += E;
                            else break;
                            w = E, R++;
                        }
                        x += R - 1;
                        const N = Me._getFromCache(I, l, c, s);
                        N + r > _ && (o += Me._addLine(a), f = !1, a = "", r = 0), a += I, r += N;
                    }
                } else {
                    a.length > 0 && (o += Me._addLine(a), a = "", r = 0);
                    const y = p === g.length - 1;
                    o += Me._addLine(m, !y), f = !1, a = "", r = 0;
                }
                else v + r > _ && (f = !1, o += Me._addLine(a), a = "", r = 0), (a.length > 0 || !Me.isBreakingSpace(m) || f) && (a += m, r += v);
            }
            return o += Me._addLine(a, !1), o;
        }
        static _addLine(e, t = !0) {
            return e = Me._trimRight(e), e = t ? `${e}
` : e, e;
        }
        static _getFromCache(e, t, n, s) {
            let r = n[e];
            return typeof r != "number" && (r = Me._measureText(e, t, s) + t, n[e] = r), r;
        }
        static _collapseSpaces(e) {
            return e === "normal" || e === "pre-line";
        }
        static _collapseNewlines(e) {
            return e === "normal";
        }
        static _trimRight(e) {
            if (typeof e != "string") return "";
            for(let t = e.length - 1; t >= 0; t--){
                const n = e[t];
                if (!Me.isBreakingSpace(n)) break;
                e = e.slice(0, -1);
            }
            return e;
        }
        static _isNewline(e) {
            return typeof e != "string" ? !1 : Me._newlines.includes(e.charCodeAt(0));
        }
        static isBreakingSpace(e, t) {
            return typeof e != "string" ? !1 : Me._breakingSpaces.includes(e.charCodeAt(0));
        }
        static _tokenize(e) {
            const t = [];
            let n = "";
            if (typeof e != "string") return t;
            for(let s = 0; s < e.length; s++){
                const r = e[s], a = e[s + 1];
                if (Me.isBreakingSpace(r, a) || Me._isNewline(r)) {
                    n !== "" && (t.push(n), n = ""), t.push(r);
                    continue;
                }
                n += r;
            }
            return n !== "" && t.push(n), t;
        }
        static canBreakWords(e, t) {
            return t;
        }
        static canBreakChars(e, t, n, s, r) {
            return !0;
        }
        static wordWrapSplit(e) {
            return Me.graphemeSegmenter(e);
        }
        static measureFont(e) {
            if (Me._fonts[e]) return Me._fonts[e];
            const t = Me._context;
            t.font = e;
            const n = t.measureText(Me.METRICS_STRING + Me.BASELINE_SYMBOL), s = {
                ascent: n.actualBoundingBoxAscent,
                descent: n.actualBoundingBoxDescent,
                fontSize: n.actualBoundingBoxAscent + n.actualBoundingBoxDescent
            };
            return Me._fonts[e] = s, s;
        }
        static clearMetrics(e = "") {
            e ? delete Me._fonts[e] : Me._fonts = {};
        }
        static get _canvas() {
            if (!Me.__canvas) {
                let e;
                try {
                    const t = new OffscreenCanvas(0, 0);
                    if (t.getContext("2d", gc)?.measureText) return Me.__canvas = t, t;
                    e = jt.get().createCanvas();
                } catch  {
                    e = jt.get().createCanvas();
                }
                e.width = e.height = 10, Me.__canvas = e;
            }
            return Me.__canvas;
        }
        static get _context() {
            return Me.__context || (Me.__context = Me._canvas.getContext("2d", gc)), Me.__context;
        }
    };
    Pn.METRICS_STRING = "|ÉqÅ";
    Pn.BASELINE_SYMBOL = "M";
    Pn.BASELINE_MULTIPLIER = 1.4;
    Pn.HEIGHT_MULTIPLIER = 2;
    Pn.graphemeSegmenter = (()=>{
        if (typeof Intl?.Segmenter == "function") {
            const i = new Intl.Segmenter;
            return (e)=>[
                    ...i.segment(e)
                ].map((t)=>t.segment);
        }
        return (i)=>[
                ...i
            ];
    })();
    Pn.experimentalLetterSpacing = !1;
    Pn._fonts = {};
    Pn._newlines = [
        10,
        13
    ];
    Pn._breakingSpaces = [
        9,
        32,
        8192,
        8193,
        8194,
        8195,
        8196,
        8197,
        8198,
        8200,
        8201,
        8202,
        8287,
        12288
    ];
    Pn._measurementCache = {};
    BA = Pn;
    var FA = `in vec2 vMaskCoord;
in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform sampler2D uMaskTexture;

uniform float uAlpha;
uniform vec4 uMaskClamp;
uniform float uInverse;

out vec4 finalColor;

void main(void)
{
    float clip = step(3.5,
        step(uMaskClamp.x, vMaskCoord.x) +
        step(uMaskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, uMaskClamp.z) +
        step(vMaskCoord.y, uMaskClamp.w));

    // TODO look into why this is needed
    float npmAlpha = uAlpha;
    vec4 original = texture(uTexture, vTextureCoord);
    vec4 masky = texture(uMaskTexture, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    float a = alphaMul * masky.r * npmAlpha * clip;

    if (uInverse == 1.0) {
        a = 1.0 - a;
    }

    finalColor = original * a;
}
`, OA = `in vec2 aPosition;

out vec2 vTextureCoord;
out vec2 vMaskCoord;


uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;
uniform mat3 uFilterMatrix;

vec4 filterVertexPosition(  vec2 aPosition )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
       
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord(  vec2 aPosition )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

vec2 getFilterCoord( vec2 aPosition )
{
    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}   

void main(void)
{
    gl_Position = filterVertexPosition(aPosition);
    vTextureCoord = filterTextureCoord(aPosition);
    vMaskCoord = getFilterCoord(aPosition);
}
`, uf = `struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct MaskUniforms {
  uFilterMatrix:mat3x3<f32>,
  uMaskClamp:vec4<f32>,
  uAlpha:f32,
  uInverse:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;
@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) filterUv : vec2<f32>,
};

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);
}

fn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>
{
  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}

@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>,
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition),
   getFilterCoord(aPosition)
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) filterUv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {

    var maskClamp = filterUniforms.uMaskClamp;
    var uAlpha = filterUniforms.uAlpha;

    var clip = step(3.5,
      step(maskClamp.x, filterUv.x) +
      step(maskClamp.y, filterUv.y) +
      step(filterUv.x, maskClamp.z) +
      step(filterUv.y, maskClamp.w));

    var mask = textureSample(uMaskTexture, uSampler, filterUv);
    var source = textureSample(uTexture, uSampler, uv);
    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);

    var a: f32 = alphaMul * mask.r * uAlpha * clip;

    if (filterUniforms.uInverse == 1.0) {
        a = 1.0 - a;
    }

    return source * a;
}
`;
    class kA extends kT {
        constructor(e){
            const { sprite: t, ...n } = e, s = new gp(t.texture), r = new $i({
                uFilterMatrix: {
                    value: new Fe,
                    type: "mat3x3<f32>"
                },
                uMaskClamp: {
                    value: s.uClampFrame,
                    type: "vec4<f32>"
                },
                uAlpha: {
                    value: 1,
                    type: "f32"
                },
                uInverse: {
                    value: e.inverse ? 1 : 0,
                    type: "f32"
                }
            }), a = Ws.from({
                vertex: {
                    source: uf,
                    entryPoint: "mainVertex"
                },
                fragment: {
                    source: uf,
                    entryPoint: "mainFragment"
                }
            }), o = Br.from({
                vertex: OA,
                fragment: FA,
                name: "mask-filter"
            });
            super({
                ...n,
                gpuProgram: a,
                glProgram: o,
                resources: {
                    filterUniforms: r,
                    uMaskTexture: t.texture.source
                }
            }), this.sprite = t, this._textureMatrix = s;
        }
        set inverse(e) {
            this.resources.filterUniforms.uniforms.uInverse = e ? 1 : 0;
        }
        get inverse() {
            return this.resources.filterUniforms.uniforms.uInverse === 1;
        }
        apply(e, t, n, s) {
            this._textureMatrix.texture = this.sprite.texture, e.calculateSpriteMatrix(this.resources.filterUniforms.uniforms.uFilterMatrix, this.sprite).prepend(this._textureMatrix.mapCoord), this.resources.uMaskTexture = this.sprite.texture.source, e.applyFilter(this, t, n, s);
        }
    }
    ja = class extends uh {
        constructor(e){
            e instanceof yn && (e = {
                context: e
            });
            const { context: t, roundPixels: n, ...s } = e || {};
            super({
                label: "Graphics",
                ...s
            }), this.renderPipeId = "graphics", t ? this._context = t : this._context = this._ownedContext = new yn, this._context.on("update", this.onViewUpdate, this), this.allowChildren = !1, this.roundPixels = n ?? !1;
        }
        set context(e) {
            e !== this._context && (this._context.off("update", this.onViewUpdate, this), this._context = e, this._context.on("update", this.onViewUpdate, this), this.onViewUpdate());
        }
        get context() {
            return this._context;
        }
        get bounds() {
            return this._context.bounds;
        }
        updateBounds() {}
        containsPoint(e) {
            return this._context.containsPoint(e);
        }
        destroy(e) {
            this._ownedContext && !e ? this._ownedContext.destroy(e) : (e === !0 || e?.context === !0) && this._context.destroy(e), this._ownedContext = null, this._context = null, super.destroy(e);
        }
        _callContextMethod(e, t) {
            return this.context[e](...t), this;
        }
        setFillStyle(...e) {
            return this._callContextMethod("setFillStyle", e);
        }
        setStrokeStyle(...e) {
            return this._callContextMethod("setStrokeStyle", e);
        }
        fill(...e) {
            return this._callContextMethod("fill", e);
        }
        stroke(...e) {
            return this._callContextMethod("stroke", e);
        }
        texture(...e) {
            return this._callContextMethod("texture", e);
        }
        beginPath() {
            return this._callContextMethod("beginPath", []);
        }
        cut() {
            return this._callContextMethod("cut", []);
        }
        arc(...e) {
            return this._callContextMethod("arc", e);
        }
        arcTo(...e) {
            return this._callContextMethod("arcTo", e);
        }
        arcToSvg(...e) {
            return this._callContextMethod("arcToSvg", e);
        }
        bezierCurveTo(...e) {
            return this._callContextMethod("bezierCurveTo", e);
        }
        closePath() {
            return this._callContextMethod("closePath", []);
        }
        ellipse(...e) {
            return this._callContextMethod("ellipse", e);
        }
        circle(...e) {
            return this._callContextMethod("circle", e);
        }
        path(...e) {
            return this._callContextMethod("path", e);
        }
        lineTo(...e) {
            return this._callContextMethod("lineTo", e);
        }
        moveTo(...e) {
            return this._callContextMethod("moveTo", e);
        }
        quadraticCurveTo(...e) {
            return this._callContextMethod("quadraticCurveTo", e);
        }
        rect(...e) {
            return this._callContextMethod("rect", e);
        }
        roundRect(...e) {
            return this._callContextMethod("roundRect", e);
        }
        poly(...e) {
            return this._callContextMethod("poly", e);
        }
        regularPoly(...e) {
            return this._callContextMethod("regularPoly", e);
        }
        roundPoly(...e) {
            return this._callContextMethod("roundPoly", e);
        }
        roundShape(...e) {
            return this._callContextMethod("roundShape", e);
        }
        filletRect(...e) {
            return this._callContextMethod("filletRect", e);
        }
        chamferRect(...e) {
            return this._callContextMethod("chamferRect", e);
        }
        star(...e) {
            return this._callContextMethod("star", e);
        }
        svg(...e) {
            return this._callContextMethod("svg", e);
        }
        restore(...e) {
            return this._callContextMethod("restore", e);
        }
        save() {
            return this._callContextMethod("save", []);
        }
        getTransform() {
            return this.context.getTransform();
        }
        resetTransform() {
            return this._callContextMethod("resetTransform", []);
        }
        rotateTransform(...e) {
            return this._callContextMethod("rotate", e);
        }
        scaleTransform(...e) {
            return this._callContextMethod("scale", e);
        }
        setTransform(...e) {
            return this._callContextMethod("setTransform", e);
        }
        transform(...e) {
            return this._callContextMethod("transform", e);
        }
        translateTransform(...e) {
            return this._callContextMethod("translate", e);
        }
        clear() {
            return this._callContextMethod("clear", []);
        }
        get fillStyle() {
            return this._context.fillStyle;
        }
        set fillStyle(e) {
            this._context.fillStyle = e;
        }
        get strokeStyle() {
            return this._context.strokeStyle;
        }
        set strokeStyle(e) {
            this._context.strokeStyle = e;
        }
        clone(e = !1) {
            return e ? new ja(this._context.clone()) : (this._ownedContext = null, new ja(this._context));
        }
        lineStyle(e, t, n) {
            ut(bt, "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");
            const s = {};
            return e && (s.width = e), t && (s.color = t), n && (s.alpha = n), this.context.strokeStyle = s, this;
        }
        beginFill(e, t) {
            ut(bt, "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
            const n = {};
            return e !== void 0 && (n.color = e), t !== void 0 && (n.alpha = t), this.context.fillStyle = n, this;
        }
        endFill() {
            ut(bt, "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."), this.context.fill();
            const e = this.context.strokeStyle;
            return (e.width !== yn.defaultStrokeStyle.width || e.color !== yn.defaultStrokeStyle.color || e.alpha !== yn.defaultStrokeStyle.alpha) && this.context.stroke(), this;
        }
        drawCircle(...e) {
            return ut(bt, "Graphics#drawCircle has been renamed to Graphics#circle"), this._callContextMethod("circle", e);
        }
        drawEllipse(...e) {
            return ut(bt, "Graphics#drawEllipse has been renamed to Graphics#ellipse"), this._callContextMethod("ellipse", e);
        }
        drawPolygon(...e) {
            return ut(bt, "Graphics#drawPolygon has been renamed to Graphics#poly"), this._callContextMethod("poly", e);
        }
        drawRect(...e) {
            return ut(bt, "Graphics#drawRect has been renamed to Graphics#rect"), this._callContextMethod("rect", e);
        }
        drawRoundedRect(...e) {
            return ut(bt, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect"), this._callContextMethod("roundRect", e);
        }
        drawStar(...e) {
            return ut(bt, "Graphics#drawStar has been renamed to Graphics#star"), this._callContextMethod("star", e);
        }
    };
    class GA extends uh {
        constructor(e, t){
            const { text: n, resolution: s, style: r, anchor: a, width: o, height: c, roundPixels: l, ...h } = e;
            super({
                ...h
            }), this.batched = !0, this._resolution = null, this._autoResolution = !0, this._didTextUpdate = !0, this._styleClass = t, this.text = n ?? "", this.style = r, this.resolution = s ?? null, this.allowChildren = !1, this._anchor = new Zt({
                _onUpdate: ()=>{
                    this.onViewUpdate();
                }
            }), a && (this.anchor = a), this.roundPixels = l ?? !1, o !== void 0 && (this.width = o), c !== void 0 && (this.height = c);
        }
        get anchor() {
            return this._anchor;
        }
        set anchor(e) {
            typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e);
        }
        set text(e) {
            e = e.toString(), this._text !== e && (this._text = e, this.onViewUpdate());
        }
        get text() {
            return this._text;
        }
        set resolution(e) {
            this._autoResolution = e === null, this._resolution = e, this.onViewUpdate();
        }
        get resolution() {
            return this._resolution;
        }
        get style() {
            return this._style;
        }
        set style(e) {
            e || (e = {}), this._style?.off("update", this.onViewUpdate, this), e instanceof this._styleClass ? this._style = e : this._style = new this._styleClass(e), this._style.on("update", this.onViewUpdate, this), this.onViewUpdate();
        }
        get width() {
            return Math.abs(this.scale.x) * this.bounds.width;
        }
        set width(e) {
            this._setWidth(e, this.bounds.width);
        }
        get height() {
            return Math.abs(this.scale.y) * this.bounds.height;
        }
        set height(e) {
            this._setHeight(e, this.bounds.height);
        }
        getSize(e) {
            return e || (e = {}), e.width = Math.abs(this.scale.x) * this.bounds.width, e.height = Math.abs(this.scale.y) * this.bounds.height, e;
        }
        setSize(e, t) {
            typeof e == "object" ? (t = e.height ?? e.width, e = e.width) : t ?? (t = e), e !== void 0 && this._setWidth(e, this.bounds.width), t !== void 0 && this._setHeight(t, this.bounds.height);
        }
        containsPoint(e) {
            const t = this.bounds.width, n = this.bounds.height, s = -t * this.anchor.x;
            let r = 0;
            return e.x >= s && e.x <= s + t && (r = -n * this.anchor.y, e.y >= r && e.y <= r + n);
        }
        onViewUpdate() {
            this.didViewUpdate || (this._didTextUpdate = !0), super.onViewUpdate();
        }
        _getKey() {
            return `${this.text}:${this._style.styleKey}:${this._resolution}`;
        }
        destroy(e = !1) {
            super.destroy(e), this.owner = null, this._bounds = null, this._anchor = null, (typeof e == "boolean" ? e : e?.style) && this._style.destroy(e), this._style = null, this._text = null;
        }
    }
    function HA(i, e) {
        let t = i[0] ?? {};
        return (typeof t == "string" || i[1]) && (ut(bt, `use new ${e}({ text: "hi!", style }) instead`), t = {
            text: t,
            style: i[1]
        }), t;
    }
    class xc extends GA {
        constructor(...e){
            const t = HA(e, "Text");
            super(t, Dl), this.renderPipeId = "text";
        }
        updateBounds() {
            const e = this._bounds, t = this._anchor, n = BA.measureText(this._text, this._style), { width: s, height: r } = n;
            e.minX = -t._x * s, e.maxX = e.minX + s, e.minY = -t._y * r, e.maxY = e.minY + r;
        }
    }
    class ym {
        constructor(){
            this._tempState = Fr.for2d(), this._didUploadHash = {};
        }
        init(e) {
            e.renderer.runners.contextChange.add(this);
        }
        contextChange() {
            this._didUploadHash = {};
        }
        start(e, t, n) {
            const s = e.renderer, r = this._didUploadHash[n.uid];
            s.shader.bind(n, r), r || (this._didUploadHash[n.uid] = !0), s.shader.updateUniformGroup(s.globalUniforms.uniformGroup), s.geometry.bind(t, n.glProgram);
        }
        execute(e, t) {
            const n = e.renderer;
            this._tempState.blendMode = t.blendMode, n.state.set(this._tempState);
            const s = t.textures.textures;
            for(let r = 0; r < t.textures.count; r++)n.texture.bind(s[r], r);
            n.geometry.draw(t.topology, t.size, t.start);
        }
    }
    ym.extension = {
        type: [
            se.WebGLPipesAdaptor
        ],
        name: "batch"
    };
    const Th = class bm {
        constructor(e, t){
            this.state = Fr.for2d(), this._batchersByInstructionSet = Object.create(null), this._activeBatches = Object.create(null), this.renderer = e, this._adaptor = t, this._adaptor.init?.(this);
        }
        static getBatcher(e) {
            return new this._availableBatchers[e];
        }
        buildStart(e) {
            let t = this._batchersByInstructionSet[e.uid];
            t || (t = this._batchersByInstructionSet[e.uid] = Object.create(null), t.default || (t.default = new yh)), this._activeBatches = t, this._activeBatch = this._activeBatches.default;
            for(const n in this._activeBatches)this._activeBatches[n].begin();
        }
        addToBatch(e, t) {
            if (this._activeBatch.name !== e.batcherName) {
                this._activeBatch.break(t);
                let n = this._activeBatches[e.batcherName];
                n || (n = this._activeBatches[e.batcherName] = bm.getBatcher(e.batcherName), n.begin()), this._activeBatch = n;
            }
            this._activeBatch.add(e);
        }
        break(e) {
            this._activeBatch.break(e);
        }
        buildEnd(e) {
            this._activeBatch.break(e);
            const t = this._activeBatches;
            for(const n in t){
                const s = t[n], r = s.geometry;
                r.indexBuffer.setDataWithSize(s.indexBuffer, s.indexSize, !0), r.buffers[0].setDataWithSize(s.attributeBuffer.float32View, s.attributeSize, !1);
            }
        }
        upload(e) {
            const t = this._batchersByInstructionSet[e.uid];
            for(const n in t){
                const s = t[n], r = s.geometry;
                s.dirty && (s.dirty = !1, r.buffers[0].update(s.attributeSize * 4));
            }
        }
        execute(e) {
            if (e.action === "startBatch") {
                const t = e.batcher, n = t.geometry, s = t.shader;
                this._adaptor.start(this, n, s);
            }
            this._adaptor.execute(this, e);
        }
        destroy() {
            this.state = null, this.renderer = null, this._adaptor = null;
            for(const e in this._activeBatches)this._activeBatches[e].destroy();
            this._activeBatches = null;
        }
    };
    Th.extension = {
        type: [
            se.WebGLPipes,
            se.WebGPUPipes,
            se.CanvasPipes
        ],
        name: "batch"
    };
    Th._availableBatchers = Object.create(null);
    let Sm = Th;
    Nt.handleByMap(se.Batcher, Sm._availableBatchers);
    Nt.add(yh);
    vc = {
        name: "local-uniform-bit",
        vertex: {
            header: `

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,
            main: `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,
            end: `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
        }
    };
    ({
        ...vc,
        vertex: {
            ...vc.vertex,
            header: vc.vertex.header.replace("group(1)", "group(2)")
        }
    });
    let zA, VA;
    Mm = {
        name: "local-uniform-bit",
        vertex: {
            header: `

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,
            main: `
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `,
            end: `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
        }
    };
    zA = {
        name: "texture-bit",
        vertex: {
            header: `
            uniform mat3 uTextureMatrix;
        `,
            main: `
            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;
        `
        },
        fragment: {
            header: `
        uniform sampler2D uTexture;

         
        `,
            main: `
            outColor = texture(uTexture, vUV);
        `
        }
    };
    VA = new en;
    class WA extends Va {
        constructor(){
            super(), this.filters = [
                new kA({
                    sprite: new Fs(Oe.EMPTY),
                    inverse: !1,
                    resolution: "inherit",
                    antialias: "inherit"
                })
            ];
        }
        get sprite() {
            return this.filters[0].sprite;
        }
        set sprite(e) {
            this.filters[0].sprite = e;
        }
        get inverse() {
            return this.filters[0].inverse;
        }
        set inverse(e) {
            this.filters[0].inverse = e;
        }
    }
    class Tm {
        constructor(e){
            this._activeMaskStage = [], this._renderer = e;
        }
        push(e, t, n) {
            const s = this._renderer;
            if (s.renderPipes.batch.break(n), n.add({
                renderPipeId: "alphaMask",
                action: "pushMaskBegin",
                mask: e,
                inverse: t._maskOptions.inverse,
                canBundle: !1,
                maskedContainer: t
            }), e.inverse = t._maskOptions.inverse, e.renderMaskToTexture) {
                const r = e.mask;
                r.includeInBuild = !0, r.collectRenderables(n, s, null), r.includeInBuild = !1;
            }
            s.renderPipes.batch.break(n), n.add({
                renderPipeId: "alphaMask",
                action: "pushMaskEnd",
                mask: e,
                maskedContainer: t,
                inverse: t._maskOptions.inverse,
                canBundle: !1
            });
        }
        pop(e, t, n) {
            this._renderer.renderPipes.batch.break(n), n.add({
                renderPipeId: "alphaMask",
                action: "popMaskEnd",
                mask: e,
                inverse: t._maskOptions.inverse,
                canBundle: !1
            });
        }
        execute(e) {
            const t = this._renderer, n = e.mask.renderMaskToTexture;
            if (e.action === "pushMaskBegin") {
                const s = Gt.get(WA);
                if (s.inverse = e.inverse, n) {
                    e.mask.mask.measurable = !0;
                    const r = oh(e.mask.mask, !0, VA);
                    e.mask.mask.measurable = !1, r.ceil();
                    const a = t.renderTarget.renderTarget.colorTexture.source, o = As.getOptimalTexture(r.width, r.height, a._resolution, a.antialias);
                    t.renderTarget.push(o, !0), t.globalUniforms.push({
                        offset: r,
                        worldColor: 4294967295
                    });
                    const c = s.sprite;
                    c.texture = o, c.worldTransform.tx = r.minX, c.worldTransform.ty = r.minY, this._activeMaskStage.push({
                        filterEffect: s,
                        maskedContainer: e.maskedContainer,
                        filterTexture: o
                    });
                } else s.sprite = e.mask.mask, this._activeMaskStage.push({
                    filterEffect: s,
                    maskedContainer: e.maskedContainer
                });
            } else if (e.action === "pushMaskEnd") {
                const s = this._activeMaskStage[this._activeMaskStage.length - 1];
                n && (t.type === Xi.WEBGL && t.renderTarget.finishRenderPass(), t.renderTarget.pop(), t.globalUniforms.pop()), t.filter.push({
                    renderPipeId: "filter",
                    action: "pushFilter",
                    container: s.maskedContainer,
                    filterEffect: s.filterEffect,
                    canBundle: !1
                });
            } else if (e.action === "popMaskEnd") {
                t.filter.pop();
                const s = this._activeMaskStage.pop();
                n && As.returnTexture(s.filterTexture), Gt.return(s.filterEffect);
            }
        }
        destroy() {
            this._renderer = null, this._activeMaskStage = null;
        }
    }
    Tm.extension = {
        type: [
            se.WebGLPipes,
            se.WebGPUPipes,
            se.CanvasPipes
        ],
        name: "alphaMask"
    };
    class Em {
        constructor(e){
            this._colorStack = [], this._colorStackIndex = 0, this._currentColor = 0, this._renderer = e;
        }
        buildStart() {
            this._colorStack[0] = 15, this._colorStackIndex = 1, this._currentColor = 15;
        }
        push(e, t, n) {
            this._renderer.renderPipes.batch.break(n);
            const r = this._colorStack;
            r[this._colorStackIndex] = r[this._colorStackIndex - 1] & e.mask;
            const a = this._colorStack[this._colorStackIndex];
            a !== this._currentColor && (this._currentColor = a, n.add({
                renderPipeId: "colorMask",
                colorMask: a,
                canBundle: !1
            })), this._colorStackIndex++;
        }
        pop(e, t, n) {
            this._renderer.renderPipes.batch.break(n);
            const r = this._colorStack;
            this._colorStackIndex--;
            const a = r[this._colorStackIndex - 1];
            a !== this._currentColor && (this._currentColor = a, n.add({
                renderPipeId: "colorMask",
                colorMask: a,
                canBundle: !1
            }));
        }
        execute(e) {
            this._renderer.colorMask.setMask(e.colorMask);
        }
        destroy() {
            this._colorStack = null;
        }
    }
    Em.extension = {
        type: [
            se.WebGLPipes,
            se.WebGPUPipes,
            se.CanvasPipes
        ],
        name: "colorMask"
    };
    class Am {
        constructor(e){
            this._maskStackHash = {}, this._maskHash = new WeakMap, this._renderer = e;
        }
        push(e, t, n) {
            var s;
            const r = e, a = this._renderer;
            a.renderPipes.batch.break(n), a.renderPipes.blendMode.setBlendMode(r.mask, "none", n), n.add({
                renderPipeId: "stencilMask",
                action: "pushMaskBegin",
                mask: e,
                inverse: t._maskOptions.inverse,
                canBundle: !1
            });
            const o = r.mask;
            o.includeInBuild = !0, this._maskHash.has(r) || this._maskHash.set(r, {
                instructionsStart: 0,
                instructionsLength: 0
            });
            const c = this._maskHash.get(r);
            c.instructionsStart = n.instructionSize, o.collectRenderables(n, a, null), o.includeInBuild = !1, a.renderPipes.batch.break(n), n.add({
                renderPipeId: "stencilMask",
                action: "pushMaskEnd",
                mask: e,
                inverse: t._maskOptions.inverse,
                canBundle: !1
            });
            const l = n.instructionSize - c.instructionsStart - 1;
            c.instructionsLength = l;
            const h = a.renderTarget.renderTarget.uid;
            (s = this._maskStackHash)[h] ?? (s[h] = 0);
        }
        pop(e, t, n) {
            const s = e, r = this._renderer;
            r.renderPipes.batch.break(n), r.renderPipes.blendMode.setBlendMode(s.mask, "none", n), n.add({
                renderPipeId: "stencilMask",
                action: "popMaskBegin",
                inverse: t._maskOptions.inverse,
                canBundle: !1
            });
            const a = this._maskHash.get(e);
            for(let o = 0; o < a.instructionsLength; o++)n.instructions[n.instructionSize++] = n.instructions[a.instructionsStart++];
            n.add({
                renderPipeId: "stencilMask",
                action: "popMaskEnd",
                canBundle: !1
            });
        }
        execute(e) {
            var t;
            const n = this._renderer, s = n.renderTarget.renderTarget.uid;
            let r = (t = this._maskStackHash)[s] ?? (t[s] = 0);
            e.action === "pushMaskBegin" ? (n.renderTarget.ensureDepthStencil(), n.stencil.setStencilMode(Ct.RENDERING_MASK_ADD, r), r++, n.colorMask.setMask(0)) : e.action === "pushMaskEnd" ? (e.inverse ? n.stencil.setStencilMode(Ct.INVERSE_MASK_ACTIVE, r) : n.stencil.setStencilMode(Ct.MASK_ACTIVE, r), n.colorMask.setMask(15)) : e.action === "popMaskBegin" ? (n.colorMask.setMask(0), r !== 0 ? n.stencil.setStencilMode(Ct.RENDERING_MASK_REMOVE, r) : (n.renderTarget.clear(null, gi.STENCIL), n.stencil.setStencilMode(Ct.DISABLED, r)), r--) : e.action === "popMaskEnd" && (e.inverse ? n.stencil.setStencilMode(Ct.INVERSE_MASK_ACTIVE, r) : n.stencil.setStencilMode(Ct.MASK_ACTIVE, r), n.colorMask.setMask(15)), this._maskStackHash[s] = r;
        }
        destroy() {
            this._renderer = null, this._maskStackHash = null, this._maskHash = null;
        }
    }
    Am.extension = {
        type: [
            se.WebGLPipes,
            se.WebGPUPipes,
            se.CanvasPipes
        ],
        name: "stencilMask"
    };
    var Ba = ((i)=>(i[i.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", i[i.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", i[i.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER", i))(Ba || {});
    class XA {
        constructor(e, t){
            this._lastBindBaseLocation = -1, this._lastBindCallId = -1, this.buffer = e || null, this.updateID = -1, this.byteLength = -1, this.type = t;
        }
    }
    class wm {
        constructor(e){
            this._gpuBuffers = Object.create(null), this._boundBufferBases = Object.create(null), this._minBaseLocation = 0, this._nextBindBaseIndex = this._minBaseLocation, this._bindCallId = 0, this._renderer = e, this._renderer.renderableGC.addManagedHash(this, "_gpuBuffers");
        }
        destroy() {
            this._renderer = null, this._gl = null, this._gpuBuffers = null, this._boundBufferBases = null;
        }
        contextChange() {
            const e = this._gl = this._renderer.gl;
            this._gpuBuffers = Object.create(null), this._maxBindings = e.MAX_UNIFORM_BUFFER_BINDINGS ? e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
        }
        getGlBuffer(e) {
            return this._gpuBuffers[e.uid] || this.createGLBuffer(e);
        }
        bind(e) {
            const { _gl: t } = this, n = this.getGlBuffer(e);
            t.bindBuffer(n.type, n.buffer);
        }
        bindBufferBase(e, t) {
            const { _gl: n } = this;
            this._boundBufferBases[t] !== e && (this._boundBufferBases[t] = e, e._lastBindBaseLocation = t, n.bindBufferBase(n.UNIFORM_BUFFER, t, e.buffer));
        }
        nextBindBase(e) {
            this._bindCallId++, this._minBaseLocation = 0, e && (this._boundBufferBases[0] = null, this._minBaseLocation = 1, this._nextBindBaseIndex < 1 && (this._nextBindBaseIndex = 1));
        }
        freeLocationForBufferBase(e) {
            let t = this.getLastBindBaseLocation(e);
            if (t >= this._minBaseLocation) return e._lastBindCallId = this._bindCallId, t;
            let n = 0, s = this._nextBindBaseIndex;
            for(; n < 2;){
                s >= this._maxBindings && (s = this._minBaseLocation, n++);
                const r = this._boundBufferBases[s];
                if (r && r._lastBindCallId === this._bindCallId) {
                    s++;
                    continue;
                }
                break;
            }
            return t = s, this._nextBindBaseIndex = s + 1, n >= 2 ? -1 : (e._lastBindCallId = this._bindCallId, this._boundBufferBases[t] = null, t);
        }
        getLastBindBaseLocation(e) {
            const t = e._lastBindBaseLocation;
            return this._boundBufferBases[t] === e ? t : -1;
        }
        bindBufferRange(e, t, n, s) {
            const { _gl: r } = this;
            n || (n = 0), t || (t = 0), this._boundBufferBases[t] = null, r.bindBufferRange(r.UNIFORM_BUFFER, t || 0, e.buffer, n * 256, s || 256);
        }
        updateBuffer(e) {
            const { _gl: t } = this, n = this.getGlBuffer(e);
            if (e._updateID === n.updateID) return n;
            n.updateID = e._updateID, t.bindBuffer(n.type, n.buffer);
            const s = e.data, r = e.descriptor.usage & St.STATIC ? t.STATIC_DRAW : t.DYNAMIC_DRAW;
            return s ? n.byteLength >= s.byteLength ? t.bufferSubData(n.type, 0, s, 0, e._updateSize / s.BYTES_PER_ELEMENT) : (n.byteLength = s.byteLength, t.bufferData(n.type, s, r)) : (n.byteLength = e.descriptor.size, t.bufferData(n.type, n.byteLength, r)), n;
        }
        destroyAll() {
            const e = this._gl;
            for(const t in this._gpuBuffers)e.deleteBuffer(this._gpuBuffers[t].buffer);
            this._gpuBuffers = Object.create(null);
        }
        onBufferDestroy(e, t) {
            const n = this._gpuBuffers[e.uid], s = this._gl;
            t || s.deleteBuffer(n.buffer), this._gpuBuffers[e.uid] = null;
        }
        createGLBuffer(e) {
            const { _gl: t } = this;
            let n = Ba.ARRAY_BUFFER;
            e.descriptor.usage & St.INDEX ? n = Ba.ELEMENT_ARRAY_BUFFER : e.descriptor.usage & St.UNIFORM && (n = Ba.UNIFORM_BUFFER);
            const s = new XA(t.createBuffer(), n);
            return this._gpuBuffers[e.uid] = s, e.on("destroy", this.onBufferDestroy, this), s;
        }
        resetState() {
            this._boundBufferBases = Object.create(null);
        }
    }
    wm.extension = {
        type: [
            se.WebGLSystem
        ],
        name: "buffer"
    };
    const Eh = class Rm {
        constructor(e){
            this.supports = {
                uint32Indices: !0,
                uniformBufferObject: !0,
                vertexArrayObject: !0,
                srgbTextures: !0,
                nonPowOf2wrapping: !0,
                msaa: !0,
                nonPowOf2mipmaps: !0
            }, this._renderer = e, this.extensions = Object.create(null), this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this);
        }
        get isLost() {
            return !this.gl || this.gl.isContextLost();
        }
        contextChange(e) {
            this.gl = e, this._renderer.gl = e;
        }
        init(e) {
            e = {
                ...Rm.defaultOptions,
                ...e
            };
            let t = this.multiView = e.multiView;
            if (e.context && t && (_t("Renderer created with both a context and multiview enabled. Disabling multiView as both cannot work together."), t = !1), t ? this.canvas = jt.get().createCanvas(this._renderer.canvas.width, this._renderer.canvas.height) : this.canvas = this._renderer.view.canvas, e.context) this.initFromContext(e.context);
            else {
                const n = this._renderer.background.alpha < 1, s = e.premultipliedAlpha ?? !0, r = e.antialias && !this._renderer.backBuffer.useBackBuffer;
                this.createContext(e.preferWebGLVersion, {
                    alpha: n,
                    premultipliedAlpha: s,
                    antialias: r,
                    stencil: !0,
                    preserveDrawingBuffer: e.preserveDrawingBuffer,
                    powerPreference: e.powerPreference ?? "default"
                });
            }
        }
        ensureCanvasSize(e) {
            if (!this.multiView) {
                e !== this.canvas && _t("multiView is disabled, but targetCanvas is not the main canvas");
                return;
            }
            const { canvas: t } = this;
            (t.width < e.width || t.height < e.height) && (t.width = Math.max(e.width, e.width), t.height = Math.max(e.height, e.height));
        }
        initFromContext(e) {
            this.gl = e, this.webGLVersion = e instanceof jt.get().getWebGLRenderingContext() ? 1 : 2, this.getExtensions(), this.validateContext(e), this._renderer.runners.contextChange.emit(e);
            const t = this._renderer.view.canvas;
            t.addEventListener("webglcontextlost", this.handleContextLost, !1), t.addEventListener("webglcontextrestored", this.handleContextRestored, !1);
        }
        createContext(e, t) {
            let n;
            const s = this.canvas;
            if (e === 2 && (n = s.getContext("webgl2", t)), !n && (n = s.getContext("webgl", t), !n)) throw new Error("This browser does not support WebGL. Try using the canvas renderer");
            this.gl = n, this.initFromContext(this.gl);
        }
        getExtensions() {
            const { gl: e } = this, t = {
                anisotropicFiltering: e.getExtension("EXT_texture_filter_anisotropic"),
                floatTextureLinear: e.getExtension("OES_texture_float_linear"),
                s3tc: e.getExtension("WEBGL_compressed_texture_s3tc"),
                s3tc_sRGB: e.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
                etc: e.getExtension("WEBGL_compressed_texture_etc"),
                etc1: e.getExtension("WEBGL_compressed_texture_etc1"),
                pvrtc: e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
                atc: e.getExtension("WEBGL_compressed_texture_atc"),
                astc: e.getExtension("WEBGL_compressed_texture_astc"),
                bptc: e.getExtension("EXT_texture_compression_bptc"),
                rgtc: e.getExtension("EXT_texture_compression_rgtc"),
                loseContext: e.getExtension("WEBGL_lose_context")
            };
            if (this.webGLVersion === 1) this.extensions = {
                ...t,
                drawBuffers: e.getExtension("WEBGL_draw_buffers"),
                depthTexture: e.getExtension("WEBGL_depth_texture"),
                vertexArrayObject: e.getExtension("OES_vertex_array_object") || e.getExtension("MOZ_OES_vertex_array_object") || e.getExtension("WEBKIT_OES_vertex_array_object"),
                uint32ElementIndex: e.getExtension("OES_element_index_uint"),
                floatTexture: e.getExtension("OES_texture_float"),
                floatTextureLinear: e.getExtension("OES_texture_float_linear"),
                textureHalfFloat: e.getExtension("OES_texture_half_float"),
                textureHalfFloatLinear: e.getExtension("OES_texture_half_float_linear"),
                vertexAttribDivisorANGLE: e.getExtension("ANGLE_instanced_arrays"),
                srgb: e.getExtension("EXT_sRGB")
            };
            else {
                this.extensions = {
                    ...t,
                    colorBufferFloat: e.getExtension("EXT_color_buffer_float")
                };
                const n = e.getExtension("WEBGL_provoking_vertex");
                n && n.provokingVertexWEBGL(n.FIRST_VERTEX_CONVENTION_WEBGL);
            }
        }
        handleContextLost(e) {
            e.preventDefault(), this._contextLossForced && (this._contextLossForced = !1, setTimeout(()=>{
                this.gl.isContextLost() && this.extensions.loseContext?.restoreContext();
            }, 0));
        }
        handleContextRestored() {
            this.getExtensions(), this._renderer.runners.contextChange.emit(this.gl);
        }
        destroy() {
            const e = this._renderer.view.canvas;
            this._renderer = null, e.removeEventListener("webglcontextlost", this.handleContextLost), e.removeEventListener("webglcontextrestored", this.handleContextRestored), this.gl.useProgram(null), this.extensions.loseContext?.loseContext();
        }
        forceContextLoss() {
            this.extensions.loseContext?.loseContext(), this._contextLossForced = !0;
        }
        validateContext(e) {
            const t = e.getContextAttributes();
            t && !t.stencil && _t("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
            const n = this.supports, s = this.webGLVersion === 2, r = this.extensions;
            n.uint32Indices = s || !!r.uint32ElementIndex, n.uniformBufferObject = s, n.vertexArrayObject = s || !!r.vertexArrayObject, n.srgbTextures = s || !!r.srgb, n.nonPowOf2wrapping = s, n.nonPowOf2mipmaps = s, n.msaa = s, n.uint32Indices || _t("Provided WebGL context does not support 32 index buffer, large scenes may not render correctly");
        }
    };
    Eh.extension = {
        type: [
            se.WebGLSystem
        ],
        name: "context"
    };
    Eh.defaultOptions = {
        context: null,
        premultipliedAlpha: !0,
        preserveDrawingBuffer: !1,
        powerPreference: void 0,
        preferWebGLVersion: 2,
        multiView: !1
    };
    let YA = Eh;
    function qA(i, e) {
        for(const t in i.attributes){
            const n = i.attributes[t], s = e[t];
            s ? (n.format ?? (n.format = s.format), n.offset ?? (n.offset = s.offset), n.instance ?? (n.instance = s.instance)) : _t(`Attribute ${t} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);
        }
        jA(i);
    }
    function jA(i) {
        const { buffers: e, attributes: t } = i, n = {}, s = {};
        for(const r in e){
            const a = e[r];
            n[a.uid] = 0, s[a.uid] = 0;
        }
        for(const r in t){
            const a = t[r];
            n[a.buffer.uid] += Pr(a.format).stride;
        }
        for(const r in t){
            const a = t[r];
            a.stride ?? (a.stride = n[a.buffer.uid]), a.start ?? (a.start = s[a.buffer.uid]), s[a.buffer.uid] += Pr(a.format).stride;
        }
    }
    var Ll = ((i)=>(i[i.RGBA = 6408] = "RGBA", i[i.RGB = 6407] = "RGB", i[i.RG = 33319] = "RG", i[i.RED = 6403] = "RED", i[i.RGBA_INTEGER = 36249] = "RGBA_INTEGER", i[i.RGB_INTEGER = 36248] = "RGB_INTEGER", i[i.RG_INTEGER = 33320] = "RG_INTEGER", i[i.RED_INTEGER = 36244] = "RED_INTEGER", i[i.ALPHA = 6406] = "ALPHA", i[i.LUMINANCE = 6409] = "LUMINANCE", i[i.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", i[i.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", i[i.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL", i))(Ll || {}), Cm = ((i)=>(i[i.TEXTURE_2D = 3553] = "TEXTURE_2D", i[i.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", i[i.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", i[i.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", i[i.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", i[i.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", i[i.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", i[i.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", i[i.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z", i))(Cm || {}), et = ((i)=>(i[i.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", i[i.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", i[i.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", i[i.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", i[i.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", i[i.UNSIGNED_INT = 5125] = "UNSIGNED_INT", i[i.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", i[i.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", i[i.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", i[i.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", i[i.BYTE = 5120] = "BYTE", i[i.SHORT = 5122] = "SHORT", i[i.INT = 5124] = "INT", i[i.FLOAT = 5126] = "FLOAT", i[i.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", i[i.HALF_FLOAT = 36193] = "HALF_FLOAT", i))(et || {});
    const df = {
        uint8x2: et.UNSIGNED_BYTE,
        uint8x4: et.UNSIGNED_BYTE,
        sint8x2: et.BYTE,
        sint8x4: et.BYTE,
        unorm8x2: et.UNSIGNED_BYTE,
        unorm8x4: et.UNSIGNED_BYTE,
        snorm8x2: et.BYTE,
        snorm8x4: et.BYTE,
        uint16x2: et.UNSIGNED_SHORT,
        uint16x4: et.UNSIGNED_SHORT,
        sint16x2: et.SHORT,
        sint16x4: et.SHORT,
        unorm16x2: et.UNSIGNED_SHORT,
        unorm16x4: et.UNSIGNED_SHORT,
        snorm16x2: et.SHORT,
        snorm16x4: et.SHORT,
        float16x2: et.HALF_FLOAT,
        float16x4: et.HALF_FLOAT,
        float32: et.FLOAT,
        float32x2: et.FLOAT,
        float32x3: et.FLOAT,
        float32x4: et.FLOAT,
        uint32: et.UNSIGNED_INT,
        uint32x2: et.UNSIGNED_INT,
        uint32x3: et.UNSIGNED_INT,
        uint32x4: et.UNSIGNED_INT,
        sint32: et.INT,
        sint32x2: et.INT,
        sint32x3: et.INT,
        sint32x4: et.INT
    };
    function $A(i) {
        return df[i] ?? df.float32;
    }
    const KA = {
        "point-list": 0,
        "line-list": 1,
        "line-strip": 3,
        "triangle-list": 4,
        "triangle-strip": 5
    };
    class Pm {
        constructor(e){
            this._geometryVaoHash = Object.create(null), this._renderer = e, this._activeGeometry = null, this._activeVao = null, this.hasVao = !0, this.hasInstance = !0, this._renderer.renderableGC.addManagedHash(this, "_geometryVaoHash");
        }
        contextChange() {
            const e = this.gl = this._renderer.gl;
            if (!this._renderer.context.supports.vertexArrayObject) throw new Error("[PixiJS] Vertex Array Objects are not supported on this device");
            const t = this._renderer.context.extensions.vertexArrayObject;
            t && (e.createVertexArray = ()=>t.createVertexArrayOES(), e.bindVertexArray = (s)=>t.bindVertexArrayOES(s), e.deleteVertexArray = (s)=>t.deleteVertexArrayOES(s));
            const n = this._renderer.context.extensions.vertexAttribDivisorANGLE;
            n && (e.drawArraysInstanced = (s, r, a, o)=>{
                n.drawArraysInstancedANGLE(s, r, a, o);
            }, e.drawElementsInstanced = (s, r, a, o, c)=>{
                n.drawElementsInstancedANGLE(s, r, a, o, c);
            }, e.vertexAttribDivisor = (s, r)=>n.vertexAttribDivisorANGLE(s, r)), this._activeGeometry = null, this._activeVao = null, this._geometryVaoHash = Object.create(null);
        }
        bind(e, t) {
            const n = this.gl;
            this._activeGeometry = e;
            const s = this.getVao(e, t);
            this._activeVao !== s && (this._activeVao = s, n.bindVertexArray(s)), this.updateBuffers();
        }
        resetState() {
            this.unbind();
        }
        updateBuffers() {
            const e = this._activeGeometry, t = this._renderer.buffer;
            for(let n = 0; n < e.buffers.length; n++){
                const s = e.buffers[n];
                t.updateBuffer(s);
            }
        }
        checkCompatibility(e, t) {
            const n = e.attributes, s = t._attributeData;
            for(const r in s)if (!n[r]) throw new Error(`shader and geometry incompatible, geometry missing the "${r}" attribute`);
        }
        getSignature(e, t) {
            const n = e.attributes, s = t._attributeData, r = [
                "g",
                e.uid
            ];
            for(const a in n)s[a] && r.push(a, s[a].location);
            return r.join("-");
        }
        getVao(e, t) {
            return this._geometryVaoHash[e.uid]?.[t._key] || this.initGeometryVao(e, t);
        }
        initGeometryVao(e, t, n = !0) {
            const s = this._renderer.gl, r = this._renderer.buffer;
            this._renderer.shader._getProgramData(t), this.checkCompatibility(e, t);
            const a = this.getSignature(e, t);
            this._geometryVaoHash[e.uid] || (this._geometryVaoHash[e.uid] = Object.create(null), e.on("destroy", this.onGeometryDestroy, this));
            const o = this._geometryVaoHash[e.uid];
            let c = o[a];
            if (c) return o[t._key] = c, c;
            qA(e, t._attributeData);
            const l = e.buffers;
            c = s.createVertexArray(), s.bindVertexArray(c);
            for(let h = 0; h < l.length; h++){
                const u = l[h];
                r.bind(u);
            }
            return this.activateVao(e, t), o[t._key] = c, o[a] = c, s.bindVertexArray(null), c;
        }
        onGeometryDestroy(e, t) {
            const n = this._geometryVaoHash[e.uid], s = this.gl;
            if (n) {
                if (t) for(const r in n)this._activeVao !== n[r] && this.unbind(), s.deleteVertexArray(n[r]);
                this._geometryVaoHash[e.uid] = null;
            }
        }
        destroyAll(e = !1) {
            const t = this.gl;
            for(const n in this._geometryVaoHash){
                if (e) for(const s in this._geometryVaoHash[n]){
                    const r = this._geometryVaoHash[n];
                    this._activeVao !== r && this.unbind(), t.deleteVertexArray(r[s]);
                }
                this._geometryVaoHash[n] = null;
            }
        }
        activateVao(e, t) {
            const n = this._renderer.gl, s = this._renderer.buffer, r = e.attributes;
            e.indexBuffer && s.bind(e.indexBuffer);
            let a = null;
            for(const o in r){
                const c = r[o], l = c.buffer, h = s.getGlBuffer(l), u = t._attributeData[o];
                if (u) {
                    a !== h && (s.bind(l), a = h);
                    const d = u.location;
                    n.enableVertexAttribArray(d);
                    const f = Pr(c.format), _ = $A(c.format);
                    if (u.format?.substring(1, 4) === "int" ? n.vertexAttribIPointer(d, f.size, _, c.stride, c.offset) : n.vertexAttribPointer(d, f.size, _, f.normalised, c.stride, c.offset), c.instance) if (this.hasInstance) {
                        const g = c.divisor ?? 1;
                        n.vertexAttribDivisor(d, g);
                    } else throw new Error("geometry error, GPU Instancing is not supported on this device");
                }
            }
        }
        draw(e, t, n, s) {
            const { gl: r } = this._renderer, a = this._activeGeometry, o = KA[e || a.topology];
            if (s ?? (s = a.instanceCount), a.indexBuffer) {
                const c = a.indexBuffer.data.BYTES_PER_ELEMENT, l = c === 2 ? r.UNSIGNED_SHORT : r.UNSIGNED_INT;
                s > 1 ? r.drawElementsInstanced(o, t || a.indexBuffer.data.length, l, (n || 0) * c, s) : r.drawElements(o, t || a.indexBuffer.data.length, l, (n || 0) * c);
            } else s > 1 ? r.drawArraysInstanced(o, n || 0, t || a.getSize(), s) : r.drawArrays(o, n || 0, t || a.getSize());
            return this;
        }
        unbind() {
            this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null;
        }
        destroy() {
            this._renderer = null, this.gl = null, this._activeVao = null, this._activeGeometry = null;
        }
    }
    Pm.extension = {
        type: [
            se.WebGLSystem
        ],
        name: "geometry"
    };
    const ZA = new nm({
        attributes: {
            aPosition: [
                -1,
                -1,
                3,
                -1,
                -1,
                3
            ]
        }
    }), Ah = class Im {
        constructor(e){
            this.useBackBuffer = !1, this._useBackBufferThisRender = !1, this._renderer = e;
        }
        init(e = {}) {
            const { useBackBuffer: t, antialias: n } = {
                ...Im.defaultOptions,
                ...e
            };
            this.useBackBuffer = t, this._antialias = n, this._renderer.context.supports.msaa || (_t("antialiasing, is not supported on when using the back buffer"), this._antialias = !1), this._state = Fr.for2d();
            const s = new Br({
                vertex: `
                attribute vec2 aPosition;
                out vec2 vUv;

                void main() {
                    gl_Position = vec4(aPosition, 0.0, 1.0);

                    vUv = (aPosition + 1.0) / 2.0;

                    // flip dem UVs
                    vUv.y = 1.0 - vUv.y;
                }`,
                fragment: `
                in vec2 vUv;
                out vec4 finalColor;

                uniform sampler2D uTexture;

                void main() {
                    finalColor = texture(uTexture, vUv);
                }`,
                name: "big-triangle"
            });
            this._bigTriangleShader = new Ki({
                glProgram: s,
                resources: {
                    uTexture: Oe.WHITE.source
                }
            });
        }
        renderStart(e) {
            const t = this._renderer.renderTarget.getRenderTarget(e.target);
            if (this._useBackBufferThisRender = this.useBackBuffer && !!t.isRoot, this._useBackBufferThisRender) {
                const n = this._renderer.renderTarget.getRenderTarget(e.target);
                this._targetTexture = n.colorTexture, e.target = this._getBackBufferTexture(n.colorTexture);
            }
        }
        renderEnd() {
            this._presentBackBuffer();
        }
        _presentBackBuffer() {
            const e = this._renderer;
            e.renderTarget.finishRenderPass(), this._useBackBufferThisRender && (e.renderTarget.bind(this._targetTexture, !1), this._bigTriangleShader.resources.uTexture = this._backBufferTexture.source, e.encoder.draw({
                geometry: ZA,
                shader: this._bigTriangleShader,
                state: this._state
            }));
        }
        _getBackBufferTexture(e) {
            return this._backBufferTexture = this._backBufferTexture || new Oe({
                source: new Ut({
                    width: e.width,
                    height: e.height,
                    resolution: e._resolution,
                    antialias: this._antialias
                })
            }), this._backBufferTexture.source.resize(e.width, e.height, e._resolution), this._backBufferTexture;
        }
        destroy() {
            this._backBufferTexture && (this._backBufferTexture.destroy(), this._backBufferTexture = null);
        }
    };
    Ah.extension = {
        type: [
            se.WebGLSystem
        ],
        name: "backBuffer",
        priority: 1
    };
    Ah.defaultOptions = {
        useBackBuffer: !1
    };
    let JA = Ah;
    class Dm {
        constructor(e){
            this._colorMaskCache = 15, this._renderer = e;
        }
        setMask(e) {
            this._colorMaskCache !== e && (this._colorMaskCache = e, this._renderer.gl.colorMask(!!(e & 8), !!(e & 4), !!(e & 2), !!(e & 1)));
        }
    }
    Dm.extension = {
        type: [
            se.WebGLSystem
        ],
        name: "colorMask"
    };
    class Lm {
        constructor(e){
            this.commandFinished = Promise.resolve(), this._renderer = e;
        }
        setGeometry(e, t) {
            this._renderer.geometry.bind(e, t.glProgram);
        }
        finishRenderPass() {}
        draw(e) {
            const t = this._renderer, { geometry: n, shader: s, state: r, skipSync: a, topology: o, size: c, start: l, instanceCount: h } = e;
            t.shader.bind(s, a), t.geometry.bind(n, t.shader._activeProgram), r && t.state.set(r), t.geometry.draw(o, c, l, h ?? n.instanceCount);
        }
        destroy() {
            this._renderer = null;
        }
    }
    Lm.extension = {
        type: [
            se.WebGLSystem
        ],
        name: "encoder"
    };
    class QA {
        constructor(){
            this.width = -1, this.height = -1, this.msaa = !1, this.msaaRenderBuffer = [];
        }
    }
    const Zi = [];
    Zi[Ct.NONE] = void 0;
    Zi[Ct.DISABLED] = {
        stencilWriteMask: 0,
        stencilReadMask: 0
    };
    Zi[Ct.RENDERING_MASK_ADD] = {
        stencilFront: {
            compare: "equal",
            passOp: "increment-clamp"
        },
        stencilBack: {
            compare: "equal",
            passOp: "increment-clamp"
        }
    };
    Zi[Ct.RENDERING_MASK_REMOVE] = {
        stencilFront: {
            compare: "equal",
            passOp: "decrement-clamp"
        },
        stencilBack: {
            compare: "equal",
            passOp: "decrement-clamp"
        }
    };
    Zi[Ct.MASK_ACTIVE] = {
        stencilWriteMask: 0,
        stencilFront: {
            compare: "equal",
            passOp: "keep"
        },
        stencilBack: {
            compare: "equal",
            passOp: "keep"
        }
    };
    Zi[Ct.INVERSE_MASK_ACTIVE] = {
        stencilWriteMask: 0,
        stencilFront: {
            compare: "not-equal",
            passOp: "replace"
        },
        stencilBack: {
            compare: "not-equal",
            passOp: "replace"
        }
    };
    class Um {
        constructor(e){
            this._stencilCache = {
                enabled: !1,
                stencilReference: 0,
                stencilMode: Ct.NONE
            }, this._renderTargetStencilState = Object.create(null), e.renderTarget.onRenderTargetChange.add(this);
        }
        contextChange(e) {
            this._gl = e, this._comparisonFuncMapping = {
                always: e.ALWAYS,
                never: e.NEVER,
                equal: e.EQUAL,
                "not-equal": e.NOTEQUAL,
                less: e.LESS,
                "less-equal": e.LEQUAL,
                greater: e.GREATER,
                "greater-equal": e.GEQUAL
            }, this._stencilOpsMapping = {
                keep: e.KEEP,
                zero: e.ZERO,
                replace: e.REPLACE,
                invert: e.INVERT,
                "increment-clamp": e.INCR,
                "decrement-clamp": e.DECR,
                "increment-wrap": e.INCR_WRAP,
                "decrement-wrap": e.DECR_WRAP
            }, this.resetState();
        }
        onRenderTargetChange(e) {
            if (this._activeRenderTarget === e) return;
            this._activeRenderTarget = e;
            let t = this._renderTargetStencilState[e.uid];
            t || (t = this._renderTargetStencilState[e.uid] = {
                stencilMode: Ct.DISABLED,
                stencilReference: 0
            }), this.setStencilMode(t.stencilMode, t.stencilReference);
        }
        resetState() {
            this._stencilCache.enabled = !1, this._stencilCache.stencilMode = Ct.NONE, this._stencilCache.stencilReference = 0;
        }
        setStencilMode(e, t) {
            const n = this._renderTargetStencilState[this._activeRenderTarget.uid], s = this._gl, r = Zi[e], a = this._stencilCache;
            if (n.stencilMode = e, n.stencilReference = t, e === Ct.DISABLED) {
                this._stencilCache.enabled && (this._stencilCache.enabled = !1, s.disable(s.STENCIL_TEST));
                return;
            }
            this._stencilCache.enabled || (this._stencilCache.enabled = !0, s.enable(s.STENCIL_TEST)), (e !== a.stencilMode || a.stencilReference !== t) && (a.stencilMode = e, a.stencilReference = t, s.stencilFunc(this._comparisonFuncMapping[r.stencilBack.compare], t, 255), s.stencilOp(s.KEEP, s.KEEP, this._stencilOpsMapping[r.stencilBack.passOp]));
        }
    }
    Um.extension = {
        type: [
            se.WebGLSystem
        ],
        name: "stencil"
    };
    class ew {
        constructor(e){
            this._syncFunctionHash = Object.create(null), this._adaptor = e, this._systemCheck();
        }
        _systemCheck() {
            if (!qp()) throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
        }
        ensureUniformGroup(e) {
            const t = this.getUniformGroupData(e);
            e.buffer || (e.buffer = new qi({
                data: new Float32Array(t.layout.size / 4),
                usage: St.UNIFORM | St.COPY_DST
            }));
        }
        getUniformGroupData(e) {
            return this._syncFunctionHash[e._signature] || this._initUniformGroup(e);
        }
        _initUniformGroup(e) {
            const t = e._signature;
            let n = this._syncFunctionHash[t];
            if (!n) {
                const s = Object.keys(e.uniformStructures).map((o)=>e.uniformStructures[o]), r = this._adaptor.createUboElements(s), a = this._generateUboSync(r.uboElements);
                n = this._syncFunctionHash[t] = {
                    layout: r,
                    syncFunction: a
                };
            }
            return this._syncFunctionHash[t];
        }
        _generateUboSync(e) {
            return this._adaptor.generateUboSync(e);
        }
        syncUniformGroup(e, t, n) {
            const s = this.getUniformGroupData(e);
            e.buffer || (e.buffer = new qi({
                data: new Float32Array(s.layout.size / 4),
                usage: St.UNIFORM | St.COPY_DST
            }));
            let r = null;
            return t || (t = e.buffer.data, r = e.buffer.dataInt32), n || (n = 0), s.syncFunction(e.uniforms, t, r, n), !0;
        }
        updateUniformGroup(e) {
            if (e.isStatic && !e._dirtyId) return !1;
            e._dirtyId = 0;
            const t = this.syncUniformGroup(e);
            return e.buffer.update(), t;
        }
        destroy() {
            this._syncFunctionHash = null;
        }
    }
    const Nm = {
        f32: 4,
        i32: 4,
        "vec2<f32>": 8,
        "vec3<f32>": 12,
        "vec4<f32>": 16,
        "vec2<i32>": 8,
        "vec3<i32>": 12,
        "vec4<i32>": 16,
        "mat2x2<f32>": 16 * 2,
        "mat3x3<f32>": 16 * 3,
        "mat4x4<f32>": 16 * 4
    };
    function tw(i) {
        const e = i.map((r)=>({
                data: r,
                offset: 0,
                size: 0
            })), t = 16;
        let n = 0, s = 0;
        for(let r = 0; r < e.length; r++){
            const a = e[r];
            if (n = Nm[a.data.type], !n) throw new Error(`Unknown type ${a.data.type}`);
            a.data.size > 1 && (n = Math.max(n, t) * a.data.size);
            const o = n === 12 ? 16 : n;
            a.size = n;
            const c = s % t;
            c > 0 && t - c < o ? s += (t - c) % 16 : s += (n - c % n) % n, a.offset = s, s += n;
        }
        return s = Math.ceil(s / 16) * 16, {
            uboElements: e,
            size: s
        };
    }
    const Gi = [
        {
            type: "mat3x3<f32>",
            test: (i)=>i.value.a !== void 0,
            ubo: `
            var matrix = uv[name].toArray(true);
            data[offset] = matrix[0];
            data[offset + 1] = matrix[1];
            data[offset + 2] = matrix[2];
            data[offset + 4] = matrix[3];
            data[offset + 5] = matrix[4];
            data[offset + 6] = matrix[5];
            data[offset + 8] = matrix[6];
            data[offset + 9] = matrix[7];
            data[offset + 10] = matrix[8];
        `,
            uniform: `
            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));
        `
        },
        {
            type: "vec4<f32>",
            test: (i)=>i.type === "vec4<f32>" && i.size === 1 && i.value.width !== void 0,
            ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
            data[offset + 2] = v.width;
            data[offset + 3] = v.height;
        `,
            uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {
                cv[0] = v.x;
                cv[1] = v.y;
                cv[2] = v.width;
                cv[3] = v.height;
                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);
            }
        `
        },
        {
            type: "vec2<f32>",
            test: (i)=>i.type === "vec2<f32>" && i.size === 1 && i.value.x !== void 0,
            ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
        `,
            uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y) {
                cv[0] = v.x;
                cv[1] = v.y;
                gl.uniform2f(ud[name].location, v.x, v.y);
            }
        `
        },
        {
            type: "vec4<f32>",
            test: (i)=>i.type === "vec4<f32>" && i.size === 1 && i.value.red !== void 0,
            ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
            data[offset + 3] = v.alpha;
        `,
            uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                cv[3] = v.alpha;
                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);
            }
        `
        },
        {
            type: "vec3<f32>",
            test: (i)=>i.type === "vec3<f32>" && i.size === 1 && i.value.red !== void 0,
            ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
        `,
            uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);
            }
        `
        }
    ];
    function nw(i, e, t, n) {
        const s = [
            `
        var v = null;
        var v2 = null;
        var t = 0;
        var index = 0;
        var name = null;
        var arrayOffset = null;
    `
        ];
        let r = 0;
        for(let o = 0; o < i.length; o++){
            const c = i[o], l = c.data.name;
            let h = !1, u = 0;
            for(let d = 0; d < Gi.length; d++)if (Gi[d].test(c.data)) {
                u = c.offset / 4, s.push(`name = "${l}";`, `offset += ${u - r};`, Gi[d][e] || Gi[d].ubo), h = !0;
                break;
            }
            if (!h) if (c.data.size > 1) u = c.offset / 4, s.push(t(c, u - r));
            else {
                const d = n[c.data.type];
                u = c.offset / 4, s.push(`
                    v = uv.${l};
                    offset += ${u - r};
                    ${d};
                `);
            }
            r = u;
        }
        const a = s.join(`
`);
        return new Function("uv", "data", "dataInt32", "offset", a);
    }
    function ms(i, e) {
        return `
        for (let i = 0; i < ${i * e}; i++) {
            data[offset + (((i / ${i})|0) * 4) + (i % ${i})] = v[i];
        }
    `;
    }
    const Bm = {
        f32: `
        data[offset] = v;`,
        i32: `
        dataInt32[offset] = v;`,
        "vec2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];`,
        "vec3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];`,
        "vec4<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];`,
        "vec2<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];`,
        "vec3<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];`,
        "vec4<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];
        dataInt32[offset + 3] = v[3];`,
        "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 4] = v[2];
        data[offset + 5] = v[3];`,
        "mat3x3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];
        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];`,
        "mat4x4<f32>": `
        for (let i = 0; i < 16; i++) {
            data[offset + i] = v[i];
        }`,
        "mat3x2<f32>": ms(3, 2),
        "mat4x2<f32>": ms(4, 2),
        "mat2x3<f32>": ms(2, 3),
        "mat4x3<f32>": ms(4, 3),
        "mat2x4<f32>": ms(2, 4),
        "mat3x4<f32>": ms(3, 4)
    };
    ({
        ...Bm
    });
    function iw(i, e) {
        const t = Math.max(Nm[i.data.type] / 16, 1), n = i.data.value.length / i.data.size, s = (4 - n % 4) % 4, r = i.data.type.indexOf("i32") >= 0 ? "dataInt32" : "data";
        return `
        v = uv.${i.data.name};
        offset += ${e};

        arrayOffset = offset;

        t = 0;

        for(var i=0; i < ${i.data.size * t}; i++)
        {
            for(var j = 0; j < ${n}; j++)
            {
                ${r}[arrayOffset++] = v[t++];
            }
            ${s !== 0 ? `arrayOffset += ${s};` : ""}
        }
    `;
    }
    function sw(i) {
        return nw(i, "uboStd40", iw, Bm);
    }
    class Fm extends ew {
        constructor(){
            super({
                createUboElements: tw,
                generateUboSync: sw
            });
        }
    }
    Fm.extension = {
        type: [
            se.WebGLSystem
        ],
        name: "ubo"
    };
    class rw {
        constructor(){
            this._clearColorCache = [
                0,
                0,
                0,
                0
            ], this._viewPortCache = new ft;
        }
        init(e, t) {
            this._renderer = e, this._renderTargetSystem = t, e.runners.contextChange.add(this);
        }
        contextChange() {
            this._clearColorCache = [
                0,
                0,
                0,
                0
            ], this._viewPortCache = new ft;
        }
        copyToTexture(e, t, n, s, r) {
            const a = this._renderTargetSystem, o = this._renderer, c = a.getGpuRenderTarget(e), l = o.gl;
            return this.finishRenderPass(e), l.bindFramebuffer(l.FRAMEBUFFER, c.resolveTargetFramebuffer), o.texture.bind(t, 0), l.copyTexSubImage2D(l.TEXTURE_2D, 0, r.x, r.y, n.x, n.y, s.width, s.height), t;
        }
        startRenderPass(e, t = !0, n, s) {
            const r = this._renderTargetSystem, a = e.colorTexture, o = r.getGpuRenderTarget(e);
            let c = s.y;
            e.isRoot && (c = a.pixelHeight - s.height), e.colorTextures.forEach((u)=>{
                this._renderer.texture.unbind(u);
            });
            const l = this._renderer.gl;
            l.bindFramebuffer(l.FRAMEBUFFER, o.framebuffer);
            const h = this._viewPortCache;
            (h.x !== s.x || h.y !== c || h.width !== s.width || h.height !== s.height) && (h.x = s.x, h.y = c, h.width = s.width, h.height = s.height, l.viewport(s.x, c, s.width, s.height)), !o.depthStencilRenderBuffer && (e.stencil || e.depth) && this._initStencil(o), this.clear(e, t, n);
        }
        finishRenderPass(e) {
            const n = this._renderTargetSystem.getGpuRenderTarget(e);
            if (!n.msaa) return;
            const s = this._renderer.gl;
            s.bindFramebuffer(s.FRAMEBUFFER, n.resolveTargetFramebuffer), s.bindFramebuffer(s.READ_FRAMEBUFFER, n.framebuffer), s.blitFramebuffer(0, 0, n.width, n.height, 0, 0, n.width, n.height, s.COLOR_BUFFER_BIT, s.NEAREST), s.bindFramebuffer(s.FRAMEBUFFER, n.framebuffer);
        }
        initGpuRenderTarget(e) {
            const n = this._renderer.gl, s = new QA, r = e.colorTexture;
            return _i.test(r.resource) ? (this._renderer.context.ensureCanvasSize(e.colorTexture.resource), s.framebuffer = null, s) : (this._initColor(e, s), n.bindFramebuffer(n.FRAMEBUFFER, null), s);
        }
        destroyGpuRenderTarget(e) {
            const t = this._renderer.gl;
            e.framebuffer && (t.deleteFramebuffer(e.framebuffer), e.framebuffer = null), e.resolveTargetFramebuffer && (t.deleteFramebuffer(e.resolveTargetFramebuffer), e.resolveTargetFramebuffer = null), e.depthStencilRenderBuffer && (t.deleteRenderbuffer(e.depthStencilRenderBuffer), e.depthStencilRenderBuffer = null), e.msaaRenderBuffer.forEach((n)=>{
                t.deleteRenderbuffer(n);
            }), e.msaaRenderBuffer = null;
        }
        clear(e, t, n) {
            if (!t) return;
            const s = this._renderTargetSystem;
            typeof t == "boolean" && (t = t ? gi.ALL : gi.NONE);
            const r = this._renderer.gl;
            if (t & gi.COLOR) {
                n ?? (n = s.defaultClearColor);
                const a = this._clearColorCache, o = n;
                (a[0] !== o[0] || a[1] !== o[1] || a[2] !== o[2] || a[3] !== o[3]) && (a[0] = o[0], a[1] = o[1], a[2] = o[2], a[3] = o[3], r.clearColor(o[0], o[1], o[2], o[3]));
            }
            r.clear(t);
        }
        resizeGpuRenderTarget(e) {
            if (e.isRoot) return;
            const n = this._renderTargetSystem.getGpuRenderTarget(e);
            this._resizeColor(e, n), (e.stencil || e.depth) && this._resizeStencil(n);
        }
        _initColor(e, t) {
            const n = this._renderer, s = n.gl, r = s.createFramebuffer();
            if (t.resolveTargetFramebuffer = r, s.bindFramebuffer(s.FRAMEBUFFER, r), t.width = e.colorTexture.source.pixelWidth, t.height = e.colorTexture.source.pixelHeight, e.colorTextures.forEach((a, o)=>{
                const c = a.source;
                c.antialias && (n.context.supports.msaa ? t.msaa = !0 : _t("[RenderTexture] Antialiasing on textures is not supported in WebGL1")), n.texture.bindSource(c, 0);
                const h = n.texture.getGlSource(c).texture;
                s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + o, 3553, h, 0);
            }), t.msaa) {
                const a = s.createFramebuffer();
                t.framebuffer = a, s.bindFramebuffer(s.FRAMEBUFFER, a), e.colorTextures.forEach((o, c)=>{
                    const l = s.createRenderbuffer();
                    t.msaaRenderBuffer[c] = l;
                });
            } else t.framebuffer = r;
            this._resizeColor(e, t);
        }
        _resizeColor(e, t) {
            const n = e.colorTexture.source;
            if (t.width = n.pixelWidth, t.height = n.pixelHeight, e.colorTextures.forEach((s, r)=>{
                r !== 0 && s.source.resize(n.width, n.height, n._resolution);
            }), t.msaa) {
                const s = this._renderer, r = s.gl, a = t.framebuffer;
                r.bindFramebuffer(r.FRAMEBUFFER, a), e.colorTextures.forEach((o, c)=>{
                    const l = o.source;
                    s.texture.bindSource(l, 0);
                    const u = s.texture.getGlSource(l).internalFormat, d = t.msaaRenderBuffer[c];
                    r.bindRenderbuffer(r.RENDERBUFFER, d), r.renderbufferStorageMultisample(r.RENDERBUFFER, 4, u, l.pixelWidth, l.pixelHeight), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + c, r.RENDERBUFFER, d);
                });
            }
        }
        _initStencil(e) {
            if (e.framebuffer === null) return;
            const t = this._renderer.gl, n = t.createRenderbuffer();
            e.depthStencilRenderBuffer = n, t.bindRenderbuffer(t.RENDERBUFFER, n), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, n), this._resizeStencil(e);
        }
        _resizeStencil(e) {
            const t = this._renderer.gl;
            t.bindRenderbuffer(t.RENDERBUFFER, e.depthStencilRenderBuffer), e.msaa ? t.renderbufferStorageMultisample(t.RENDERBUFFER, 4, t.DEPTH24_STENCIL8, e.width, e.height) : t.renderbufferStorage(t.RENDERBUFFER, this._renderer.context.webGLVersion === 2 ? t.DEPTH24_STENCIL8 : t.DEPTH_STENCIL, e.width, e.height);
        }
        prerender(e) {
            const t = e.colorTexture.resource;
            this._renderer.context.multiView && _i.test(t) && this._renderer.context.ensureCanvasSize(t);
        }
        postrender(e) {
            if (this._renderer.context.multiView && _i.test(e.colorTexture.resource)) {
                const t = this._renderer.context.canvas, n = e.colorTexture;
                n.context2D.drawImage(t, 0, n.pixelHeight - t.height);
            }
        }
    }
    function aw(i, e, t, n, s, r) {
        const a = r ? 1 : -1;
        return i.identity(), i.a = 1 / n * 2, i.d = a * (1 / s * 2), i.tx = -1 - e * i.a, i.ty = -a - t * i.d, i;
    }
    const rr = new Map;
    function Om(i, e) {
        if (!rr.has(i)) {
            const t = new Oe({
                source: new _i({
                    resource: i,
                    ...e
                })
            }), n = ()=>{
                rr.get(i) === t && rr.delete(i);
            };
            t.once("destroy", n), t.source.once("destroy", n), rr.set(i, t);
        }
        return rr.get(i);
    }
    function ow(i) {
        const e = i.colorTexture.source.resource;
        return globalThis.HTMLCanvasElement && e instanceof HTMLCanvasElement && document.body.contains(e);
    }
    const km = class Gm {
        constructor(e = {}){
            if (this.uid = pt("renderTarget"), this.colorTextures = [], this.dirtyId = 0, this.isRoot = !1, this._size = new Float32Array(2), this._managedColorTextures = !1, e = {
                ...Gm.defaultOptions,
                ...e
            }, this.stencil = e.stencil, this.depth = e.depth, this.isRoot = e.isRoot, typeof e.colorTextures == "number") {
                this._managedColorTextures = !0;
                for(let t = 0; t < e.colorTextures; t++)this.colorTextures.push(new Ut({
                    width: e.width,
                    height: e.height,
                    resolution: e.resolution,
                    antialias: e.antialias
                }));
            } else {
                this.colorTextures = [
                    ...e.colorTextures.map((n)=>n.source)
                ];
                const t = this.colorTexture.source;
                this.resize(t.width, t.height, t._resolution);
            }
            this.colorTexture.source.on("resize", this.onSourceResize, this), (e.depthStencilTexture || this.stencil) && (e.depthStencilTexture instanceof Oe || e.depthStencilTexture instanceof Ut ? this.depthStencilTexture = e.depthStencilTexture.source : this.ensureDepthStencilTexture());
        }
        get size() {
            const e = this._size;
            return e[0] = this.pixelWidth, e[1] = this.pixelHeight, e;
        }
        get width() {
            return this.colorTexture.source.width;
        }
        get height() {
            return this.colorTexture.source.height;
        }
        get pixelWidth() {
            return this.colorTexture.source.pixelWidth;
        }
        get pixelHeight() {
            return this.colorTexture.source.pixelHeight;
        }
        get resolution() {
            return this.colorTexture.source._resolution;
        }
        get colorTexture() {
            return this.colorTextures[0];
        }
        onSourceResize(e) {
            this.resize(e.width, e.height, e._resolution, !0);
        }
        ensureDepthStencilTexture() {
            this.depthStencilTexture || (this.depthStencilTexture = new Ut({
                width: this.width,
                height: this.height,
                resolution: this.resolution,
                format: "depth24plus-stencil8",
                autoGenerateMipmaps: !1,
                antialias: !1,
                mipLevelCount: 1
            }));
        }
        resize(e, t, n = this.resolution, s = !1) {
            this.dirtyId++, this.colorTextures.forEach((r, a)=>{
                s && a === 0 || r.source.resize(e, t, n);
            }), this.depthStencilTexture && this.depthStencilTexture.source.resize(e, t, n);
        }
        destroy() {
            this.colorTexture.source.off("resize", this.onSourceResize, this), this._managedColorTextures && this.colorTextures.forEach((e)=>{
                e.destroy();
            }), this.depthStencilTexture && (this.depthStencilTexture.destroy(), delete this.depthStencilTexture);
        }
    };
    km.defaultOptions = {
        width: 0,
        height: 0,
        resolution: 1,
        colorTextures: 1,
        stencil: !1,
        depth: !1,
        antialias: !1,
        isRoot: !1
    };
    let Ul = km;
    class cw {
        constructor(e){
            this.rootViewPort = new ft, this.viewport = new ft, this.onRenderTargetChange = new jp("onRenderTargetChange"), this.projectionMatrix = new Fe, this.defaultClearColor = [
                0,
                0,
                0,
                0
            ], this._renderSurfaceToRenderTargetHash = new Map, this._gpuRenderTargetHash = Object.create(null), this._renderTargetStack = [], this._renderer = e, e.renderableGC.addManagedHash(this, "_gpuRenderTargetHash");
        }
        finishRenderPass() {
            this.adaptor.finishRenderPass(this.renderTarget);
        }
        renderStart({ target: e, clear: t, clearColor: n, frame: s }) {
            this._renderTargetStack.length = 0, this.push(e, t, n, s), this.rootViewPort.copyFrom(this.viewport), this.rootRenderTarget = this.renderTarget, this.renderingToScreen = ow(this.rootRenderTarget), this.adaptor.prerender?.(this.rootRenderTarget);
        }
        postrender() {
            this.adaptor.postrender?.(this.rootRenderTarget);
        }
        bind(e, t = !0, n, s) {
            const r = this.getRenderTarget(e), a = this.renderTarget !== r;
            this.renderTarget = r, this.renderSurface = e;
            const o = this.getGpuRenderTarget(r);
            (r.pixelWidth !== o.width || r.pixelHeight !== o.height) && (this.adaptor.resizeGpuRenderTarget(r), o.width = r.pixelWidth, o.height = r.pixelHeight);
            const c = r.colorTexture, l = this.viewport, h = c.pixelWidth, u = c.pixelHeight;
            if (!s && e instanceof Oe && (s = e.frame), s) {
                const d = c._resolution;
                l.x = s.x * d + .5 | 0, l.y = s.y * d + .5 | 0, l.width = s.width * d + .5 | 0, l.height = s.height * d + .5 | 0;
            } else l.x = 0, l.y = 0, l.width = h, l.height = u;
            return aw(this.projectionMatrix, 0, 0, l.width / c.resolution, l.height / c.resolution, !r.isRoot), this.adaptor.startRenderPass(r, t, n, l), a && this.onRenderTargetChange.emit(r), r;
        }
        clear(e, t = gi.ALL, n) {
            t && (e && (e = this.getRenderTarget(e)), this.adaptor.clear(e || this.renderTarget, t, n, this.viewport));
        }
        contextChange() {
            this._gpuRenderTargetHash = Object.create(null);
        }
        push(e, t = gi.ALL, n, s) {
            const r = this.bind(e, t, n, s);
            return this._renderTargetStack.push({
                renderTarget: r,
                frame: s
            }), r;
        }
        pop() {
            this._renderTargetStack.pop();
            const e = this._renderTargetStack[this._renderTargetStack.length - 1];
            this.bind(e.renderTarget, !1, null, e.frame);
        }
        getRenderTarget(e) {
            return e.isTexture && (e = e.source), this._renderSurfaceToRenderTargetHash.get(e) ?? this._initRenderTarget(e);
        }
        copyToTexture(e, t, n, s, r) {
            n.x < 0 && (s.width += n.x, r.x -= n.x, n.x = 0), n.y < 0 && (s.height += n.y, r.y -= n.y, n.y = 0);
            const { pixelWidth: a, pixelHeight: o } = e;
            return s.width = Math.min(s.width, a - n.x), s.height = Math.min(s.height, o - n.y), this.adaptor.copyToTexture(e, t, n, s, r);
        }
        ensureDepthStencil() {
            this.renderTarget.stencil || (this.renderTarget.stencil = !0, this.adaptor.startRenderPass(this.renderTarget, !1, null, this.viewport));
        }
        destroy() {
            this._renderer = null, this._renderSurfaceToRenderTargetHash.forEach((e, t)=>{
                e !== t && e.destroy();
            }), this._renderSurfaceToRenderTargetHash.clear(), this._gpuRenderTargetHash = Object.create(null);
        }
        _initRenderTarget(e) {
            let t = null;
            return _i.test(e) && (e = Om(e).source), e instanceof Ul ? t = e : e instanceof Ut && (t = new Ul({
                colorTextures: [
                    e
                ]
            }), _i.test(e.source.resource) && (t.isRoot = !0), e.once("destroy", ()=>{
                t.destroy(), this._renderSurfaceToRenderTargetHash.delete(e);
                const n = this._gpuRenderTargetHash[t.uid];
                n && (this._gpuRenderTargetHash[t.uid] = null, this.adaptor.destroyGpuRenderTarget(n));
            })), this._renderSurfaceToRenderTargetHash.set(e, t), t;
        }
        getGpuRenderTarget(e) {
            return this._gpuRenderTargetHash[e.uid] || (this._gpuRenderTargetHash[e.uid] = this.adaptor.initGpuRenderTarget(e));
        }
        resetState() {
            this.renderTarget = null, this.renderSurface = null;
        }
    }
    class Hm extends cw {
        constructor(e){
            super(e), this.adaptor = new rw, this.adaptor.init(e, this);
        }
    }
    Hm.extension = {
        type: [
            se.WebGLSystem
        ],
        name: "renderTarget"
    };
    class zm extends Cn {
        constructor({ buffer: e, offset: t, size: n }){
            super(), this.uid = pt("buffer"), this._resourceType = "bufferResource", this._touched = 0, this._resourceId = pt("resource"), this._bufferResource = !0, this.destroyed = !1, this.buffer = e, this.offset = t | 0, this.size = n, this.buffer.on("change", this.onBufferChange, this);
        }
        onBufferChange() {
            this._resourceId = pt("resource"), this.emit("change", this);
        }
        destroy(e = !1) {
            this.destroyed = !0, e && this.buffer.destroy(), this.emit("change", this), this.buffer = null;
        }
    }
    function lw(i, e) {
        const t = [], n = [
            `
        var g = s.groups;
        var sS = r.shader;
        var p = s.glProgram;
        var ugS = r.uniformGroup;
        var resources;
    `
        ];
        let s = !1, r = 0;
        const a = e._getProgramData(i.glProgram);
        for(const c in i.groups){
            const l = i.groups[c];
            t.push(`
            resources = g[${c}].resources;
        `);
            for(const h in l.resources){
                const u = l.resources[h];
                if (u instanceof $i) if (u.ubo) {
                    const d = i._uniformBindMap[c][Number(h)];
                    t.push(`
                        sS.bindUniformBlock(
                            resources[${h}],
                            '${d}',
                            ${i.glProgram._uniformBlockData[d].index}
                        );
                    `);
                } else t.push(`
                        ugS.updateUniformGroup(resources[${h}], p, sD);
                    `);
                else if (u instanceof zm) {
                    const d = i._uniformBindMap[c][Number(h)];
                    t.push(`
                    sS.bindUniformBlock(
                        resources[${h}],
                        '${d}',
                        ${i.glProgram._uniformBlockData[d].index}
                    );
                `);
                } else if (u instanceof Ut) {
                    const d = i._uniformBindMap[c][h], f = a.uniformData[d];
                    f && (s || (s = !0, n.push(`
                        var tS = r.texture;
                        `)), e._gl.uniform1i(f.location, r), t.push(`
                        tS.bind(resources[${h}], ${r});
                    `), r++);
                }
            }
        }
        const o = [
            ...n,
            ...t
        ].join(`
`);
        return new Function("r", "s", "sD", o);
    }
    class hw {
        constructor(e, t){
            this.program = e, this.uniformData = t, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBlockBindings = {};
        }
        destroy() {
            this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBlockBindings = null, this.program = null;
        }
    }
    function ff(i, e, t) {
        const n = i.createShader(e);
        return i.shaderSource(n, t), i.compileShader(n), n;
    }
    function yc(i) {
        const e = new Array(i);
        for(let t = 0; t < e.length; t++)e[t] = !1;
        return e;
    }
    function Vm(i, e) {
        switch(i){
            case "float":
                return 0;
            case "vec2":
                return new Float32Array(2 * e);
            case "vec3":
                return new Float32Array(3 * e);
            case "vec4":
                return new Float32Array(4 * e);
            case "int":
            case "uint":
            case "sampler2D":
            case "sampler2DArray":
                return 0;
            case "ivec2":
                return new Int32Array(2 * e);
            case "ivec3":
                return new Int32Array(3 * e);
            case "ivec4":
                return new Int32Array(4 * e);
            case "uvec2":
                return new Uint32Array(2 * e);
            case "uvec3":
                return new Uint32Array(3 * e);
            case "uvec4":
                return new Uint32Array(4 * e);
            case "bool":
                return !1;
            case "bvec2":
                return yc(2 * e);
            case "bvec3":
                return yc(3 * e);
            case "bvec4":
                return yc(4 * e);
            case "mat2":
                return new Float32Array([
                    1,
                    0,
                    0,
                    1
                ]);
            case "mat3":
                return new Float32Array([
                    1,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    1
                ]);
            case "mat4":
                return new Float32Array([
                    1,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    1
                ]);
        }
        return null;
    }
    let Sa = null;
    const pf = {
        FLOAT: "float",
        FLOAT_VEC2: "vec2",
        FLOAT_VEC3: "vec3",
        FLOAT_VEC4: "vec4",
        INT: "int",
        INT_VEC2: "ivec2",
        INT_VEC3: "ivec3",
        INT_VEC4: "ivec4",
        UNSIGNED_INT: "uint",
        UNSIGNED_INT_VEC2: "uvec2",
        UNSIGNED_INT_VEC3: "uvec3",
        UNSIGNED_INT_VEC4: "uvec4",
        BOOL: "bool",
        BOOL_VEC2: "bvec2",
        BOOL_VEC3: "bvec3",
        BOOL_VEC4: "bvec4",
        FLOAT_MAT2: "mat2",
        FLOAT_MAT3: "mat3",
        FLOAT_MAT4: "mat4",
        SAMPLER_2D: "sampler2D",
        INT_SAMPLER_2D: "sampler2D",
        UNSIGNED_INT_SAMPLER_2D: "sampler2D",
        SAMPLER_CUBE: "samplerCube",
        INT_SAMPLER_CUBE: "samplerCube",
        UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
        SAMPLER_2D_ARRAY: "sampler2DArray",
        INT_SAMPLER_2D_ARRAY: "sampler2DArray",
        UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
    }, uw = {
        float: "float32",
        vec2: "float32x2",
        vec3: "float32x3",
        vec4: "float32x4",
        int: "sint32",
        ivec2: "sint32x2",
        ivec3: "sint32x3",
        ivec4: "sint32x4",
        uint: "uint32",
        uvec2: "uint32x2",
        uvec3: "uint32x3",
        uvec4: "uint32x4",
        bool: "uint32",
        bvec2: "uint32x2",
        bvec3: "uint32x3",
        bvec4: "uint32x4"
    };
    function Wm(i, e) {
        if (!Sa) {
            const t = Object.keys(pf);
            Sa = {};
            for(let n = 0; n < t.length; ++n){
                const s = t[n];
                Sa[i[s]] = pf[s];
            }
        }
        return Sa[e];
    }
    function dw(i, e) {
        const t = Wm(i, e);
        return uw[t] || "float32";
    }
    function fw(i, e, t = !1) {
        const n = {}, s = e.getProgramParameter(i, e.ACTIVE_ATTRIBUTES);
        for(let a = 0; a < s; a++){
            const o = e.getActiveAttrib(i, a);
            if (o.name.startsWith("gl_")) continue;
            const c = dw(e, o.type);
            n[o.name] = {
                location: 0,
                format: c,
                stride: Pr(c).stride,
                offset: 0,
                instance: !1,
                start: 0
            };
        }
        const r = Object.keys(n);
        if (t) {
            r.sort((a, o)=>a > o ? 1 : -1);
            for(let a = 0; a < r.length; a++)n[r[a]].location = a, e.bindAttribLocation(i, a, r[a]);
            e.linkProgram(i);
        } else for(let a = 0; a < r.length; a++)n[r[a]].location = e.getAttribLocation(i, r[a]);
        return n;
    }
    function pw(i, e) {
        if (!e.ACTIVE_UNIFORM_BLOCKS) return {};
        const t = {}, n = e.getProgramParameter(i, e.ACTIVE_UNIFORM_BLOCKS);
        for(let s = 0; s < n; s++){
            const r = e.getActiveUniformBlockName(i, s), a = e.getUniformBlockIndex(i, r), o = e.getActiveUniformBlockParameter(i, s, e.UNIFORM_BLOCK_DATA_SIZE);
            t[r] = {
                name: r,
                index: a,
                size: o
            };
        }
        return t;
    }
    function mw(i, e) {
        const t = {}, n = e.getProgramParameter(i, e.ACTIVE_UNIFORMS);
        for(let s = 0; s < n; s++){
            const r = e.getActiveUniform(i, s), a = r.name.replace(/\[.*?\]$/, ""), o = !!r.name.match(/\[.*?\]$/), c = Wm(e, r.type);
            t[a] = {
                name: a,
                index: s,
                type: c,
                size: r.size,
                isArray: o,
                value: Vm(c, r.size)
            };
        }
        return t;
    }
    function mf(i, e) {
        const t = i.getShaderSource(e).split(`
`).map((l, h)=>`${h}: ${l}`), n = i.getShaderInfoLog(e), s = n.split(`
`), r = {}, a = s.map((l)=>parseFloat(l.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter((l)=>l && !r[l] ? (r[l] = !0, !0) : !1), o = [
            ""
        ];
        a.forEach((l)=>{
            t[l - 1] = `%c${t[l - 1]}%c`, o.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
        });
        const c = t.join(`
`);
        o[0] = c, console.error(n), console.groupCollapsed("click to view full shader code"), console.warn(...o), console.groupEnd();
    }
    function _w(i, e, t, n) {
        i.getProgramParameter(e, i.LINK_STATUS) || (i.getShaderParameter(t, i.COMPILE_STATUS) || mf(i, t), i.getShaderParameter(n, i.COMPILE_STATUS) || mf(i, n), console.error("PixiJS Error: Could not initialize shader."), i.getProgramInfoLog(e) !== "" && console.warn("PixiJS Warning: gl.getProgramInfoLog()", i.getProgramInfoLog(e)));
    }
    function gw(i, e) {
        const t = ff(i, i.VERTEX_SHADER, e.vertex), n = ff(i, i.FRAGMENT_SHADER, e.fragment), s = i.createProgram();
        i.attachShader(s, t), i.attachShader(s, n);
        const r = e.transformFeedbackVaryings;
        r && (typeof i.transformFeedbackVaryings != "function" ? _t("TransformFeedback is not supported but TransformFeedbackVaryings are given.") : i.transformFeedbackVaryings(s, r.names, r.bufferMode === "separate" ? i.SEPARATE_ATTRIBS : i.INTERLEAVED_ATTRIBS)), i.linkProgram(s), i.getProgramParameter(s, i.LINK_STATUS) || _w(i, s, t, n), e._attributeData = fw(s, i, !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(e.vertex)), e._uniformData = mw(s, i), e._uniformBlockData = pw(s, i), i.deleteShader(t), i.deleteShader(n);
        const a = {};
        for(const c in e._uniformData){
            const l = e._uniformData[c];
            a[c] = {
                location: i.getUniformLocation(s, c),
                value: Vm(l.type, l.size)
            };
        }
        return new hw(s, a);
    }
    const Ma = {
        textureCount: 0,
        blockIndex: 0
    };
    class Xm {
        constructor(e){
            this._activeProgram = null, this._programDataHash = Object.create(null), this._shaderSyncFunctions = Object.create(null), this._renderer = e, this._renderer.renderableGC.addManagedHash(this, "_programDataHash");
        }
        contextChange(e) {
            this._gl = e, this._programDataHash = Object.create(null), this._shaderSyncFunctions = Object.create(null), this._activeProgram = null, this.maxTextures = eo();
        }
        bind(e, t) {
            if (this._setProgram(e.glProgram), t) return;
            Ma.textureCount = 0, Ma.blockIndex = 0;
            let n = this._shaderSyncFunctions[e.glProgram._key];
            n || (n = this._shaderSyncFunctions[e.glProgram._key] = this._generateShaderSync(e, this)), this._renderer.buffer.nextBindBase(!!e.glProgram.transformFeedbackVaryings), n(this._renderer, e, Ma);
        }
        updateUniformGroup(e) {
            this._renderer.uniformGroup.updateUniformGroup(e, this._activeProgram, Ma);
        }
        bindUniformBlock(e, t, n = 0) {
            const s = this._renderer.buffer, r = this._getProgramData(this._activeProgram), a = e._bufferResource;
            a || this._renderer.ubo.updateUniformGroup(e);
            const o = e.buffer, c = s.updateBuffer(o), l = s.freeLocationForBufferBase(c);
            if (a) {
                const { offset: u, size: d } = e;
                u === 0 && d === o.data.byteLength ? s.bindBufferBase(c, l) : s.bindBufferRange(c, l, u);
            } else s.getLastBindBaseLocation(c) !== l && s.bindBufferBase(c, l);
            const h = this._activeProgram._uniformBlockData[t].index;
            r.uniformBlockBindings[n] !== l && (r.uniformBlockBindings[n] = l, this._renderer.gl.uniformBlockBinding(r.program, h, l));
        }
        _setProgram(e) {
            if (this._activeProgram === e) return;
            this._activeProgram = e;
            const t = this._getProgramData(e);
            this._gl.useProgram(t.program);
        }
        _getProgramData(e) {
            return this._programDataHash[e._key] || this._createProgramData(e);
        }
        _createProgramData(e) {
            const t = e._key;
            return this._programDataHash[t] = gw(this._gl, e), this._programDataHash[t];
        }
        destroy() {
            for (const e of Object.keys(this._programDataHash))this._programDataHash[e].destroy(), this._programDataHash[e] = null;
            this._programDataHash = null;
        }
        _generateShaderSync(e, t) {
            return lw(e, t);
        }
        resetState() {
            this._activeProgram = null;
        }
    }
    Xm.extension = {
        type: [
            se.WebGLSystem
        ],
        name: "shader"
    };
    const xw = {
        f32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1f(location, v);
        }`,
        "vec2<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2f(location, v[0], v[1]);
        }`,
        "vec3<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3f(location, v[0], v[1], v[2]);
        }`,
        "vec4<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4f(location, v[0], v[1], v[2], v[3]);
        }`,
        i32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
        "vec2<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
        "vec3<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
        "vec4<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
        u32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1ui(location, v);
        }`,
        "vec2<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2ui(location, v[0], v[1]);
        }`,
        "vec3<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3ui(location, v[0], v[1], v[2]);
        }`,
        "vec4<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
        }`,
        bool: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
        "vec2<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
        "vec3<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
        "vec4<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
        "mat2x2<f32>": "gl.uniformMatrix2fv(location, false, v);",
        "mat3x3<f32>": "gl.uniformMatrix3fv(location, false, v);",
        "mat4x4<f32>": "gl.uniformMatrix4fv(location, false, v);"
    }, vw = {
        f32: "gl.uniform1fv(location, v);",
        "vec2<f32>": "gl.uniform2fv(location, v);",
        "vec3<f32>": "gl.uniform3fv(location, v);",
        "vec4<f32>": "gl.uniform4fv(location, v);",
        "mat2x2<f32>": "gl.uniformMatrix2fv(location, false, v);",
        "mat3x3<f32>": "gl.uniformMatrix3fv(location, false, v);",
        "mat4x4<f32>": "gl.uniformMatrix4fv(location, false, v);",
        i32: "gl.uniform1iv(location, v);",
        "vec2<i32>": "gl.uniform2iv(location, v);",
        "vec3<i32>": "gl.uniform3iv(location, v);",
        "vec4<i32>": "gl.uniform4iv(location, v);",
        u32: "gl.uniform1iv(location, v);",
        "vec2<u32>": "gl.uniform2iv(location, v);",
        "vec3<u32>": "gl.uniform3iv(location, v);",
        "vec4<u32>": "gl.uniform4iv(location, v);",
        bool: "gl.uniform1iv(location, v);",
        "vec2<bool>": "gl.uniform2iv(location, v);",
        "vec3<bool>": "gl.uniform3iv(location, v);",
        "vec4<bool>": "gl.uniform4iv(location, v);"
    };
    function yw(i, e) {
        const t = [
            `
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
        var name = null;
    `
        ];
        for(const n in i.uniforms){
            if (!e[n]) {
                i.uniforms[n] instanceof $i ? i.uniforms[n].ubo ? t.push(`
                        renderer.shader.bindUniformBlock(uv.${n}, "${n}");
                    `) : t.push(`
                        renderer.shader.updateUniformGroup(uv.${n});
                    `) : i.uniforms[n] instanceof zm && t.push(`
                        renderer.shader.bindBufferResource(uv.${n}, "${n}");
                    `);
                continue;
            }
            const s = i.uniformStructures[n];
            let r = !1;
            for(let a = 0; a < Gi.length; a++){
                const o = Gi[a];
                if (s.type === o.type && o.test(s)) {
                    t.push(`name = "${n}";`, Gi[a].uniform), r = !0;
                    break;
                }
            }
            if (!r) {
                const o = (s.size === 1 ? xw : vw)[s.type].replace("location", `ud["${n}"].location`);
                t.push(`
            cu = ud["${n}"];
            cv = cu.value;
            v = uv["${n}"];
            ${o};`);
            }
        }
        return new Function("ud", "uv", "renderer", "syncData", t.join(`
`));
    }
    class Ym {
        constructor(e){
            this._cache = {}, this._uniformGroupSyncHash = {}, this._renderer = e, this.gl = null, this._cache = {};
        }
        contextChange(e) {
            this.gl = e;
        }
        updateUniformGroup(e, t, n) {
            const s = this._renderer.shader._getProgramData(t);
            (!e.isStatic || e._dirtyId !== s.uniformDirtyGroups[e.uid]) && (s.uniformDirtyGroups[e.uid] = e._dirtyId, this._getUniformSyncFunction(e, t)(s.uniformData, e.uniforms, this._renderer, n));
        }
        _getUniformSyncFunction(e, t) {
            return this._uniformGroupSyncHash[e._signature]?.[t._key] || this._createUniformSyncFunction(e, t);
        }
        _createUniformSyncFunction(e, t) {
            const n = this._uniformGroupSyncHash[e._signature] || (this._uniformGroupSyncHash[e._signature] = {}), s = this._getSignature(e, t._uniformData, "u");
            return this._cache[s] || (this._cache[s] = this._generateUniformsSync(e, t._uniformData)), n[t._key] = this._cache[s], n[t._key];
        }
        _generateUniformsSync(e, t) {
            return yw(e, t);
        }
        _getSignature(e, t, n) {
            const s = e.uniforms, r = [
                `${n}-`
            ];
            for(const a in s)r.push(a), t[a] && r.push(t[a].type);
            return r.join("-");
        }
        destroy() {
            this._renderer = null, this._cache = null;
        }
    }
    Ym.extension = {
        type: [
            se.WebGLSystem
        ],
        name: "uniformGroup"
    };
    function bw(i) {
        const e = {};
        if (e.normal = [
            i.ONE,
            i.ONE_MINUS_SRC_ALPHA
        ], e.add = [
            i.ONE,
            i.ONE
        ], e.multiply = [
            i.DST_COLOR,
            i.ONE_MINUS_SRC_ALPHA,
            i.ONE,
            i.ONE_MINUS_SRC_ALPHA
        ], e.screen = [
            i.ONE,
            i.ONE_MINUS_SRC_COLOR,
            i.ONE,
            i.ONE_MINUS_SRC_ALPHA
        ], e.none = [
            0,
            0
        ], e["normal-npm"] = [
            i.SRC_ALPHA,
            i.ONE_MINUS_SRC_ALPHA,
            i.ONE,
            i.ONE_MINUS_SRC_ALPHA
        ], e["add-npm"] = [
            i.SRC_ALPHA,
            i.ONE,
            i.ONE,
            i.ONE
        ], e["screen-npm"] = [
            i.SRC_ALPHA,
            i.ONE_MINUS_SRC_COLOR,
            i.ONE,
            i.ONE_MINUS_SRC_ALPHA
        ], e.erase = [
            i.ZERO,
            i.ONE_MINUS_SRC_ALPHA
        ], !(i instanceof jt.get().getWebGLRenderingContext())) e.min = [
            i.ONE,
            i.ONE,
            i.ONE,
            i.ONE,
            i.MIN,
            i.MIN
        ], e.max = [
            i.ONE,
            i.ONE,
            i.ONE,
            i.ONE,
            i.MAX,
            i.MAX
        ];
        else {
            const n = i.getExtension("EXT_blend_minmax");
            n && (e.min = [
                i.ONE,
                i.ONE,
                i.ONE,
                i.ONE,
                n.MIN_EXT,
                n.MIN_EXT
            ], e.max = [
                i.ONE,
                i.ONE,
                i.ONE,
                i.ONE,
                n.MAX_EXT,
                n.MAX_EXT
            ]);
        }
        return e;
    }
    const Sw = 0, Mw = 1, Tw = 2, Ew = 3, Aw = 4, ww = 5, qm = class Nl {
        constructor(e){
            this._invertFrontFace = !1, this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = "none", this._blendEq = !1, this.map = [], this.map[Sw] = this.setBlend, this.map[Mw] = this.setOffset, this.map[Tw] = this.setCullFace, this.map[Ew] = this.setDepthTest, this.map[Aw] = this.setFrontFace, this.map[ww] = this.setDepthMask, this.checks = [], this.defaultState = Fr.for2d(), e.renderTarget.onRenderTargetChange.add(this);
        }
        onRenderTargetChange(e) {
            this._invertFrontFace = !e.isRoot, this._cullFace ? this.setFrontFace(this._frontFace) : this._frontFaceDirty = !0;
        }
        contextChange(e) {
            this.gl = e, this.blendModesMap = bw(e), this.resetState();
        }
        set(e) {
            if (e || (e = this.defaultState), this.stateId !== e.data) {
                let t = this.stateId ^ e.data, n = 0;
                for(; t;)t & 1 && this.map[n].call(this, !!(e.data & 1 << n)), t >>= 1, n++;
                this.stateId = e.data;
            }
            for(let t = 0; t < this.checks.length; t++)this.checks[t](this, e);
        }
        forceState(e) {
            e || (e = this.defaultState);
            for(let t = 0; t < this.map.length; t++)this.map[t].call(this, !!(e.data & 1 << t));
            for(let t = 0; t < this.checks.length; t++)this.checks[t](this, e);
            this.stateId = e.data;
        }
        setBlend(e) {
            this._updateCheck(Nl._checkBlendMode, e), this.gl[e ? "enable" : "disable"](this.gl.BLEND);
        }
        setOffset(e) {
            this._updateCheck(Nl._checkPolygonOffset, e), this.gl[e ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
        }
        setDepthTest(e) {
            this.gl[e ? "enable" : "disable"](this.gl.DEPTH_TEST);
        }
        setDepthMask(e) {
            this.gl.depthMask(e);
        }
        setCullFace(e) {
            this._cullFace = e, this.gl[e ? "enable" : "disable"](this.gl.CULL_FACE), this._cullFace && this._frontFaceDirty && this.setFrontFace(this._frontFace);
        }
        setFrontFace(e) {
            this._frontFace = e, this._frontFaceDirty = !1;
            const t = this._invertFrontFace ? !e : e;
            this._glFrontFace !== t && (this._glFrontFace = t, this.gl.frontFace(this.gl[t ? "CW" : "CCW"]));
        }
        setBlendMode(e) {
            if (this.blendModesMap[e] || (e = "normal"), e === this.blendMode) return;
            this.blendMode = e;
            const t = this.blendModesMap[e], n = this.gl;
            t.length === 2 ? n.blendFunc(t[0], t[1]) : n.blendFuncSeparate(t[0], t[1], t[2], t[3]), t.length === 6 ? (this._blendEq = !0, n.blendEquationSeparate(t[4], t[5])) : this._blendEq && (this._blendEq = !1, n.blendEquationSeparate(n.FUNC_ADD, n.FUNC_ADD));
        }
        setPolygonOffset(e, t) {
            this.gl.polygonOffset(e, t);
        }
        resetState() {
            this._glFrontFace = !1, this._frontFace = !1, this._cullFace = !1, this._frontFaceDirty = !1, this._invertFrontFace = !1, this.gl.frontFace(this.gl.CCW), this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1), this.forceState(this.defaultState), this._blendEq = !0, this.blendMode = "", this.setBlendMode("normal");
        }
        _updateCheck(e, t) {
            const n = this.checks.indexOf(e);
            t && n === -1 ? this.checks.push(e) : !t && n !== -1 && this.checks.splice(n, 1);
        }
        static _checkBlendMode(e, t) {
            e.setBlendMode(t.blendMode);
        }
        static _checkPolygonOffset(e, t) {
            e.setPolygonOffset(1, t.polygonOffset);
        }
        destroy() {
            this.gl = null, this.checks.length = 0;
        }
    };
    qm.extension = {
        type: [
            se.WebGLSystem
        ],
        name: "state"
    };
    let Rw = qm;
    class Cw {
        constructor(e){
            this.target = Cm.TEXTURE_2D, this.texture = e, this.width = -1, this.height = -1, this.type = et.UNSIGNED_BYTE, this.internalFormat = Ll.RGBA, this.format = Ll.RGBA, this.samplerType = 0;
        }
    }
    const Pw = {
        id: "buffer",
        upload (i, e, t) {
            e.width === i.width || e.height === i.height ? t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, i.width, i.height, e.format, e.type, i.resource) : t.texImage2D(e.target, 0, e.internalFormat, i.width, i.height, 0, e.format, e.type, i.resource), e.width = i.width, e.height = i.height;
        }
    }, Iw = {
        "bc1-rgba-unorm": !0,
        "bc1-rgba-unorm-srgb": !0,
        "bc2-rgba-unorm": !0,
        "bc2-rgba-unorm-srgb": !0,
        "bc3-rgba-unorm": !0,
        "bc3-rgba-unorm-srgb": !0,
        "bc4-r-unorm": !0,
        "bc4-r-snorm": !0,
        "bc5-rg-unorm": !0,
        "bc5-rg-snorm": !0,
        "bc6h-rgb-ufloat": !0,
        "bc6h-rgb-float": !0,
        "bc7-rgba-unorm": !0,
        "bc7-rgba-unorm-srgb": !0,
        "etc2-rgb8unorm": !0,
        "etc2-rgb8unorm-srgb": !0,
        "etc2-rgb8a1unorm": !0,
        "etc2-rgb8a1unorm-srgb": !0,
        "etc2-rgba8unorm": !0,
        "etc2-rgba8unorm-srgb": !0,
        "eac-r11unorm": !0,
        "eac-r11snorm": !0,
        "eac-rg11unorm": !0,
        "eac-rg11snorm": !0,
        "astc-4x4-unorm": !0,
        "astc-4x4-unorm-srgb": !0,
        "astc-5x4-unorm": !0,
        "astc-5x4-unorm-srgb": !0,
        "astc-5x5-unorm": !0,
        "astc-5x5-unorm-srgb": !0,
        "astc-6x5-unorm": !0,
        "astc-6x5-unorm-srgb": !0,
        "astc-6x6-unorm": !0,
        "astc-6x6-unorm-srgb": !0,
        "astc-8x5-unorm": !0,
        "astc-8x5-unorm-srgb": !0,
        "astc-8x6-unorm": !0,
        "astc-8x6-unorm-srgb": !0,
        "astc-8x8-unorm": !0,
        "astc-8x8-unorm-srgb": !0,
        "astc-10x5-unorm": !0,
        "astc-10x5-unorm-srgb": !0,
        "astc-10x6-unorm": !0,
        "astc-10x6-unorm-srgb": !0,
        "astc-10x8-unorm": !0,
        "astc-10x8-unorm-srgb": !0,
        "astc-10x10-unorm": !0,
        "astc-10x10-unorm-srgb": !0,
        "astc-12x10-unorm": !0,
        "astc-12x10-unorm-srgb": !0,
        "astc-12x12-unorm": !0,
        "astc-12x12-unorm-srgb": !0
    }, Dw = {
        id: "compressed",
        upload (i, e, t) {
            t.pixelStorei(t.UNPACK_ALIGNMENT, 4);
            let n = i.pixelWidth, s = i.pixelHeight;
            const r = !!Iw[i.format];
            for(let a = 0; a < i.resource.length; a++){
                const o = i.resource[a];
                r ? t.compressedTexImage2D(t.TEXTURE_2D, a, e.internalFormat, n, s, 0, o) : t.texImage2D(t.TEXTURE_2D, a, e.internalFormat, n, s, 0, e.format, e.type, o), n = Math.max(n >> 1, 1), s = Math.max(s >> 1, 1);
            }
        }
    }, jm = {
        id: "image",
        upload (i, e, t, n) {
            const s = e.width, r = e.height, a = i.pixelWidth, o = i.pixelHeight, c = i.resourceWidth, l = i.resourceHeight;
            c < a || l < o ? ((s !== a || r !== o) && t.texImage2D(e.target, 0, e.internalFormat, a, o, 0, e.format, e.type, null), n === 2 ? t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, c, l, e.format, e.type, i.resource) : t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, e.format, e.type, i.resource)) : s === a && r === o ? t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, e.format, e.type, i.resource) : n === 2 ? t.texImage2D(e.target, 0, e.internalFormat, a, o, 0, e.format, e.type, i.resource) : t.texImage2D(e.target, 0, e.internalFormat, e.format, e.type, i.resource), e.width = a, e.height = o;
        }
    }, Lw = {
        id: "video",
        upload (i, e, t, n) {
            if (!i.isValid) {
                t.texImage2D(e.target, 0, e.internalFormat, 1, 1, 0, e.format, e.type, null);
                return;
            }
            jm.upload(i, e, t, n);
        }
    }, _f = {
        linear: 9729,
        nearest: 9728
    }, Uw = {
        linear: {
            linear: 9987,
            nearest: 9985
        },
        nearest: {
            linear: 9986,
            nearest: 9984
        }
    }, bc = {
        "clamp-to-edge": 33071,
        repeat: 10497,
        "mirror-repeat": 33648
    }, Nw = {
        never: 512,
        less: 513,
        equal: 514,
        "less-equal": 515,
        greater: 516,
        "not-equal": 517,
        "greater-equal": 518,
        always: 519
    };
    function gf(i, e, t, n, s, r, a, o) {
        const c = r;
        if (!o || i.addressModeU !== "repeat" || i.addressModeV !== "repeat" || i.addressModeW !== "repeat") {
            const l = bc[a ? "clamp-to-edge" : i.addressModeU], h = bc[a ? "clamp-to-edge" : i.addressModeV], u = bc[a ? "clamp-to-edge" : i.addressModeW];
            e[s](c, e.TEXTURE_WRAP_S, l), e[s](c, e.TEXTURE_WRAP_T, h), e.TEXTURE_WRAP_R && e[s](c, e.TEXTURE_WRAP_R, u);
        }
        if ((!o || i.magFilter !== "linear") && e[s](c, e.TEXTURE_MAG_FILTER, _f[i.magFilter]), t) {
            if (!o || i.mipmapFilter !== "linear") {
                const l = Uw[i.minFilter][i.mipmapFilter];
                e[s](c, e.TEXTURE_MIN_FILTER, l);
            }
        } else e[s](c, e.TEXTURE_MIN_FILTER, _f[i.minFilter]);
        if (n && i.maxAnisotropy > 1) {
            const l = Math.min(i.maxAnisotropy, e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
            e[s](c, n.TEXTURE_MAX_ANISOTROPY_EXT, l);
        }
        i.compare && e[s](c, e.TEXTURE_COMPARE_FUNC, Nw[i.compare]);
    }
    function Bw(i) {
        return {
            r8unorm: i.RED,
            r8snorm: i.RED,
            r8uint: i.RED,
            r8sint: i.RED,
            r16uint: i.RED,
            r16sint: i.RED,
            r16float: i.RED,
            rg8unorm: i.RG,
            rg8snorm: i.RG,
            rg8uint: i.RG,
            rg8sint: i.RG,
            r32uint: i.RED,
            r32sint: i.RED,
            r32float: i.RED,
            rg16uint: i.RG,
            rg16sint: i.RG,
            rg16float: i.RG,
            rgba8unorm: i.RGBA,
            "rgba8unorm-srgb": i.RGBA,
            rgba8snorm: i.RGBA,
            rgba8uint: i.RGBA,
            rgba8sint: i.RGBA,
            bgra8unorm: i.RGBA,
            "bgra8unorm-srgb": i.RGBA,
            rgb9e5ufloat: i.RGB,
            rgb10a2unorm: i.RGBA,
            rg11b10ufloat: i.RGB,
            rg32uint: i.RG,
            rg32sint: i.RG,
            rg32float: i.RG,
            rgba16uint: i.RGBA,
            rgba16sint: i.RGBA,
            rgba16float: i.RGBA,
            rgba32uint: i.RGBA,
            rgba32sint: i.RGBA,
            rgba32float: i.RGBA,
            stencil8: i.STENCIL_INDEX8,
            depth16unorm: i.DEPTH_COMPONENT,
            depth24plus: i.DEPTH_COMPONENT,
            "depth24plus-stencil8": i.DEPTH_STENCIL,
            depth32float: i.DEPTH_COMPONENT,
            "depth32float-stencil8": i.DEPTH_STENCIL
        };
    }
    function Fw(i, e) {
        let t = {}, n = i.RGBA;
        return i instanceof jt.get().getWebGLRenderingContext() ? e.srgb && (t = {
            "rgba8unorm-srgb": e.srgb.SRGB8_ALPHA8_EXT,
            "bgra8unorm-srgb": e.srgb.SRGB8_ALPHA8_EXT
        }) : (t = {
            "rgba8unorm-srgb": i.SRGB8_ALPHA8,
            "bgra8unorm-srgb": i.SRGB8_ALPHA8
        }, n = i.RGBA8), {
            r8unorm: i.R8,
            r8snorm: i.R8_SNORM,
            r8uint: i.R8UI,
            r8sint: i.R8I,
            r16uint: i.R16UI,
            r16sint: i.R16I,
            r16float: i.R16F,
            rg8unorm: i.RG8,
            rg8snorm: i.RG8_SNORM,
            rg8uint: i.RG8UI,
            rg8sint: i.RG8I,
            r32uint: i.R32UI,
            r32sint: i.R32I,
            r32float: i.R32F,
            rg16uint: i.RG16UI,
            rg16sint: i.RG16I,
            rg16float: i.RG16F,
            rgba8unorm: i.RGBA,
            ...t,
            rgba8snorm: i.RGBA8_SNORM,
            rgba8uint: i.RGBA8UI,
            rgba8sint: i.RGBA8I,
            bgra8unorm: n,
            rgb9e5ufloat: i.RGB9_E5,
            rgb10a2unorm: i.RGB10_A2,
            rg11b10ufloat: i.R11F_G11F_B10F,
            rg32uint: i.RG32UI,
            rg32sint: i.RG32I,
            rg32float: i.RG32F,
            rgba16uint: i.RGBA16UI,
            rgba16sint: i.RGBA16I,
            rgba16float: i.RGBA16F,
            rgba32uint: i.RGBA32UI,
            rgba32sint: i.RGBA32I,
            rgba32float: i.RGBA32F,
            stencil8: i.STENCIL_INDEX8,
            depth16unorm: i.DEPTH_COMPONENT16,
            depth24plus: i.DEPTH_COMPONENT24,
            "depth24plus-stencil8": i.DEPTH24_STENCIL8,
            depth32float: i.DEPTH_COMPONENT32F,
            "depth32float-stencil8": i.DEPTH32F_STENCIL8,
            ...e.s3tc ? {
                "bc1-rgba-unorm": e.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,
                "bc2-rgba-unorm": e.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,
                "bc3-rgba-unorm": e.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT
            } : {},
            ...e.s3tc_sRGB ? {
                "bc1-rgba-unorm-srgb": e.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
                "bc2-rgba-unorm-srgb": e.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
                "bc3-rgba-unorm-srgb": e.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
            } : {},
            ...e.rgtc ? {
                "bc4-r-unorm": e.rgtc.COMPRESSED_RED_RGTC1_EXT,
                "bc4-r-snorm": e.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,
                "bc5-rg-unorm": e.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,
                "bc5-rg-snorm": e.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
            } : {},
            ...e.bptc ? {
                "bc6h-rgb-float": e.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,
                "bc6h-rgb-ufloat": e.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,
                "bc7-rgba-unorm": e.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,
                "bc7-rgba-unorm-srgb": e.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            } : {},
            ...e.etc ? {
                "etc2-rgb8unorm": e.etc.COMPRESSED_RGB8_ETC2,
                "etc2-rgb8unorm-srgb": e.etc.COMPRESSED_SRGB8_ETC2,
                "etc2-rgb8a1unorm": e.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
                "etc2-rgb8a1unorm-srgb": e.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,
                "etc2-rgba8unorm": e.etc.COMPRESSED_RGBA8_ETC2_EAC,
                "etc2-rgba8unorm-srgb": e.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,
                "eac-r11unorm": e.etc.COMPRESSED_R11_EAC,
                "eac-rg11unorm": e.etc.COMPRESSED_SIGNED_RG11_EAC
            } : {},
            ...e.astc ? {
                "astc-4x4-unorm": e.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,
                "astc-4x4-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,
                "astc-5x4-unorm": e.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,
                "astc-5x4-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,
                "astc-5x5-unorm": e.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,
                "astc-5x5-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,
                "astc-6x5-unorm": e.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,
                "astc-6x5-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,
                "astc-6x6-unorm": e.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,
                "astc-6x6-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,
                "astc-8x5-unorm": e.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,
                "astc-8x5-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,
                "astc-8x6-unorm": e.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,
                "astc-8x6-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,
                "astc-8x8-unorm": e.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,
                "astc-8x8-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,
                "astc-10x5-unorm": e.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,
                "astc-10x5-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,
                "astc-10x6-unorm": e.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,
                "astc-10x6-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,
                "astc-10x8-unorm": e.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,
                "astc-10x8-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,
                "astc-10x10-unorm": e.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,
                "astc-10x10-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,
                "astc-12x10-unorm": e.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,
                "astc-12x10-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,
                "astc-12x12-unorm": e.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,
                "astc-12x12-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            } : {}
        };
    }
    function Ow(i) {
        return {
            r8unorm: i.UNSIGNED_BYTE,
            r8snorm: i.BYTE,
            r8uint: i.UNSIGNED_BYTE,
            r8sint: i.BYTE,
            r16uint: i.UNSIGNED_SHORT,
            r16sint: i.SHORT,
            r16float: i.HALF_FLOAT,
            rg8unorm: i.UNSIGNED_BYTE,
            rg8snorm: i.BYTE,
            rg8uint: i.UNSIGNED_BYTE,
            rg8sint: i.BYTE,
            r32uint: i.UNSIGNED_INT,
            r32sint: i.INT,
            r32float: i.FLOAT,
            rg16uint: i.UNSIGNED_SHORT,
            rg16sint: i.SHORT,
            rg16float: i.HALF_FLOAT,
            rgba8unorm: i.UNSIGNED_BYTE,
            "rgba8unorm-srgb": i.UNSIGNED_BYTE,
            rgba8snorm: i.BYTE,
            rgba8uint: i.UNSIGNED_BYTE,
            rgba8sint: i.BYTE,
            bgra8unorm: i.UNSIGNED_BYTE,
            "bgra8unorm-srgb": i.UNSIGNED_BYTE,
            rgb9e5ufloat: i.UNSIGNED_INT_5_9_9_9_REV,
            rgb10a2unorm: i.UNSIGNED_INT_2_10_10_10_REV,
            rg11b10ufloat: i.UNSIGNED_INT_10F_11F_11F_REV,
            rg32uint: i.UNSIGNED_INT,
            rg32sint: i.INT,
            rg32float: i.FLOAT,
            rgba16uint: i.UNSIGNED_SHORT,
            rgba16sint: i.SHORT,
            rgba16float: i.HALF_FLOAT,
            rgba32uint: i.UNSIGNED_INT,
            rgba32sint: i.INT,
            rgba32float: i.FLOAT,
            stencil8: i.UNSIGNED_BYTE,
            depth16unorm: i.UNSIGNED_SHORT,
            depth24plus: i.UNSIGNED_INT,
            "depth24plus-stencil8": i.UNSIGNED_INT_24_8,
            depth32float: i.FLOAT,
            "depth32float-stencil8": i.FLOAT_32_UNSIGNED_INT_24_8_REV
        };
    }
    const kw = 4;
    class $m {
        constructor(e){
            this.managedTextures = [], this._glTextures = Object.create(null), this._glSamplers = Object.create(null), this._boundTextures = [], this._activeTextureLocation = -1, this._boundSamplers = Object.create(null), this._uploads = {
                image: jm,
                buffer: Pw,
                video: Lw,
                compressed: Dw
            }, this._premultiplyAlpha = !1, this._useSeparateSamplers = !1, this._renderer = e, this._renderer.renderableGC.addManagedHash(this, "_glTextures"), this._renderer.renderableGC.addManagedHash(this, "_glSamplers");
        }
        contextChange(e) {
            this._gl = e, this._mapFormatToInternalFormat || (this._mapFormatToInternalFormat = Fw(e, this._renderer.context.extensions), this._mapFormatToType = Ow(e), this._mapFormatToFormat = Bw(e)), this._glTextures = Object.create(null), this._glSamplers = Object.create(null), this._boundSamplers = Object.create(null), this._premultiplyAlpha = !1;
            for(let t = 0; t < 16; t++)this.bind(Oe.EMPTY, t);
        }
        initSource(e) {
            this.bind(e);
        }
        bind(e, t = 0) {
            const n = e.source;
            e ? (this.bindSource(n, t), this._useSeparateSamplers && this._bindSampler(n.style, t)) : (this.bindSource(null, t), this._useSeparateSamplers && this._bindSampler(null, t));
        }
        bindSource(e, t = 0) {
            const n = this._gl;
            if (e._touched = this._renderer.textureGC.count, this._boundTextures[t] !== e) {
                this._boundTextures[t] = e, this._activateLocation(t), e || (e = Oe.EMPTY.source);
                const s = this.getGlSource(e);
                n.bindTexture(s.target, s.texture);
            }
        }
        _bindSampler(e, t = 0) {
            const n = this._gl;
            if (!e) {
                this._boundSamplers[t] = null, n.bindSampler(t, null);
                return;
            }
            const s = this._getGlSampler(e);
            this._boundSamplers[t] !== s && (this._boundSamplers[t] = s, n.bindSampler(t, s));
        }
        unbind(e) {
            const t = e.source, n = this._boundTextures, s = this._gl;
            for(let r = 0; r < n.length; r++)if (n[r] === t) {
                this._activateLocation(r);
                const a = this.getGlSource(t);
                s.bindTexture(a.target, null), n[r] = null;
            }
        }
        _activateLocation(e) {
            this._activeTextureLocation !== e && (this._activeTextureLocation = e, this._gl.activeTexture(this._gl.TEXTURE0 + e));
        }
        _initSource(e) {
            const t = this._gl, n = new Cw(t.createTexture());
            if (n.type = this._mapFormatToType[e.format], n.internalFormat = this._mapFormatToInternalFormat[e.format], n.format = this._mapFormatToFormat[e.format], e.autoGenerateMipmaps && (this._renderer.context.supports.nonPowOf2mipmaps || e.isPowerOfTwo)) {
                const s = Math.max(e.width, e.height);
                e.mipLevelCount = Math.floor(Math.log2(s)) + 1;
            }
            return this._glTextures[e.uid] = n, this.managedTextures.includes(e) || (e.on("update", this.onSourceUpdate, this), e.on("resize", this.onSourceUpdate, this), e.on("styleChange", this.onStyleChange, this), e.on("destroy", this.onSourceDestroy, this), e.on("unload", this.onSourceUnload, this), e.on("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.push(e)), this.onSourceUpdate(e), this.updateStyle(e, !1), n;
        }
        onStyleChange(e) {
            this.updateStyle(e, !1);
        }
        updateStyle(e, t) {
            const n = this._gl, s = this.getGlSource(e);
            n.bindTexture(n.TEXTURE_2D, s.texture), this._boundTextures[this._activeTextureLocation] = e, gf(e.style, n, e.mipLevelCount > 1, this._renderer.context.extensions.anisotropicFiltering, "texParameteri", n.TEXTURE_2D, !this._renderer.context.supports.nonPowOf2wrapping && !e.isPowerOfTwo, t);
        }
        onSourceUnload(e) {
            const t = this._glTextures[e.uid];
            t && (this.unbind(e), this._glTextures[e.uid] = null, this._gl.deleteTexture(t.texture));
        }
        onSourceUpdate(e) {
            const t = this._gl, n = this.getGlSource(e);
            t.bindTexture(t.TEXTURE_2D, n.texture), this._boundTextures[this._activeTextureLocation] = e;
            const s = e.alphaMode === "premultiply-alpha-on-upload";
            this._premultiplyAlpha !== s && (this._premultiplyAlpha = s, t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, s)), this._uploads[e.uploadMethodId] ? this._uploads[e.uploadMethodId].upload(e, n, t, this._renderer.context.webGLVersion) : t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, e.pixelWidth, e.pixelHeight, 0, t.RGBA, t.UNSIGNED_BYTE, null), e.autoGenerateMipmaps && e.mipLevelCount > 1 && this.onUpdateMipmaps(e, !1);
        }
        onUpdateMipmaps(e, t = !0) {
            t && this.bindSource(e, 0);
            const n = this.getGlSource(e);
            this._gl.generateMipmap(n.target);
        }
        onSourceDestroy(e) {
            e.off("destroy", this.onSourceDestroy, this), e.off("update", this.onSourceUpdate, this), e.off("resize", this.onSourceUpdate, this), e.off("unload", this.onSourceUnload, this), e.off("styleChange", this.onStyleChange, this), e.off("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.splice(this.managedTextures.indexOf(e), 1), this.onSourceUnload(e);
        }
        _initSampler(e) {
            const t = this._gl, n = this._gl.createSampler();
            return this._glSamplers[e._resourceId] = n, gf(e, t, this._boundTextures[this._activeTextureLocation].mipLevelCount > 1, this._renderer.context.extensions.anisotropicFiltering, "samplerParameteri", n, !1, !0), this._glSamplers[e._resourceId];
        }
        _getGlSampler(e) {
            return this._glSamplers[e._resourceId] || this._initSampler(e);
        }
        getGlSource(e) {
            return this._glTextures[e.uid] || this._initSource(e);
        }
        generateCanvas(e) {
            const { pixels: t, width: n, height: s } = this.getPixels(e), r = jt.get().createCanvas();
            r.width = n, r.height = s;
            const a = r.getContext("2d");
            if (a) {
                const o = a.createImageData(n, s);
                o.data.set(t), a.putImageData(o, 0, 0);
            }
            return r;
        }
        getPixels(e) {
            const t = e.source.resolution, n = e.frame, s = Math.max(Math.round(n.width * t), 1), r = Math.max(Math.round(n.height * t), 1), a = new Uint8Array(kw * s * r), o = this._renderer, c = o.renderTarget.getRenderTarget(e), l = o.renderTarget.getGpuRenderTarget(c), h = o.gl;
            return h.bindFramebuffer(h.FRAMEBUFFER, l.resolveTargetFramebuffer), h.readPixels(Math.round(n.x * t), Math.round(n.y * t), s, r, h.RGBA, h.UNSIGNED_BYTE, a), {
                pixels: new Uint8ClampedArray(a.buffer),
                width: s,
                height: r
            };
        }
        destroy() {
            this.managedTextures.slice().forEach((e)=>this.onSourceDestroy(e)), this.managedTextures = null, this._renderer = null;
        }
        resetState() {
            this._activeTextureLocation = -1, this._boundTextures.fill(Oe.EMPTY.source), this._boundSamplers = Object.create(null);
            const e = this._gl;
            this._premultiplyAlpha = !1, e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._premultiplyAlpha);
        }
    }
    $m.extension = {
        type: [
            se.WebGLSystem
        ],
        name: "texture"
    };
    class Km {
        init() {
            const e = new $i({
                uColor: {
                    value: new Float32Array([
                        1,
                        1,
                        1,
                        1
                    ]),
                    type: "vec4<f32>"
                },
                uTransformMatrix: {
                    value: new Fe,
                    type: "mat3x3<f32>"
                },
                uRound: {
                    value: 0,
                    type: "f32"
                }
            }), t = eo(), n = xh({
                name: "graphics",
                bits: [
                    rm,
                    am(t),
                    Mm,
                    vh
                ]
            });
            this.shader = new Ki({
                glProgram: n,
                resources: {
                    localUniforms: e,
                    batchSamplers: om(t)
                }
            });
        }
        execute(e, t) {
            const n = t.context, s = n.customShader || this.shader, r = e.renderer, a = r.graphicsContext, { batcher: o, instructions: c } = a.getContextRenderData(n);
            s.groups[0] = r.globalUniforms.bindGroup, r.state.set(e.state), r.shader.bind(s), r.geometry.bind(o.geometry, s.glProgram);
            const l = c.instructions;
            for(let h = 0; h < c.instructionSize; h++){
                const u = l[h];
                if (u.size) {
                    for(let d = 0; d < u.textures.count; d++)r.texture.bind(u.textures.textures[d], d);
                    r.geometry.draw(u.topology, u.size, u.start);
                }
            }
        }
        destroy() {
            this.shader.destroy(!0), this.shader = null;
        }
    }
    Km.extension = {
        type: [
            se.WebGLPipesAdaptor
        ],
        name: "graphics"
    };
    class Zm {
        init() {
            const e = xh({
                name: "mesh",
                bits: [
                    Mm,
                    zA,
                    vh
                ]
            });
            this._shader = new Ki({
                glProgram: e,
                resources: {
                    uTexture: Oe.EMPTY.source,
                    textureUniforms: {
                        uTextureMatrix: {
                            type: "mat3x3<f32>",
                            value: new Fe
                        }
                    }
                }
            });
        }
        execute(e, t) {
            const n = e.renderer;
            let s = t._shader;
            if (s) {
                if (!s.glProgram) {
                    _t("Mesh shader has no glProgram", t.shader);
                    return;
                }
            } else {
                s = this._shader;
                const r = t.texture, a = r.source;
                s.resources.uTexture = a, s.resources.uSampler = a.style, s.resources.textureUniforms.uniforms.uTextureMatrix = r.textureMatrix.mapCoord;
            }
            s.groups[100] = n.globalUniforms.bindGroup, s.groups[101] = e.localUniformsBindGroup, n.encoder.draw({
                geometry: t._geometry,
                shader: s,
                state: t.state
            });
        }
        destroy() {
            this._shader.destroy(!0), this._shader = null;
        }
    }
    Zm.extension = {
        type: [
            se.WebGLPipesAdaptor
        ],
        name: "mesh"
    };
    class Jm {
        constructor(e){
            this._renderer = e;
        }
        updateRenderable() {}
        destroyRenderable() {}
        validateRenderable() {
            return !1;
        }
        addRenderable(e, t) {
            this._renderer.renderPipes.batch.break(t), t.add(e);
        }
        execute(e) {
            e.isRenderable && e.render(this._renderer);
        }
        destroy() {
            this._renderer = null;
        }
    }
    Jm.extension = {
        type: [
            se.WebGLPipes,
            se.WebGPUPipes,
            se.CanvasPipes
        ],
        name: "customRender"
    };
    Qm = class {
        constructor(){
            this.batcherName = "default", this.topology = "triangle-list", this.attributeSize = 4, this.indexSize = 6, this.packAsQuad = !0, this.roundPixels = 0, this._attributeStart = 0, this._batcher = null, this._batch = null;
        }
        get blendMode() {
            return this.renderable.groupBlendMode;
        }
        get color() {
            return this.renderable.groupColorAlpha;
        }
        reset() {
            this.renderable = null, this.texture = null, this._batcher = null, this._batch = null, this.bounds = null;
        }
    };
    function Bl(i, e) {
        const t = i.instructionSet, n = t.instructions;
        for(let s = 0; s < t.instructionSize; s++){
            const r = n[s];
            e[r.renderPipeId].execute(r);
        }
    }
    const Gw = new Fe;
    class e_ {
        constructor(e){
            this._renderer = e;
        }
        addRenderGroup(e, t) {
            e.isCachedAsTexture ? this._addRenderableCacheAsTexture(e, t) : this._addRenderableDirect(e, t);
        }
        execute(e) {
            e.isRenderable && (e.isCachedAsTexture ? this._executeCacheAsTexture(e) : this._executeDirect(e));
        }
        destroy() {
            this._renderer = null;
        }
        _addRenderableDirect(e, t) {
            this._renderer.renderPipes.batch.break(t), e._batchableRenderGroup && (Gt.return(e._batchableRenderGroup), e._batchableRenderGroup = null), t.add(e);
        }
        _addRenderableCacheAsTexture(e, t) {
            const n = e._batchableRenderGroup ?? (e._batchableRenderGroup = Gt.get(Qm));
            n.renderable = e.root, n.transform = e.root.relativeGroupTransform, n.texture = e.texture, n.bounds = e._textureBounds, t.add(e), this._renderer.renderPipes.batch.addToBatch(n, t);
        }
        _executeCacheAsTexture(e) {
            if (e.textureNeedsUpdate) {
                e.textureNeedsUpdate = !1;
                const t = Gw.identity().translate(-e._textureBounds.x, -e._textureBounds.y);
                this._renderer.renderTarget.push(e.texture, !0, null, e.texture.frame), this._renderer.globalUniforms.push({
                    worldTransformMatrix: t,
                    worldColor: 4294967295
                }), Bl(e, this._renderer.renderPipes), this._renderer.renderTarget.finishRenderPass(), this._renderer.renderTarget.pop(), this._renderer.globalUniforms.pop();
            }
            e._batchableRenderGroup._batcher.updateElement(e._batchableRenderGroup), e._batchableRenderGroup._batcher.geometry.buffers[0].update();
        }
        _executeDirect(e) {
            this._renderer.globalUniforms.push({
                worldTransformMatrix: e.inverseParentTextureTransform,
                worldColor: e.worldColorAlpha
            }), Bl(e, this._renderer.renderPipes), this._renderer.globalUniforms.pop();
        }
    }
    e_.extension = {
        type: [
            se.WebGLPipes,
            se.WebGPUPipes,
            se.CanvasPipes
        ],
        name: "renderGroup"
    };
    function Fl(i, e) {
        e || (e = 0);
        for(let t = e; t < i.length && i[t]; t++)i[t] = null;
    }
    const Hw = new wn, xf = _r | Xa | hh;
    function t_(i, e = !1) {
        zw(i);
        const t = i.childrenToUpdate, n = i.updateTick++;
        for(const s in t){
            const r = Number(s), a = t[s], o = a.list, c = a.index;
            for(let l = 0; l < c; l++){
                const h = o[l];
                h.parentRenderGroup === i && h.relativeRenderGroupDepth === r && n_(h, n, 0);
            }
            Fl(o, c), a.index = 0;
        }
        if (e) for(let s = 0; s < i.renderGroupChildren.length; s++)t_(i.renderGroupChildren[s], e);
    }
    function zw(i) {
        const e = i.root;
        let t;
        if (i.renderGroupParent) {
            const n = i.renderGroupParent;
            i.worldTransform.appendFrom(e.relativeGroupTransform, n.worldTransform), i.worldColor = Wa(e.groupColor, n.worldColor), t = e.groupAlpha * n.worldAlpha;
        } else i.worldTransform.copyFrom(e.localTransform), i.worldColor = e.localColor, t = e.localAlpha;
        t = t < 0 ? 0 : t > 1 ? 1 : t, i.worldAlpha = t, i.worldColorAlpha = i.worldColor + ((t * 255 | 0) << 24);
    }
    function n_(i, e, t) {
        if (e === i.updateTick) return;
        i.updateTick = e, i.didChange = !1;
        const n = i.localTransform;
        i.updateLocalTransform();
        const s = i.parent;
        if (s && !s.renderGroup ? (t |= i._updateFlags, i.relativeGroupTransform.appendFrom(n, s.relativeGroupTransform), t & xf && vf(i, s, t)) : (t = i._updateFlags, i.relativeGroupTransform.copyFrom(n), t & xf && vf(i, Hw, t)), !i.renderGroup) {
            const r = i.children, a = r.length;
            for(let l = 0; l < a; l++)n_(r[l], e, t);
            const o = i.parentRenderGroup, c = i;
            c.renderPipeId && !o.structureDidChange && o.updateRenderable(c);
        }
    }
    function vf(i, e, t) {
        if (t & Xa) {
            i.groupColor = Wa(i.localColor, e.groupColor);
            let n = i.localAlpha * e.groupAlpha;
            n = n < 0 ? 0 : n > 1 ? 1 : n, i.groupAlpha = n, i.groupColorAlpha = i.groupColor + ((n * 255 | 0) << 24);
        }
        t & hh && (i.groupBlendMode = i.localBlendMode === "inherit" ? e.groupBlendMode : i.localBlendMode), t & _r && (i.globalDisplayStatus = i.localDisplayStatus & e.globalDisplayStatus), i._updateFlags = 0;
    }
    function Vw(i, e) {
        const { list: t, index: n } = i.childrenRenderablesToUpdate;
        let s = !1;
        for(let r = 0; r < n; r++){
            const a = t[r];
            if (s = e[a.renderPipeId].validateRenderable(a), s) break;
        }
        return i.structureDidChange = s, s;
    }
    const Ww = new Fe;
    class i_ {
        constructor(e){
            this._renderer = e;
        }
        render({ container: e, transform: t }) {
            const n = e.parent, s = e.renderGroup.renderGroupParent;
            e.parent = null, e.renderGroup.renderGroupParent = null;
            const r = this._renderer;
            let a = Ww;
            t && (a = a.copyFrom(e.renderGroup.localTransform), e.renderGroup.localTransform.copyFrom(t));
            const o = r.renderPipes;
            this._updateCachedRenderGroups(e.renderGroup, null), this._updateRenderGroups(e.renderGroup), r.globalUniforms.start({
                worldTransformMatrix: t ? e.renderGroup.localTransform : e.renderGroup.worldTransform,
                worldColor: e.renderGroup.worldColorAlpha
            }), Bl(e.renderGroup, o), o.uniformBatch && o.uniformBatch.renderEnd(), t && e.renderGroup.localTransform.copyFrom(a), e.parent = n, e.renderGroup.renderGroupParent = s;
        }
        destroy() {
            this._renderer = null;
        }
        _updateCachedRenderGroups(e, t) {
            if (e.isCachedAsTexture) {
                if (!e.updateCacheTexture) return;
                t = e;
            }
            e._parentCacheAsTextureRenderGroup = t;
            for(let n = e.renderGroupChildren.length - 1; n >= 0; n--)this._updateCachedRenderGroups(e.renderGroupChildren[n], t);
            if (e.invalidateMatrices(), e.isCachedAsTexture) {
                if (e.textureNeedsUpdate) {
                    const n = e.root.getLocalBounds();
                    n.ceil();
                    const s = e.texture;
                    e.texture && As.returnTexture(e.texture);
                    const r = this._renderer, a = e.textureOptions.resolution || r.view.resolution, o = e.textureOptions.antialias ?? r.view.antialias;
                    e.texture = As.getOptimalTexture(n.width, n.height, a, o), e._textureBounds || (e._textureBounds = new en), e._textureBounds.copyFrom(n), s !== e.texture && e.renderGroupParent && (e.renderGroupParent.structureDidChange = !0);
                }
            } else e.texture && (As.returnTexture(e.texture), e.texture = null);
        }
        _updateRenderGroups(e) {
            const t = this._renderer, n = t.renderPipes;
            if (e.runOnRender(t), e.instructionSet.renderPipes = n, e.structureDidChange ? Fl(e.childrenRenderablesToUpdate.list, 0) : Vw(e, n), t_(e), e.structureDidChange ? (e.structureDidChange = !1, this._buildInstructions(e, t)) : this._updateRenderables(e), e.childrenRenderablesToUpdate.index = 0, t.renderPipes.batch.upload(e.instructionSet), !(e.isCachedAsTexture && !e.textureNeedsUpdate)) for(let s = 0; s < e.renderGroupChildren.length; s++)this._updateRenderGroups(e.renderGroupChildren[s]);
        }
        _updateRenderables(e) {
            const { list: t, index: n } = e.childrenRenderablesToUpdate;
            for(let s = 0; s < n; s++){
                const r = t[s];
                r.didViewUpdate && e.updateRenderable(r);
            }
            Fl(t, n);
        }
        _buildInstructions(e, t) {
            const n = e.root, s = e.instructionSet;
            s.reset();
            const r = t.renderPipes ? t : t.batch.renderer, a = r.renderPipes;
            a.batch.buildStart(s), a.blendMode.buildStart(), a.colorMask.buildStart(), n.sortableChildren && n.sortChildren(), n.collectRenderablesWithEffects(s, r, null), a.batch.buildEnd(s), a.blendMode.buildEnd(s);
        }
    }
    i_.extension = {
        type: [
            se.WebGLSystem,
            se.WebGPUSystem,
            se.CanvasSystem
        ],
        name: "renderGroup"
    };
    class s_ {
        constructor(e){
            this._gpuSpriteHash = Object.create(null), this._destroyRenderableBound = this.destroyRenderable.bind(this), this._renderer = e, this._renderer.renderableGC.addManagedHash(this, "_gpuSpriteHash");
        }
        addRenderable(e, t) {
            const n = this._getGpuSprite(e);
            e.didViewUpdate && this._updateBatchableSprite(e, n), this._renderer.renderPipes.batch.addToBatch(n, t);
        }
        updateRenderable(e) {
            const t = this._gpuSpriteHash[e.uid];
            e.didViewUpdate && this._updateBatchableSprite(e, t), t._batcher.updateElement(t);
        }
        validateRenderable(e) {
            const t = this._getGpuSprite(e);
            return !t._batcher.checkAndUpdateTexture(t, e._texture);
        }
        destroyRenderable(e) {
            const t = this._gpuSpriteHash[e.uid];
            Gt.return(t), this._gpuSpriteHash[e.uid] = null, e.off("destroyed", this._destroyRenderableBound);
        }
        _updateBatchableSprite(e, t) {
            t.bounds = e.visualBounds, t.texture = e._texture;
        }
        _getGpuSprite(e) {
            return this._gpuSpriteHash[e.uid] || this._initGPUSprite(e);
        }
        _initGPUSprite(e) {
            const t = Gt.get(Qm);
            return t.renderable = e, t.transform = e.groupTransform, t.texture = e._texture, t.bounds = e.visualBounds, t.roundPixels = this._renderer._roundPixels | e._roundPixels, this._gpuSpriteHash[e.uid] = t, e.on("destroyed", this._destroyRenderableBound), t;
        }
        destroy() {
            for(const e in this._gpuSpriteHash)Gt.return(this._gpuSpriteHash[e]);
            this._gpuSpriteHash = null, this._renderer = null;
        }
    }
    s_.extension = {
        type: [
            se.WebGLPipes,
            se.WebGPUPipes,
            se.CanvasPipes
        ],
        name: "sprite"
    };
    const wh = class r_ {
        constructor(){
            this.clearBeforeRender = !0, this._backgroundColor = new Pt(0), this.color = this._backgroundColor, this.alpha = 1;
        }
        init(e) {
            e = {
                ...r_.defaultOptions,
                ...e
            }, this.clearBeforeRender = e.clearBeforeRender, this.color = e.background || e.backgroundColor || this._backgroundColor, this.alpha = e.backgroundAlpha, this._backgroundColor.setAlpha(e.backgroundAlpha);
        }
        get color() {
            return this._backgroundColor;
        }
        set color(e) {
            this._backgroundColor.setValue(e);
        }
        get alpha() {
            return this._backgroundColor.alpha;
        }
        set alpha(e) {
            this._backgroundColor.setAlpha(e);
        }
        get colorRgba() {
            return this._backgroundColor.toArray();
        }
        destroy() {}
    };
    wh.extension = {
        type: [
            se.WebGLSystem,
            se.WebGPUSystem,
            se.CanvasSystem
        ],
        name: "background",
        priority: 0
    };
    wh.defaultOptions = {
        backgroundAlpha: 1,
        backgroundColor: 0,
        clearBeforeRender: !0
    };
    let Xw = wh;
    const yr = {};
    Nt.handle(se.BlendMode, (i)=>{
        if (!i.name) throw new Error("BlendMode extension must have a name property");
        yr[i.name] = i.ref;
    }, (i)=>{
        delete yr[i.name];
    });
    class a_ {
        constructor(e){
            this._isAdvanced = !1, this._filterHash = Object.create(null), this._renderer = e, this._renderer.runners.prerender.add(this);
        }
        prerender() {
            this._activeBlendMode = "normal", this._isAdvanced = !1;
        }
        setBlendMode(e, t, n) {
            if (this._activeBlendMode === t) {
                this._isAdvanced && this._renderableList.push(e);
                return;
            }
            this._activeBlendMode = t, this._isAdvanced && this._endAdvancedBlendMode(n), this._isAdvanced = !!yr[t], this._isAdvanced && (this._beginAdvancedBlendMode(n), this._renderableList.push(e));
        }
        _beginAdvancedBlendMode(e) {
            this._renderer.renderPipes.batch.break(e);
            const t = this._activeBlendMode;
            if (!yr[t]) {
                _t(`Unable to assign BlendMode: '${t}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);
                return;
            }
            let n = this._filterHash[t];
            n || (n = this._filterHash[t] = new Va, n.filters = [
                new yr[t]
            ]);
            const s = {
                renderPipeId: "filter",
                action: "pushFilter",
                renderables: [],
                filterEffect: n,
                canBundle: !1
            };
            this._renderableList = s.renderables, e.add(s);
        }
        _endAdvancedBlendMode(e) {
            this._renderableList = null, this._renderer.renderPipes.batch.break(e), e.add({
                renderPipeId: "filter",
                action: "popFilter",
                canBundle: !1
            });
        }
        buildStart() {
            this._isAdvanced = !1;
        }
        buildEnd(e) {
            this._isAdvanced && this._endAdvancedBlendMode(e);
        }
        destroy() {
            this._renderer = null, this._renderableList = null;
            for(const e in this._filterHash)this._filterHash[e].destroy();
            this._filterHash = null;
        }
    }
    a_.extension = {
        type: [
            se.WebGLPipes,
            se.WebGPUPipes,
            se.CanvasPipes
        ],
        name: "blendMode"
    };
    const Sc = {
        png: "image/png",
        jpg: "image/jpeg",
        webp: "image/webp"
    }, Rh = class o_ {
        constructor(e){
            this._renderer = e;
        }
        _normalizeOptions(e, t = {}) {
            return e instanceof wn || e instanceof Oe ? {
                target: e,
                ...t
            } : {
                ...t,
                ...e
            };
        }
        async image(e) {
            const t = new Image;
            return t.src = await this.base64(e), t;
        }
        async base64(e) {
            e = this._normalizeOptions(e, o_.defaultImageOptions);
            const { format: t, quality: n } = e, s = this.canvas(e);
            if (s.toBlob !== void 0) return new Promise((r, a)=>{
                s.toBlob((o)=>{
                    if (!o) {
                        a(new Error("ICanvas.toBlob failed!"));
                        return;
                    }
                    const c = new FileReader;
                    c.onload = ()=>r(c.result), c.onerror = a, c.readAsDataURL(o);
                }, Sc[t], n);
            });
            if (s.toDataURL !== void 0) return s.toDataURL(Sc[t], n);
            if (s.convertToBlob !== void 0) {
                const r = await s.convertToBlob({
                    type: Sc[t],
                    quality: n
                });
                return new Promise((a, o)=>{
                    const c = new FileReader;
                    c.onload = ()=>a(c.result), c.onerror = o, c.readAsDataURL(r);
                });
            }
            throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");
        }
        canvas(e) {
            e = this._normalizeOptions(e);
            const t = e.target, n = this._renderer;
            if (t instanceof Oe) return n.texture.generateCanvas(t);
            const s = n.textureGenerator.generateTexture(e), r = n.texture.generateCanvas(s);
            return s.destroy(!0), r;
        }
        pixels(e) {
            e = this._normalizeOptions(e);
            const t = e.target, n = this._renderer, s = t instanceof Oe ? t : n.textureGenerator.generateTexture(e), r = n.texture.getPixels(s);
            return t instanceof wn && s.destroy(!0), r;
        }
        texture(e) {
            return e = this._normalizeOptions(e), e.target instanceof Oe ? e.target : this._renderer.textureGenerator.generateTexture(e);
        }
        download(e) {
            e = this._normalizeOptions(e);
            const t = this.canvas(e), n = document.createElement("a");
            n.download = e.filename ?? "image.png", n.href = t.toDataURL("image/png"), document.body.appendChild(n), n.click(), document.body.removeChild(n);
        }
        log(e) {
            const t = e.width ?? 200;
            e = this._normalizeOptions(e);
            const n = this.canvas(e), s = n.toDataURL();
            console.log(`[Pixi Texture] ${n.width}px ${n.height}px`);
            const r = [
                "font-size: 1px;",
                `padding: ${t}px 300px;`,
                `background: url(${s}) no-repeat;`,
                "background-size: contain;"
            ].join(" ");
            console.log("%c ", r);
        }
        destroy() {
            this._renderer = null;
        }
    };
    Rh.extension = {
        type: [
            se.WebGLSystem,
            se.WebGPUSystem
        ],
        name: "extract"
    };
    Rh.defaultImageOptions = {
        format: "png",
        quality: 1
    };
    let Yw = Rh;
    class Ch extends Oe {
        static create(e) {
            return new Ch({
                source: new Ut(e)
            });
        }
        resize(e, t, n) {
            return this.source.resize(e, t, n), this;
        }
    }
    const qw = new ft, jw = new en, $w = [
        0,
        0,
        0,
        0
    ];
    class c_ {
        constructor(e){
            this._renderer = e;
        }
        generateTexture(e) {
            e instanceof wn && (e = {
                target: e,
                frame: void 0,
                textureSourceOptions: {},
                resolution: void 0
            });
            const t = e.resolution || this._renderer.resolution, n = e.antialias || this._renderer.view.antialias, s = e.target;
            let r = e.clearColor;
            r ? r = Array.isArray(r) && r.length === 4 ? r : Pt.shared.setValue(r).toArray() : r = $w;
            const a = e.frame?.copyTo(qw) || lh(s, jw).rectangle;
            a.width = Math.max(a.width, 1 / t) | 0, a.height = Math.max(a.height, 1 / t) | 0;
            const o = Ch.create({
                ...e.textureSourceOptions,
                width: a.width,
                height: a.height,
                resolution: t,
                antialias: n
            }), c = Fe.shared.translate(-a.x, -a.y);
            return this._renderer.render({
                container: s,
                transform: c,
                target: o,
                clearColor: r
            }), o.source.updateMipmaps(), o;
        }
        destroy() {
            this._renderer = null;
        }
    }
    c_.extension = {
        type: [
            se.WebGLSystem,
            se.WebGPUSystem
        ],
        name: "textureGenerator"
    };
    Kw = function(i, e, t) {
        const n = (i >> 24 & 255) / 255;
        e[t++] = (i & 255) / 255 * n, e[t++] = (i >> 8 & 255) / 255 * n, e[t++] = (i >> 16 & 255) / 255 * n, e[t++] = n;
    };
    class l_ {
        constructor(e){
            this._stackIndex = 0, this._globalUniformDataStack = [], this._uniformsPool = [], this._activeUniforms = [], this._bindGroupPool = [], this._activeBindGroups = [], this._renderer = e;
        }
        reset() {
            this._stackIndex = 0;
            for(let e = 0; e < this._activeUniforms.length; e++)this._uniformsPool.push(this._activeUniforms[e]);
            for(let e = 0; e < this._activeBindGroups.length; e++)this._bindGroupPool.push(this._activeBindGroups[e]);
            this._activeUniforms.length = 0, this._activeBindGroups.length = 0;
        }
        start(e) {
            this.reset(), this.push(e);
        }
        bind({ size: e, projectionMatrix: t, worldTransformMatrix: n, worldColor: s, offset: r }) {
            const a = this._renderer.renderTarget.renderTarget, o = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {
                worldTransformMatrix: new Fe,
                worldColor: 4294967295,
                offset: new Lt
            }, c = {
                projectionMatrix: t || this._renderer.renderTarget.projectionMatrix,
                resolution: e || a.size,
                worldTransformMatrix: n || o.worldTransformMatrix,
                worldColor: s || o.worldColor,
                offset: r || o.offset,
                bindGroup: null
            }, l = this._uniformsPool.pop() || this._createUniforms();
            this._activeUniforms.push(l);
            const h = l.uniforms;
            h.uProjectionMatrix = c.projectionMatrix, h.uResolution = c.resolution, h.uWorldTransformMatrix.copyFrom(c.worldTransformMatrix), h.uWorldTransformMatrix.tx -= c.offset.x, h.uWorldTransformMatrix.ty -= c.offset.y, Kw(c.worldColor, h.uWorldColorAlpha, 0), l.update();
            let u;
            this._renderer.renderPipes.uniformBatch ? u = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(l, !1) : (u = this._bindGroupPool.pop() || new gr, this._activeBindGroups.push(u), u.setResource(l, 0)), c.bindGroup = u, this._currentGlobalUniformData = c;
        }
        push(e) {
            this.bind(e), this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;
        }
        pop() {
            this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1], this._renderer.type === Xi.WEBGL && this._currentGlobalUniformData.bindGroup.resources[0].update();
        }
        get bindGroup() {
            return this._currentGlobalUniformData.bindGroup;
        }
        get globalUniformData() {
            return this._currentGlobalUniformData;
        }
        get uniformGroup() {
            return this._currentGlobalUniformData.bindGroup.resources[0];
        }
        _createUniforms() {
            return new $i({
                uProjectionMatrix: {
                    value: new Fe,
                    type: "mat3x3<f32>"
                },
                uWorldTransformMatrix: {
                    value: new Fe,
                    type: "mat3x3<f32>"
                },
                uWorldColorAlpha: {
                    value: new Float32Array(4),
                    type: "vec4<f32>"
                },
                uResolution: {
                    value: [
                        0,
                        0
                    ],
                    type: "vec2<f32>"
                }
            }, {
                isStatic: !0
            });
        }
        destroy() {
            this._renderer = null;
        }
    }
    l_.extension = {
        type: [
            se.WebGLSystem,
            se.WebGPUSystem,
            se.CanvasSystem
        ],
        name: "globalUniforms"
    };
    let Zw = 1;
    class h_ {
        constructor(){
            this._tasks = [], this._offset = 0;
        }
        init() {
            Ss.system.add(this._update, this);
        }
        repeat(e, t, n = !0) {
            const s = Zw++;
            let r = 0;
            return n && (this._offset += 1e3, r = this._offset), this._tasks.push({
                func: e,
                duration: t,
                start: performance.now(),
                offset: r,
                last: performance.now(),
                repeat: !0,
                id: s
            }), s;
        }
        cancel(e) {
            for(let t = 0; t < this._tasks.length; t++)if (this._tasks[t].id === e) {
                this._tasks.splice(t, 1);
                return;
            }
        }
        _update() {
            const e = performance.now();
            for(let t = 0; t < this._tasks.length; t++){
                const n = this._tasks[t];
                if (e - n.offset - n.last >= n.duration) {
                    const s = e - n.start;
                    n.func(s), n.last = e;
                }
            }
        }
        destroy() {
            Ss.system.remove(this._update, this), this._tasks.length = 0;
        }
    }
    h_.extension = {
        type: [
            se.WebGLSystem,
            se.WebGPUSystem,
            se.CanvasSystem
        ],
        name: "scheduler",
        priority: 0
    };
    let yf = !1;
    function Jw(i) {
        if (!yf) {
            if (jt.get().getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
                const e = [
                    `%c  %c  %c  %c  %c PixiJS %c v${Al} (${i}) http://www.pixijs.com/

`,
                    "background: #E72264; padding:5px 0;",
                    "background: #6CA2EA; padding:5px 0;",
                    "background: #B5D33D; padding:5px 0;",
                    "background: #FED23F; padding:5px 0;",
                    "color: #FFFFFF; background: #E72264; padding:5px 0;",
                    "color: #E72264; background: #FFFFFF; padding:5px 0;"
                ];
                globalThis.console.log(...e);
            } else globalThis.console && globalThis.console.log(`PixiJS ${Al} - ${i} - http://www.pixijs.com/`);
            yf = !0;
        }
    }
    class Ph {
        constructor(e){
            this._renderer = e;
        }
        init(e) {
            if (e.hello) {
                let t = this._renderer.name;
                this._renderer.type === Xi.WEBGL && (t += ` ${this._renderer.context.webGLVersion}`), Jw(t);
            }
        }
    }
    Ph.extension = {
        type: [
            se.WebGLSystem,
            se.WebGPUSystem,
            se.CanvasSystem
        ],
        name: "hello",
        priority: -2
    };
    Ph.defaultOptions = {
        hello: !1
    };
    function Qw(i) {
        let e = !1;
        for(const n in i)if (i[n] == null) {
            e = !0;
            break;
        }
        if (!e) return i;
        const t = Object.create(null);
        for(const n in i){
            const s = i[n];
            s && (t[n] = s);
        }
        return t;
    }
    function e1(i) {
        let e = 0;
        for(let t = 0; t < i.length; t++)i[t] == null ? e++ : i[t - e] = i[t];
        return i.length -= e, i;
    }
    let t1 = 0;
    const Ih = class u_ {
        constructor(e){
            this._managedRenderables = [], this._managedHashes = [], this._managedArrays = [], this._renderer = e;
        }
        init(e) {
            e = {
                ...u_.defaultOptions,
                ...e
            }, this.maxUnusedTime = e.renderableGCMaxUnusedTime, this._frequency = e.renderableGCFrequency, this.enabled = e.renderableGCActive;
        }
        get enabled() {
            return !!this._handler;
        }
        set enabled(e) {
            this.enabled !== e && (e ? (this._handler = this._renderer.scheduler.repeat(()=>this.run(), this._frequency, !1), this._hashHandler = this._renderer.scheduler.repeat(()=>{
                for (const t of this._managedHashes)t.context[t.hash] = Qw(t.context[t.hash]);
            }, this._frequency), this._arrayHandler = this._renderer.scheduler.repeat(()=>{
                for (const t of this._managedArrays)e1(t.context[t.hash]);
            }, this._frequency)) : (this._renderer.scheduler.cancel(this._handler), this._renderer.scheduler.cancel(this._hashHandler), this._renderer.scheduler.cancel(this._arrayHandler)));
        }
        addManagedHash(e, t) {
            this._managedHashes.push({
                context: e,
                hash: t
            });
        }
        addManagedArray(e, t) {
            this._managedArrays.push({
                context: e,
                hash: t
            });
        }
        prerender({ container: e }) {
            this._now = performance.now(), e.renderGroup.gcTick = t1++, this._updateInstructionGCTick(e.renderGroup, e.renderGroup.gcTick);
        }
        addRenderable(e) {
            this.enabled && (e._lastUsed === -1 && (this._managedRenderables.push(e), e.once("destroyed", this._removeRenderable, this)), e._lastUsed = this._now);
        }
        run() {
            const e = this._now, t = this._managedRenderables, n = this._renderer.renderPipes;
            let s = 0;
            for(let r = 0; r < t.length; r++){
                const a = t[r];
                if (a === null) {
                    s++;
                    continue;
                }
                const o = a.renderGroup ?? a.parentRenderGroup, c = o?.instructionSet?.gcTick ?? -1;
                if ((o?.gcTick ?? 0) === c && (a._lastUsed = e), e - a._lastUsed > this.maxUnusedTime) {
                    if (!a.destroyed) {
                        const l = n;
                        o && (o.structureDidChange = !0), l[a.renderPipeId].destroyRenderable(a);
                    }
                    a._lastUsed = -1, s++, a.off("destroyed", this._removeRenderable, this);
                } else t[r - s] = a;
            }
            t.length -= s;
        }
        destroy() {
            this.enabled = !1, this._renderer = null, this._managedRenderables.length = 0, this._managedHashes.length = 0, this._managedArrays.length = 0;
        }
        _removeRenderable(e) {
            const t = this._managedRenderables.indexOf(e);
            t >= 0 && (e.off("destroyed", this._removeRenderable, this), this._managedRenderables[t] = null);
        }
        _updateInstructionGCTick(e, t) {
            e.instructionSet.gcTick = t;
            for (const n of e.renderGroupChildren)this._updateInstructionGCTick(n, t);
        }
    };
    Ih.extension = {
        type: [
            se.WebGLSystem,
            se.WebGPUSystem
        ],
        name: "renderableGC",
        priority: 0
    };
    Ih.defaultOptions = {
        renderableGCActive: !0,
        renderableGCMaxUnusedTime: 6e4,
        renderableGCFrequency: 3e4
    };
    let n1 = Ih;
    const Dh = class d_ {
        constructor(e){
            this._renderer = e, this.count = 0, this.checkCount = 0;
        }
        init(e) {
            e = {
                ...d_.defaultOptions,
                ...e
            }, this.checkCountMax = e.textureGCCheckCountMax, this.maxIdle = e.textureGCAMaxIdle ?? e.textureGCMaxIdle, this.active = e.textureGCActive;
        }
        postrender() {
            this._renderer.renderingToScreen && (this.count++, this.active && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())));
        }
        run() {
            const e = this._renderer.texture.managedTextures;
            for(let t = 0; t < e.length; t++){
                const n = e[t];
                n.autoGarbageCollect && n.resource && n._touched > -1 && this.count - n._touched > this.maxIdle && (n._touched = -1, n.unload());
            }
        }
        destroy() {
            this._renderer = null;
        }
    };
    Dh.extension = {
        type: [
            se.WebGLSystem,
            se.WebGPUSystem
        ],
        name: "textureGC"
    };
    Dh.defaultOptions = {
        textureGCActive: !0,
        textureGCAMaxIdle: null,
        textureGCMaxIdle: 60 * 60,
        textureGCCheckCountMax: 600
    };
    let i1 = Dh;
    const Lh = class f_ {
        get autoDensity() {
            return this.texture.source.autoDensity;
        }
        set autoDensity(e) {
            this.texture.source.autoDensity = e;
        }
        get resolution() {
            return this.texture.source._resolution;
        }
        set resolution(e) {
            this.texture.source.resize(this.texture.source.width, this.texture.source.height, e);
        }
        init(e) {
            e = {
                ...f_.defaultOptions,
                ...e
            }, e.view && (ut(bt, "ViewSystem.view has been renamed to ViewSystem.canvas"), e.canvas = e.view), this.screen = new ft(0, 0, e.width, e.height), this.canvas = e.canvas || jt.get().createCanvas(), this.antialias = !!e.antialias, this.texture = Om(this.canvas, e), this.renderTarget = new Ul({
                colorTextures: [
                    this.texture
                ],
                depth: !!e.depth,
                isRoot: !0
            }), this.texture.source.transparent = e.backgroundAlpha < 1, this.resolution = e.resolution;
        }
        resize(e, t, n) {
            this.texture.source.resize(e, t, n), this.screen.width = this.texture.frame.width, this.screen.height = this.texture.frame.height;
        }
        destroy(e = !1) {
            (typeof e == "boolean" ? e : !!e?.removeView) && this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);
        }
    };
    Lh.extension = {
        type: [
            se.WebGLSystem,
            se.WebGPUSystem,
            se.CanvasSystem
        ],
        name: "view",
        priority: 0
    };
    Lh.defaultOptions = {
        width: 800,
        height: 600,
        autoDensity: !1,
        antialias: !1
    };
    let s1 = Lh;
    const r1 = [
        Xw,
        l_,
        Ph,
        s1,
        i_,
        i1,
        c_,
        Yw,
        Zp,
        n1,
        h_
    ], a1 = [
        a_,
        Sm,
        s_,
        e_,
        Tm,
        Am,
        Em,
        Jm
    ], o1 = [
        ...r1,
        Fm,
        JA,
        YA,
        wm,
        $m,
        Hm,
        Pm,
        Ym,
        Xm,
        Lm,
        Rw,
        Um,
        Dm
    ], c1 = [
        ...a1
    ], l1 = [
        ym,
        Zm,
        Km
    ], p_ = [], m_ = [], __ = [];
    Nt.handleByNamedList(se.WebGLSystem, p_);
    Nt.handleByNamedList(se.WebGLPipes, m_);
    Nt.handleByNamedList(se.WebGLPipesAdaptor, __);
    Nt.add(...o1, ...c1, ...l1);
    class h1 extends XT {
        constructor(){
            const e = {
                name: "webgl",
                type: Xi.WEBGL,
                systems: p_,
                renderPipes: m_,
                renderPipeAdaptors: __
            };
            super(e);
        }
    }
    Nt.add(xM, vM);
    class u1 {
        _renderer;
        constructor(){
            this._renderer = new h1;
        }
        init = async (e, t, n, s)=>{
            await this._renderer.init({
                canvas: e,
                context: t,
                width: n,
                height: s,
                clearBeforeRender: !1
            });
        };
        get renderer() {
            return this._renderer;
        }
        render(e) {
            if (!e) {
                console.warn("No game scene provided for rendering.");
                return;
            }
            this._renderer.resetState(), e.entities2D.forEach((t)=>{
                t?.renderable && this._renderer.render({
                    container: t,
                    clear: !1
                });
            });
        }
        resize = (e, t)=>{
            this._renderer.resize(e, t);
        };
    }
    class An {
        static _instance = new An;
        _scenes = new Map;
        _currentScene = null;
        static get instance() {
            return this._instance;
        }
        constructor(){}
        addScene(e, t) {
            this._scenes.set(e, t);
        }
        getScene(e) {
            return this._scenes.get(e);
        }
        switchToScene(e) {
            this._currentScene = this._scenes.get(e) || null;
        }
        get currentScene() {
            return this._currentScene;
        }
        removeScene(e) {
            this._scenes.delete(e);
        }
        clearScenes() {
            this._scenes.clear();
        }
        listScenes() {
            return Array.from(this._scenes.keys());
        }
        hasScene(e) {
            return this._scenes.has(e);
        }
    }
    class d1 {
        _model;
        _animationMixer;
        _animationIndex = 0;
        _animationLoopStyle = Pa;
        _keyPressed = new Set;
        _collider;
        _moveX = 0;
        _moveY = 0;
        _moveSpeed = 2;
        static animationNames = [
            "Attack",
            "Brag",
            "Defend",
            "Hit",
            "Idle"
        ];
        constructor(e){
            this._model = Wi.instance.getModel("ninja"), this._animationMixer = new Zx(this._model.scene), this._animationIndex = this._model.animations.length - 1, this._model.scene.rotateY(Math.PI * .5), this._model.scene.position.copy(e), this._model.scene.scale.set(.5, .5, .5), this._collider = new fn().setFromObject(this._model.scene);
        }
        load = ()=>{
            this._model.scene.traverse((t)=>{
                t instanceof kt && (t.material.map = Wi.instance.getTexture("ninja"));
            });
        };
        get model() {
            return this._model;
        }
        setAnimation = (e, t = Pa)=>{
            this._animationIndex = e, this._animationLoopStyle = t, this._animationMixer.stopAllAction();
        };
        update = (e)=>{
            this.handleInput(), this._model.scene.position.y < 0 && (this._animationIndex = 1), this._animationMixer.clipAction(this._model.animations[this._animationIndex]).play().setLoop(this._animationLoopStyle, 1 / 0), this._animationMixer.update(e), this._keyPressed.has("a") || this._keyPressed.has("ArrowLeft") ? (this._model.scene.rotation.y = Math.PI * 1.5, this._model.scene.position.x -= this._moveSpeed * e) : this._keyPressed.has("d") || this._keyPressed.has("ArrowRight") ? (this._model.scene.rotation.y = Math.PI * .5, this._model.scene.position.x += this._moveSpeed * e) : this._keyPressed.has("w") || this._keyPressed.has("ArrowUp") ? this._model.scene.position.y += this._moveSpeed * e : this._keyPressed.has("s") || this._keyPressed.has("ArrowDown") ? this._model.scene.position.y -= this._moveSpeed * e : this._moveX != 0 ? (this._model.scene.rotation.y = Math.PI * (this._moveX > 0 ? .5 : 1.5), this._model.scene.position.x += this._moveX * e) : this._moveY != 0 && (this._model.scene.position.y += this._moveY * e);
        };
        onMousePressed = (e)=>{
            if (e.button == 0) {
                const t = e.clientX, n = e.clientY, s = t - window.innerWidth / 2, r = n - window.innerHeight / 2;
                Math.abs(s) > Math.abs(r) ? t > window.innerWidth / 2 ? (this._model.scene.rotation.y = Math.PI * .5, this._moveX = this._moveSpeed, this._moveY = 0) : (this._model.scene.rotation.y = Math.PI * 1.5, this._moveX = -this._moveSpeed, this._moveY = 0) : n > window.innerHeight / 2 ? (this._moveX = 0, this._moveY = -this._moveSpeed) : (this._moveX = 0, this._moveY = this._moveSpeed);
            }
        };
        onMouseReleased = (e)=>{
            e.button == 0 && (this._moveX = 0, this._moveY = 0);
        };
        handleInput() {
            let e = (n)=>{
                switch(this._keyPressed.add(n.key.toLowerCase()), n.key){
                    case "1":
                        this.setAnimation(0, or);
                        break;
                    case "2":
                        this.setAnimation(1, or);
                        break;
                    case "3":
                        this.setAnimation(2, or);
                        break;
                    case "4":
                        this.setAnimation(3, or);
                        break;
                    case "5":
                        this.setAnimation(4, Pa);
                        break;
                }
            }, t = (n)=>{
                this._keyPressed.delete(n.key.toLowerCase());
            };
            document.addEventListener("keydown", e), document.addEventListener("keyup", t);
        }
        checkCollisions = (e)=>{
            const t = this._model.scene.position.z;
            this._model.scene.position.z = 0;
            const n = new fn().setFromObject(this._model.scene);
            this._collider = n;
            let s = !1;
            return e.forEach((r)=>{
                const a = new fn().setFromObject(r);
                let o = new k;
                a.getSize(o), a.intersectsBox(this._collider) && (s = !0);
            }), this._model.scene.position.z = t, s;
        };
    }
    class f1 {
        _entities2D = [];
        _entities3D = [];
        _camera3D;
        _width;
        _height;
        constructor(e, t){
            this._width = e, this._height = t, this._camera3D = new Wt(60, e / t, .1, 1e3);
        }
        get camera3D() {
            return this._camera3D;
        }
        get entities2D() {
            return this._entities2D;
        }
        get entities3D() {
            return this._entities3D;
        }
        update(e) {}
        onMousePressed(e) {}
        onMouseReleased(e) {}
        resize(e, t) {
            this._width = e, this._height = t, console.log("resize", e, t), this._camera3D.aspect = this._width / this._height, this._camera3D.updateProjectionMatrix();
        }
    }
    class p1 extends f1 {
        _container;
        _scene;
        _time = 0;
        _frameCount = 0;
        _fpsText = new xc;
        _dateTime = new Date;
        _player = new d1(new k(1, 1, .7));
        _walls = [];
        _exitX = 0;
        _exitY = 0;
        constructor(e, t){
            super(e, t), this._container = new wn, this.fillContainer(), this._scene = new rx, this.addTiles3D(), this.addPlayer();
        }
        addPlayer() {
            this._player.load(), this._scene.add(this._player.model.scene), this._player.model.scene.rotation.y = Math.PI * .5;
            const e = new tp(16777215, 1);
            e.position.set(0, 0, 5), this._scene.add(this._player.model.scene, e, new Nx), this._camera3D.position.x = this._player.model.scene.position.x, this._camera3D.position.y = this._player.model.scene.position.y, this._camera3D.position.z = 10, this._entities3D.push(this._scene);
        }
        fillContainer() {
            const t = new ja().rect(0, 0, this._width, 30).fill("DarkOrange");
            this._container.addChild(t.clone()), this._fpsText.style = {
                fontFamily: "Arial",
                fontSize: t.height * .5,
                fill: "MediumBlue"
            }, this._fpsText.x = 10, this._fpsText.y = t.y + t.height * .5 - this._fpsText.height * .5;
            const n = new xc({
                text: this._dateTime.toDateString(),
                style: {
                    fontFamily: "Arial",
                    fontSize: t.height * .5,
                    fill: "MediumBlue"
                }
            });
            n.x = this._width - n.width - 10, n.y = t.y + t.height * .5 - n.height * .5;
            const s = new xc({
                text: "Ninja Maze Game",
                style: {
                    fontFamily: "Arial",
                    fontSize: t.height * .5,
                    fill: "MediumBlue"
                }
            });
            s.x = (this._width - s.width) * .5, s.y = t.y + t.height * .5 - s.height * .5;
        }
        addTiles3D = ()=>{
            const e = [
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    1,
                    0,
                    1,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    1,
                    0,
                    1,
                    1,
                    0,
                    1,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    0,
                    1,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    0
                ],
                [
                    1,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    0,
                    1,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    0
                ],
                [
                    1,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    1,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    1,
                    0,
                    0,
                    0,
                    1,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ]
            ];
            this._exitX = 15, this._exitY = 5;
            const t = new Ur(1, 1), n = new Rr({
                map: Wi.instance.getTexture("ground")
            }), s = new ks(1, 1, 1), r = new Rr({
                map: Wi.instance.getTexture("wall")
            }), a = new kt(s, r), o = new kt(t, n);
            for(let c = 0; c < e.length; c++)for(let l = 0; l < e[c].length; l++){
                const h = l, u = e.length - 1 - c;
                if (o.position.set(h, u, 0), this._scene.add(o.clone()), e[c][l] == 1) {
                    const d = a.clone();
                    d.position.set(h, u, 0), this._walls.push(d), this._scene.add(d);
                }
            }
        };
        update(e) {
            super.update(e), this._time += e, this._frameCount++, this._time >= 1 && (this._time -= 1, this._fpsText.text = `FPS: ${this._frameCount}`, this._frameCount = 0);
            const t = this._player.model.scene.position.clone();
            if (this._player.update(e), this._player.checkCollisions(this._walls)) {
                this._player.model.scene.position.copy(t);
                return;
            }
            this._camera3D.position.x = this._player.model.scene.position.x, this._camera3D.position.y = this._player.model.scene.position.y, Math.abs(this._player.model.scene.position.x - this._exitX) < .5 && Math.abs(this._player.model.scene.position.y - this._exitY) < .5 && (console.log("Level completed."), this._player.setAnimation(1));
        }
        onMousePressed(e) {
            super.onMousePressed(e), this._player.onMousePressed(e);
        }
        onMouseReleased(e) {
            super.onMouseReleased(e), this._player.onMouseReleased(e);
        }
        resize(e, t) {
            super.resize(e, t), this._container.width = e;
        }
    }
    const Dr = document.getElementById("main");
    if (!Dr) throw new Error("Canvas element not found");
    console.log("Canvas", Dr.width, Dr.height);
    const Hi = new mM(Dr), Uh = new u1, m1 = async ()=>{
        await Uh.init(Dr, Hi.renderer.getContext(), Hi.width, Hi.height), await Wi.instance.loadAsync();
    };
    await m1();
    An.instance.addScene("maze", new p1(Hi.width, Hi.height));
    An.instance.switchToScene("maze");
    if (!An.instance.currentScene) throw new Error("Scene not found");
    window.addEventListener("resize", ()=>{
        const i = window.innerWidth, e = window.innerHeight;
        Hi.resize(i, e), Uh.resize(i, e), An.instance.currentScene?.resize(i, e);
    });
    document.addEventListener("pointerdown", (i)=>{
        An.instance.currentScene?.onMousePressed(i);
    });
    document.addEventListener("pointerup", (i)=>{
        An.instance.currentScene?.onMouseReleased(i);
    });
    const _1 = new Ox, g_ = ()=>{
        const i = _1.getDelta();
        An.instance.currentScene?.update(i), Hi.render(An.instance.currentScene), Uh.render(An.instance.currentScene), requestAnimationFrame(g_);
    };
    g_();
})();
export { rm as $, Ki as A, gr as B, wn as C, jt as D, se as E, ph as F, nm as G, Br as H, Ya as I, Ws as J, PM as K, RE as L, Fe as M, vc as N, UE as O, Lt as P, xh as Q, ft as R, Fr as S, Ss as T, yl as U, Od as V, Mm as W, vh as X, eo as Y, CE as Z, DE as _, Cn as a, am as a0, om as a1, ja as a2, IM as a3, Qm as a4, pm as a5, Oe as b, Pt as c, ut as d, Nt as e, Yi as f, NA as g, BA as h, Dl as i, gs as j, $i as k, As as l, Xi as m, dd as n, en as o, qi as p, St as q, WM as r, PA as s, Kw as t, Gt as u, bt as v, _t as w, um as x, Gd as y, Pr as z, __tla };
