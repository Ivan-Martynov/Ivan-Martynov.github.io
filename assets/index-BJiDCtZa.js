const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/browserAll-FGtH13EM.js","assets/webworkerAll-BEf_tPj_.js"])))=>i.map(i=>d[i]);
let _t, HA, Br, Jt, Oh, J, c_, Lm, kh, go, FA, kA, Fm, Ne, Nm, Om, Ot, Pf, ns, Kr, Ps, Uc, Qd, VE, oi, Mt, GT, k_, yn, Ef, mt, $c, so, qc, Rf, Xm, rs, Ls, Ie, At, sn, et, is, wt, Et, $s, NE, J1, Vt, zm, tf, Xr, QT, as, $r, ir, dt, tt, kT, UA, Bl;
let __tla = (async ()=>{
    (function() {
        const e = document.createElement("link").relList;
        if (e && e.supports && e.supports("modulepreload")) return;
        for (const s of document.querySelectorAll('link[rel="modulepreload"]'))n(s);
        new MutationObserver((s)=>{
            for (const r of s)if (r.type === "childList") for (const a of r.addedNodes)a.tagName === "LINK" && a.rel === "modulepreload" && n(a);
        }).observe(document, {
            childList: !0,
            subtree: !0
        });
        function t(s) {
            const r = {};
            return s.integrity && (r.integrity = s.integrity), s.referrerPolicy && (r.referrerPolicy = s.referrerPolicy), s.crossOrigin === "use-credentials" ? r.credentials = "include" : s.crossOrigin === "anonymous" ? r.credentials = "omit" : r.credentials = "same-origin", r;
        }
        function n(s) {
            if (s.ep) return;
            s.ep = !0;
            const r = t(s);
            fetch(s.href, r);
        }
    })();
    const sh = "175", fg = 0, hu = 1, pg = 2, Jf = 1, mg = 2, ei = 3, ci = 0, tn = 1, gn = 2, Ti = 0, Is = 1, uu = 2, du = 3, fu = 4, _g = 5, Yi = 100, gg = 101, xg = 102, vg = 103, yg = 104, bg = 200, Sg = 201, Tg = 202, Mg = 203, Hl = 204, zl = 205, Ag = 206, Eg = 207, wg = 208, Rg = 209, Cg = 210, Pg = 211, Ig = 212, Dg = 213, Lg = 214, Vl = 0, Wl = 1, Xl = 2, Ns = 3, Yl = 4, jl = 5, ql = 6, $l = 7, Qf = 0, Bg = 1, Ug = 2, Mi = 0, Fg = 1, Ng = 2, Og = 3, kg = 4, Gg = 5, Hg = 6, zg = 7, pu = "attached", Vg = "detached", ep = 300, Os = 301, ks = 302, Kl = 303, Zl = 304, ho = 306, Gs = 1e3, yi = 1001, Ja = 1002, $t = 1003, tp = 1004, Tr = 1005, cn = 1006, Oa = 1007, ni = 1008, hi = 1009, np = 1010, ip = 1011, Or = 1012, rh = 1013, Ji = 1014, Pn = 1015, jr = 1016, ah = 1017, oh = 1018, kr = 1020, sp = 35902, rp = 1021, ap = 1022, xn = 1023, op = 1024, lp = 1025, Gr = 1026, Hr = 1027, lh = 1028, ch = 1029, cp = 1030, hh = 1031, uh = 1033, ka = 33776, Ga = 33777, Ha = 33778, za = 33779, Jl = 35840, Ql = 35841, ec = 35842, tc = 35843, nc = 36196, ic = 37492, sc = 37496, rc = 37808, ac = 37809, oc = 37810, lc = 37811, cc = 37812, hc = 37813, uc = 37814, dc = 37815, fc = 37816, pc = 37817, mc = 37818, _c = 37819, gc = 37820, xc = 37821, Va = 36492, vc = 36494, yc = 36495, hp = 36283, bc = 36284, Sc = 36285, Tc = 36286, Wg = 2200, up = 2201, Xg = 2202, zr = 2300, Vr = 2301, bo = 2302, ws = 2400, Rs = 2401, Qa = 2402, dh = 2500, Yg = 2501, jg = 0, dp = 1, Mc = 2, qg = 3200, $g = 3201, fp = 0, Kg = 1, vi = "", Ft = "srgb", Zt = "srgb-linear", eo = "linear", ut = "srgb", cs = 7680, mu = 519, Zg = 512, Jg = 513, Qg = 514, pp = 515, ex = 516, tx = 517, nx = 518, ix = 519, Ac = 35044, _u = "300 es", ii = 2e3, to = 2001;
    class ss {
        addEventListener(e, t) {
            this._listeners === void 0 && (this._listeners = {});
            const n = this._listeners;
            n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
        }
        hasEventListener(e, t) {
            const n = this._listeners;
            return n === void 0 ? !1 : n[e] !== void 0 && n[e].indexOf(t) !== -1;
        }
        removeEventListener(e, t) {
            const n = this._listeners;
            if (n === void 0) return;
            const s = n[e];
            if (s !== void 0) {
                const r = s.indexOf(t);
                r !== -1 && s.splice(r, 1);
            }
        }
        dispatchEvent(e) {
            const t = this._listeners;
            if (t === void 0) return;
            const n = t[e.type];
            if (n !== void 0) {
                e.target = this;
                const s = n.slice(0);
                for(let r = 0, a = s.length; r < a; r++)s[r].call(this, e);
                e.target = null;
            }
        }
    }
    const Ht = [
        "00",
        "01",
        "02",
        "03",
        "04",
        "05",
        "06",
        "07",
        "08",
        "09",
        "0a",
        "0b",
        "0c",
        "0d",
        "0e",
        "0f",
        "10",
        "11",
        "12",
        "13",
        "14",
        "15",
        "16",
        "17",
        "18",
        "19",
        "1a",
        "1b",
        "1c",
        "1d",
        "1e",
        "1f",
        "20",
        "21",
        "22",
        "23",
        "24",
        "25",
        "26",
        "27",
        "28",
        "29",
        "2a",
        "2b",
        "2c",
        "2d",
        "2e",
        "2f",
        "30",
        "31",
        "32",
        "33",
        "34",
        "35",
        "36",
        "37",
        "38",
        "39",
        "3a",
        "3b",
        "3c",
        "3d",
        "3e",
        "3f",
        "40",
        "41",
        "42",
        "43",
        "44",
        "45",
        "46",
        "47",
        "48",
        "49",
        "4a",
        "4b",
        "4c",
        "4d",
        "4e",
        "4f",
        "50",
        "51",
        "52",
        "53",
        "54",
        "55",
        "56",
        "57",
        "58",
        "59",
        "5a",
        "5b",
        "5c",
        "5d",
        "5e",
        "5f",
        "60",
        "61",
        "62",
        "63",
        "64",
        "65",
        "66",
        "67",
        "68",
        "69",
        "6a",
        "6b",
        "6c",
        "6d",
        "6e",
        "6f",
        "70",
        "71",
        "72",
        "73",
        "74",
        "75",
        "76",
        "77",
        "78",
        "79",
        "7a",
        "7b",
        "7c",
        "7d",
        "7e",
        "7f",
        "80",
        "81",
        "82",
        "83",
        "84",
        "85",
        "86",
        "87",
        "88",
        "89",
        "8a",
        "8b",
        "8c",
        "8d",
        "8e",
        "8f",
        "90",
        "91",
        "92",
        "93",
        "94",
        "95",
        "96",
        "97",
        "98",
        "99",
        "9a",
        "9b",
        "9c",
        "9d",
        "9e",
        "9f",
        "a0",
        "a1",
        "a2",
        "a3",
        "a4",
        "a5",
        "a6",
        "a7",
        "a8",
        "a9",
        "aa",
        "ab",
        "ac",
        "ad",
        "ae",
        "af",
        "b0",
        "b1",
        "b2",
        "b3",
        "b4",
        "b5",
        "b6",
        "b7",
        "b8",
        "b9",
        "ba",
        "bb",
        "bc",
        "bd",
        "be",
        "bf",
        "c0",
        "c1",
        "c2",
        "c3",
        "c4",
        "c5",
        "c6",
        "c7",
        "c8",
        "c9",
        "ca",
        "cb",
        "cc",
        "cd",
        "ce",
        "cf",
        "d0",
        "d1",
        "d2",
        "d3",
        "d4",
        "d5",
        "d6",
        "d7",
        "d8",
        "d9",
        "da",
        "db",
        "dc",
        "dd",
        "de",
        "df",
        "e0",
        "e1",
        "e2",
        "e3",
        "e4",
        "e5",
        "e6",
        "e7",
        "e8",
        "e9",
        "ea",
        "eb",
        "ec",
        "ed",
        "ee",
        "ef",
        "f0",
        "f1",
        "f2",
        "f3",
        "f4",
        "f5",
        "f6",
        "f7",
        "f8",
        "f9",
        "fa",
        "fb",
        "fc",
        "fd",
        "fe",
        "ff"
    ];
    let gu = 1234567;
    const Cr = Math.PI / 180, Hs = 180 / Math.PI;
    function In() {
        const i = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0;
        return (Ht[i & 255] + Ht[i >> 8 & 255] + Ht[i >> 16 & 255] + Ht[i >> 24 & 255] + "-" + Ht[e & 255] + Ht[e >> 8 & 255] + "-" + Ht[e >> 16 & 15 | 64] + Ht[e >> 24 & 255] + "-" + Ht[t & 63 | 128] + Ht[t >> 8 & 255] + "-" + Ht[t >> 16 & 255] + Ht[t >> 24 & 255] + Ht[n & 255] + Ht[n >> 8 & 255] + Ht[n >> 16 & 255] + Ht[n >> 24 & 255]).toLowerCase();
    }
    function Ye(i, e, t) {
        return Math.max(e, Math.min(t, i));
    }
    function fh(i, e) {
        return (i % e + e) % e;
    }
    function sx(i, e, t, n, s) {
        return n + (i - e) * (s - n) / (t - e);
    }
    function rx(i, e, t) {
        return i !== e ? (t - i) / (e - i) : 0;
    }
    function Pr(i, e, t) {
        return (1 - t) * i + t * e;
    }
    function ax(i, e, t, n) {
        return Pr(i, e, 1 - Math.exp(-t * n));
    }
    function ox(i, e = 1) {
        return e - Math.abs(fh(i, e * 2) - e);
    }
    function lx(i, e, t) {
        return i <= e ? 0 : i >= t ? 1 : (i = (i - e) / (t - e), i * i * (3 - 2 * i));
    }
    function cx(i, e, t) {
        return i <= e ? 0 : i >= t ? 1 : (i = (i - e) / (t - e), i * i * i * (i * (i * 6 - 15) + 10));
    }
    function hx(i, e) {
        return i + Math.floor(Math.random() * (e - i + 1));
    }
    function ux(i, e) {
        return i + Math.random() * (e - i);
    }
    function dx(i) {
        return i * (.5 - Math.random());
    }
    function fx(i) {
        i !== void 0 && (gu = i);
        let e = gu += 1831565813;
        return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
    }
    function px(i) {
        return i * Cr;
    }
    function mx(i) {
        return i * Hs;
    }
    function _x(i) {
        return (i & i - 1) === 0 && i !== 0;
    }
    function gx(i) {
        return Math.pow(2, Math.ceil(Math.log(i) / Math.LN2));
    }
    function xx(i) {
        return Math.pow(2, Math.floor(Math.log(i) / Math.LN2));
    }
    function vx(i, e, t, n, s) {
        const r = Math.cos, a = Math.sin, o = r(t / 2), l = a(t / 2), h = r((e + n) / 2), d = a((e + n) / 2), c = r((e - n) / 2), u = a((e - n) / 2), f = r((n - e) / 2), _ = a((n - e) / 2);
        switch(s){
            case "XYX":
                i.set(o * d, l * c, l * u, o * h);
                break;
            case "YZY":
                i.set(l * u, o * d, l * c, o * h);
                break;
            case "ZXZ":
                i.set(l * c, l * u, o * d, o * h);
                break;
            case "XZX":
                i.set(o * d, l * _, l * f, o * h);
                break;
            case "YXY":
                i.set(l * f, o * d, l * _, o * h);
                break;
            case "ZYZ":
                i.set(l * _, l * f, o * d, o * h);
                break;
            default:
                console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + s);
        }
    }
    function wn(i, e) {
        switch(e.constructor){
            case Float32Array:
                return i;
            case Uint32Array:
                return i / 4294967295;
            case Uint16Array:
                return i / 65535;
            case Uint8Array:
                return i / 255;
            case Int32Array:
                return Math.max(i / 2147483647, -1);
            case Int16Array:
                return Math.max(i / 32767, -1);
            case Int8Array:
                return Math.max(i / 127, -1);
            default:
                throw new Error("Invalid component type.");
        }
    }
    function ht(i, e) {
        switch(e.constructor){
            case Float32Array:
                return i;
            case Uint32Array:
                return Math.round(i * 4294967295);
            case Uint16Array:
                return Math.round(i * 65535);
            case Uint8Array:
                return Math.round(i * 255);
            case Int32Array:
                return Math.round(i * 2147483647);
            case Int16Array:
                return Math.round(i * 32767);
            case Int8Array:
                return Math.round(i * 127);
            default:
                throw new Error("Invalid component type.");
        }
    }
    const yx = {
        DEG2RAD: Cr,
        RAD2DEG: Hs,
        generateUUID: In,
        clamp: Ye,
        euclideanModulo: fh,
        mapLinear: sx,
        inverseLerp: rx,
        lerp: Pr,
        damp: ax,
        pingpong: ox,
        smoothstep: lx,
        smootherstep: cx,
        randInt: hx,
        randFloat: ux,
        randFloatSpread: dx,
        seededRandom: fx,
        degToRad: px,
        radToDeg: mx,
        isPowerOfTwo: _x,
        ceilPowerOfTwo: gx,
        floorPowerOfTwo: xx,
        setQuaternionFromProperEuler: vx,
        normalize: ht,
        denormalize: wn
    };
    class Ze {
        constructor(e = 0, t = 0){
            Ze.prototype.isVector2 = !0, this.x = e, this.y = t;
        }
        get width() {
            return this.x;
        }
        set width(e) {
            this.x = e;
        }
        get height() {
            return this.y;
        }
        set height(e) {
            this.y = e;
        }
        set(e, t) {
            return this.x = e, this.y = t, this;
        }
        setScalar(e) {
            return this.x = e, this.y = e, this;
        }
        setX(e) {
            return this.x = e, this;
        }
        setY(e) {
            return this.y = e, this;
        }
        setComponent(e, t) {
            switch(e){
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e);
            }
            return this;
        }
        getComponent(e) {
            switch(e){
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error("index is out of range: " + e);
            }
        }
        clone() {
            return new this.constructor(this.x, this.y);
        }
        copy(e) {
            return this.x = e.x, this.y = e.y, this;
        }
        add(e) {
            return this.x += e.x, this.y += e.y, this;
        }
        addScalar(e) {
            return this.x += e, this.y += e, this;
        }
        addVectors(e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this;
        }
        addScaledVector(e, t) {
            return this.x += e.x * t, this.y += e.y * t, this;
        }
        sub(e) {
            return this.x -= e.x, this.y -= e.y, this;
        }
        subScalar(e) {
            return this.x -= e, this.y -= e, this;
        }
        subVectors(e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this;
        }
        multiply(e) {
            return this.x *= e.x, this.y *= e.y, this;
        }
        multiplyScalar(e) {
            return this.x *= e, this.y *= e, this;
        }
        divide(e) {
            return this.x /= e.x, this.y /= e.y, this;
        }
        divideScalar(e) {
            return this.multiplyScalar(1 / e);
        }
        applyMatrix3(e) {
            const t = this.x, n = this.y, s = e.elements;
            return this.x = s[0] * t + s[3] * n + s[6], this.y = s[1] * t + s[4] * n + s[7], this;
        }
        min(e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
        }
        max(e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
        }
        clamp(e, t) {
            return this.x = Ye(this.x, e.x, t.x), this.y = Ye(this.y, e.y, t.y), this;
        }
        clampScalar(e, t) {
            return this.x = Ye(this.x, e, t), this.y = Ye(this.y, e, t), this;
        }
        clampLength(e, t) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Ye(n, e, t));
        }
        floor() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
        }
        ceil() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
        }
        round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        }
        roundToZero() {
            return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
        }
        negate() {
            return this.x = -this.x, this.y = -this.y, this;
        }
        dot(e) {
            return this.x * e.x + this.y * e.y;
        }
        cross(e) {
            return this.x * e.y - this.y * e.x;
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y;
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
            return this.divideScalar(this.length() || 1);
        }
        angle() {
            return Math.atan2(-this.y, -this.x) + Math.PI;
        }
        angleTo(e) {
            const t = Math.sqrt(this.lengthSq() * e.lengthSq());
            if (t === 0) return Math.PI / 2;
            const n = this.dot(e) / t;
            return Math.acos(Ye(n, -1, 1));
        }
        distanceTo(e) {
            return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
            const t = this.x - e.x, n = this.y - e.y;
            return t * t + n * n;
        }
        manhattanDistanceTo(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
        }
        setLength(e) {
            return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
        }
        lerpVectors(e, t, n) {
            return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this;
        }
        equals(e) {
            return e.x === this.x && e.y === this.y;
        }
        fromArray(e, t = 0) {
            return this.x = e[t], this.y = e[t + 1], this;
        }
        toArray(e = [], t = 0) {
            return e[t] = this.x, e[t + 1] = this.y, e;
        }
        fromBufferAttribute(e, t) {
            return this.x = e.getX(t), this.y = e.getY(t), this;
        }
        rotateAround(e, t) {
            const n = Math.cos(t), s = Math.sin(t), r = this.x - e.x, a = this.y - e.y;
            return this.x = r * n - a * s + e.x, this.y = r * s + a * n + e.y, this;
        }
        random() {
            return this.x = Math.random(), this.y = Math.random(), this;
        }
        *[Symbol.iterator]() {
            yield this.x, yield this.y;
        }
    }
    class Ge {
        constructor(e, t, n, s, r, a, o, l, h){
            Ge.prototype.isMatrix3 = !0, this.elements = [
                1,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                1
            ], e !== void 0 && this.set(e, t, n, s, r, a, o, l, h);
        }
        set(e, t, n, s, r, a, o, l, h) {
            const d = this.elements;
            return d[0] = e, d[1] = s, d[2] = o, d[3] = t, d[4] = r, d[5] = l, d[6] = n, d[7] = a, d[8] = h, this;
        }
        identity() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
        }
        copy(e) {
            const t = this.elements, n = e.elements;
            return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this;
        }
        extractBasis(e, t, n) {
            return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
        }
        setFromMatrix4(e) {
            const t = e.elements;
            return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this;
        }
        multiply(e) {
            return this.multiplyMatrices(this, e);
        }
        premultiply(e) {
            return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
            const n = e.elements, s = t.elements, r = this.elements, a = n[0], o = n[3], l = n[6], h = n[1], d = n[4], c = n[7], u = n[2], f = n[5], _ = n[8], g = s[0], m = s[3], p = s[6], x = s[1], v = s[4], y = s[7], P = s[2], w = s[5], R = s[8];
            return r[0] = a * g + o * x + l * P, r[3] = a * m + o * v + l * w, r[6] = a * p + o * y + l * R, r[1] = h * g + d * x + c * P, r[4] = h * m + d * v + c * w, r[7] = h * p + d * y + c * R, r[2] = u * g + f * x + _ * P, r[5] = u * m + f * v + _ * w, r[8] = u * p + f * y + _ * R, this;
        }
        multiplyScalar(e) {
            const t = this.elements;
            return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
        }
        determinant() {
            const e = this.elements, t = e[0], n = e[1], s = e[2], r = e[3], a = e[4], o = e[5], l = e[6], h = e[7], d = e[8];
            return t * a * d - t * o * h - n * r * d + n * o * l + s * r * h - s * a * l;
        }
        invert() {
            const e = this.elements, t = e[0], n = e[1], s = e[2], r = e[3], a = e[4], o = e[5], l = e[6], h = e[7], d = e[8], c = d * a - o * h, u = o * l - d * r, f = h * r - a * l, _ = t * c + n * u + s * f;
            if (_ === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
            const g = 1 / _;
            return e[0] = c * g, e[1] = (s * h - d * n) * g, e[2] = (o * n - s * a) * g, e[3] = u * g, e[4] = (d * t - s * l) * g, e[5] = (s * r - o * t) * g, e[6] = f * g, e[7] = (n * l - h * t) * g, e[8] = (a * t - n * r) * g, this;
        }
        transpose() {
            let e;
            const t = this.elements;
            return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
        }
        getNormalMatrix(e) {
            return this.setFromMatrix4(e).invert().transpose();
        }
        transposeIntoArray(e) {
            const t = this.elements;
            return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
        }
        setUvTransform(e, t, n, s, r, a, o) {
            const l = Math.cos(r), h = Math.sin(r);
            return this.set(n * l, n * h, -n * (l * a + h * o) + a + e, -s * h, s * l, -s * (-h * a + l * o) + o + t, 0, 0, 1), this;
        }
        scale(e, t) {
            return this.premultiply(So.makeScale(e, t)), this;
        }
        rotate(e) {
            return this.premultiply(So.makeRotation(-e)), this;
        }
        translate(e, t) {
            return this.premultiply(So.makeTranslation(e, t)), this;
        }
        makeTranslation(e, t) {
            return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1), this;
        }
        makeRotation(e) {
            const t = Math.cos(e), n = Math.sin(e);
            return this.set(t, -n, 0, n, t, 0, 0, 0, 1), this;
        }
        makeScale(e, t) {
            return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
        }
        equals(e) {
            const t = this.elements, n = e.elements;
            for(let s = 0; s < 9; s++)if (t[s] !== n[s]) return !1;
            return !0;
        }
        fromArray(e, t = 0) {
            for(let n = 0; n < 9; n++)this.elements[n] = e[n + t];
            return this;
        }
        toArray(e = [], t = 0) {
            const n = this.elements;
            return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e;
        }
        clone() {
            return new this.constructor().fromArray(this.elements);
        }
    }
    const So = new Ge;
    function mp(i) {
        for(let e = i.length - 1; e >= 0; --e)if (i[e] >= 65535) return !0;
        return !1;
    }
    function Wr(i) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", i);
    }
    function bx() {
        const i = Wr("canvas");
        return i.style.display = "block", i;
    }
    const xu = {};
    function Wa(i) {
        i in xu || (xu[i] = !0, console.warn(i));
    }
    function Sx(i, e, t) {
        return new Promise(function(n, s) {
            function r() {
                switch(i.clientWaitSync(e, i.SYNC_FLUSH_COMMANDS_BIT, 0)){
                    case i.WAIT_FAILED:
                        s();
                        break;
                    case i.TIMEOUT_EXPIRED:
                        setTimeout(r, t);
                        break;
                    default:
                        n();
                }
            }
            setTimeout(r, t);
        });
    }
    function Tx(i) {
        const e = i.elements;
        e[2] = .5 * e[2] + .5 * e[3], e[6] = .5 * e[6] + .5 * e[7], e[10] = .5 * e[10] + .5 * e[11], e[14] = .5 * e[14] + .5 * e[15];
    }
    function Mx(i) {
        const e = i.elements;
        e[11] === -1 ? (e[10] = -e[10] - 1, e[14] = -e[14]) : (e[10] = -e[10], e[14] = -e[14] + 1);
    }
    const vu = new Ge().set(.4123908, .3575843, .1804808, .212639, .7151687, .0721923, .0193308, .1191948, .9505322), yu = new Ge().set(3.2409699, -1.5373832, -.4986108, -.9692436, 1.8759675, .0415551, .0556301, -.203977, 1.0569715);
    function Ax() {
        const i = {
            enabled: !0,
            workingColorSpace: Zt,
            spaces: {},
            convert: function(s, r, a) {
                return this.enabled === !1 || r === a || !r || !a || (this.spaces[r].transfer === ut && (s.r = si(s.r), s.g = si(s.g), s.b = si(s.b)), this.spaces[r].primaries !== this.spaces[a].primaries && (s.applyMatrix3(this.spaces[r].toXYZ), s.applyMatrix3(this.spaces[a].fromXYZ)), this.spaces[a].transfer === ut && (s.r = Ds(s.r), s.g = Ds(s.g), s.b = Ds(s.b))), s;
            },
            fromWorkingColorSpace: function(s, r) {
                return this.convert(s, this.workingColorSpace, r);
            },
            toWorkingColorSpace: function(s, r) {
                return this.convert(s, r, this.workingColorSpace);
            },
            getPrimaries: function(s) {
                return this.spaces[s].primaries;
            },
            getTransfer: function(s) {
                return s === vi ? eo : this.spaces[s].transfer;
            },
            getLuminanceCoefficients: function(s, r = this.workingColorSpace) {
                return s.fromArray(this.spaces[r].luminanceCoefficients);
            },
            define: function(s) {
                Object.assign(this.spaces, s);
            },
            _getMatrix: function(s, r, a) {
                return s.copy(this.spaces[r].toXYZ).multiply(this.spaces[a].fromXYZ);
            },
            _getDrawingBufferColorSpace: function(s) {
                return this.spaces[s].outputColorSpaceConfig.drawingBufferColorSpace;
            },
            _getUnpackColorSpace: function(s = this.workingColorSpace) {
                return this.spaces[s].workingColorSpaceConfig.unpackColorSpace;
            }
        }, e = [
            .64,
            .33,
            .3,
            .6,
            .15,
            .06
        ], t = [
            .2126,
            .7152,
            .0722
        ], n = [
            .3127,
            .329
        ];
        return i.define({
            [Zt]: {
                primaries: e,
                whitePoint: n,
                transfer: eo,
                toXYZ: vu,
                fromXYZ: yu,
                luminanceCoefficients: t,
                workingColorSpaceConfig: {
                    unpackColorSpace: Ft
                },
                outputColorSpaceConfig: {
                    drawingBufferColorSpace: Ft
                }
            },
            [Ft]: {
                primaries: e,
                whitePoint: n,
                transfer: ut,
                toXYZ: vu,
                fromXYZ: yu,
                luminanceCoefficients: t,
                outputColorSpaceConfig: {
                    drawingBufferColorSpace: Ft
                }
            }
        }), i;
    }
    const Ke = Ax();
    function si(i) {
        return i < .04045 ? i * .0773993808 : Math.pow(i * .9478672986 + .0521327014, 2.4);
    }
    function Ds(i) {
        return i < .0031308 ? i * 12.92 : 1.055 * Math.pow(i, .41666) - .055;
    }
    let hs;
    class Ex {
        static getDataURL(e, t = "image/png") {
            if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
            let n;
            if (e instanceof HTMLCanvasElement) n = e;
            else {
                hs === void 0 && (hs = Wr("canvas")), hs.width = e.width, hs.height = e.height;
                const s = hs.getContext("2d");
                e instanceof ImageData ? s.putImageData(e, 0, 0) : s.drawImage(e, 0, 0, e.width, e.height), n = hs;
            }
            return n.toDataURL(t);
        }
        static sRGBToLinear(e) {
            if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
                const t = Wr("canvas");
                t.width = e.width, t.height = e.height;
                const n = t.getContext("2d");
                n.drawImage(e, 0, 0, e.width, e.height);
                const s = n.getImageData(0, 0, e.width, e.height), r = s.data;
                for(let a = 0; a < r.length; a++)r[a] = si(r[a] / 255) * 255;
                return n.putImageData(s, 0, 0), t;
            } else if (e.data) {
                const t = e.data.slice(0);
                for(let n = 0; n < t.length; n++)t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[n] = Math.floor(si(t[n] / 255) * 255) : t[n] = si(t[n]);
                return {
                    data: t,
                    width: e.width,
                    height: e.height
                };
            } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
        }
    }
    let wx = 0;
    class ph {
        constructor(e = null){
            this.isSource = !0, Object.defineProperty(this, "id", {
                value: wx++
            }), this.uuid = In(), this.data = e, this.dataReady = !0, this.version = 0;
        }
        set needsUpdate(e) {
            e === !0 && this.version++;
        }
        toJSON(e) {
            const t = e === void 0 || typeof e == "string";
            if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
            const n = {
                uuid: this.uuid,
                url: ""
            }, s = this.data;
            if (s !== null) {
                let r;
                if (Array.isArray(s)) {
                    r = [];
                    for(let a = 0, o = s.length; a < o; a++)s[a].isDataTexture ? r.push(To(s[a].image)) : r.push(To(s[a]));
                } else r = To(s);
                n.url = r;
            }
            return t || (e.images[this.uuid] = n), n;
        }
    }
    function To(i) {
        return typeof HTMLImageElement < "u" && i instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && i instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && i instanceof ImageBitmap ? Ex.getDataURL(i) : i.data ? {
            data: Array.from(i.data),
            width: i.width,
            height: i.height,
            type: i.data.constructor.name
        } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
    }
    let Rx = 0, nn = class Xa extends ss {
        constructor(e = Xa.DEFAULT_IMAGE, t = Xa.DEFAULT_MAPPING, n = yi, s = yi, r = cn, a = ni, o = xn, l = hi, h = Xa.DEFAULT_ANISOTROPY, d = vi){
            super(), this.isTexture = !0, Object.defineProperty(this, "id", {
                value: Rx++
            }), this.uuid = In(), this.name = "", this.source = new ph(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = n, this.wrapT = s, this.magFilter = r, this.minFilter = a, this.anisotropy = h, this.format = o, this.internalFormat = null, this.type = l, this.offset = new Ze(0, 0), this.repeat = new Ze(1, 1), this.center = new Ze(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Ge, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = d, this.userData = {}, this.version = 0, this.onUpdate = null, this.renderTarget = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0;
        }
        get image() {
            return this.source.data;
        }
        set image(e = null) {
            this.source.data = e;
        }
        updateMatrix() {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
        }
        clone() {
            return new this.constructor().copy(this);
        }
        copy(e) {
            return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.renderTarget = e.renderTarget, this.isRenderTargetTexture = e.isRenderTargetTexture, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
        }
        toJSON(e) {
            const t = e === void 0 || typeof e == "string";
            if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
            const n = {
                metadata: {
                    version: 4.6,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                image: this.source.toJSON(e).uuid,
                mapping: this.mapping,
                channel: this.channel,
                repeat: [
                    this.repeat.x,
                    this.repeat.y
                ],
                offset: [
                    this.offset.x,
                    this.offset.y
                ],
                center: [
                    this.center.x,
                    this.center.y
                ],
                rotation: this.rotation,
                wrap: [
                    this.wrapS,
                    this.wrapT
                ],
                format: this.format,
                internalFormat: this.internalFormat,
                type: this.type,
                colorSpace: this.colorSpace,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY,
                generateMipmaps: this.generateMipmaps,
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment
            };
            return Object.keys(this.userData).length > 0 && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n;
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            });
        }
        transformUv(e) {
            if (this.mapping !== ep) return e;
            if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch(this.wrapS){
                case Gs:
                    e.x = e.x - Math.floor(e.x);
                    break;
                case yi:
                    e.x = e.x < 0 ? 0 : 1;
                    break;
                case Ja:
                    Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                    break;
            }
            if (e.y < 0 || e.y > 1) switch(this.wrapT){
                case Gs:
                    e.y = e.y - Math.floor(e.y);
                    break;
                case yi:
                    e.y = e.y < 0 ? 0 : 1;
                    break;
                case Ja:
                    Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                    break;
            }
            return this.flipY && (e.y = 1 - e.y), e;
        }
        set needsUpdate(e) {
            e === !0 && (this.version++, this.source.needsUpdate = !0);
        }
        set needsPMREMUpdate(e) {
            e === !0 && this.pmremVersion++;
        }
    };
    nn.DEFAULT_IMAGE = null;
    nn.DEFAULT_MAPPING = ep;
    nn.DEFAULT_ANISOTROPY = 1;
    class rt {
        constructor(e = 0, t = 0, n = 0, s = 1){
            rt.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = n, this.w = s;
        }
        get width() {
            return this.z;
        }
        set width(e) {
            this.z = e;
        }
        get height() {
            return this.w;
        }
        set height(e) {
            this.w = e;
        }
        set(e, t, n, s) {
            return this.x = e, this.y = t, this.z = n, this.w = s, this;
        }
        setScalar(e) {
            return this.x = e, this.y = e, this.z = e, this.w = e, this;
        }
        setX(e) {
            return this.x = e, this;
        }
        setY(e) {
            return this.y = e, this;
        }
        setZ(e) {
            return this.z = e, this;
        }
        setW(e) {
            return this.w = e, this;
        }
        setComponent(e, t) {
            switch(e){
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                case 3:
                    this.w = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e);
            }
            return this;
        }
        getComponent(e) {
            switch(e){
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error("index is out of range: " + e);
            }
        }
        clone() {
            return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(e) {
            return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
        }
        add(e) {
            return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
        }
        addScalar(e) {
            return this.x += e, this.y += e, this.z += e, this.w += e, this;
        }
        addVectors(e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
        }
        addScaledVector(e, t) {
            return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
        }
        sub(e) {
            return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
        }
        subScalar(e) {
            return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
        }
        subVectors(e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
        }
        multiply(e) {
            return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
        }
        multiplyScalar(e) {
            return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
        }
        applyMatrix4(e) {
            const t = this.x, n = this.y, s = this.z, r = this.w, a = e.elements;
            return this.x = a[0] * t + a[4] * n + a[8] * s + a[12] * r, this.y = a[1] * t + a[5] * n + a[9] * s + a[13] * r, this.z = a[2] * t + a[6] * n + a[10] * s + a[14] * r, this.w = a[3] * t + a[7] * n + a[11] * s + a[15] * r, this;
        }
        divide(e) {
            return this.x /= e.x, this.y /= e.y, this.z /= e.z, this.w /= e.w, this;
        }
        divideScalar(e) {
            return this.multiplyScalar(1 / e);
        }
        setAxisAngleFromQuaternion(e) {
            this.w = 2 * Math.acos(e.w);
            const t = Math.sqrt(1 - e.w * e.w);
            return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
        }
        setAxisAngleFromRotationMatrix(e) {
            let t, n, s, r;
            const l = e.elements, h = l[0], d = l[4], c = l[8], u = l[1], f = l[5], _ = l[9], g = l[2], m = l[6], p = l[10];
            if (Math.abs(d - u) < .01 && Math.abs(c - g) < .01 && Math.abs(_ - m) < .01) {
                if (Math.abs(d + u) < .1 && Math.abs(c + g) < .1 && Math.abs(_ + m) < .1 && Math.abs(h + f + p - 3) < .1) return this.set(1, 0, 0, 0), this;
                t = Math.PI;
                const v = (h + 1) / 2, y = (f + 1) / 2, P = (p + 1) / 2, w = (d + u) / 4, R = (c + g) / 4, B = (_ + m) / 4;
                return v > y && v > P ? v < .01 ? (n = 0, s = .707106781, r = .707106781) : (n = Math.sqrt(v), s = w / n, r = R / n) : y > P ? y < .01 ? (n = .707106781, s = 0, r = .707106781) : (s = Math.sqrt(y), n = w / s, r = B / s) : P < .01 ? (n = .707106781, s = .707106781, r = 0) : (r = Math.sqrt(P), n = R / r, s = B / r), this.set(n, s, r, t), this;
            }
            let x = Math.sqrt((m - _) * (m - _) + (c - g) * (c - g) + (u - d) * (u - d));
            return Math.abs(x) < .001 && (x = 1), this.x = (m - _) / x, this.y = (c - g) / x, this.z = (u - d) / x, this.w = Math.acos((h + f + p - 1) / 2), this;
        }
        setFromMatrixPosition(e) {
            const t = e.elements;
            return this.x = t[12], this.y = t[13], this.z = t[14], this.w = t[15], this;
        }
        min(e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
        }
        max(e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
        }
        clamp(e, t) {
            return this.x = Ye(this.x, e.x, t.x), this.y = Ye(this.y, e.y, t.y), this.z = Ye(this.z, e.z, t.z), this.w = Ye(this.w, e.w, t.w), this;
        }
        clampScalar(e, t) {
            return this.x = Ye(this.x, e, t), this.y = Ye(this.y, e, t), this.z = Ye(this.z, e, t), this.w = Ye(this.w, e, t), this;
        }
        clampLength(e, t) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Ye(n, e, t));
        }
        floor() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
        }
        ceil() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
        }
        round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
        }
        roundToZero() {
            return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
        }
        negate() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
        }
        dot(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
        }
        normalize() {
            return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
            return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
        }
        lerpVectors(e, t, n) {
            return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this;
        }
        equals(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
        }
        fromArray(e, t = 0) {
            return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
        }
        toArray(e = [], t = 0) {
            return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
        }
        fromBufferAttribute(e, t) {
            return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
        }
        random() {
            return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
        }
        *[Symbol.iterator]() {
            yield this.x, yield this.y, yield this.z, yield this.w;
        }
    }
    let Cx = class extends ss {
        constructor(e = 1, t = 1, n = {}){
            super(), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new rt(0, 0, e, t), this.scissorTest = !1, this.viewport = new rt(0, 0, e, t);
            const s = {
                width: e,
                height: t,
                depth: 1
            };
            n = Object.assign({
                generateMipmaps: !1,
                internalFormat: null,
                minFilter: cn,
                depthBuffer: !0,
                stencilBuffer: !1,
                resolveDepthBuffer: !0,
                resolveStencilBuffer: !0,
                depthTexture: null,
                samples: 0,
                count: 1
            }, n);
            const r = new nn(s, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace);
            r.flipY = !1, r.generateMipmaps = n.generateMipmaps, r.internalFormat = n.internalFormat, this.textures = [];
            const a = n.count;
            for(let o = 0; o < a; o++)this.textures[o] = r.clone(), this.textures[o].isRenderTargetTexture = !0, this.textures[o].renderTarget = this;
            this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.resolveDepthBuffer = n.resolveDepthBuffer, this.resolveStencilBuffer = n.resolveStencilBuffer, this._depthTexture = n.depthTexture, this.samples = n.samples;
        }
        get texture() {
            return this.textures[0];
        }
        set texture(e) {
            this.textures[0] = e;
        }
        set depthTexture(e) {
            this._depthTexture !== null && (this._depthTexture.renderTarget = null), e !== null && (e.renderTarget = this), this._depthTexture = e;
        }
        get depthTexture() {
            return this._depthTexture;
        }
        setSize(e, t, n = 1) {
            if (this.width !== e || this.height !== t || this.depth !== n) {
                this.width = e, this.height = t, this.depth = n;
                for(let s = 0, r = this.textures.length; s < r; s++)this.textures[s].image.width = e, this.textures[s].image.height = t, this.textures[s].image.depth = n;
                this.dispose();
            }
            this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
        }
        clone() {
            return new this.constructor().copy(this);
        }
        copy(e) {
            this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
            for(let t = 0, n = e.textures.length; t < n; t++){
                this.textures[t] = e.textures[t].clone(), this.textures[t].isRenderTargetTexture = !0, this.textures[t].renderTarget = this;
                const s = Object.assign({}, e.textures[t].image);
                this.textures[t].source = new ph(s);
            }
            return this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            });
        }
    };
    class Qi extends Cx {
        constructor(e = 1, t = 1, n = {}){
            super(e, t, n), this.isWebGLRenderTarget = !0;
        }
    }
    class _p extends nn {
        constructor(e = null, t = 1, n = 1, s = 1){
            super(null), this.isDataArrayTexture = !0, this.image = {
                data: e,
                width: t,
                height: n,
                depth: s
            }, this.magFilter = $t, this.minFilter = $t, this.wrapR = yi, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = new Set;
        }
        addLayerUpdate(e) {
            this.layerUpdates.add(e);
        }
        clearLayerUpdates() {
            this.layerUpdates.clear();
        }
    }
    class Px extends nn {
        constructor(e = null, t = 1, n = 1, s = 1){
            super(null), this.isData3DTexture = !0, this.image = {
                data: e,
                width: t,
                height: n,
                depth: s
            }, this.magFilter = $t, this.minFilter = $t, this.wrapR = yi, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
        }
    }
    class Dn {
        constructor(e = 0, t = 0, n = 0, s = 1){
            this.isQuaternion = !0, this._x = e, this._y = t, this._z = n, this._w = s;
        }
        static slerpFlat(e, t, n, s, r, a, o) {
            let l = n[s + 0], h = n[s + 1], d = n[s + 2], c = n[s + 3];
            const u = r[a + 0], f = r[a + 1], _ = r[a + 2], g = r[a + 3];
            if (o === 0) {
                e[t + 0] = l, e[t + 1] = h, e[t + 2] = d, e[t + 3] = c;
                return;
            }
            if (o === 1) {
                e[t + 0] = u, e[t + 1] = f, e[t + 2] = _, e[t + 3] = g;
                return;
            }
            if (c !== g || l !== u || h !== f || d !== _) {
                let m = 1 - o;
                const p = l * u + h * f + d * _ + c * g, x = p >= 0 ? 1 : -1, v = 1 - p * p;
                if (v > Number.EPSILON) {
                    const P = Math.sqrt(v), w = Math.atan2(P, p * x);
                    m = Math.sin(m * w) / P, o = Math.sin(o * w) / P;
                }
                const y = o * x;
                if (l = l * m + u * y, h = h * m + f * y, d = d * m + _ * y, c = c * m + g * y, m === 1 - o) {
                    const P = 1 / Math.sqrt(l * l + h * h + d * d + c * c);
                    l *= P, h *= P, d *= P, c *= P;
                }
            }
            e[t] = l, e[t + 1] = h, e[t + 2] = d, e[t + 3] = c;
        }
        static multiplyQuaternionsFlat(e, t, n, s, r, a) {
            const o = n[s], l = n[s + 1], h = n[s + 2], d = n[s + 3], c = r[a], u = r[a + 1], f = r[a + 2], _ = r[a + 3];
            return e[t] = o * _ + d * c + l * f - h * u, e[t + 1] = l * _ + d * u + h * c - o * f, e[t + 2] = h * _ + d * f + o * u - l * c, e[t + 3] = d * _ - o * c - l * u - h * f, e;
        }
        get x() {
            return this._x;
        }
        set x(e) {
            this._x = e, this._onChangeCallback();
        }
        get y() {
            return this._y;
        }
        set y(e) {
            this._y = e, this._onChangeCallback();
        }
        get z() {
            return this._z;
        }
        set z(e) {
            this._z = e, this._onChangeCallback();
        }
        get w() {
            return this._w;
        }
        set w(e) {
            this._w = e, this._onChangeCallback();
        }
        set(e, t, n, s) {
            return this._x = e, this._y = t, this._z = n, this._w = s, this._onChangeCallback(), this;
        }
        clone() {
            return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(e) {
            return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
        }
        setFromEuler(e, t = !0) {
            const n = e._x, s = e._y, r = e._z, a = e._order, o = Math.cos, l = Math.sin, h = o(n / 2), d = o(s / 2), c = o(r / 2), u = l(n / 2), f = l(s / 2), _ = l(r / 2);
            switch(a){
                case "XYZ":
                    this._x = u * d * c + h * f * _, this._y = h * f * c - u * d * _, this._z = h * d * _ + u * f * c, this._w = h * d * c - u * f * _;
                    break;
                case "YXZ":
                    this._x = u * d * c + h * f * _, this._y = h * f * c - u * d * _, this._z = h * d * _ - u * f * c, this._w = h * d * c + u * f * _;
                    break;
                case "ZXY":
                    this._x = u * d * c - h * f * _, this._y = h * f * c + u * d * _, this._z = h * d * _ + u * f * c, this._w = h * d * c - u * f * _;
                    break;
                case "ZYX":
                    this._x = u * d * c - h * f * _, this._y = h * f * c + u * d * _, this._z = h * d * _ - u * f * c, this._w = h * d * c + u * f * _;
                    break;
                case "YZX":
                    this._x = u * d * c + h * f * _, this._y = h * f * c + u * d * _, this._z = h * d * _ - u * f * c, this._w = h * d * c - u * f * _;
                    break;
                case "XZY":
                    this._x = u * d * c - h * f * _, this._y = h * f * c - u * d * _, this._z = h * d * _ + u * f * c, this._w = h * d * c + u * f * _;
                    break;
                default:
                    console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a);
            }
            return t === !0 && this._onChangeCallback(), this;
        }
        setFromAxisAngle(e, t) {
            const n = t / 2, s = Math.sin(n);
            return this._x = e.x * s, this._y = e.y * s, this._z = e.z * s, this._w = Math.cos(n), this._onChangeCallback(), this;
        }
        setFromRotationMatrix(e) {
            const t = e.elements, n = t[0], s = t[4], r = t[8], a = t[1], o = t[5], l = t[9], h = t[2], d = t[6], c = t[10], u = n + o + c;
            if (u > 0) {
                const f = .5 / Math.sqrt(u + 1);
                this._w = .25 / f, this._x = (d - l) * f, this._y = (r - h) * f, this._z = (a - s) * f;
            } else if (n > o && n > c) {
                const f = 2 * Math.sqrt(1 + n - o - c);
                this._w = (d - l) / f, this._x = .25 * f, this._y = (s + a) / f, this._z = (r + h) / f;
            } else if (o > c) {
                const f = 2 * Math.sqrt(1 + o - n - c);
                this._w = (r - h) / f, this._x = (s + a) / f, this._y = .25 * f, this._z = (l + d) / f;
            } else {
                const f = 2 * Math.sqrt(1 + c - n - o);
                this._w = (a - s) / f, this._x = (r + h) / f, this._y = (l + d) / f, this._z = .25 * f;
            }
            return this._onChangeCallback(), this;
        }
        setFromUnitVectors(e, t) {
            let n = e.dot(t) + 1;
            return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize();
        }
        angleTo(e) {
            return 2 * Math.acos(Math.abs(Ye(this.dot(e), -1, 1)));
        }
        rotateTowards(e, t) {
            const n = this.angleTo(e);
            if (n === 0) return this;
            const s = Math.min(1, t / n);
            return this.slerp(e, s), this;
        }
        identity() {
            return this.set(0, 0, 0, 1);
        }
        invert() {
            return this.conjugate();
        }
        conjugate() {
            return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
        }
        dot(e) {
            return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
        }
        lengthSq() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
        }
        length() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
        }
        normalize() {
            let e = this.length();
            return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
        }
        multiply(e) {
            return this.multiplyQuaternions(this, e);
        }
        premultiply(e) {
            return this.multiplyQuaternions(e, this);
        }
        multiplyQuaternions(e, t) {
            const n = e._x, s = e._y, r = e._z, a = e._w, o = t._x, l = t._y, h = t._z, d = t._w;
            return this._x = n * d + a * o + s * h - r * l, this._y = s * d + a * l + r * o - n * h, this._z = r * d + a * h + n * l - s * o, this._w = a * d - n * o - s * l - r * h, this._onChangeCallback(), this;
        }
        slerp(e, t) {
            if (t === 0) return this;
            if (t === 1) return this.copy(e);
            const n = this._x, s = this._y, r = this._z, a = this._w;
            let o = a * e._w + n * e._x + s * e._y + r * e._z;
            if (o < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e), o >= 1) return this._w = a, this._x = n, this._y = s, this._z = r, this;
            const l = 1 - o * o;
            if (l <= Number.EPSILON) {
                const f = 1 - t;
                return this._w = f * a + t * this._w, this._x = f * n + t * this._x, this._y = f * s + t * this._y, this._z = f * r + t * this._z, this.normalize(), this;
            }
            const h = Math.sqrt(l), d = Math.atan2(h, o), c = Math.sin((1 - t) * d) / h, u = Math.sin(t * d) / h;
            return this._w = a * c + this._w * u, this._x = n * c + this._x * u, this._y = s * c + this._y * u, this._z = r * c + this._z * u, this._onChangeCallback(), this;
        }
        slerpQuaternions(e, t, n) {
            return this.copy(e).slerp(t, n);
        }
        random() {
            const e = 2 * Math.PI * Math.random(), t = 2 * Math.PI * Math.random(), n = Math.random(), s = Math.sqrt(1 - n), r = Math.sqrt(n);
            return this.set(s * Math.sin(e), s * Math.cos(e), r * Math.sin(t), r * Math.cos(t));
        }
        equals(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
        }
        fromArray(e, t = 0) {
            return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
        }
        toArray(e = [], t = 0) {
            return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
        }
        fromBufferAttribute(e, t) {
            return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this;
        }
        toJSON() {
            return this.toArray();
        }
        _onChange(e) {
            return this._onChangeCallback = e, this;
        }
        _onChangeCallback() {}
        *[Symbol.iterator]() {
            yield this._x, yield this._y, yield this._z, yield this._w;
        }
    }
    class k {
        constructor(e = 0, t = 0, n = 0){
            k.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = n;
        }
        set(e, t, n) {
            return n === void 0 && (n = this.z), this.x = e, this.y = t, this.z = n, this;
        }
        setScalar(e) {
            return this.x = e, this.y = e, this.z = e, this;
        }
        setX(e) {
            return this.x = e, this;
        }
        setY(e) {
            return this.y = e, this;
        }
        setZ(e) {
            return this.z = e, this;
        }
        setComponent(e, t) {
            switch(e){
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e);
            }
            return this;
        }
        getComponent(e) {
            switch(e){
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error("index is out of range: " + e);
            }
        }
        clone() {
            return new this.constructor(this.x, this.y, this.z);
        }
        copy(e) {
            return this.x = e.x, this.y = e.y, this.z = e.z, this;
        }
        add(e) {
            return this.x += e.x, this.y += e.y, this.z += e.z, this;
        }
        addScalar(e) {
            return this.x += e, this.y += e, this.z += e, this;
        }
        addVectors(e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
        }
        addScaledVector(e, t) {
            return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
        }
        sub(e) {
            return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
        }
        subScalar(e) {
            return this.x -= e, this.y -= e, this.z -= e, this;
        }
        subVectors(e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
        }
        multiply(e) {
            return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
        }
        multiplyScalar(e) {
            return this.x *= e, this.y *= e, this.z *= e, this;
        }
        multiplyVectors(e, t) {
            return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
        }
        applyEuler(e) {
            return this.applyQuaternion(bu.setFromEuler(e));
        }
        applyAxisAngle(e, t) {
            return this.applyQuaternion(bu.setFromAxisAngle(e, t));
        }
        applyMatrix3(e) {
            const t = this.x, n = this.y, s = this.z, r = e.elements;
            return this.x = r[0] * t + r[3] * n + r[6] * s, this.y = r[1] * t + r[4] * n + r[7] * s, this.z = r[2] * t + r[5] * n + r[8] * s, this;
        }
        applyNormalMatrix(e) {
            return this.applyMatrix3(e).normalize();
        }
        applyMatrix4(e) {
            const t = this.x, n = this.y, s = this.z, r = e.elements, a = 1 / (r[3] * t + r[7] * n + r[11] * s + r[15]);
            return this.x = (r[0] * t + r[4] * n + r[8] * s + r[12]) * a, this.y = (r[1] * t + r[5] * n + r[9] * s + r[13]) * a, this.z = (r[2] * t + r[6] * n + r[10] * s + r[14]) * a, this;
        }
        applyQuaternion(e) {
            const t = this.x, n = this.y, s = this.z, r = e.x, a = e.y, o = e.z, l = e.w, h = 2 * (a * s - o * n), d = 2 * (o * t - r * s), c = 2 * (r * n - a * t);
            return this.x = t + l * h + a * c - o * d, this.y = n + l * d + o * h - r * c, this.z = s + l * c + r * d - a * h, this;
        }
        project(e) {
            return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
        }
        unproject(e) {
            return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
        }
        transformDirection(e) {
            const t = this.x, n = this.y, s = this.z, r = e.elements;
            return this.x = r[0] * t + r[4] * n + r[8] * s, this.y = r[1] * t + r[5] * n + r[9] * s, this.z = r[2] * t + r[6] * n + r[10] * s, this.normalize();
        }
        divide(e) {
            return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
        }
        divideScalar(e) {
            return this.multiplyScalar(1 / e);
        }
        min(e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
        }
        max(e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
        }
        clamp(e, t) {
            return this.x = Ye(this.x, e.x, t.x), this.y = Ye(this.y, e.y, t.y), this.z = Ye(this.z, e.z, t.z), this;
        }
        clampScalar(e, t) {
            return this.x = Ye(this.x, e, t), this.y = Ye(this.y, e, t), this.z = Ye(this.z, e, t), this;
        }
        clampLength(e, t) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Ye(n, e, t));
        }
        floor() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
        }
        ceil() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
        }
        round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
        }
        roundToZero() {
            return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
        }
        negate() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
        }
        dot(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z;
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
            return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
            return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
        }
        lerpVectors(e, t, n) {
            return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this;
        }
        cross(e) {
            return this.crossVectors(this, e);
        }
        crossVectors(e, t) {
            const n = e.x, s = e.y, r = e.z, a = t.x, o = t.y, l = t.z;
            return this.x = s * l - r * o, this.y = r * a - n * l, this.z = n * o - s * a, this;
        }
        projectOnVector(e) {
            const t = e.lengthSq();
            if (t === 0) return this.set(0, 0, 0);
            const n = e.dot(this) / t;
            return this.copy(e).multiplyScalar(n);
        }
        projectOnPlane(e) {
            return Mo.copy(this).projectOnVector(e), this.sub(Mo);
        }
        reflect(e) {
            return this.sub(Mo.copy(e).multiplyScalar(2 * this.dot(e)));
        }
        angleTo(e) {
            const t = Math.sqrt(this.lengthSq() * e.lengthSq());
            if (t === 0) return Math.PI / 2;
            const n = this.dot(e) / t;
            return Math.acos(Ye(n, -1, 1));
        }
        distanceTo(e) {
            return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
            const t = this.x - e.x, n = this.y - e.y, s = this.z - e.z;
            return t * t + n * n + s * s;
        }
        manhattanDistanceTo(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
        }
        setFromSpherical(e) {
            return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
        }
        setFromSphericalCoords(e, t, n) {
            const s = Math.sin(t) * e;
            return this.x = s * Math.sin(n), this.y = Math.cos(t) * e, this.z = s * Math.cos(n), this;
        }
        setFromCylindrical(e) {
            return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
        }
        setFromCylindricalCoords(e, t, n) {
            return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this;
        }
        setFromMatrixPosition(e) {
            const t = e.elements;
            return this.x = t[12], this.y = t[13], this.z = t[14], this;
        }
        setFromMatrixScale(e) {
            const t = this.setFromMatrixColumn(e, 0).length(), n = this.setFromMatrixColumn(e, 1).length(), s = this.setFromMatrixColumn(e, 2).length();
            return this.x = t, this.y = n, this.z = s, this;
        }
        setFromMatrixColumn(e, t) {
            return this.fromArray(e.elements, t * 4);
        }
        setFromMatrix3Column(e, t) {
            return this.fromArray(e.elements, t * 3);
        }
        setFromEuler(e) {
            return this.x = e._x, this.y = e._y, this.z = e._z, this;
        }
        setFromColor(e) {
            return this.x = e.r, this.y = e.g, this.z = e.b, this;
        }
        equals(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z;
        }
        fromArray(e, t = 0) {
            return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
        }
        toArray(e = [], t = 0) {
            return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
        }
        fromBufferAttribute(e, t) {
            return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
        }
        random() {
            return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
        }
        randomDirection() {
            const e = Math.random() * Math.PI * 2, t = Math.random() * 2 - 1, n = Math.sqrt(1 - t * t);
            return this.x = n * Math.cos(e), this.y = t, this.z = n * Math.sin(e), this;
        }
        *[Symbol.iterator]() {
            yield this.x, yield this.y, yield this.z;
        }
    }
    const Mo = new k, bu = new Dn;
    class Ln {
        constructor(e = new k(1 / 0, 1 / 0, 1 / 0), t = new k(-1 / 0, -1 / 0, -1 / 0)){
            this.isBox3 = !0, this.min = e, this.max = t;
        }
        set(e, t) {
            return this.min.copy(e), this.max.copy(t), this;
        }
        setFromArray(e) {
            this.makeEmpty();
            for(let t = 0, n = e.length; t < n; t += 3)this.expandByPoint(Tn.fromArray(e, t));
            return this;
        }
        setFromBufferAttribute(e) {
            this.makeEmpty();
            for(let t = 0, n = e.count; t < n; t++)this.expandByPoint(Tn.fromBufferAttribute(e, t));
            return this;
        }
        setFromPoints(e) {
            this.makeEmpty();
            for(let t = 0, n = e.length; t < n; t++)this.expandByPoint(e[t]);
            return this;
        }
        setFromCenterAndSize(e, t) {
            const n = Tn.copy(t).multiplyScalar(.5);
            return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
        }
        setFromObject(e, t = !1) {
            return this.makeEmpty(), this.expandByObject(e, t);
        }
        clone() {
            return new this.constructor().copy(this);
        }
        copy(e) {
            return this.min.copy(e.min), this.max.copy(e.max), this;
        }
        makeEmpty() {
            return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
        }
        isEmpty() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
        }
        getCenter(e) {
            return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5);
        }
        getSize(e) {
            return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
        }
        expandByPoint(e) {
            return this.min.min(e), this.max.max(e), this;
        }
        expandByVector(e) {
            return this.min.sub(e), this.max.add(e), this;
        }
        expandByScalar(e) {
            return this.min.addScalar(-e), this.max.addScalar(e), this;
        }
        expandByObject(e, t = !1) {
            e.updateWorldMatrix(!1, !1);
            const n = e.geometry;
            if (n !== void 0) {
                const r = n.getAttribute("position");
                if (t === !0 && r !== void 0 && e.isInstancedMesh !== !0) for(let a = 0, o = r.count; a < o; a++)e.isMesh === !0 ? e.getVertexPosition(a, Tn) : Tn.fromBufferAttribute(r, a), Tn.applyMatrix4(e.matrixWorld), this.expandByPoint(Tn);
                else e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), Qr.copy(e.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(), Qr.copy(n.boundingBox)), Qr.applyMatrix4(e.matrixWorld), this.union(Qr);
            }
            const s = e.children;
            for(let r = 0, a = s.length; r < a; r++)this.expandByObject(s[r], t);
            return this;
        }
        containsPoint(e) {
            return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z;
        }
        containsBox(e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
        }
        getParameter(e, t) {
            return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z));
        }
        intersectsBox(e) {
            return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z;
        }
        intersectsSphere(e) {
            return this.clampPoint(e.center, Tn), Tn.distanceToSquared(e.center) <= e.radius * e.radius;
        }
        intersectsPlane(e) {
            let t, n;
            return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant;
        }
        intersectsTriangle(e) {
            if (this.isEmpty()) return !1;
            this.getCenter(or), ea.subVectors(this.max, or), us.subVectors(e.a, or), ds.subVectors(e.b, or), fs.subVectors(e.c, or), ui.subVectors(ds, us), di.subVectors(fs, ds), Di.subVectors(us, fs);
            let t = [
                0,
                -ui.z,
                ui.y,
                0,
                -di.z,
                di.y,
                0,
                -Di.z,
                Di.y,
                ui.z,
                0,
                -ui.x,
                di.z,
                0,
                -di.x,
                Di.z,
                0,
                -Di.x,
                -ui.y,
                ui.x,
                0,
                -di.y,
                di.x,
                0,
                -Di.y,
                Di.x,
                0
            ];
            return !Ao(t, us, ds, fs, ea) || (t = [
                1,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                1
            ], !Ao(t, us, ds, fs, ea)) ? !1 : (ta.crossVectors(ui, di), t = [
                ta.x,
                ta.y,
                ta.z
            ], Ao(t, us, ds, fs, ea));
        }
        clampPoint(e, t) {
            return t.copy(e).clamp(this.min, this.max);
        }
        distanceToPoint(e) {
            return this.clampPoint(e, Tn).distanceTo(e);
        }
        getBoundingSphere(e) {
            return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(Tn).length() * .5), e;
        }
        intersect(e) {
            return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
        }
        union(e) {
            return this.min.min(e.min), this.max.max(e.max), this;
        }
        applyMatrix4(e) {
            return this.isEmpty() ? this : (jn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), jn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), jn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), jn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), jn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), jn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), jn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), jn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(jn), this);
        }
        translate(e) {
            return this.min.add(e), this.max.add(e), this;
        }
        equals(e) {
            return e.min.equals(this.min) && e.max.equals(this.max);
        }
    }
    const jn = [
        new k,
        new k,
        new k,
        new k,
        new k,
        new k,
        new k,
        new k
    ], Tn = new k, Qr = new Ln, us = new k, ds = new k, fs = new k, ui = new k, di = new k, Di = new k, or = new k, ea = new k, ta = new k, Li = new k;
    function Ao(i, e, t, n, s) {
        for(let r = 0, a = i.length - 3; r <= a; r += 3){
            Li.fromArray(i, r);
            const o = s.x * Math.abs(Li.x) + s.y * Math.abs(Li.y) + s.z * Math.abs(Li.z), l = e.dot(Li), h = t.dot(Li), d = n.dot(Li);
            if (Math.max(-Math.max(l, h, d), Math.min(l, h, d)) > o) return !1;
        }
        return !0;
    }
    const Ix = new Ln, lr = new k, Eo = new k;
    class Vn {
        constructor(e = new k, t = -1){
            this.isSphere = !0, this.center = e, this.radius = t;
        }
        set(e, t) {
            return this.center.copy(e), this.radius = t, this;
        }
        setFromPoints(e, t) {
            const n = this.center;
            t !== void 0 ? n.copy(t) : Ix.setFromPoints(e).getCenter(n);
            let s = 0;
            for(let r = 0, a = e.length; r < a; r++)s = Math.max(s, n.distanceToSquared(e[r]));
            return this.radius = Math.sqrt(s), this;
        }
        copy(e) {
            return this.center.copy(e.center), this.radius = e.radius, this;
        }
        isEmpty() {
            return this.radius < 0;
        }
        makeEmpty() {
            return this.center.set(0, 0, 0), this.radius = -1, this;
        }
        containsPoint(e) {
            return e.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(e) {
            return e.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(e) {
            const t = this.radius + e.radius;
            return e.center.distanceToSquared(this.center) <= t * t;
        }
        intersectsBox(e) {
            return e.intersectsSphere(this);
        }
        intersectsPlane(e) {
            return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(e, t) {
            const n = this.center.distanceToSquared(e);
            return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
        }
        getBoundingBox(e) {
            return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
        }
        applyMatrix4(e) {
            return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
        }
        translate(e) {
            return this.center.add(e), this;
        }
        expandByPoint(e) {
            if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this;
            lr.subVectors(e, this.center);
            const t = lr.lengthSq();
            if (t > this.radius * this.radius) {
                const n = Math.sqrt(t), s = (n - this.radius) * .5;
                this.center.addScaledVector(lr, s / n), this.radius += s;
            }
            return this;
        }
        union(e) {
            return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (Eo.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(lr.copy(e.center).add(Eo)), this.expandByPoint(lr.copy(e.center).sub(Eo))), this);
        }
        equals(e) {
            return e.center.equals(this.center) && e.radius === this.radius;
        }
        clone() {
            return new this.constructor().copy(this);
        }
    }
    const qn = new k, wo = new k, na = new k, fi = new k, Ro = new k, ia = new k, Co = new k;
    class uo {
        constructor(e = new k, t = new k(0, 0, -1)){
            this.origin = e, this.direction = t;
        }
        set(e, t) {
            return this.origin.copy(e), this.direction.copy(t), this;
        }
        copy(e) {
            return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
        }
        at(e, t) {
            return t.copy(this.origin).addScaledVector(this.direction, e);
        }
        lookAt(e) {
            return this.direction.copy(e).sub(this.origin).normalize(), this;
        }
        recast(e) {
            return this.origin.copy(this.at(e, qn)), this;
        }
        closestPointToPoint(e, t) {
            t.subVectors(e, this.origin);
            const n = t.dot(this.direction);
            return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n);
        }
        distanceToPoint(e) {
            return Math.sqrt(this.distanceSqToPoint(e));
        }
        distanceSqToPoint(e) {
            const t = qn.subVectors(e, this.origin).dot(this.direction);
            return t < 0 ? this.origin.distanceToSquared(e) : (qn.copy(this.origin).addScaledVector(this.direction, t), qn.distanceToSquared(e));
        }
        distanceSqToSegment(e, t, n, s) {
            wo.copy(e).add(t).multiplyScalar(.5), na.copy(t).sub(e).normalize(), fi.copy(this.origin).sub(wo);
            const r = e.distanceTo(t) * .5, a = -this.direction.dot(na), o = fi.dot(this.direction), l = -fi.dot(na), h = fi.lengthSq(), d = Math.abs(1 - a * a);
            let c, u, f, _;
            if (d > 0) if (c = a * l - o, u = a * o - l, _ = r * d, c >= 0) if (u >= -_) if (u <= _) {
                const g = 1 / d;
                c *= g, u *= g, f = c * (c + a * u + 2 * o) + u * (a * c + u + 2 * l) + h;
            } else u = r, c = Math.max(0, -(a * u + o)), f = -c * c + u * (u + 2 * l) + h;
            else u = -r, c = Math.max(0, -(a * u + o)), f = -c * c + u * (u + 2 * l) + h;
            else u <= -_ ? (c = Math.max(0, -(-a * r + o)), u = c > 0 ? -r : Math.min(Math.max(-r, -l), r), f = -c * c + u * (u + 2 * l) + h) : u <= _ ? (c = 0, u = Math.min(Math.max(-r, -l), r), f = u * (u + 2 * l) + h) : (c = Math.max(0, -(a * r + o)), u = c > 0 ? r : Math.min(Math.max(-r, -l), r), f = -c * c + u * (u + 2 * l) + h);
            else u = a > 0 ? -r : r, c = Math.max(0, -(a * u + o)), f = -c * c + u * (u + 2 * l) + h;
            return n && n.copy(this.origin).addScaledVector(this.direction, c), s && s.copy(wo).addScaledVector(na, u), f;
        }
        intersectSphere(e, t) {
            qn.subVectors(e.center, this.origin);
            const n = qn.dot(this.direction), s = qn.dot(qn) - n * n, r = e.radius * e.radius;
            if (s > r) return null;
            const a = Math.sqrt(r - s), o = n - a, l = n + a;
            return l < 0 ? null : o < 0 ? this.at(l, t) : this.at(o, t);
        }
        intersectsSphere(e) {
            return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
        }
        distanceToPlane(e) {
            const t = e.normal.dot(this.direction);
            if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
            const n = -(this.origin.dot(e.normal) + e.constant) / t;
            return n >= 0 ? n : null;
        }
        intersectPlane(e, t) {
            const n = this.distanceToPlane(e);
            return n === null ? null : this.at(n, t);
        }
        intersectsPlane(e) {
            const t = e.distanceToPoint(this.origin);
            return t === 0 || e.normal.dot(this.direction) * t < 0;
        }
        intersectBox(e, t) {
            let n, s, r, a, o, l;
            const h = 1 / this.direction.x, d = 1 / this.direction.y, c = 1 / this.direction.z, u = this.origin;
            return h >= 0 ? (n = (e.min.x - u.x) * h, s = (e.max.x - u.x) * h) : (n = (e.max.x - u.x) * h, s = (e.min.x - u.x) * h), d >= 0 ? (r = (e.min.y - u.y) * d, a = (e.max.y - u.y) * d) : (r = (e.max.y - u.y) * d, a = (e.min.y - u.y) * d), n > a || r > s || ((r > n || isNaN(n)) && (n = r), (a < s || isNaN(s)) && (s = a), c >= 0 ? (o = (e.min.z - u.z) * c, l = (e.max.z - u.z) * c) : (o = (e.max.z - u.z) * c, l = (e.min.z - u.z) * c), n > l || o > s) || ((o > n || n !== n) && (n = o), (l < s || s !== s) && (s = l), s < 0) ? null : this.at(n >= 0 ? n : s, t);
        }
        intersectsBox(e) {
            return this.intersectBox(e, qn) !== null;
        }
        intersectTriangle(e, t, n, s, r) {
            Ro.subVectors(t, e), ia.subVectors(n, e), Co.crossVectors(Ro, ia);
            let a = this.direction.dot(Co), o;
            if (a > 0) {
                if (s) return null;
                o = 1;
            } else if (a < 0) o = -1, a = -a;
            else return null;
            fi.subVectors(this.origin, e);
            const l = o * this.direction.dot(ia.crossVectors(fi, ia));
            if (l < 0) return null;
            const h = o * this.direction.dot(Ro.cross(fi));
            if (h < 0 || l + h > a) return null;
            const d = -o * fi.dot(Co);
            return d < 0 ? null : this.at(d / a, r);
        }
        applyMatrix4(e) {
            return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
        }
        equals(e) {
            return e.origin.equals(this.origin) && e.direction.equals(this.direction);
        }
        clone() {
            return new this.constructor().copy(this);
        }
    }
    class He {
        constructor(e, t, n, s, r, a, o, l, h, d, c, u, f, _, g, m){
            He.prototype.isMatrix4 = !0, this.elements = [
                1,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                1
            ], e !== void 0 && this.set(e, t, n, s, r, a, o, l, h, d, c, u, f, _, g, m);
        }
        set(e, t, n, s, r, a, o, l, h, d, c, u, f, _, g, m) {
            const p = this.elements;
            return p[0] = e, p[4] = t, p[8] = n, p[12] = s, p[1] = r, p[5] = a, p[9] = o, p[13] = l, p[2] = h, p[6] = d, p[10] = c, p[14] = u, p[3] = f, p[7] = _, p[11] = g, p[15] = m, this;
        }
        identity() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        clone() {
            return new He().fromArray(this.elements);
        }
        copy(e) {
            const t = this.elements, n = e.elements;
            return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this;
        }
        copyPosition(e) {
            const t = this.elements, n = e.elements;
            return t[12] = n[12], t[13] = n[13], t[14] = n[14], this;
        }
        setFromMatrix3(e) {
            const t = e.elements;
            return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this;
        }
        extractBasis(e, t, n) {
            return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
        }
        makeBasis(e, t, n) {
            return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this;
        }
        extractRotation(e) {
            const t = this.elements, n = e.elements, s = 1 / ps.setFromMatrixColumn(e, 0).length(), r = 1 / ps.setFromMatrixColumn(e, 1).length(), a = 1 / ps.setFromMatrixColumn(e, 2).length();
            return t[0] = n[0] * s, t[1] = n[1] * s, t[2] = n[2] * s, t[3] = 0, t[4] = n[4] * r, t[5] = n[5] * r, t[6] = n[6] * r, t[7] = 0, t[8] = n[8] * a, t[9] = n[9] * a, t[10] = n[10] * a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
        }
        makeRotationFromEuler(e) {
            const t = this.elements, n = e.x, s = e.y, r = e.z, a = Math.cos(n), o = Math.sin(n), l = Math.cos(s), h = Math.sin(s), d = Math.cos(r), c = Math.sin(r);
            if (e.order === "XYZ") {
                const u = a * d, f = a * c, _ = o * d, g = o * c;
                t[0] = l * d, t[4] = -l * c, t[8] = h, t[1] = f + _ * h, t[5] = u - g * h, t[9] = -o * l, t[2] = g - u * h, t[6] = _ + f * h, t[10] = a * l;
            } else if (e.order === "YXZ") {
                const u = l * d, f = l * c, _ = h * d, g = h * c;
                t[0] = u + g * o, t[4] = _ * o - f, t[8] = a * h, t[1] = a * c, t[5] = a * d, t[9] = -o, t[2] = f * o - _, t[6] = g + u * o, t[10] = a * l;
            } else if (e.order === "ZXY") {
                const u = l * d, f = l * c, _ = h * d, g = h * c;
                t[0] = u - g * o, t[4] = -a * c, t[8] = _ + f * o, t[1] = f + _ * o, t[5] = a * d, t[9] = g - u * o, t[2] = -a * h, t[6] = o, t[10] = a * l;
            } else if (e.order === "ZYX") {
                const u = a * d, f = a * c, _ = o * d, g = o * c;
                t[0] = l * d, t[4] = _ * h - f, t[8] = u * h + g, t[1] = l * c, t[5] = g * h + u, t[9] = f * h - _, t[2] = -h, t[6] = o * l, t[10] = a * l;
            } else if (e.order === "YZX") {
                const u = a * l, f = a * h, _ = o * l, g = o * h;
                t[0] = l * d, t[4] = g - u * c, t[8] = _ * c + f, t[1] = c, t[5] = a * d, t[9] = -o * d, t[2] = -h * d, t[6] = f * c + _, t[10] = u - g * c;
            } else if (e.order === "XZY") {
                const u = a * l, f = a * h, _ = o * l, g = o * h;
                t[0] = l * d, t[4] = -c, t[8] = h * d, t[1] = u * c + g, t[5] = a * d, t[9] = f * c - _, t[2] = _ * c - f, t[6] = o * d, t[10] = g * c + u;
            }
            return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
        }
        makeRotationFromQuaternion(e) {
            return this.compose(Dx, e, Lx);
        }
        lookAt(e, t, n) {
            const s = this.elements;
            return an.subVectors(e, t), an.lengthSq() === 0 && (an.z = 1), an.normalize(), pi.crossVectors(n, an), pi.lengthSq() === 0 && (Math.abs(n.z) === 1 ? an.x += 1e-4 : an.z += 1e-4, an.normalize(), pi.crossVectors(n, an)), pi.normalize(), sa.crossVectors(an, pi), s[0] = pi.x, s[4] = sa.x, s[8] = an.x, s[1] = pi.y, s[5] = sa.y, s[9] = an.y, s[2] = pi.z, s[6] = sa.z, s[10] = an.z, this;
        }
        multiply(e) {
            return this.multiplyMatrices(this, e);
        }
        premultiply(e) {
            return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
            const n = e.elements, s = t.elements, r = this.elements, a = n[0], o = n[4], l = n[8], h = n[12], d = n[1], c = n[5], u = n[9], f = n[13], _ = n[2], g = n[6], m = n[10], p = n[14], x = n[3], v = n[7], y = n[11], P = n[15], w = s[0], R = s[4], B = s[8], T = s[12], S = s[1], D = s[5], q = s[9], H = s[13], $ = s[2], ne = s[6], b = s[10], C = s[14], E = s[3], U = s[7], F = s[11], V = s[15];
            return r[0] = a * w + o * S + l * $ + h * E, r[4] = a * R + o * D + l * ne + h * U, r[8] = a * B + o * q + l * b + h * F, r[12] = a * T + o * H + l * C + h * V, r[1] = d * w + c * S + u * $ + f * E, r[5] = d * R + c * D + u * ne + f * U, r[9] = d * B + c * q + u * b + f * F, r[13] = d * T + c * H + u * C + f * V, r[2] = _ * w + g * S + m * $ + p * E, r[6] = _ * R + g * D + m * ne + p * U, r[10] = _ * B + g * q + m * b + p * F, r[14] = _ * T + g * H + m * C + p * V, r[3] = x * w + v * S + y * $ + P * E, r[7] = x * R + v * D + y * ne + P * U, r[11] = x * B + v * q + y * b + P * F, r[15] = x * T + v * H + y * C + P * V, this;
        }
        multiplyScalar(e) {
            const t = this.elements;
            return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
        }
        determinant() {
            const e = this.elements, t = e[0], n = e[4], s = e[8], r = e[12], a = e[1], o = e[5], l = e[9], h = e[13], d = e[2], c = e[6], u = e[10], f = e[14], _ = e[3], g = e[7], m = e[11], p = e[15];
            return _ * (+r * l * c - s * h * c - r * o * u + n * h * u + s * o * f - n * l * f) + g * (+t * l * f - t * h * u + r * a * u - s * a * f + s * h * d - r * l * d) + m * (+t * h * c - t * o * f - r * a * c + n * a * f + r * o * d - n * h * d) + p * (-s * o * d - t * l * c + t * o * u + s * a * c - n * a * u + n * l * d);
        }
        transpose() {
            const e = this.elements;
            let t;
            return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
        }
        setPosition(e, t, n) {
            const s = this.elements;
            return e.isVector3 ? (s[12] = e.x, s[13] = e.y, s[14] = e.z) : (s[12] = e, s[13] = t, s[14] = n), this;
        }
        invert() {
            const e = this.elements, t = e[0], n = e[1], s = e[2], r = e[3], a = e[4], o = e[5], l = e[6], h = e[7], d = e[8], c = e[9], u = e[10], f = e[11], _ = e[12], g = e[13], m = e[14], p = e[15], x = c * m * h - g * u * h + g * l * f - o * m * f - c * l * p + o * u * p, v = _ * u * h - d * m * h - _ * l * f + a * m * f + d * l * p - a * u * p, y = d * g * h - _ * c * h + _ * o * f - a * g * f - d * o * p + a * c * p, P = _ * c * l - d * g * l - _ * o * u + a * g * u + d * o * m - a * c * m, w = t * x + n * v + s * y + r * P;
            if (w === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            const R = 1 / w;
            return e[0] = x * R, e[1] = (g * u * r - c * m * r - g * s * f + n * m * f + c * s * p - n * u * p) * R, e[2] = (o * m * r - g * l * r + g * s * h - n * m * h - o * s * p + n * l * p) * R, e[3] = (c * l * r - o * u * r - c * s * h + n * u * h + o * s * f - n * l * f) * R, e[4] = v * R, e[5] = (d * m * r - _ * u * r + _ * s * f - t * m * f - d * s * p + t * u * p) * R, e[6] = (_ * l * r - a * m * r - _ * s * h + t * m * h + a * s * p - t * l * p) * R, e[7] = (a * u * r - d * l * r + d * s * h - t * u * h - a * s * f + t * l * f) * R, e[8] = y * R, e[9] = (_ * c * r - d * g * r - _ * n * f + t * g * f + d * n * p - t * c * p) * R, e[10] = (a * g * r - _ * o * r + _ * n * h - t * g * h - a * n * p + t * o * p) * R, e[11] = (d * o * r - a * c * r - d * n * h + t * c * h + a * n * f - t * o * f) * R, e[12] = P * R, e[13] = (d * g * s - _ * c * s + _ * n * u - t * g * u - d * n * m + t * c * m) * R, e[14] = (_ * o * s - a * g * s - _ * n * l + t * g * l + a * n * m - t * o * m) * R, e[15] = (a * c * s - d * o * s + d * n * l - t * c * l - a * n * u + t * o * u) * R, this;
        }
        scale(e) {
            const t = this.elements, n = e.x, s = e.y, r = e.z;
            return t[0] *= n, t[4] *= s, t[8] *= r, t[1] *= n, t[5] *= s, t[9] *= r, t[2] *= n, t[6] *= s, t[10] *= r, t[3] *= n, t[7] *= s, t[11] *= r, this;
        }
        getMaxScaleOnAxis() {
            const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], s = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
            return Math.sqrt(Math.max(t, n, s));
        }
        makeTranslation(e, t, n) {
            return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this;
        }
        makeRotationX(e) {
            const t = Math.cos(e), n = Math.sin(e);
            return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this;
        }
        makeRotationY(e) {
            const t = Math.cos(e), n = Math.sin(e);
            return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this;
        }
        makeRotationZ(e) {
            const t = Math.cos(e), n = Math.sin(e);
            return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        makeRotationAxis(e, t) {
            const n = Math.cos(t), s = Math.sin(t), r = 1 - n, a = e.x, o = e.y, l = e.z, h = r * a, d = r * o;
            return this.set(h * a + n, h * o - s * l, h * l + s * o, 0, h * o + s * l, d * o + n, d * l - s * a, 0, h * l - s * o, d * l + s * a, r * l * l + n, 0, 0, 0, 0, 1), this;
        }
        makeScale(e, t, n) {
            return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
        }
        makeShear(e, t, n, s, r, a) {
            return this.set(1, n, r, 0, e, 1, a, 0, t, s, 1, 0, 0, 0, 0, 1), this;
        }
        compose(e, t, n) {
            const s = this.elements, r = t._x, a = t._y, o = t._z, l = t._w, h = r + r, d = a + a, c = o + o, u = r * h, f = r * d, _ = r * c, g = a * d, m = a * c, p = o * c, x = l * h, v = l * d, y = l * c, P = n.x, w = n.y, R = n.z;
            return s[0] = (1 - (g + p)) * P, s[1] = (f + y) * P, s[2] = (_ - v) * P, s[3] = 0, s[4] = (f - y) * w, s[5] = (1 - (u + p)) * w, s[6] = (m + x) * w, s[7] = 0, s[8] = (_ + v) * R, s[9] = (m - x) * R, s[10] = (1 - (u + g)) * R, s[11] = 0, s[12] = e.x, s[13] = e.y, s[14] = e.z, s[15] = 1, this;
        }
        decompose(e, t, n) {
            const s = this.elements;
            let r = ps.set(s[0], s[1], s[2]).length();
            const a = ps.set(s[4], s[5], s[6]).length(), o = ps.set(s[8], s[9], s[10]).length();
            this.determinant() < 0 && (r = -r), e.x = s[12], e.y = s[13], e.z = s[14], Mn.copy(this);
            const h = 1 / r, d = 1 / a, c = 1 / o;
            return Mn.elements[0] *= h, Mn.elements[1] *= h, Mn.elements[2] *= h, Mn.elements[4] *= d, Mn.elements[5] *= d, Mn.elements[6] *= d, Mn.elements[8] *= c, Mn.elements[9] *= c, Mn.elements[10] *= c, t.setFromRotationMatrix(Mn), n.x = r, n.y = a, n.z = o, this;
        }
        makePerspective(e, t, n, s, r, a, o = ii) {
            const l = this.elements, h = 2 * r / (t - e), d = 2 * r / (n - s), c = (t + e) / (t - e), u = (n + s) / (n - s);
            let f, _;
            if (o === ii) f = -(a + r) / (a - r), _ = -2 * a * r / (a - r);
            else if (o === to) f = -a / (a - r), _ = -a * r / (a - r);
            else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + o);
            return l[0] = h, l[4] = 0, l[8] = c, l[12] = 0, l[1] = 0, l[5] = d, l[9] = u, l[13] = 0, l[2] = 0, l[6] = 0, l[10] = f, l[14] = _, l[3] = 0, l[7] = 0, l[11] = -1, l[15] = 0, this;
        }
        makeOrthographic(e, t, n, s, r, a, o = ii) {
            const l = this.elements, h = 1 / (t - e), d = 1 / (n - s), c = 1 / (a - r), u = (t + e) * h, f = (n + s) * d;
            let _, g;
            if (o === ii) _ = (a + r) * c, g = -2 * c;
            else if (o === to) _ = r * c, g = -1 * c;
            else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + o);
            return l[0] = 2 * h, l[4] = 0, l[8] = 0, l[12] = -u, l[1] = 0, l[5] = 2 * d, l[9] = 0, l[13] = -f, l[2] = 0, l[6] = 0, l[10] = g, l[14] = -_, l[3] = 0, l[7] = 0, l[11] = 0, l[15] = 1, this;
        }
        equals(e) {
            const t = this.elements, n = e.elements;
            for(let s = 0; s < 16; s++)if (t[s] !== n[s]) return !1;
            return !0;
        }
        fromArray(e, t = 0) {
            for(let n = 0; n < 16; n++)this.elements[n] = e[n + t];
            return this;
        }
        toArray(e = [], t = 0) {
            const n = this.elements;
            return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e;
        }
    }
    const ps = new k, Mn = new He, Dx = new k(0, 0, 0), Lx = new k(1, 1, 1), pi = new k, sa = new k, an = new k, Su = new He, Tu = new Dn;
    class Hn {
        constructor(e = 0, t = 0, n = 0, s = Hn.DEFAULT_ORDER){
            this.isEuler = !0, this._x = e, this._y = t, this._z = n, this._order = s;
        }
        get x() {
            return this._x;
        }
        set x(e) {
            this._x = e, this._onChangeCallback();
        }
        get y() {
            return this._y;
        }
        set y(e) {
            this._y = e, this._onChangeCallback();
        }
        get z() {
            return this._z;
        }
        set z(e) {
            this._z = e, this._onChangeCallback();
        }
        get order() {
            return this._order;
        }
        set order(e) {
            this._order = e, this._onChangeCallback();
        }
        set(e, t, n, s = this._order) {
            return this._x = e, this._y = t, this._z = n, this._order = s, this._onChangeCallback(), this;
        }
        clone() {
            return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(e) {
            return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
        }
        setFromRotationMatrix(e, t = this._order, n = !0) {
            const s = e.elements, r = s[0], a = s[4], o = s[8], l = s[1], h = s[5], d = s[9], c = s[2], u = s[6], f = s[10];
            switch(t){
                case "XYZ":
                    this._y = Math.asin(Ye(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-d, f), this._z = Math.atan2(-a, r)) : (this._x = Math.atan2(u, h), this._z = 0);
                    break;
                case "YXZ":
                    this._x = Math.asin(-Ye(d, -1, 1)), Math.abs(d) < .9999999 ? (this._y = Math.atan2(o, f), this._z = Math.atan2(l, h)) : (this._y = Math.atan2(-c, r), this._z = 0);
                    break;
                case "ZXY":
                    this._x = Math.asin(Ye(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(-c, f), this._z = Math.atan2(-a, h)) : (this._y = 0, this._z = Math.atan2(l, r));
                    break;
                case "ZYX":
                    this._y = Math.asin(-Ye(c, -1, 1)), Math.abs(c) < .9999999 ? (this._x = Math.atan2(u, f), this._z = Math.atan2(l, r)) : (this._x = 0, this._z = Math.atan2(-a, h));
                    break;
                case "YZX":
                    this._z = Math.asin(Ye(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(-d, h), this._y = Math.atan2(-c, r)) : (this._x = 0, this._y = Math.atan2(o, f));
                    break;
                case "XZY":
                    this._z = Math.asin(-Ye(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(u, h), this._y = Math.atan2(o, r)) : (this._x = Math.atan2(-d, f), this._y = 0);
                    break;
                default:
                    console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
            }
            return this._order = t, n === !0 && this._onChangeCallback(), this;
        }
        setFromQuaternion(e, t, n) {
            return Su.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Su, t, n);
        }
        setFromVector3(e, t = this._order) {
            return this.set(e.x, e.y, e.z, t);
        }
        reorder(e) {
            return Tu.setFromEuler(this), this.setFromQuaternion(Tu, e);
        }
        equals(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
        }
        fromArray(e) {
            return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
        }
        toArray(e = [], t = 0) {
            return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
        }
        _onChange(e) {
            return this._onChangeCallback = e, this;
        }
        _onChangeCallback() {}
        *[Symbol.iterator]() {
            yield this._x, yield this._y, yield this._z, yield this._order;
        }
    }
    Hn.DEFAULT_ORDER = "XYZ";
    class gp {
        constructor(){
            this.mask = 1;
        }
        set(e) {
            this.mask = (1 << e | 0) >>> 0;
        }
        enable(e) {
            this.mask |= 1 << e | 0;
        }
        enableAll() {
            this.mask = -1;
        }
        toggle(e) {
            this.mask ^= 1 << e | 0;
        }
        disable(e) {
            this.mask &= ~(1 << e | 0);
        }
        disableAll() {
            this.mask = 0;
        }
        test(e) {
            return (this.mask & e.mask) !== 0;
        }
        isEnabled(e) {
            return (this.mask & (1 << e | 0)) !== 0;
        }
    }
    let Bx = 0;
    const Mu = new k, ms = new Dn, $n = new He, ra = new k, cr = new k, Ux = new k, Fx = new Dn, Au = new k(1, 0, 0), Eu = new k(0, 1, 0), wu = new k(0, 0, 1), Ru = {
        type: "added"
    }, Nx = {
        type: "removed"
    }, _s = {
        type: "childadded",
        child: null
    }, Po = {
        type: "childremoved",
        child: null
    };
    class yt extends ss {
        constructor(){
            super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
                value: Bx++
            }), this.uuid = In(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = yt.DEFAULT_UP.clone();
            const e = new k, t = new Hn, n = new Dn, s = new k(1, 1, 1);
            function r() {
                n.setFromEuler(t, !1);
            }
            function a() {
                t.setFromQuaternion(n, void 0, !1);
            }
            t._onChange(r), n._onChange(a), Object.defineProperties(this, {
                position: {
                    configurable: !0,
                    enumerable: !0,
                    value: e
                },
                rotation: {
                    configurable: !0,
                    enumerable: !0,
                    value: t
                },
                quaternion: {
                    configurable: !0,
                    enumerable: !0,
                    value: n
                },
                scale: {
                    configurable: !0,
                    enumerable: !0,
                    value: s
                },
                modelViewMatrix: {
                    value: new He
                },
                normalMatrix: {
                    value: new Ge
                }
            }), this.matrix = new He, this.matrixWorld = new He, this.matrixAutoUpdate = yt.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = yt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new gp, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.customDepthMaterial = void 0, this.customDistanceMaterial = void 0, this.userData = {};
        }
        onBeforeShadow() {}
        onAfterShadow() {}
        onBeforeRender() {}
        onAfterRender() {}
        applyMatrix4(e) {
            this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
        }
        applyQuaternion(e) {
            return this.quaternion.premultiply(e), this;
        }
        setRotationFromAxisAngle(e, t) {
            this.quaternion.setFromAxisAngle(e, t);
        }
        setRotationFromEuler(e) {
            this.quaternion.setFromEuler(e, !0);
        }
        setRotationFromMatrix(e) {
            this.quaternion.setFromRotationMatrix(e);
        }
        setRotationFromQuaternion(e) {
            this.quaternion.copy(e);
        }
        rotateOnAxis(e, t) {
            return ms.setFromAxisAngle(e, t), this.quaternion.multiply(ms), this;
        }
        rotateOnWorldAxis(e, t) {
            return ms.setFromAxisAngle(e, t), this.quaternion.premultiply(ms), this;
        }
        rotateX(e) {
            return this.rotateOnAxis(Au, e);
        }
        rotateY(e) {
            return this.rotateOnAxis(Eu, e);
        }
        rotateZ(e) {
            return this.rotateOnAxis(wu, e);
        }
        translateOnAxis(e, t) {
            return Mu.copy(e).applyQuaternion(this.quaternion), this.position.add(Mu.multiplyScalar(t)), this;
        }
        translateX(e) {
            return this.translateOnAxis(Au, e);
        }
        translateY(e) {
            return this.translateOnAxis(Eu, e);
        }
        translateZ(e) {
            return this.translateOnAxis(wu, e);
        }
        localToWorld(e) {
            return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
        }
        worldToLocal(e) {
            return this.updateWorldMatrix(!0, !1), e.applyMatrix4($n.copy(this.matrixWorld).invert());
        }
        lookAt(e, t, n) {
            e.isVector3 ? ra.copy(e) : ra.set(e, t, n);
            const s = this.parent;
            this.updateWorldMatrix(!0, !1), cr.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? $n.lookAt(cr, ra, this.up) : $n.lookAt(ra, cr, this.up), this.quaternion.setFromRotationMatrix($n), s && ($n.extractRotation(s.matrixWorld), ms.setFromRotationMatrix($n), this.quaternion.premultiply(ms.invert()));
        }
        add(e) {
            if (arguments.length > 1) {
                for(let t = 0; t < arguments.length; t++)this.add(arguments[t]);
                return this;
            }
            return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(Ru), _s.child = e, this.dispatchEvent(_s), _s.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
        }
        remove(e) {
            if (arguments.length > 1) {
                for(let n = 0; n < arguments.length; n++)this.remove(arguments[n]);
                return this;
            }
            const t = this.children.indexOf(e);
            return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(Nx), Po.child = e, this.dispatchEvent(Po), Po.child = null), this;
        }
        removeFromParent() {
            const e = this.parent;
            return e !== null && e.remove(this), this;
        }
        clear() {
            return this.remove(...this.children);
        }
        attach(e) {
            return this.updateWorldMatrix(!0, !1), $n.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), $n.multiply(e.parent.matrixWorld)), e.applyMatrix4($n), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(Ru), _s.child = e, this.dispatchEvent(_s), _s.child = null, this;
        }
        getObjectById(e) {
            return this.getObjectByProperty("id", e);
        }
        getObjectByName(e) {
            return this.getObjectByProperty("name", e);
        }
        getObjectByProperty(e, t) {
            if (this[e] === t) return this;
            for(let n = 0, s = this.children.length; n < s; n++){
                const a = this.children[n].getObjectByProperty(e, t);
                if (a !== void 0) return a;
            }
        }
        getObjectsByProperty(e, t, n = []) {
            this[e] === t && n.push(this);
            const s = this.children;
            for(let r = 0, a = s.length; r < a; r++)s[r].getObjectsByProperty(e, t, n);
            return n;
        }
        getWorldPosition(e) {
            return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
        }
        getWorldQuaternion(e) {
            return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(cr, e, Ux), e;
        }
        getWorldScale(e) {
            return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(cr, Fx, e), e;
        }
        getWorldDirection(e) {
            this.updateWorldMatrix(!0, !1);
            const t = this.matrixWorld.elements;
            return e.set(t[8], t[9], t[10]).normalize();
        }
        raycast() {}
        traverse(e) {
            e(this);
            const t = this.children;
            for(let n = 0, s = t.length; n < s; n++)t[n].traverse(e);
        }
        traverseVisible(e) {
            if (this.visible === !1) return;
            e(this);
            const t = this.children;
            for(let n = 0, s = t.length; n < s; n++)t[n].traverseVisible(e);
        }
        traverseAncestors(e) {
            const t = this.parent;
            t !== null && (e(t), t.traverseAncestors(e));
        }
        updateMatrix() {
            this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
        }
        updateMatrixWorld(e) {
            this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, e = !0);
            const t = this.children;
            for(let n = 0, s = t.length; n < s; n++)t[n].updateMatrixWorld(e);
        }
        updateWorldMatrix(e, t) {
            const n = this.parent;
            if (e === !0 && n !== null && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), t === !0) {
                const s = this.children;
                for(let r = 0, a = s.length; r < a; r++)s[r].updateWorldMatrix(!1, !0);
            }
        }
        toJSON(e) {
            const t = e === void 0 || typeof e == "string", n = {};
            t && (e = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {},
                skeletons: {},
                animations: {},
                nodes: {}
            }, n.metadata = {
                version: 4.6,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            const s = {};
            s.uuid = this.uuid, s.type = this.type, this.name !== "" && (s.name = this.name), this.castShadow === !0 && (s.castShadow = !0), this.receiveShadow === !0 && (s.receiveShadow = !0), this.visible === !1 && (s.visible = !1), this.frustumCulled === !1 && (s.frustumCulled = !1), this.renderOrder !== 0 && (s.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (s.userData = this.userData), s.layers = this.layers.mask, s.matrix = this.matrix.toArray(), s.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (s.matrixAutoUpdate = !1), this.isInstancedMesh && (s.type = "InstancedMesh", s.count = this.count, s.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (s.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (s.type = "BatchedMesh", s.perObjectFrustumCulled = this.perObjectFrustumCulled, s.sortObjects = this.sortObjects, s.drawRanges = this._drawRanges, s.reservedRanges = this._reservedRanges, s.visibility = this._visibility, s.active = this._active, s.bounds = this._bounds.map((o)=>({
                    boxInitialized: o.boxInitialized,
                    boxMin: o.box.min.toArray(),
                    boxMax: o.box.max.toArray(),
                    sphereInitialized: o.sphereInitialized,
                    sphereRadius: o.sphere.radius,
                    sphereCenter: o.sphere.center.toArray()
                })), s.maxInstanceCount = this._maxInstanceCount, s.maxVertexCount = this._maxVertexCount, s.maxIndexCount = this._maxIndexCount, s.geometryInitialized = this._geometryInitialized, s.geometryCount = this._geometryCount, s.matricesTexture = this._matricesTexture.toJSON(e), this._colorsTexture !== null && (s.colorsTexture = this._colorsTexture.toJSON(e)), this.boundingSphere !== null && (s.boundingSphere = {
                center: s.boundingSphere.center.toArray(),
                radius: s.boundingSphere.radius
            }), this.boundingBox !== null && (s.boundingBox = {
                min: s.boundingBox.min.toArray(),
                max: s.boundingBox.max.toArray()
            }));
            function r(o, l) {
                return o[l.uuid] === void 0 && (o[l.uuid] = l.toJSON(e)), l.uuid;
            }
            if (this.isScene) this.background && (this.background.isColor ? s.background = this.background.toJSON() : this.background.isTexture && (s.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (s.environment = this.environment.toJSON(e).uuid);
            else if (this.isMesh || this.isLine || this.isPoints) {
                s.geometry = r(e.geometries, this.geometry);
                const o = this.geometry.parameters;
                if (o !== void 0 && o.shapes !== void 0) {
                    const l = o.shapes;
                    if (Array.isArray(l)) for(let h = 0, d = l.length; h < d; h++){
                        const c = l[h];
                        r(e.shapes, c);
                    }
                    else r(e.shapes, l);
                }
            }
            if (this.isSkinnedMesh && (s.bindMode = this.bindMode, s.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (r(e.skeletons, this.skeleton), s.skeleton = this.skeleton.uuid)), this.material !== void 0) if (Array.isArray(this.material)) {
                const o = [];
                for(let l = 0, h = this.material.length; l < h; l++)o.push(r(e.materials, this.material[l]));
                s.material = o;
            } else s.material = r(e.materials, this.material);
            if (this.children.length > 0) {
                s.children = [];
                for(let o = 0; o < this.children.length; o++)s.children.push(this.children[o].toJSON(e).object);
            }
            if (this.animations.length > 0) {
                s.animations = [];
                for(let o = 0; o < this.animations.length; o++){
                    const l = this.animations[o];
                    s.animations.push(r(e.animations, l));
                }
            }
            if (t) {
                const o = a(e.geometries), l = a(e.materials), h = a(e.textures), d = a(e.images), c = a(e.shapes), u = a(e.skeletons), f = a(e.animations), _ = a(e.nodes);
                o.length > 0 && (n.geometries = o), l.length > 0 && (n.materials = l), h.length > 0 && (n.textures = h), d.length > 0 && (n.images = d), c.length > 0 && (n.shapes = c), u.length > 0 && (n.skeletons = u), f.length > 0 && (n.animations = f), _.length > 0 && (n.nodes = _);
            }
            return n.object = s, n;
            function a(o) {
                const l = [];
                for(const h in o){
                    const d = o[h];
                    delete d.metadata, l.push(d);
                }
                return l;
            }
        }
        clone(e) {
            return new this.constructor().copy(this, e);
        }
        copy(e, t = !0) {
            if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0) for(let n = 0; n < e.children.length; n++){
                const s = e.children[n];
                this.add(s.clone());
            }
            return this;
        }
    }
    yt.DEFAULT_UP = new k(0, 1, 0);
    yt.DEFAULT_MATRIX_AUTO_UPDATE = !0;
    yt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
    const An = new k, Kn = new k, Io = new k, Zn = new k, gs = new k, xs = new k, Cu = new k, Do = new k, Lo = new k, Bo = new k, Uo = new rt, Fo = new rt, No = new rt;
    class Rn {
        constructor(e = new k, t = new k, n = new k){
            this.a = e, this.b = t, this.c = n;
        }
        static getNormal(e, t, n, s) {
            s.subVectors(n, t), An.subVectors(e, t), s.cross(An);
            const r = s.lengthSq();
            return r > 0 ? s.multiplyScalar(1 / Math.sqrt(r)) : s.set(0, 0, 0);
        }
        static getBarycoord(e, t, n, s, r) {
            An.subVectors(s, t), Kn.subVectors(n, t), Io.subVectors(e, t);
            const a = An.dot(An), o = An.dot(Kn), l = An.dot(Io), h = Kn.dot(Kn), d = Kn.dot(Io), c = a * h - o * o;
            if (c === 0) return r.set(0, 0, 0), null;
            const u = 1 / c, f = (h * l - o * d) * u, _ = (a * d - o * l) * u;
            return r.set(1 - f - _, _, f);
        }
        static containsPoint(e, t, n, s) {
            return this.getBarycoord(e, t, n, s, Zn) === null ? !1 : Zn.x >= 0 && Zn.y >= 0 && Zn.x + Zn.y <= 1;
        }
        static getInterpolation(e, t, n, s, r, a, o, l) {
            return this.getBarycoord(e, t, n, s, Zn) === null ? (l.x = 0, l.y = 0, "z" in l && (l.z = 0), "w" in l && (l.w = 0), null) : (l.setScalar(0), l.addScaledVector(r, Zn.x), l.addScaledVector(a, Zn.y), l.addScaledVector(o, Zn.z), l);
        }
        static getInterpolatedAttribute(e, t, n, s, r, a) {
            return Uo.setScalar(0), Fo.setScalar(0), No.setScalar(0), Uo.fromBufferAttribute(e, t), Fo.fromBufferAttribute(e, n), No.fromBufferAttribute(e, s), a.setScalar(0), a.addScaledVector(Uo, r.x), a.addScaledVector(Fo, r.y), a.addScaledVector(No, r.z), a;
        }
        static isFrontFacing(e, t, n, s) {
            return An.subVectors(n, t), Kn.subVectors(e, t), An.cross(Kn).dot(s) < 0;
        }
        set(e, t, n) {
            return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
        }
        setFromPointsAndIndices(e, t, n, s) {
            return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[s]), this;
        }
        setFromAttributeAndIndices(e, t, n, s) {
            return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, s), this;
        }
        clone() {
            return new this.constructor().copy(this);
        }
        copy(e) {
            return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
        }
        getArea() {
            return An.subVectors(this.c, this.b), Kn.subVectors(this.a, this.b), An.cross(Kn).length() * .5;
        }
        getMidpoint(e) {
            return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
        }
        getNormal(e) {
            return Rn.getNormal(this.a, this.b, this.c, e);
        }
        getPlane(e) {
            return e.setFromCoplanarPoints(this.a, this.b, this.c);
        }
        getBarycoord(e, t) {
            return Rn.getBarycoord(e, this.a, this.b, this.c, t);
        }
        getInterpolation(e, t, n, s, r) {
            return Rn.getInterpolation(e, this.a, this.b, this.c, t, n, s, r);
        }
        containsPoint(e) {
            return Rn.containsPoint(e, this.a, this.b, this.c);
        }
        isFrontFacing(e) {
            return Rn.isFrontFacing(this.a, this.b, this.c, e);
        }
        intersectsBox(e) {
            return e.intersectsTriangle(this);
        }
        closestPointToPoint(e, t) {
            const n = this.a, s = this.b, r = this.c;
            let a, o;
            gs.subVectors(s, n), xs.subVectors(r, n), Do.subVectors(e, n);
            const l = gs.dot(Do), h = xs.dot(Do);
            if (l <= 0 && h <= 0) return t.copy(n);
            Lo.subVectors(e, s);
            const d = gs.dot(Lo), c = xs.dot(Lo);
            if (d >= 0 && c <= d) return t.copy(s);
            const u = l * c - d * h;
            if (u <= 0 && l >= 0 && d <= 0) return a = l / (l - d), t.copy(n).addScaledVector(gs, a);
            Bo.subVectors(e, r);
            const f = gs.dot(Bo), _ = xs.dot(Bo);
            if (_ >= 0 && f <= _) return t.copy(r);
            const g = f * h - l * _;
            if (g <= 0 && h >= 0 && _ <= 0) return o = h / (h - _), t.copy(n).addScaledVector(xs, o);
            const m = d * _ - f * c;
            if (m <= 0 && c - d >= 0 && f - _ >= 0) return Cu.subVectors(r, s), o = (c - d) / (c - d + (f - _)), t.copy(s).addScaledVector(Cu, o);
            const p = 1 / (m + g + u);
            return a = g * p, o = u * p, t.copy(n).addScaledVector(gs, a).addScaledVector(xs, o);
        }
        equals(e) {
            return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
        }
    }
    const xp = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    }, mi = {
        h: 0,
        s: 0,
        l: 0
    }, aa = {
        h: 0,
        s: 0,
        l: 0
    };
    function Oo(i, e, t) {
        return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? i + (e - i) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? i + (e - i) * 6 * (2 / 3 - t) : i;
    }
    let Oe = class {
        constructor(e, t, n){
            return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, n);
        }
        set(e, t, n) {
            if (t === void 0 && n === void 0) {
                const s = e;
                s && s.isColor ? this.copy(s) : typeof s == "number" ? this.setHex(s) : typeof s == "string" && this.setStyle(s);
            } else this.setRGB(e, t, n);
            return this;
        }
        setScalar(e) {
            return this.r = e, this.g = e, this.b = e, this;
        }
        setHex(e, t = Ft) {
            return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, Ke.toWorkingColorSpace(this, t), this;
        }
        setRGB(e, t, n, s = Ke.workingColorSpace) {
            return this.r = e, this.g = t, this.b = n, Ke.toWorkingColorSpace(this, s), this;
        }
        setHSL(e, t, n, s = Ke.workingColorSpace) {
            if (e = fh(e, 1), t = Ye(t, 0, 1), n = Ye(n, 0, 1), t === 0) this.r = this.g = this.b = n;
            else {
                const r = n <= .5 ? n * (1 + t) : n + t - n * t, a = 2 * n - r;
                this.r = Oo(a, r, e + 1 / 3), this.g = Oo(a, r, e), this.b = Oo(a, r, e - 1 / 3);
            }
            return Ke.toWorkingColorSpace(this, s), this;
        }
        setStyle(e, t = Ft) {
            function n(r) {
                r !== void 0 && parseFloat(r) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
            }
            let s;
            if (s = /^(\w+)\(([^\)]*)\)/.exec(e)) {
                let r;
                const a = s[1], o = s[2];
                switch(a){
                    case "rgb":
                    case "rgba":
                        if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return n(r[4]), this.setRGB(Math.min(255, parseInt(r[1], 10)) / 255, Math.min(255, parseInt(r[2], 10)) / 255, Math.min(255, parseInt(r[3], 10)) / 255, t);
                        if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return n(r[4]), this.setRGB(Math.min(100, parseInt(r[1], 10)) / 100, Math.min(100, parseInt(r[2], 10)) / 100, Math.min(100, parseInt(r[3], 10)) / 100, t);
                        break;
                    case "hsl":
                    case "hsla":
                        if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return n(r[4]), this.setHSL(parseFloat(r[1]) / 360, parseFloat(r[2]) / 100, parseFloat(r[3]) / 100, t);
                        break;
                    default:
                        console.warn("THREE.Color: Unknown color model " + e);
                }
            } else if (s = /^\#([A-Fa-f\d]+)$/.exec(e)) {
                const r = s[1], a = r.length;
                if (a === 3) return this.setRGB(parseInt(r.charAt(0), 16) / 15, parseInt(r.charAt(1), 16) / 15, parseInt(r.charAt(2), 16) / 15, t);
                if (a === 6) return this.setHex(parseInt(r, 16), t);
                console.warn("THREE.Color: Invalid hex color " + e);
            } else if (e && e.length > 0) return this.setColorName(e, t);
            return this;
        }
        setColorName(e, t = Ft) {
            const n = xp[e.toLowerCase()];
            return n !== void 0 ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this;
        }
        clone() {
            return new this.constructor(this.r, this.g, this.b);
        }
        copy(e) {
            return this.r = e.r, this.g = e.g, this.b = e.b, this;
        }
        copySRGBToLinear(e) {
            return this.r = si(e.r), this.g = si(e.g), this.b = si(e.b), this;
        }
        copyLinearToSRGB(e) {
            return this.r = Ds(e.r), this.g = Ds(e.g), this.b = Ds(e.b), this;
        }
        convertSRGBToLinear() {
            return this.copySRGBToLinear(this), this;
        }
        convertLinearToSRGB() {
            return this.copyLinearToSRGB(this), this;
        }
        getHex(e = Ft) {
            return Ke.fromWorkingColorSpace(zt.copy(this), e), Math.round(Ye(zt.r * 255, 0, 255)) * 65536 + Math.round(Ye(zt.g * 255, 0, 255)) * 256 + Math.round(Ye(zt.b * 255, 0, 255));
        }
        getHexString(e = Ft) {
            return ("000000" + this.getHex(e).toString(16)).slice(-6);
        }
        getHSL(e, t = Ke.workingColorSpace) {
            Ke.fromWorkingColorSpace(zt.copy(this), t);
            const n = zt.r, s = zt.g, r = zt.b, a = Math.max(n, s, r), o = Math.min(n, s, r);
            let l, h;
            const d = (o + a) / 2;
            if (o === a) l = 0, h = 0;
            else {
                const c = a - o;
                switch(h = d <= .5 ? c / (a + o) : c / (2 - a - o), a){
                    case n:
                        l = (s - r) / c + (s < r ? 6 : 0);
                        break;
                    case s:
                        l = (r - n) / c + 2;
                        break;
                    case r:
                        l = (n - s) / c + 4;
                        break;
                }
                l /= 6;
            }
            return e.h = l, e.s = h, e.l = d, e;
        }
        getRGB(e, t = Ke.workingColorSpace) {
            return Ke.fromWorkingColorSpace(zt.copy(this), t), e.r = zt.r, e.g = zt.g, e.b = zt.b, e;
        }
        getStyle(e = Ft) {
            Ke.fromWorkingColorSpace(zt.copy(this), e);
            const t = zt.r, n = zt.g, s = zt.b;
            return e !== Ft ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${s.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(s * 255)})`;
        }
        offsetHSL(e, t, n) {
            return this.getHSL(mi), this.setHSL(mi.h + e, mi.s + t, mi.l + n);
        }
        add(e) {
            return this.r += e.r, this.g += e.g, this.b += e.b, this;
        }
        addColors(e, t) {
            return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
        }
        addScalar(e) {
            return this.r += e, this.g += e, this.b += e, this;
        }
        sub(e) {
            return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
        }
        multiply(e) {
            return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
        }
        multiplyScalar(e) {
            return this.r *= e, this.g *= e, this.b *= e, this;
        }
        lerp(e, t) {
            return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
        }
        lerpColors(e, t, n) {
            return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this;
        }
        lerpHSL(e, t) {
            this.getHSL(mi), e.getHSL(aa);
            const n = Pr(mi.h, aa.h, t), s = Pr(mi.s, aa.s, t), r = Pr(mi.l, aa.l, t);
            return this.setHSL(n, s, r), this;
        }
        setFromVector3(e) {
            return this.r = e.x, this.g = e.y, this.b = e.z, this;
        }
        applyMatrix3(e) {
            const t = this.r, n = this.g, s = this.b, r = e.elements;
            return this.r = r[0] * t + r[3] * n + r[6] * s, this.g = r[1] * t + r[4] * n + r[7] * s, this.b = r[2] * t + r[5] * n + r[8] * s, this;
        }
        equals(e) {
            return e.r === this.r && e.g === this.g && e.b === this.b;
        }
        fromArray(e, t = 0) {
            return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
        }
        toArray(e = [], t = 0) {
            return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
        }
        fromBufferAttribute(e, t) {
            return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
        }
        toJSON() {
            return this.getHex();
        }
        *[Symbol.iterator]() {
            yield this.r, yield this.g, yield this.b;
        }
    };
    const zt = new Oe;
    Oe.NAMES = xp;
    let Ox = 0;
    class Gn extends ss {
        constructor(){
            super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
                value: Ox++
            }), this.uuid = In(), this.name = "", this.type = "Material", this.blending = Is, this.side = ci, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = Hl, this.blendDst = zl, this.blendEquation = Yi, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Oe(0, 0, 0), this.blendAlpha = 0, this.depthFunc = Ns, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = mu, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = cs, this.stencilZFail = cs, this.stencilZPass = cs, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.allowOverride = !0, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
        }
        get alphaTest() {
            return this._alphaTest;
        }
        set alphaTest(e) {
            this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
        }
        onBeforeRender() {}
        onBeforeCompile() {}
        customProgramCacheKey() {
            return this.onBeforeCompile.toString();
        }
        setValues(e) {
            if (e !== void 0) for(const t in e){
                const n = e[t];
                if (n === void 0) {
                    console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
                    continue;
                }
                const s = this[t];
                if (s === void 0) {
                    console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
                    continue;
                }
                s && s.isColor ? s.set(n) : s && s.isVector3 && n && n.isVector3 ? s.copy(n) : this[t] = n;
            }
        }
        toJSON(e) {
            const t = e === void 0 || typeof e == "string";
            t && (e = {
                textures: {},
                images: {}
            });
            const n = {
                metadata: {
                    version: 4.6,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };
            n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (n.dispersion = this.dispersion), this.iridescence !== void 0 && (n.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapRotation !== void 0 && (n.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== Is && (n.blending = this.blending), this.side !== ci && (n.side = this.side), this.vertexColors === !0 && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = !0), this.blendSrc !== Hl && (n.blendSrc = this.blendSrc), this.blendDst !== zl && (n.blendDst = this.blendDst), this.blendEquation !== Yi && (n.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha), this.depthFunc !== Ns && (n.depthFunc = this.depthFunc), this.depthTest === !1 && (n.depthTest = this.depthTest), this.depthWrite === !1 && (n.depthWrite = this.depthWrite), this.colorWrite === !1 && (n.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== mu && (n.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (n.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== cs && (n.stencilFail = this.stencilFail), this.stencilZFail !== cs && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== cs && (n.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaHash === !0 && (n.alphaHash = !0), this.alphaToCoverage === !0 && (n.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0), this.forceSinglePass === !0 && (n.forceSinglePass = !0), this.wireframe === !0 && (n.wireframe = !0), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (n.flatShading = !0), this.visible === !1 && (n.visible = !1), this.toneMapped === !1 && (n.toneMapped = !1), this.fog === !1 && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData);
            function s(r) {
                const a = [];
                for(const o in r){
                    const l = r[o];
                    delete l.metadata, a.push(l);
                }
                return a;
            }
            if (t) {
                const r = s(e.textures), a = s(e.images);
                r.length > 0 && (n.textures = r), a.length > 0 && (n.images = a);
            }
            return n;
        }
        clone() {
            return new this.constructor().copy(this);
        }
        copy(e) {
            this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
            const t = e.clippingPlanes;
            let n = null;
            if (t !== null) {
                const s = t.length;
                n = new Array(s);
                for(let r = 0; r !== s; ++r)n[r] = t[r].clone();
            }
            return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            });
        }
        set needsUpdate(e) {
            e === !0 && this.version++;
        }
        onBuild() {
            console.warn("Material: onBuild() has been removed.");
        }
    }
    class qi extends Gn {
        constructor(e){
            super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Oe(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Hn, this.combine = Qf, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
        }
        copy(e) {
            return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
        }
    }
    const Ct = new k, oa = new Ze;
    let kx = 0;
    class Kt {
        constructor(e, t, n = !1){
            if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.isBufferAttribute = !0, Object.defineProperty(this, "id", {
                value: kx++
            }), this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = n, this.usage = Ac, this.updateRanges = [], this.gpuType = Pn, this.version = 0;
        }
        onUploadCallback() {}
        set needsUpdate(e) {
            e === !0 && this.version++;
        }
        setUsage(e) {
            return this.usage = e, this;
        }
        addUpdateRange(e, t) {
            this.updateRanges.push({
                start: e,
                count: t
            });
        }
        clearUpdateRanges() {
            this.updateRanges.length = 0;
        }
        copy(e) {
            return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
        }
        copyAt(e, t, n) {
            e *= this.itemSize, n *= t.itemSize;
            for(let s = 0, r = this.itemSize; s < r; s++)this.array[e + s] = t.array[n + s];
            return this;
        }
        copyArray(e) {
            return this.array.set(e), this;
        }
        applyMatrix3(e) {
            if (this.itemSize === 2) for(let t = 0, n = this.count; t < n; t++)oa.fromBufferAttribute(this, t), oa.applyMatrix3(e), this.setXY(t, oa.x, oa.y);
            else if (this.itemSize === 3) for(let t = 0, n = this.count; t < n; t++)Ct.fromBufferAttribute(this, t), Ct.applyMatrix3(e), this.setXYZ(t, Ct.x, Ct.y, Ct.z);
            return this;
        }
        applyMatrix4(e) {
            for(let t = 0, n = this.count; t < n; t++)Ct.fromBufferAttribute(this, t), Ct.applyMatrix4(e), this.setXYZ(t, Ct.x, Ct.y, Ct.z);
            return this;
        }
        applyNormalMatrix(e) {
            for(let t = 0, n = this.count; t < n; t++)Ct.fromBufferAttribute(this, t), Ct.applyNormalMatrix(e), this.setXYZ(t, Ct.x, Ct.y, Ct.z);
            return this;
        }
        transformDirection(e) {
            for(let t = 0, n = this.count; t < n; t++)Ct.fromBufferAttribute(this, t), Ct.transformDirection(e), this.setXYZ(t, Ct.x, Ct.y, Ct.z);
            return this;
        }
        set(e, t = 0) {
            return this.array.set(e, t), this;
        }
        getComponent(e, t) {
            let n = this.array[e * this.itemSize + t];
            return this.normalized && (n = wn(n, this.array)), n;
        }
        setComponent(e, t, n) {
            return this.normalized && (n = ht(n, this.array)), this.array[e * this.itemSize + t] = n, this;
        }
        getX(e) {
            let t = this.array[e * this.itemSize];
            return this.normalized && (t = wn(t, this.array)), t;
        }
        setX(e, t) {
            return this.normalized && (t = ht(t, this.array)), this.array[e * this.itemSize] = t, this;
        }
        getY(e) {
            let t = this.array[e * this.itemSize + 1];
            return this.normalized && (t = wn(t, this.array)), t;
        }
        setY(e, t) {
            return this.normalized && (t = ht(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
        }
        getZ(e) {
            let t = this.array[e * this.itemSize + 2];
            return this.normalized && (t = wn(t, this.array)), t;
        }
        setZ(e, t) {
            return this.normalized && (t = ht(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
        }
        getW(e) {
            let t = this.array[e * this.itemSize + 3];
            return this.normalized && (t = wn(t, this.array)), t;
        }
        setW(e, t) {
            return this.normalized && (t = ht(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
        }
        setXY(e, t, n) {
            return e *= this.itemSize, this.normalized && (t = ht(t, this.array), n = ht(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this;
        }
        setXYZ(e, t, n, s) {
            return e *= this.itemSize, this.normalized && (t = ht(t, this.array), n = ht(n, this.array), s = ht(s, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = s, this;
        }
        setXYZW(e, t, n, s, r) {
            return e *= this.itemSize, this.normalized && (t = ht(t, this.array), n = ht(n, this.array), s = ht(s, this.array), r = ht(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = s, this.array[e + 3] = r, this;
        }
        onUpload(e) {
            return this.onUploadCallback = e, this;
        }
        clone() {
            return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
            const e = {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: Array.from(this.array),
                normalized: this.normalized
            };
            return this.name !== "" && (e.name = this.name), this.usage !== Ac && (e.usage = this.usage), e;
        }
    }
    class vp extends Kt {
        constructor(e, t, n){
            super(new Uint16Array(e), t, n);
        }
    }
    class yp extends Kt {
        constructor(e, t, n){
            super(new Uint32Array(e), t, n);
        }
    }
    class ri extends Kt {
        constructor(e, t, n){
            super(new Float32Array(e), t, n);
        }
    }
    let Gx = 0;
    const fn = new He, ko = new yt, vs = new k, on = new Ln, hr = new Ln, Dt = new k;
    class Wn extends ss {
        constructor(){
            super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
                value: Gx++
            }), this.uuid = In(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                start: 0,
                count: 1 / 0
            }, this.userData = {};
        }
        getIndex() {
            return this.index;
        }
        setIndex(e) {
            return Array.isArray(e) ? this.index = new (mp(e) ? yp : vp)(e, 1) : this.index = e, this;
        }
        setIndirect(e) {
            return this.indirect = e, this;
        }
        getIndirect() {
            return this.indirect;
        }
        getAttribute(e) {
            return this.attributes[e];
        }
        setAttribute(e, t) {
            return this.attributes[e] = t, this;
        }
        deleteAttribute(e) {
            return delete this.attributes[e], this;
        }
        hasAttribute(e) {
            return this.attributes[e] !== void 0;
        }
        addGroup(e, t, n = 0) {
            this.groups.push({
                start: e,
                count: t,
                materialIndex: n
            });
        }
        clearGroups() {
            this.groups = [];
        }
        setDrawRange(e, t) {
            this.drawRange.start = e, this.drawRange.count = t;
        }
        applyMatrix4(e) {
            const t = this.attributes.position;
            t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
            const n = this.attributes.normal;
            if (n !== void 0) {
                const r = new Ge().getNormalMatrix(e);
                n.applyNormalMatrix(r), n.needsUpdate = !0;
            }
            const s = this.attributes.tangent;
            return s !== void 0 && (s.transformDirection(e), s.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
        }
        applyQuaternion(e) {
            return fn.makeRotationFromQuaternion(e), this.applyMatrix4(fn), this;
        }
        rotateX(e) {
            return fn.makeRotationX(e), this.applyMatrix4(fn), this;
        }
        rotateY(e) {
            return fn.makeRotationY(e), this.applyMatrix4(fn), this;
        }
        rotateZ(e) {
            return fn.makeRotationZ(e), this.applyMatrix4(fn), this;
        }
        translate(e, t, n) {
            return fn.makeTranslation(e, t, n), this.applyMatrix4(fn), this;
        }
        scale(e, t, n) {
            return fn.makeScale(e, t, n), this.applyMatrix4(fn), this;
        }
        lookAt(e) {
            return ko.lookAt(e), ko.updateMatrix(), this.applyMatrix4(ko.matrix), this;
        }
        center() {
            return this.computeBoundingBox(), this.boundingBox.getCenter(vs).negate(), this.translate(vs.x, vs.y, vs.z), this;
        }
        setFromPoints(e) {
            const t = this.getAttribute("position");
            if (t === void 0) {
                const n = [];
                for(let s = 0, r = e.length; s < r; s++){
                    const a = e[s];
                    n.push(a.x, a.y, a.z || 0);
                }
                this.setAttribute("position", new ri(n, 3));
            } else {
                const n = Math.min(e.length, t.count);
                for(let s = 0; s < n; s++){
                    const r = e[s];
                    t.setXYZ(s, r.x, r.y, r.z || 0);
                }
                e.length > t.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), t.needsUpdate = !0;
            }
            return this;
        }
        computeBoundingBox() {
            this.boundingBox === null && (this.boundingBox = new Ln);
            const e = this.attributes.position, t = this.morphAttributes.position;
            if (e && e.isGLBufferAttribute) {
                console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(new k(-1 / 0, -1 / 0, -1 / 0), new k(1 / 0, 1 / 0, 1 / 0));
                return;
            }
            if (e !== void 0) {
                if (this.boundingBox.setFromBufferAttribute(e), t) for(let n = 0, s = t.length; n < s; n++){
                    const r = t[n];
                    on.setFromBufferAttribute(r), this.morphTargetsRelative ? (Dt.addVectors(this.boundingBox.min, on.min), this.boundingBox.expandByPoint(Dt), Dt.addVectors(this.boundingBox.max, on.max), this.boundingBox.expandByPoint(Dt)) : (this.boundingBox.expandByPoint(on.min), this.boundingBox.expandByPoint(on.max));
                }
            } else this.boundingBox.makeEmpty();
            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
        }
        computeBoundingSphere() {
            this.boundingSphere === null && (this.boundingSphere = new Vn);
            const e = this.attributes.position, t = this.morphAttributes.position;
            if (e && e.isGLBufferAttribute) {
                console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new k, 1 / 0);
                return;
            }
            if (e) {
                const n = this.boundingSphere.center;
                if (on.setFromBufferAttribute(e), t) for(let r = 0, a = t.length; r < a; r++){
                    const o = t[r];
                    hr.setFromBufferAttribute(o), this.morphTargetsRelative ? (Dt.addVectors(on.min, hr.min), on.expandByPoint(Dt), Dt.addVectors(on.max, hr.max), on.expandByPoint(Dt)) : (on.expandByPoint(hr.min), on.expandByPoint(hr.max));
                }
                on.getCenter(n);
                let s = 0;
                for(let r = 0, a = e.count; r < a; r++)Dt.fromBufferAttribute(e, r), s = Math.max(s, n.distanceToSquared(Dt));
                if (t) for(let r = 0, a = t.length; r < a; r++){
                    const o = t[r], l = this.morphTargetsRelative;
                    for(let h = 0, d = o.count; h < d; h++)Dt.fromBufferAttribute(o, h), l && (vs.fromBufferAttribute(e, h), Dt.add(vs)), s = Math.max(s, n.distanceToSquared(Dt));
                }
                this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
            }
        }
        computeTangents() {
            const e = this.index, t = this.attributes;
            if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
                console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                return;
            }
            const n = t.position, s = t.normal, r = t.uv;
            this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Kt(new Float32Array(4 * n.count), 4));
            const a = this.getAttribute("tangent"), o = [], l = [];
            for(let B = 0; B < n.count; B++)o[B] = new k, l[B] = new k;
            const h = new k, d = new k, c = new k, u = new Ze, f = new Ze, _ = new Ze, g = new k, m = new k;
            function p(B, T, S) {
                h.fromBufferAttribute(n, B), d.fromBufferAttribute(n, T), c.fromBufferAttribute(n, S), u.fromBufferAttribute(r, B), f.fromBufferAttribute(r, T), _.fromBufferAttribute(r, S), d.sub(h), c.sub(h), f.sub(u), _.sub(u);
                const D = 1 / (f.x * _.y - _.x * f.y);
                isFinite(D) && (g.copy(d).multiplyScalar(_.y).addScaledVector(c, -f.y).multiplyScalar(D), m.copy(c).multiplyScalar(f.x).addScaledVector(d, -_.x).multiplyScalar(D), o[B].add(g), o[T].add(g), o[S].add(g), l[B].add(m), l[T].add(m), l[S].add(m));
            }
            let x = this.groups;
            x.length === 0 && (x = [
                {
                    start: 0,
                    count: e.count
                }
            ]);
            for(let B = 0, T = x.length; B < T; ++B){
                const S = x[B], D = S.start, q = S.count;
                for(let H = D, $ = D + q; H < $; H += 3)p(e.getX(H + 0), e.getX(H + 1), e.getX(H + 2));
            }
            const v = new k, y = new k, P = new k, w = new k;
            function R(B) {
                P.fromBufferAttribute(s, B), w.copy(P);
                const T = o[B];
                v.copy(T), v.sub(P.multiplyScalar(P.dot(T))).normalize(), y.crossVectors(w, T);
                const D = y.dot(l[B]) < 0 ? -1 : 1;
                a.setXYZW(B, v.x, v.y, v.z, D);
            }
            for(let B = 0, T = x.length; B < T; ++B){
                const S = x[B], D = S.start, q = S.count;
                for(let H = D, $ = D + q; H < $; H += 3)R(e.getX(H + 0)), R(e.getX(H + 1)), R(e.getX(H + 2));
            }
        }
        computeVertexNormals() {
            const e = this.index, t = this.getAttribute("position");
            if (t !== void 0) {
                let n = this.getAttribute("normal");
                if (n === void 0) n = new Kt(new Float32Array(t.count * 3), 3), this.setAttribute("normal", n);
                else for(let u = 0, f = n.count; u < f; u++)n.setXYZ(u, 0, 0, 0);
                const s = new k, r = new k, a = new k, o = new k, l = new k, h = new k, d = new k, c = new k;
                if (e) for(let u = 0, f = e.count; u < f; u += 3){
                    const _ = e.getX(u + 0), g = e.getX(u + 1), m = e.getX(u + 2);
                    s.fromBufferAttribute(t, _), r.fromBufferAttribute(t, g), a.fromBufferAttribute(t, m), d.subVectors(a, r), c.subVectors(s, r), d.cross(c), o.fromBufferAttribute(n, _), l.fromBufferAttribute(n, g), h.fromBufferAttribute(n, m), o.add(d), l.add(d), h.add(d), n.setXYZ(_, o.x, o.y, o.z), n.setXYZ(g, l.x, l.y, l.z), n.setXYZ(m, h.x, h.y, h.z);
                }
                else for(let u = 0, f = t.count; u < f; u += 3)s.fromBufferAttribute(t, u + 0), r.fromBufferAttribute(t, u + 1), a.fromBufferAttribute(t, u + 2), d.subVectors(a, r), c.subVectors(s, r), d.cross(c), n.setXYZ(u + 0, d.x, d.y, d.z), n.setXYZ(u + 1, d.x, d.y, d.z), n.setXYZ(u + 2, d.x, d.y, d.z);
                this.normalizeNormals(), n.needsUpdate = !0;
            }
        }
        normalizeNormals() {
            const e = this.attributes.normal;
            for(let t = 0, n = e.count; t < n; t++)Dt.fromBufferAttribute(e, t), Dt.normalize(), e.setXYZ(t, Dt.x, Dt.y, Dt.z);
        }
        toNonIndexed() {
            function e(o, l) {
                const h = o.array, d = o.itemSize, c = o.normalized, u = new h.constructor(l.length * d);
                let f = 0, _ = 0;
                for(let g = 0, m = l.length; g < m; g++){
                    o.isInterleavedBufferAttribute ? f = l[g] * o.data.stride + o.offset : f = l[g] * d;
                    for(let p = 0; p < d; p++)u[_++] = h[f++];
                }
                return new Kt(u, d, c);
            }
            if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
            const t = new Wn, n = this.index.array, s = this.attributes;
            for(const o in s){
                const l = s[o], h = e(l, n);
                t.setAttribute(o, h);
            }
            const r = this.morphAttributes;
            for(const o in r){
                const l = [], h = r[o];
                for(let d = 0, c = h.length; d < c; d++){
                    const u = h[d], f = e(u, n);
                    l.push(f);
                }
                t.morphAttributes[o] = l;
            }
            t.morphTargetsRelative = this.morphTargetsRelative;
            const a = this.groups;
            for(let o = 0, l = a.length; o < l; o++){
                const h = a[o];
                t.addGroup(h.start, h.count, h.materialIndex);
            }
            return t;
        }
        toJSON() {
            const e = {
                metadata: {
                    version: 4.6,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
                const l = this.parameters;
                for(const h in l)l[h] !== void 0 && (e[h] = l[h]);
                return e;
            }
            e.data = {
                attributes: {}
            };
            const t = this.index;
            t !== null && (e.data.index = {
                type: t.array.constructor.name,
                array: Array.prototype.slice.call(t.array)
            });
            const n = this.attributes;
            for(const l in n){
                const h = n[l];
                e.data.attributes[l] = h.toJSON(e.data);
            }
            const s = {};
            let r = !1;
            for(const l in this.morphAttributes){
                const h = this.morphAttributes[l], d = [];
                for(let c = 0, u = h.length; c < u; c++){
                    const f = h[c];
                    d.push(f.toJSON(e.data));
                }
                d.length > 0 && (s[l] = d, r = !0);
            }
            r && (e.data.morphAttributes = s, e.data.morphTargetsRelative = this.morphTargetsRelative);
            const a = this.groups;
            a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
            const o = this.boundingSphere;
            return o !== null && (e.data.boundingSphere = {
                center: o.center.toArray(),
                radius: o.radius
            }), e;
        }
        clone() {
            return new this.constructor().copy(this);
        }
        copy(e) {
            this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
            const t = {};
            this.name = e.name;
            const n = e.index;
            n !== null && this.setIndex(n.clone());
            const s = e.attributes;
            for(const h in s){
                const d = s[h];
                this.setAttribute(h, d.clone(t));
            }
            const r = e.morphAttributes;
            for(const h in r){
                const d = [], c = r[h];
                for(let u = 0, f = c.length; u < f; u++)d.push(c[u].clone(t));
                this.morphAttributes[h] = d;
            }
            this.morphTargetsRelative = e.morphTargetsRelative;
            const a = e.groups;
            for(let h = 0, d = a.length; h < d; h++){
                const c = a[h];
                this.addGroup(c.start, c.count, c.materialIndex);
            }
            const o = e.boundingBox;
            o !== null && (this.boundingBox = o.clone());
            const l = e.boundingSphere;
            return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            });
        }
    }
    const Pu = new He, Bi = new uo, la = new Vn, Iu = new k, ca = new k, ha = new k, ua = new k, Go = new k, da = new k, Du = new k, fa = new k;
    class Nt extends yt {
        constructor(e = new Wn, t = new qi){
            super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets();
        }
        copy(e, t) {
            return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
        }
        updateMorphTargets() {
            const t = this.geometry.morphAttributes, n = Object.keys(t);
            if (n.length > 0) {
                const s = t[n[0]];
                if (s !== void 0) {
                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                    for(let r = 0, a = s.length; r < a; r++){
                        const o = s[r].name || String(r);
                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = r;
                    }
                }
            }
        }
        getVertexPosition(e, t) {
            const n = this.geometry, s = n.attributes.position, r = n.morphAttributes.position, a = n.morphTargetsRelative;
            t.fromBufferAttribute(s, e);
            const o = this.morphTargetInfluences;
            if (r && o) {
                da.set(0, 0, 0);
                for(let l = 0, h = r.length; l < h; l++){
                    const d = o[l], c = r[l];
                    d !== 0 && (Go.fromBufferAttribute(c, e), a ? da.addScaledVector(Go, d) : da.addScaledVector(Go.sub(t), d));
                }
                t.add(da);
            }
            return t;
        }
        raycast(e, t) {
            const n = this.geometry, s = this.material, r = this.matrixWorld;
            s !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(), la.copy(n.boundingSphere), la.applyMatrix4(r), Bi.copy(e.ray).recast(e.near), !(la.containsPoint(Bi.origin) === !1 && (Bi.intersectSphere(la, Iu) === null || Bi.origin.distanceToSquared(Iu) > (e.far - e.near) ** 2)) && (Pu.copy(r).invert(), Bi.copy(e.ray).applyMatrix4(Pu), !(n.boundingBox !== null && Bi.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(e, t, Bi)));
        }
        _computeIntersections(e, t, n) {
            let s;
            const r = this.geometry, a = this.material, o = r.index, l = r.attributes.position, h = r.attributes.uv, d = r.attributes.uv1, c = r.attributes.normal, u = r.groups, f = r.drawRange;
            if (o !== null) if (Array.isArray(a)) for(let _ = 0, g = u.length; _ < g; _++){
                const m = u[_], p = a[m.materialIndex], x = Math.max(m.start, f.start), v = Math.min(o.count, Math.min(m.start + m.count, f.start + f.count));
                for(let y = x, P = v; y < P; y += 3){
                    const w = o.getX(y), R = o.getX(y + 1), B = o.getX(y + 2);
                    s = pa(this, p, e, n, h, d, c, w, R, B), s && (s.faceIndex = Math.floor(y / 3), s.face.materialIndex = m.materialIndex, t.push(s));
                }
            }
            else {
                const _ = Math.max(0, f.start), g = Math.min(o.count, f.start + f.count);
                for(let m = _, p = g; m < p; m += 3){
                    const x = o.getX(m), v = o.getX(m + 1), y = o.getX(m + 2);
                    s = pa(this, a, e, n, h, d, c, x, v, y), s && (s.faceIndex = Math.floor(m / 3), t.push(s));
                }
            }
            else if (l !== void 0) if (Array.isArray(a)) for(let _ = 0, g = u.length; _ < g; _++){
                const m = u[_], p = a[m.materialIndex], x = Math.max(m.start, f.start), v = Math.min(l.count, Math.min(m.start + m.count, f.start + f.count));
                for(let y = x, P = v; y < P; y += 3){
                    const w = y, R = y + 1, B = y + 2;
                    s = pa(this, p, e, n, h, d, c, w, R, B), s && (s.faceIndex = Math.floor(y / 3), s.face.materialIndex = m.materialIndex, t.push(s));
                }
            }
            else {
                const _ = Math.max(0, f.start), g = Math.min(l.count, f.start + f.count);
                for(let m = _, p = g; m < p; m += 3){
                    const x = m, v = m + 1, y = m + 2;
                    s = pa(this, a, e, n, h, d, c, x, v, y), s && (s.faceIndex = Math.floor(m / 3), t.push(s));
                }
            }
        }
    }
    function Hx(i, e, t, n, s, r, a, o) {
        let l;
        if (e.side === tn ? l = n.intersectTriangle(a, r, s, !0, o) : l = n.intersectTriangle(s, r, a, e.side === ci, o), l === null) return null;
        fa.copy(o), fa.applyMatrix4(i.matrixWorld);
        const h = t.ray.origin.distanceTo(fa);
        return h < t.near || h > t.far ? null : {
            distance: h,
            point: fa.clone(),
            object: i
        };
    }
    function pa(i, e, t, n, s, r, a, o, l, h) {
        i.getVertexPosition(o, ca), i.getVertexPosition(l, ha), i.getVertexPosition(h, ua);
        const d = Hx(i, e, t, n, ca, ha, ua, Du);
        if (d) {
            const c = new k;
            Rn.getBarycoord(Du, ca, ha, ua, c), s && (d.uv = Rn.getInterpolatedAttribute(s, o, l, h, c, new Ze)), r && (d.uv1 = Rn.getInterpolatedAttribute(r, o, l, h, c, new Ze)), a && (d.normal = Rn.getInterpolatedAttribute(a, o, l, h, c, new k), d.normal.dot(n.direction) > 0 && d.normal.multiplyScalar(-1));
            const u = {
                a: o,
                b: l,
                c: h,
                normal: new k,
                materialIndex: 0
            };
            Rn.getNormal(ca, ha, ua, u.normal), d.face = u, d.barycoord = c;
        }
        return d;
    }
    class Ks extends Wn {
        constructor(e = 1, t = 1, n = 1, s = 1, r = 1, a = 1){
            super(), this.type = "BoxGeometry", this.parameters = {
                width: e,
                height: t,
                depth: n,
                widthSegments: s,
                heightSegments: r,
                depthSegments: a
            };
            const o = this;
            s = Math.floor(s), r = Math.floor(r), a = Math.floor(a);
            const l = [], h = [], d = [], c = [];
            let u = 0, f = 0;
            _("z", "y", "x", -1, -1, n, t, e, a, r, 0), _("z", "y", "x", 1, -1, n, t, -e, a, r, 1), _("x", "z", "y", 1, 1, e, n, t, s, a, 2), _("x", "z", "y", 1, -1, e, n, -t, s, a, 3), _("x", "y", "z", 1, -1, e, t, n, s, r, 4), _("x", "y", "z", -1, -1, e, t, -n, s, r, 5), this.setIndex(l), this.setAttribute("position", new ri(h, 3)), this.setAttribute("normal", new ri(d, 3)), this.setAttribute("uv", new ri(c, 2));
            function _(g, m, p, x, v, y, P, w, R, B, T) {
                const S = y / R, D = P / B, q = y / 2, H = P / 2, $ = w / 2, ne = R + 1, b = B + 1;
                let C = 0, E = 0;
                const U = new k;
                for(let F = 0; F < b; F++){
                    const V = F * D - H;
                    for(let j = 0; j < ne; j++){
                        const ie = j * S - q;
                        U[g] = ie * x, U[m] = V * v, U[p] = $, h.push(U.x, U.y, U.z), U[g] = 0, U[m] = 0, U[p] = w > 0 ? 1 : -1, d.push(U.x, U.y, U.z), c.push(j / R), c.push(1 - F / B), C += 1;
                    }
                }
                for(let F = 0; F < B; F++)for(let V = 0; V < R; V++){
                    const j = u + V + ne * F, ie = u + V + ne * (F + 1), z = u + (V + 1) + ne * (F + 1), K = u + (V + 1) + ne * F;
                    l.push(j, ie, K), l.push(ie, z, K), E += 6;
                }
                o.addGroup(f, E, T), f += E, u += C;
            }
        }
        copy(e) {
            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
        }
        static fromJSON(e) {
            return new Ks(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
        }
    }
    function zs(i) {
        const e = {};
        for(const t in i){
            e[t] = {};
            for(const n in i[t]){
                const s = i[t][n];
                s && (s.isColor || s.isMatrix3 || s.isMatrix4 || s.isVector2 || s.isVector3 || s.isVector4 || s.isTexture || s.isQuaternion) ? s.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][n] = null) : e[t][n] = s.clone() : Array.isArray(s) ? e[t][n] = s.slice() : e[t][n] = s;
            }
        }
        return e;
    }
    function Yt(i) {
        const e = {};
        for(let t = 0; t < i.length; t++){
            const n = zs(i[t]);
            for(const s in n)e[s] = n[s];
        }
        return e;
    }
    function zx(i) {
        const e = [];
        for(let t = 0; t < i.length; t++)e.push(i[t].clone());
        return e;
    }
    function bp(i) {
        const e = i.getRenderTarget();
        return e === null ? i.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : Ke.workingColorSpace;
    }
    const Vx = {
        clone: zs,
        merge: Yt
    };
    var Wx = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, Xx = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
    class wi extends Gn {
        constructor(e){
            super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = Wx, this.fragmentShader = Xx, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
                clipCullDistance: !1,
                multiDraw: !1
            }, this.defaultAttributeValues = {
                color: [
                    1,
                    1,
                    1
                ],
                uv: [
                    0,
                    0
                ],
                uv1: [
                    0,
                    0
                ]
            }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e);
        }
        copy(e) {
            return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = zs(e.uniforms), this.uniformsGroups = zx(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
        }
        toJSON(e) {
            const t = super.toJSON(e);
            t.glslVersion = this.glslVersion, t.uniforms = {};
            for(const s in this.uniforms){
                const a = this.uniforms[s].value;
                a && a.isTexture ? t.uniforms[s] = {
                    type: "t",
                    value: a.toJSON(e).uuid
                } : a && a.isColor ? t.uniforms[s] = {
                    type: "c",
                    value: a.getHex()
                } : a && a.isVector2 ? t.uniforms[s] = {
                    type: "v2",
                    value: a.toArray()
                } : a && a.isVector3 ? t.uniforms[s] = {
                    type: "v3",
                    value: a.toArray()
                } : a && a.isVector4 ? t.uniforms[s] = {
                    type: "v4",
                    value: a.toArray()
                } : a && a.isMatrix3 ? t.uniforms[s] = {
                    type: "m3",
                    value: a.toArray()
                } : a && a.isMatrix4 ? t.uniforms[s] = {
                    type: "m4",
                    value: a.toArray()
                } : t.uniforms[s] = {
                    value: a
                };
            }
            Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
            const n = {};
            for(const s in this.extensions)this.extensions[s] === !0 && (n[s] = !0);
            return Object.keys(n).length > 0 && (t.extensions = n), t;
        }
    }
    class Sp extends yt {
        constructor(){
            super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new He, this.projectionMatrix = new He, this.projectionMatrixInverse = new He, this.coordinateSystem = ii;
        }
        copy(e, t) {
            return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
        }
        getWorldDirection(e) {
            return super.getWorldDirection(e).negate();
        }
        updateMatrixWorld(e) {
            super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        updateWorldMatrix(e, t) {
            super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        clone() {
            return new this.constructor().copy(this);
        }
    }
    const _i = new k, Lu = new Ze, Bu = new Ze;
    class jt extends Sp {
        constructor(e = 50, t = 1, n = .1, s = 2e3){
            super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = s, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
        }
        copy(e, t) {
            return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
        }
        setFocalLength(e) {
            const t = .5 * this.getFilmHeight() / e;
            this.fov = Hs * 2 * Math.atan(t), this.updateProjectionMatrix();
        }
        getFocalLength() {
            const e = Math.tan(Cr * .5 * this.fov);
            return .5 * this.getFilmHeight() / e;
        }
        getEffectiveFOV() {
            return Hs * 2 * Math.atan(Math.tan(Cr * .5 * this.fov) / this.zoom);
        }
        getFilmWidth() {
            return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
            return this.filmGauge / Math.max(this.aspect, 1);
        }
        getViewBounds(e, t, n) {
            _i.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse), t.set(_i.x, _i.y).multiplyScalar(-e / _i.z), _i.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse), n.set(_i.x, _i.y).multiplyScalar(-e / _i.z);
        }
        getViewSize(e, t) {
            return this.getViewBounds(e, Lu, Bu), t.subVectors(Bu, Lu);
        }
        setViewOffset(e, t, n, s, r, a) {
            this.aspect = e / t, this.view === null && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = s, this.view.width = r, this.view.height = a, this.updateProjectionMatrix();
        }
        clearViewOffset() {
            this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
            const e = this.near;
            let t = e * Math.tan(Cr * .5 * this.fov) / this.zoom, n = 2 * t, s = this.aspect * n, r = -.5 * s;
            const a = this.view;
            if (this.view !== null && this.view.enabled) {
                const l = a.fullWidth, h = a.fullHeight;
                r += a.offsetX * s / l, t -= a.offsetY * n / h, s *= a.width / l, n *= a.height / h;
            }
            const o = this.filmOffset;
            o !== 0 && (r += e * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + s, t, t - n, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
        }
    }
    const ys = -90, bs = 1;
    class Yx extends yt {
        constructor(e, t, n){
            super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0;
            const s = new jt(ys, bs, e, t);
            s.layers = this.layers, this.add(s);
            const r = new jt(ys, bs, e, t);
            r.layers = this.layers, this.add(r);
            const a = new jt(ys, bs, e, t);
            a.layers = this.layers, this.add(a);
            const o = new jt(ys, bs, e, t);
            o.layers = this.layers, this.add(o);
            const l = new jt(ys, bs, e, t);
            l.layers = this.layers, this.add(l);
            const h = new jt(ys, bs, e, t);
            h.layers = this.layers, this.add(h);
        }
        updateCoordinateSystem() {
            const e = this.coordinateSystem, t = this.children.concat(), [n, s, r, a, o, l] = t;
            for (const h of t)this.remove(h);
            if (e === ii) n.up.set(0, 1, 0), n.lookAt(1, 0, 0), s.up.set(0, 1, 0), s.lookAt(-1, 0, 0), r.up.set(0, 0, -1), r.lookAt(0, 1, 0), a.up.set(0, 0, 1), a.lookAt(0, -1, 0), o.up.set(0, 1, 0), o.lookAt(0, 0, 1), l.up.set(0, 1, 0), l.lookAt(0, 0, -1);
            else if (e === to) n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), s.up.set(0, -1, 0), s.lookAt(1, 0, 0), r.up.set(0, 0, 1), r.lookAt(0, 1, 0), a.up.set(0, 0, -1), a.lookAt(0, -1, 0), o.up.set(0, -1, 0), o.lookAt(0, 0, 1), l.up.set(0, -1, 0), l.lookAt(0, 0, -1);
            else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
            for (const h of t)this.add(h), h.updateMatrixWorld();
        }
        update(e, t) {
            this.parent === null && this.updateMatrixWorld();
            const { renderTarget: n, activeMipmapLevel: s } = this;
            this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
            const [r, a, o, l, h, d] = this.children, c = e.getRenderTarget(), u = e.getActiveCubeFace(), f = e.getActiveMipmapLevel(), _ = e.xr.enabled;
            e.xr.enabled = !1;
            const g = n.texture.generateMipmaps;
            n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0, s), e.render(t, r), e.setRenderTarget(n, 1, s), e.render(t, a), e.setRenderTarget(n, 2, s), e.render(t, o), e.setRenderTarget(n, 3, s), e.render(t, l), e.setRenderTarget(n, 4, s), e.render(t, h), n.texture.generateMipmaps = g, e.setRenderTarget(n, 5, s), e.render(t, d), e.setRenderTarget(c, u, f), e.xr.enabled = _, n.texture.needsPMREMUpdate = !0;
        }
    }
    class Tp extends nn {
        constructor(e = [], t = Os, n, s, r, a, o, l, h, d){
            super(e, t, n, s, r, a, o, l, h, d), this.isCubeTexture = !0, this.flipY = !1;
        }
        get images() {
            return this.image;
        }
        set images(e) {
            this.image = e;
        }
    }
    class jx extends Qi {
        constructor(e = 1, t = {}){
            super(e, e, t), this.isWebGLCubeRenderTarget = !0;
            const n = {
                width: e,
                height: e,
                depth: 1
            }, s = [
                n,
                n,
                n,
                n,
                n,
                n
            ];
            this.texture = new Tp(s, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : cn;
        }
        fromEquirectangularTexture(e, t) {
            this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
            const n = {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
                fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
            }, s = new Ks(5, 5, 5), r = new wi({
                name: "CubemapFromEquirect",
                uniforms: zs(n.uniforms),
                vertexShader: n.vertexShader,
                fragmentShader: n.fragmentShader,
                side: tn,
                blending: Ti
            });
            r.uniforms.tEquirect.value = t;
            const a = new Nt(s, r), o = t.minFilter;
            return t.minFilter === ni && (t.minFilter = cn), new Yx(1, 10, this).update(e, a), t.minFilter = o, a.geometry.dispose(), a.material.dispose(), this;
        }
        clear(e, t = !0, n = !0, s = !0) {
            const r = e.getRenderTarget();
            for(let a = 0; a < 6; a++)e.setRenderTarget(this, a), e.clear(t, n, s);
            e.setRenderTarget(r);
        }
    }
    class $i extends yt {
        constructor(){
            super(), this.isGroup = !0, this.type = "Group";
        }
    }
    const qx = {
        type: "move"
    };
    class Ho {
        constructor(){
            this._targetRay = null, this._grip = null, this._hand = null;
        }
        getHandSpace() {
            return this._hand === null && (this._hand = new $i, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
                pinching: !1
            }), this._hand;
        }
        getTargetRaySpace() {
            return this._targetRay === null && (this._targetRay = new $i, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new k, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new k), this._targetRay;
        }
        getGripSpace() {
            return this._grip === null && (this._grip = new $i, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new k, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new k), this._grip;
        }
        dispatchEvent(e) {
            return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
        }
        connect(e) {
            if (e && e.hand) {
                const t = this._hand;
                if (t) for (const n of e.hand.values())this._getHandJoint(t, n);
            }
            return this.dispatchEvent({
                type: "connected",
                data: e
            }), this;
        }
        disconnect(e) {
            return this.dispatchEvent({
                type: "disconnected",
                data: e
            }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
        }
        update(e, t, n) {
            let s = null, r = null, a = null;
            const o = this._targetRay, l = this._grip, h = this._hand;
            if (e && t.session.visibilityState !== "visible-blurred") {
                if (h && e.hand) {
                    a = !0;
                    for (const g of e.hand.values()){
                        const m = t.getJointPose(g, n), p = this._getHandJoint(h, g);
                        m !== null && (p.matrix.fromArray(m.transform.matrix), p.matrix.decompose(p.position, p.rotation, p.scale), p.matrixWorldNeedsUpdate = !0, p.jointRadius = m.radius), p.visible = m !== null;
                    }
                    const d = h.joints["index-finger-tip"], c = h.joints["thumb-tip"], u = d.position.distanceTo(c.position), f = .02, _ = .005;
                    h.inputState.pinching && u > f + _ ? (h.inputState.pinching = !1, this.dispatchEvent({
                        type: "pinchend",
                        handedness: e.handedness,
                        target: this
                    })) : !h.inputState.pinching && u <= f - _ && (h.inputState.pinching = !0, this.dispatchEvent({
                        type: "pinchstart",
                        handedness: e.handedness,
                        target: this
                    }));
                } else l !== null && e.gripSpace && (r = t.getPose(e.gripSpace, n), r !== null && (l.matrix.fromArray(r.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(r.linearVelocity)) : l.hasLinearVelocity = !1, r.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(r.angularVelocity)) : l.hasAngularVelocity = !1));
                o !== null && (s = t.getPose(e.targetRaySpace, n), s === null && r !== null && (s = r), s !== null && (o.matrix.fromArray(s.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.matrixWorldNeedsUpdate = !0, s.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(s.linearVelocity)) : o.hasLinearVelocity = !1, s.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(s.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent(qx)));
            }
            return o !== null && (o.visible = s !== null), l !== null && (l.visible = r !== null), h !== null && (h.visible = a !== null), this;
        }
        _getHandJoint(e, t) {
            if (e.joints[t.jointName] === void 0) {
                const n = new $i;
                n.matrixAutoUpdate = !1, n.visible = !1, e.joints[t.jointName] = n, e.add(n);
            }
            return e.joints[t.jointName];
        }
    }
    class $x extends yt {
        constructor(){
            super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new Hn, this.environmentIntensity = 1, this.environmentRotation = new Hn, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                detail: this
            }));
        }
        copy(e, t) {
            return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity), t.object.environmentRotation = this.environmentRotation.toArray(), t;
        }
    }
    class Kx {
        constructor(e, t){
            this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = Ac, this.updateRanges = [], this.version = 0, this.uuid = In();
        }
        onUploadCallback() {}
        set needsUpdate(e) {
            e === !0 && this.version++;
        }
        setUsage(e) {
            return this.usage = e, this;
        }
        addUpdateRange(e, t) {
            this.updateRanges.push({
                start: e,
                count: t
            });
        }
        clearUpdateRanges() {
            this.updateRanges.length = 0;
        }
        copy(e) {
            return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
        }
        copyAt(e, t, n) {
            e *= this.stride, n *= t.stride;
            for(let s = 0, r = this.stride; s < r; s++)this.array[e + s] = t.array[n + s];
            return this;
        }
        set(e, t = 0) {
            return this.array.set(e, t), this;
        }
        clone(e) {
            e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = In()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
            const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), n = new this.constructor(t, this.stride);
            return n.setUsage(this.usage), n;
        }
        onUpload(e) {
            return this.onUploadCallback = e, this;
        }
        toJSON(e) {
            return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = In()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
                uuid: this.uuid,
                buffer: this.array.buffer._uuid,
                type: this.array.constructor.name,
                stride: this.stride
            };
        }
    }
    const Xt = new k;
    class mh {
        constructor(e, t, n, s = !1){
            this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = s;
        }
        get count() {
            return this.data.count;
        }
        get array() {
            return this.data.array;
        }
        set needsUpdate(e) {
            this.data.needsUpdate = e;
        }
        applyMatrix4(e) {
            for(let t = 0, n = this.data.count; t < n; t++)Xt.fromBufferAttribute(this, t), Xt.applyMatrix4(e), this.setXYZ(t, Xt.x, Xt.y, Xt.z);
            return this;
        }
        applyNormalMatrix(e) {
            for(let t = 0, n = this.count; t < n; t++)Xt.fromBufferAttribute(this, t), Xt.applyNormalMatrix(e), this.setXYZ(t, Xt.x, Xt.y, Xt.z);
            return this;
        }
        transformDirection(e) {
            for(let t = 0, n = this.count; t < n; t++)Xt.fromBufferAttribute(this, t), Xt.transformDirection(e), this.setXYZ(t, Xt.x, Xt.y, Xt.z);
            return this;
        }
        getComponent(e, t) {
            let n = this.array[e * this.data.stride + this.offset + t];
            return this.normalized && (n = wn(n, this.array)), n;
        }
        setComponent(e, t, n) {
            return this.normalized && (n = ht(n, this.array)), this.data.array[e * this.data.stride + this.offset + t] = n, this;
        }
        setX(e, t) {
            return this.normalized && (t = ht(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this;
        }
        setY(e, t) {
            return this.normalized && (t = ht(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this;
        }
        setZ(e, t) {
            return this.normalized && (t = ht(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this;
        }
        setW(e, t) {
            return this.normalized && (t = ht(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this;
        }
        getX(e) {
            let t = this.data.array[e * this.data.stride + this.offset];
            return this.normalized && (t = wn(t, this.array)), t;
        }
        getY(e) {
            let t = this.data.array[e * this.data.stride + this.offset + 1];
            return this.normalized && (t = wn(t, this.array)), t;
        }
        getZ(e) {
            let t = this.data.array[e * this.data.stride + this.offset + 2];
            return this.normalized && (t = wn(t, this.array)), t;
        }
        getW(e) {
            let t = this.data.array[e * this.data.stride + this.offset + 3];
            return this.normalized && (t = wn(t, this.array)), t;
        }
        setXY(e, t, n) {
            return e = e * this.data.stride + this.offset, this.normalized && (t = ht(t, this.array), n = ht(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this;
        }
        setXYZ(e, t, n, s) {
            return e = e * this.data.stride + this.offset, this.normalized && (t = ht(t, this.array), n = ht(n, this.array), s = ht(s, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = s, this;
        }
        setXYZW(e, t, n, s, r) {
            return e = e * this.data.stride + this.offset, this.normalized && (t = ht(t, this.array), n = ht(n, this.array), s = ht(s, this.array), r = ht(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = s, this.data.array[e + 3] = r, this;
        }
        clone(e) {
            if (e === void 0) {
                console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
                const t = [];
                for(let n = 0; n < this.count; n++){
                    const s = n * this.data.stride + this.offset;
                    for(let r = 0; r < this.itemSize; r++)t.push(this.data.array[s + r]);
                }
                return new Kt(new this.array.constructor(t), this.itemSize, this.normalized);
            } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new mh(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
        }
        toJSON(e) {
            if (e === void 0) {
                console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
                const t = [];
                for(let n = 0; n < this.count; n++){
                    const s = n * this.data.stride + this.offset;
                    for(let r = 0; r < this.itemSize; r++)t.push(this.data.array[s + r]);
                }
                return {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: t,
                    normalized: this.normalized
                };
            } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            };
        }
    }
    const Uu = new k, Fu = new rt, Nu = new rt, Zx = new k, Ou = new He, ma = new k, zo = new Vn, ku = new He, Vo = new uo;
    class Jx extends Nt {
        constructor(e, t){
            super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = pu, this.bindMatrix = new He, this.bindMatrixInverse = new He, this.boundingBox = null, this.boundingSphere = null;
        }
        computeBoundingBox() {
            const e = this.geometry;
            this.boundingBox === null && (this.boundingBox = new Ln), this.boundingBox.makeEmpty();
            const t = e.getAttribute("position");
            for(let n = 0; n < t.count; n++)this.getVertexPosition(n, ma), this.boundingBox.expandByPoint(ma);
        }
        computeBoundingSphere() {
            const e = this.geometry;
            this.boundingSphere === null && (this.boundingSphere = new Vn), this.boundingSphere.makeEmpty();
            const t = e.getAttribute("position");
            for(let n = 0; n < t.count; n++)this.getVertexPosition(n, ma), this.boundingSphere.expandByPoint(ma);
        }
        copy(e, t) {
            return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
        }
        raycast(e, t) {
            const n = this.material, s = this.matrixWorld;
            n !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), zo.copy(this.boundingSphere), zo.applyMatrix4(s), e.ray.intersectsSphere(zo) !== !1 && (ku.copy(s).invert(), Vo.copy(e.ray).applyMatrix4(ku), !(this.boundingBox !== null && Vo.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, Vo)));
        }
        getVertexPosition(e, t) {
            return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
        }
        bind(e, t) {
            this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
        }
        pose() {
            this.skeleton.pose();
        }
        normalizeSkinWeights() {
            const e = new rt, t = this.geometry.attributes.skinWeight;
            for(let n = 0, s = t.count; n < s; n++){
                e.fromBufferAttribute(t, n);
                const r = 1 / e.manhattanLength();
                r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w);
            }
        }
        updateMatrixWorld(e) {
            super.updateMatrixWorld(e), this.bindMode === pu ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === Vg ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
        }
        applyBoneTransform(e, t) {
            const n = this.skeleton, s = this.geometry;
            Fu.fromBufferAttribute(s.attributes.skinIndex, e), Nu.fromBufferAttribute(s.attributes.skinWeight, e), Uu.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
            for(let r = 0; r < 4; r++){
                const a = Nu.getComponent(r);
                if (a !== 0) {
                    const o = Fu.getComponent(r);
                    Ou.multiplyMatrices(n.bones[o].matrixWorld, n.boneInverses[o]), t.addScaledVector(Zx.copy(Uu).applyMatrix4(Ou), a);
                }
            }
            return t.applyMatrix4(this.bindMatrixInverse);
        }
    }
    class Mp extends yt {
        constructor(){
            super(), this.isBone = !0, this.type = "Bone";
        }
    }
    class Ap extends nn {
        constructor(e = null, t = 1, n = 1, s, r, a, o, l, h = $t, d = $t, c, u){
            super(null, a, o, l, h, d, s, r, c, u), this.isDataTexture = !0, this.image = {
                data: e,
                width: t,
                height: n
            }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
        }
    }
    const Gu = new He, Qx = new He;
    class _h {
        constructor(e = [], t = []){
            this.uuid = In(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.init();
        }
        init() {
            const e = this.bones, t = this.boneInverses;
            if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0) this.calculateInverses();
            else if (e.length !== t.length) {
                console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
                for(let n = 0, s = this.bones.length; n < s; n++)this.boneInverses.push(new He);
            }
        }
        calculateInverses() {
            this.boneInverses.length = 0;
            for(let e = 0, t = this.bones.length; e < t; e++){
                const n = new He;
                this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(n);
            }
        }
        pose() {
            for(let e = 0, t = this.bones.length; e < t; e++){
                const n = this.bones[e];
                n && n.matrixWorld.copy(this.boneInverses[e]).invert();
            }
            for(let e = 0, t = this.bones.length; e < t; e++){
                const n = this.bones[e];
                n && (n.parent && n.parent.isBone ? (n.matrix.copy(n.parent.matrixWorld).invert(), n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld), n.matrix.decompose(n.position, n.quaternion, n.scale));
            }
        }
        update() {
            const e = this.bones, t = this.boneInverses, n = this.boneMatrices, s = this.boneTexture;
            for(let r = 0, a = e.length; r < a; r++){
                const o = e[r] ? e[r].matrixWorld : Qx;
                Gu.multiplyMatrices(o, t[r]), Gu.toArray(n, r * 16);
            }
            s !== null && (s.needsUpdate = !0);
        }
        clone() {
            return new _h(this.bones, this.boneInverses);
        }
        computeBoneTexture() {
            let e = Math.sqrt(this.bones.length * 4);
            e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
            const t = new Float32Array(e * e * 4);
            t.set(this.boneMatrices);
            const n = new Ap(t, e, e, xn, Pn);
            return n.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = n, this;
        }
        getBoneByName(e) {
            for(let t = 0, n = this.bones.length; t < n; t++){
                const s = this.bones[t];
                if (s.name === e) return s;
            }
        }
        dispose() {
            this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
        }
        fromJSON(e, t) {
            this.uuid = e.uuid;
            for(let n = 0, s = e.bones.length; n < s; n++){
                const r = e.bones[n];
                let a = t[r];
                a === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", r), a = new Mp), this.bones.push(a), this.boneInverses.push(new He().fromArray(e.boneInverses[n]));
            }
            return this.init(), this;
        }
        toJSON() {
            const e = {
                metadata: {
                    version: 4.6,
                    type: "Skeleton",
                    generator: "Skeleton.toJSON"
                },
                bones: [],
                boneInverses: []
            };
            e.uuid = this.uuid;
            const t = this.bones, n = this.boneInverses;
            for(let s = 0, r = t.length; s < r; s++){
                const a = t[s];
                e.bones.push(a.uuid);
                const o = n[s];
                e.boneInverses.push(o.toArray());
            }
            return e;
        }
    }
    class Ec extends Kt {
        constructor(e, t, n, s = 1){
            super(e, t, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = s;
        }
        copy(e) {
            return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
        }
        toJSON() {
            const e = super.toJSON();
            return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
        }
    }
    const Ss = new He, Hu = new He, _a = [], zu = new Ln, e0 = new He, ur = new Nt, dr = new Vn;
    class t0 extends Nt {
        constructor(e, t, n){
            super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new Ec(new Float32Array(n * 16), 16), this.instanceColor = null, this.morphTexture = null, this.count = n, this.boundingBox = null, this.boundingSphere = null;
            for(let s = 0; s < n; s++)this.setMatrixAt(s, e0);
        }
        computeBoundingBox() {
            const e = this.geometry, t = this.count;
            this.boundingBox === null && (this.boundingBox = new Ln), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
            for(let n = 0; n < t; n++)this.getMatrixAt(n, Ss), zu.copy(e.boundingBox).applyMatrix4(Ss), this.boundingBox.union(zu);
        }
        computeBoundingSphere() {
            const e = this.geometry, t = this.count;
            this.boundingSphere === null && (this.boundingSphere = new Vn), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
            for(let n = 0; n < t; n++)this.getMatrixAt(n, Ss), dr.copy(e.boundingSphere).applyMatrix4(Ss), this.boundingSphere.union(dr);
        }
        copy(e, t) {
            return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
        }
        getColorAt(e, t) {
            t.fromArray(this.instanceColor.array, e * 3);
        }
        getMatrixAt(e, t) {
            t.fromArray(this.instanceMatrix.array, e * 16);
        }
        getMorphAt(e, t) {
            const n = t.morphTargetInfluences, s = this.morphTexture.source.data.data, r = n.length + 1, a = e * r + 1;
            for(let o = 0; o < n.length; o++)n[o] = s[a + o];
        }
        raycast(e, t) {
            const n = this.matrixWorld, s = this.count;
            if (ur.geometry = this.geometry, ur.material = this.material, ur.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), dr.copy(this.boundingSphere), dr.applyMatrix4(n), e.ray.intersectsSphere(dr) !== !1)) for(let r = 0; r < s; r++){
                this.getMatrixAt(r, Ss), Hu.multiplyMatrices(n, Ss), ur.matrixWorld = Hu, ur.raycast(e, _a);
                for(let a = 0, o = _a.length; a < o; a++){
                    const l = _a[a];
                    l.instanceId = r, l.object = this, t.push(l);
                }
                _a.length = 0;
            }
        }
        setColorAt(e, t) {
            this.instanceColor === null && (this.instanceColor = new Ec(new Float32Array(this.instanceMatrix.count * 3).fill(1), 3)), t.toArray(this.instanceColor.array, e * 3);
        }
        setMatrixAt(e, t) {
            t.toArray(this.instanceMatrix.array, e * 16);
        }
        setMorphAt(e, t) {
            const n = t.morphTargetInfluences, s = n.length + 1;
            this.morphTexture === null && (this.morphTexture = new Ap(new Float32Array(s * this.count), s, this.count, lh, Pn));
            const r = this.morphTexture.source.data.data;
            let a = 0;
            for(let h = 0; h < n.length; h++)a += n[h];
            const o = this.geometry.morphTargetsRelative ? 1 : 1 - a, l = s * e;
            r[l] = o, r.set(n, l + 1);
        }
        updateMorphTargets() {}
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            }), this.morphTexture !== null && (this.morphTexture.dispose(), this.morphTexture = null);
        }
    }
    const Wo = new k, n0 = new k, i0 = new Ge;
    class Gi {
        constructor(e = new k(1, 0, 0), t = 0){
            this.isPlane = !0, this.normal = e, this.constant = t;
        }
        set(e, t) {
            return this.normal.copy(e), this.constant = t, this;
        }
        setComponents(e, t, n, s) {
            return this.normal.set(e, t, n), this.constant = s, this;
        }
        setFromNormalAndCoplanarPoint(e, t) {
            return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
        }
        setFromCoplanarPoints(e, t, n) {
            const s = Wo.subVectors(n, t).cross(n0.subVectors(e, t)).normalize();
            return this.setFromNormalAndCoplanarPoint(s, e), this;
        }
        copy(e) {
            return this.normal.copy(e.normal), this.constant = e.constant, this;
        }
        normalize() {
            const e = 1 / this.normal.length();
            return this.normal.multiplyScalar(e), this.constant *= e, this;
        }
        negate() {
            return this.constant *= -1, this.normal.negate(), this;
        }
        distanceToPoint(e) {
            return this.normal.dot(e) + this.constant;
        }
        distanceToSphere(e) {
            return this.distanceToPoint(e.center) - e.radius;
        }
        projectPoint(e, t) {
            return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
        }
        intersectLine(e, t) {
            const n = e.delta(Wo), s = this.normal.dot(n);
            if (s === 0) return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
            const r = -(e.start.dot(this.normal) + this.constant) / s;
            return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(n, r);
        }
        intersectsLine(e) {
            const t = this.distanceToPoint(e.start), n = this.distanceToPoint(e.end);
            return t < 0 && n > 0 || n < 0 && t > 0;
        }
        intersectsBox(e) {
            return e.intersectsPlane(this);
        }
        intersectsSphere(e) {
            return e.intersectsPlane(this);
        }
        coplanarPoint(e) {
            return e.copy(this.normal).multiplyScalar(-this.constant);
        }
        applyMatrix4(e, t) {
            const n = t || i0.getNormalMatrix(e), s = this.coplanarPoint(Wo).applyMatrix4(e), r = this.normal.applyMatrix3(n).normalize();
            return this.constant = -s.dot(r), this;
        }
        translate(e) {
            return this.constant -= e.dot(this.normal), this;
        }
        equals(e) {
            return e.normal.equals(this.normal) && e.constant === this.constant;
        }
        clone() {
            return new this.constructor().copy(this);
        }
    }
    const Ui = new Vn, ga = new k;
    class gh {
        constructor(e = new Gi, t = new Gi, n = new Gi, s = new Gi, r = new Gi, a = new Gi){
            this.planes = [
                e,
                t,
                n,
                s,
                r,
                a
            ];
        }
        set(e, t, n, s, r, a) {
            const o = this.planes;
            return o[0].copy(e), o[1].copy(t), o[2].copy(n), o[3].copy(s), o[4].copy(r), o[5].copy(a), this;
        }
        copy(e) {
            const t = this.planes;
            for(let n = 0; n < 6; n++)t[n].copy(e.planes[n]);
            return this;
        }
        setFromProjectionMatrix(e, t = ii) {
            const n = this.planes, s = e.elements, r = s[0], a = s[1], o = s[2], l = s[3], h = s[4], d = s[5], c = s[6], u = s[7], f = s[8], _ = s[9], g = s[10], m = s[11], p = s[12], x = s[13], v = s[14], y = s[15];
            if (n[0].setComponents(l - r, u - h, m - f, y - p).normalize(), n[1].setComponents(l + r, u + h, m + f, y + p).normalize(), n[2].setComponents(l + a, u + d, m + _, y + x).normalize(), n[3].setComponents(l - a, u - d, m - _, y - x).normalize(), n[4].setComponents(l - o, u - c, m - g, y - v).normalize(), t === ii) n[5].setComponents(l + o, u + c, m + g, y + v).normalize();
            else if (t === to) n[5].setComponents(o, c, g, v).normalize();
            else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
            return this;
        }
        intersectsObject(e) {
            if (e.boundingSphere !== void 0) e.boundingSphere === null && e.computeBoundingSphere(), Ui.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
            else {
                const t = e.geometry;
                t.boundingSphere === null && t.computeBoundingSphere(), Ui.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
            }
            return this.intersectsSphere(Ui);
        }
        intersectsSprite(e) {
            return Ui.center.set(0, 0, 0), Ui.radius = .7071067811865476, Ui.applyMatrix4(e.matrixWorld), this.intersectsSphere(Ui);
        }
        intersectsSphere(e) {
            const t = this.planes, n = e.center, s = -e.radius;
            for(let r = 0; r < 6; r++)if (t[r].distanceToPoint(n) < s) return !1;
            return !0;
        }
        intersectsBox(e) {
            const t = this.planes;
            for(let n = 0; n < 6; n++){
                const s = t[n];
                if (ga.x = s.normal.x > 0 ? e.max.x : e.min.x, ga.y = s.normal.y > 0 ? e.max.y : e.min.y, ga.z = s.normal.z > 0 ? e.max.z : e.min.z, s.distanceToPoint(ga) < 0) return !1;
            }
            return !0;
        }
        containsPoint(e) {
            const t = this.planes;
            for(let n = 0; n < 6; n++)if (t[n].distanceToPoint(e) < 0) return !1;
            return !0;
        }
        clone() {
            return new this.constructor().copy(this);
        }
    }
    class Ep extends Gn {
        constructor(e){
            super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new Oe(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
        }
        copy(e) {
            return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
        }
    }
    const no = new k, io = new k, Vu = new He, fr = new uo, xa = new Vn, Xo = new k, Wu = new k;
    class xh extends yt {
        constructor(e = new Wn, t = new Ep){
            super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets();
        }
        copy(e, t) {
            return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
        }
        computeLineDistances() {
            const e = this.geometry;
            if (e.index === null) {
                const t = e.attributes.position, n = [
                    0
                ];
                for(let s = 1, r = t.count; s < r; s++)no.fromBufferAttribute(t, s - 1), io.fromBufferAttribute(t, s), n[s] = n[s - 1], n[s] += no.distanceTo(io);
                e.setAttribute("lineDistance", new ri(n, 1));
            } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            return this;
        }
        raycast(e, t) {
            const n = this.geometry, s = this.matrixWorld, r = e.params.Line.threshold, a = n.drawRange;
            if (n.boundingSphere === null && n.computeBoundingSphere(), xa.copy(n.boundingSphere), xa.applyMatrix4(s), xa.radius += r, e.ray.intersectsSphere(xa) === !1) return;
            Vu.copy(s).invert(), fr.copy(e.ray).applyMatrix4(Vu);
            const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = o * o, h = this.isLineSegments ? 2 : 1, d = n.index, u = n.attributes.position;
            if (d !== null) {
                const f = Math.max(0, a.start), _ = Math.min(d.count, a.start + a.count);
                for(let g = f, m = _ - 1; g < m; g += h){
                    const p = d.getX(g), x = d.getX(g + 1), v = va(this, e, fr, l, p, x, g);
                    v && t.push(v);
                }
                if (this.isLineLoop) {
                    const g = d.getX(_ - 1), m = d.getX(f), p = va(this, e, fr, l, g, m, _ - 1);
                    p && t.push(p);
                }
            } else {
                const f = Math.max(0, a.start), _ = Math.min(u.count, a.start + a.count);
                for(let g = f, m = _ - 1; g < m; g += h){
                    const p = va(this, e, fr, l, g, g + 1, g);
                    p && t.push(p);
                }
                if (this.isLineLoop) {
                    const g = va(this, e, fr, l, _ - 1, f, _ - 1);
                    g && t.push(g);
                }
            }
        }
        updateMorphTargets() {
            const t = this.geometry.morphAttributes, n = Object.keys(t);
            if (n.length > 0) {
                const s = t[n[0]];
                if (s !== void 0) {
                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                    for(let r = 0, a = s.length; r < a; r++){
                        const o = s[r].name || String(r);
                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = r;
                    }
                }
            }
        }
    }
    function va(i, e, t, n, s, r, a) {
        const o = i.geometry.attributes.position;
        if (no.fromBufferAttribute(o, s), io.fromBufferAttribute(o, r), t.distanceSqToSegment(no, io, Xo, Wu) > n) return;
        Xo.applyMatrix4(i.matrixWorld);
        const h = e.ray.origin.distanceTo(Xo);
        if (!(h < e.near || h > e.far)) return {
            distance: h,
            point: Wu.clone().applyMatrix4(i.matrixWorld),
            index: a,
            face: null,
            faceIndex: null,
            barycoord: null,
            object: i
        };
    }
    const Xu = new k, Yu = new k;
    class s0 extends xh {
        constructor(e, t){
            super(e, t), this.isLineSegments = !0, this.type = "LineSegments";
        }
        computeLineDistances() {
            const e = this.geometry;
            if (e.index === null) {
                const t = e.attributes.position, n = [];
                for(let s = 0, r = t.count; s < r; s += 2)Xu.fromBufferAttribute(t, s), Yu.fromBufferAttribute(t, s + 1), n[s] = s === 0 ? 0 : n[s - 1], n[s + 1] = n[s] + Xu.distanceTo(Yu);
                e.setAttribute("lineDistance", new ri(n, 1));
            } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            return this;
        }
    }
    class r0 extends xh {
        constructor(e, t){
            super(e, t), this.isLineLoop = !0, this.type = "LineLoop";
        }
    }
    class wp extends Gn {
        constructor(e){
            super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new Oe(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e);
        }
        copy(e) {
            return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
        }
    }
    const ju = new He, wc = new uo, ya = new Vn, ba = new k;
    class a0 extends yt {
        constructor(e = new Wn, t = new wp){
            super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets();
        }
        copy(e, t) {
            return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
        }
        raycast(e, t) {
            const n = this.geometry, s = this.matrixWorld, r = e.params.Points.threshold, a = n.drawRange;
            if (n.boundingSphere === null && n.computeBoundingSphere(), ya.copy(n.boundingSphere), ya.applyMatrix4(s), ya.radius += r, e.ray.intersectsSphere(ya) === !1) return;
            ju.copy(s).invert(), wc.copy(e.ray).applyMatrix4(ju);
            const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = o * o, h = n.index, c = n.attributes.position;
            if (h !== null) {
                const u = Math.max(0, a.start), f = Math.min(h.count, a.start + a.count);
                for(let _ = u, g = f; _ < g; _++){
                    const m = h.getX(_);
                    ba.fromBufferAttribute(c, m), qu(ba, m, l, s, e, t, this);
                }
            } else {
                const u = Math.max(0, a.start), f = Math.min(c.count, a.start + a.count);
                for(let _ = u, g = f; _ < g; _++)ba.fromBufferAttribute(c, _), qu(ba, _, l, s, e, t, this);
            }
        }
        updateMorphTargets() {
            const t = this.geometry.morphAttributes, n = Object.keys(t);
            if (n.length > 0) {
                const s = t[n[0]];
                if (s !== void 0) {
                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                    for(let r = 0, a = s.length; r < a; r++){
                        const o = s[r].name || String(r);
                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = r;
                    }
                }
            }
        }
    }
    function qu(i, e, t, n, s, r, a) {
        const o = wc.distanceSqToPoint(i);
        if (o < t) {
            const l = new k;
            wc.closestPointToPoint(i, l), l.applyMatrix4(n);
            const h = s.ray.origin.distanceTo(l);
            if (h < s.near || h > s.far) return;
            r.push({
                distance: h,
                distanceToRay: Math.sqrt(o),
                point: l,
                index: e,
                face: null,
                faceIndex: null,
                barycoord: null,
                object: a
            });
        }
    }
    class Rp extends nn {
        constructor(e, t, n = Ji, s, r, a, o = $t, l = $t, h, d = Gr){
            if (d !== Gr && d !== Hr) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
            super(null, s, r, a, o, l, d, n, h), this.isDepthTexture = !0, this.image = {
                width: e,
                height: t
            }, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
        }
        copy(e) {
            return super.copy(e), this.source = new ph(Object.assign({}, e.image)), this.compareFunction = e.compareFunction, this;
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t;
        }
    }
    class Zs extends Wn {
        constructor(e = 1, t = 1, n = 1, s = 1){
            super(), this.type = "PlaneGeometry", this.parameters = {
                width: e,
                height: t,
                widthSegments: n,
                heightSegments: s
            };
            const r = e / 2, a = t / 2, o = Math.floor(n), l = Math.floor(s), h = o + 1, d = l + 1, c = e / o, u = t / l, f = [], _ = [], g = [], m = [];
            for(let p = 0; p < d; p++){
                const x = p * u - a;
                for(let v = 0; v < h; v++){
                    const y = v * c - r;
                    _.push(y, -x, 0), g.push(0, 0, 1), m.push(v / o), m.push(1 - p / l);
                }
            }
            for(let p = 0; p < l; p++)for(let x = 0; x < o; x++){
                const v = x + h * p, y = x + h * (p + 1), P = x + 1 + h * (p + 1), w = x + 1 + h * p;
                f.push(v, y, w), f.push(y, P, w);
            }
            this.setIndex(f), this.setAttribute("position", new ri(_, 3)), this.setAttribute("normal", new ri(g, 3)), this.setAttribute("uv", new ri(m, 2));
        }
        copy(e) {
            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
        }
        static fromJSON(e) {
            return new Zs(e.width, e.height, e.widthSegments, e.heightSegments);
        }
    }
    class Vs extends Gn {
        constructor(e){
            super(), this.isMeshStandardMaterial = !0, this.type = "MeshStandardMaterial", this.defines = {
                STANDARD: ""
            }, this.color = new Oe(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Oe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = fp, this.normalScale = new Ze(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Hn, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
        }
        copy(e) {
            return super.copy(e), this.defines = {
                STANDARD: ""
            }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
        }
    }
    class Xn extends Vs {
        constructor(e){
            super(), this.isMeshPhysicalMaterial = !0, this.defines = {
                STANDARD: "",
                PHYSICAL: ""
            }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Ze(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
                get: function() {
                    return Ye(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
                },
                set: function(t) {
                    this.ior = (1 + .4 * t) / (1 - .4 * t);
                }
            }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [
                100,
                400
            ], this.iridescenceThicknessMap = null, this.sheenColor = new Oe(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Oe(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Oe(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e);
        }
        get anisotropy() {
            return this._anisotropy;
        }
        set anisotropy(e) {
            this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e;
        }
        get clearcoat() {
            return this._clearcoat;
        }
        set clearcoat(e) {
            this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
        }
        get iridescence() {
            return this._iridescence;
        }
        set iridescence(e) {
            this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
        }
        get dispersion() {
            return this._dispersion;
        }
        set dispersion(e) {
            this._dispersion > 0 != e > 0 && this.version++, this._dispersion = e;
        }
        get sheen() {
            return this._sheen;
        }
        set sheen(e) {
            this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
        }
        get transmission() {
            return this._transmission;
        }
        set transmission(e) {
            this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
        }
        copy(e) {
            return super.copy(e), this.defines = {
                STANDARD: "",
                PHYSICAL: ""
            }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.dispersion = e.dispersion, this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [
                ...e.iridescenceThicknessRange
            ], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
        }
    }
    class o0 extends Gn {
        constructor(e){
            super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = qg, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
        }
        copy(e) {
            return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
        }
    }
    class l0 extends Gn {
        constructor(e){
            super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
        }
        copy(e) {
            return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
        }
    }
    function Sa(i, e) {
        return !i || i.constructor === e ? i : typeof e.BYTES_PER_ELEMENT == "number" ? new e(i) : Array.prototype.slice.call(i);
    }
    function c0(i) {
        return ArrayBuffer.isView(i) && !(i instanceof DataView);
    }
    function h0(i) {
        function e(s, r) {
            return i[s] - i[r];
        }
        const t = i.length, n = new Array(t);
        for(let s = 0; s !== t; ++s)n[s] = s;
        return n.sort(e), n;
    }
    function $u(i, e, t) {
        const n = i.length, s = new i.constructor(n);
        for(let r = 0, a = 0; a !== n; ++r){
            const o = t[r] * e;
            for(let l = 0; l !== e; ++l)s[a++] = i[o + l];
        }
        return s;
    }
    function Cp(i, e, t, n) {
        let s = 1, r = i[0];
        for(; r !== void 0 && r[n] === void 0;)r = i[s++];
        if (r === void 0) return;
        let a = r[n];
        if (a !== void 0) if (Array.isArray(a)) do a = r[n], a !== void 0 && (e.push(r.time), t.push(...a)), r = i[s++];
        while (r !== void 0);
        else if (a.toArray !== void 0) do a = r[n], a !== void 0 && (e.push(r.time), a.toArray(t, t.length)), r = i[s++];
        while (r !== void 0);
        else do a = r[n], a !== void 0 && (e.push(r.time), t.push(a)), r = i[s++];
        while (r !== void 0);
    }
    class qr {
        constructor(e, t, n, s){
            this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = s !== void 0 ? s : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {};
        }
        evaluate(e) {
            const t = this.parameterPositions;
            let n = this._cachedIndex, s = t[n], r = t[n - 1];
            e: {
                t: {
                    let a;
                    n: {
                        i: if (!(e < s)) {
                            for(let o = n + 2;;){
                                if (s === void 0) {
                                    if (e < r) break i;
                                    return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
                                }
                                if (n === o) break;
                                if (r = s, s = t[++n], e < s) break t;
                            }
                            a = t.length;
                            break n;
                        }
                        if (!(e >= r)) {
                            const o = t[1];
                            e < o && (n = 2, r = o);
                            for(let l = n - 2;;){
                                if (r === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
                                if (n === l) break;
                                if (s = r, r = t[--n - 1], e >= r) break t;
                            }
                            a = n, n = 0;
                            break n;
                        }
                        break e;
                    }
                    for(; n < a;){
                        const o = n + a >>> 1;
                        e < t[o] ? a = o : n = o + 1;
                    }
                    if (s = t[n], r = t[n - 1], r === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
                    if (s === void 0) return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
                }
                this._cachedIndex = n, this.intervalChanged_(n, r, s);
            }
            return this.interpolate_(n, r, e, s);
        }
        getSettings_() {
            return this.settings || this.DefaultSettings_;
        }
        copySampleValue_(e) {
            const t = this.resultBuffer, n = this.sampleValues, s = this.valueSize, r = e * s;
            for(let a = 0; a !== s; ++a)t[a] = n[r + a];
            return t;
        }
        interpolate_() {
            throw new Error("call to abstract method");
        }
        intervalChanged_() {}
    }
    class u0 extends qr {
        constructor(e, t, n, s){
            super(e, t, n, s), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
                endingStart: ws,
                endingEnd: ws
            };
        }
        intervalChanged_(e, t, n) {
            const s = this.parameterPositions;
            let r = e - 2, a = e + 1, o = s[r], l = s[a];
            if (o === void 0) switch(this.getSettings_().endingStart){
                case Rs:
                    r = e, o = 2 * t - n;
                    break;
                case Qa:
                    r = s.length - 2, o = t + s[r] - s[r + 1];
                    break;
                default:
                    r = e, o = n;
            }
            if (l === void 0) switch(this.getSettings_().endingEnd){
                case Rs:
                    a = e, l = 2 * n - t;
                    break;
                case Qa:
                    a = 1, l = n + s[1] - s[0];
                    break;
                default:
                    a = e - 1, l = t;
            }
            const h = (n - t) * .5, d = this.valueSize;
            this._weightPrev = h / (t - o), this._weightNext = h / (l - n), this._offsetPrev = r * d, this._offsetNext = a * d;
        }
        interpolate_(e, t, n, s) {
            const r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = e * o, h = l - o, d = this._offsetPrev, c = this._offsetNext, u = this._weightPrev, f = this._weightNext, _ = (n - t) / (s - t), g = _ * _, m = g * _, p = -u * m + 2 * u * g - u * _, x = (1 + u) * m + (-1.5 - 2 * u) * g + (-.5 + u) * _ + 1, v = (-1 - f) * m + (1.5 + f) * g + .5 * _, y = f * m - f * g;
            for(let P = 0; P !== o; ++P)r[P] = p * a[d + P] + x * a[h + P] + v * a[l + P] + y * a[c + P];
            return r;
        }
    }
    class Pp extends qr {
        constructor(e, t, n, s){
            super(e, t, n, s);
        }
        interpolate_(e, t, n, s) {
            const r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = e * o, h = l - o, d = (n - t) / (s - t), c = 1 - d;
            for(let u = 0; u !== o; ++u)r[u] = a[h + u] * c + a[l + u] * d;
            return r;
        }
    }
    class d0 extends qr {
        constructor(e, t, n, s){
            super(e, t, n, s);
        }
        interpolate_(e) {
            return this.copySampleValue_(e - 1);
        }
    }
    class Bn {
        constructor(e, t, n, s){
            if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
            if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
            this.name = e, this.times = Sa(t, this.TimeBufferType), this.values = Sa(n, this.ValueBufferType), this.setInterpolation(s || this.DefaultInterpolation);
        }
        static toJSON(e) {
            const t = e.constructor;
            let n;
            if (t.toJSON !== this.toJSON) n = t.toJSON(e);
            else {
                n = {
                    name: e.name,
                    times: Sa(e.times, Array),
                    values: Sa(e.values, Array)
                };
                const s = e.getInterpolation();
                s !== e.DefaultInterpolation && (n.interpolation = s);
            }
            return n.type = e.ValueTypeName, n;
        }
        InterpolantFactoryMethodDiscrete(e) {
            return new d0(this.times, this.values, this.getValueSize(), e);
        }
        InterpolantFactoryMethodLinear(e) {
            return new Pp(this.times, this.values, this.getValueSize(), e);
        }
        InterpolantFactoryMethodSmooth(e) {
            return new u0(this.times, this.values, this.getValueSize(), e);
        }
        setInterpolation(e) {
            let t;
            switch(e){
                case zr:
                    t = this.InterpolantFactoryMethodDiscrete;
                    break;
                case Vr:
                    t = this.InterpolantFactoryMethodLinear;
                    break;
                case bo:
                    t = this.InterpolantFactoryMethodSmooth;
                    break;
            }
            if (t === void 0) {
                const n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                if (this.createInterpolant === void 0) if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
                else throw new Error(n);
                return console.warn("THREE.KeyframeTrack:", n), this;
            }
            return this.createInterpolant = t, this;
        }
        getInterpolation() {
            switch(this.createInterpolant){
                case this.InterpolantFactoryMethodDiscrete:
                    return zr;
                case this.InterpolantFactoryMethodLinear:
                    return Vr;
                case this.InterpolantFactoryMethodSmooth:
                    return bo;
            }
        }
        getValueSize() {
            return this.values.length / this.times.length;
        }
        shift(e) {
            if (e !== 0) {
                const t = this.times;
                for(let n = 0, s = t.length; n !== s; ++n)t[n] += e;
            }
            return this;
        }
        scale(e) {
            if (e !== 1) {
                const t = this.times;
                for(let n = 0, s = t.length; n !== s; ++n)t[n] *= e;
            }
            return this;
        }
        trim(e, t) {
            const n = this.times, s = n.length;
            let r = 0, a = s - 1;
            for(; r !== s && n[r] < e;)++r;
            for(; a !== -1 && n[a] > t;)--a;
            if (++a, r !== 0 || a !== s) {
                r >= a && (a = Math.max(a, 1), r = a - 1);
                const o = this.getValueSize();
                this.times = n.slice(r, a), this.values = this.values.slice(r * o, a * o);
            }
            return this;
        }
        validate() {
            let e = !0;
            const t = this.getValueSize();
            t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
            const n = this.times, s = this.values, r = n.length;
            r === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
            let a = null;
            for(let o = 0; o !== r; o++){
                const l = n[o];
                if (typeof l == "number" && isNaN(l)) {
                    console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, l), e = !1;
                    break;
                }
                if (a !== null && a > l) {
                    console.error("THREE.KeyframeTrack: Out of order keys.", this, o, l, a), e = !1;
                    break;
                }
                a = l;
            }
            if (s !== void 0 && c0(s)) for(let o = 0, l = s.length; o !== l; ++o){
                const h = s[o];
                if (isNaN(h)) {
                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, h), e = !1;
                    break;
                }
            }
            return e;
        }
        optimize() {
            const e = this.times.slice(), t = this.values.slice(), n = this.getValueSize(), s = this.getInterpolation() === bo, r = e.length - 1;
            let a = 1;
            for(let o = 1; o < r; ++o){
                let l = !1;
                const h = e[o], d = e[o + 1];
                if (h !== d && (o !== 1 || h !== e[0])) if (s) l = !0;
                else {
                    const c = o * n, u = c - n, f = c + n;
                    for(let _ = 0; _ !== n; ++_){
                        const g = t[c + _];
                        if (g !== t[u + _] || g !== t[f + _]) {
                            l = !0;
                            break;
                        }
                    }
                }
                if (l) {
                    if (o !== a) {
                        e[a] = e[o];
                        const c = o * n, u = a * n;
                        for(let f = 0; f !== n; ++f)t[u + f] = t[c + f];
                    }
                    ++a;
                }
            }
            if (r > 0) {
                e[a] = e[r];
                for(let o = r * n, l = a * n, h = 0; h !== n; ++h)t[l + h] = t[o + h];
                ++a;
            }
            return a !== e.length ? (this.times = e.slice(0, a), this.values = t.slice(0, a * n)) : (this.times = e, this.values = t), this;
        }
        clone() {
            const e = this.times.slice(), t = this.values.slice(), n = this.constructor, s = new n(this.name, e, t);
            return s.createInterpolant = this.createInterpolant, s;
        }
    }
    Bn.prototype.ValueTypeName = "";
    Bn.prototype.TimeBufferType = Float32Array;
    Bn.prototype.ValueBufferType = Float32Array;
    Bn.prototype.DefaultInterpolation = Vr;
    class Js extends Bn {
        constructor(e, t, n){
            super(e, t, n);
        }
    }
    Js.prototype.ValueTypeName = "bool";
    Js.prototype.ValueBufferType = Array;
    Js.prototype.DefaultInterpolation = zr;
    Js.prototype.InterpolantFactoryMethodLinear = void 0;
    Js.prototype.InterpolantFactoryMethodSmooth = void 0;
    class Ip extends Bn {
        constructor(e, t, n, s){
            super(e, t, n, s);
        }
    }
    Ip.prototype.ValueTypeName = "color";
    class Ws extends Bn {
        constructor(e, t, n, s){
            super(e, t, n, s);
        }
    }
    Ws.prototype.ValueTypeName = "number";
    class f0 extends qr {
        constructor(e, t, n, s){
            super(e, t, n, s);
        }
        interpolate_(e, t, n, s) {
            const r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = (n - t) / (s - t);
            let h = e * o;
            for(let d = h + o; h !== d; h += 4)Dn.slerpFlat(r, 0, a, h - o, a, h, l);
            return r;
        }
    }
    class Xs extends Bn {
        constructor(e, t, n, s){
            super(e, t, n, s);
        }
        InterpolantFactoryMethodLinear(e) {
            return new f0(this.times, this.values, this.getValueSize(), e);
        }
    }
    Xs.prototype.ValueTypeName = "quaternion";
    Xs.prototype.InterpolantFactoryMethodSmooth = void 0;
    class Qs extends Bn {
        constructor(e, t, n){
            super(e, t, n);
        }
    }
    Qs.prototype.ValueTypeName = "string";
    Qs.prototype.ValueBufferType = Array;
    Qs.prototype.DefaultInterpolation = zr;
    Qs.prototype.InterpolantFactoryMethodLinear = void 0;
    Qs.prototype.InterpolantFactoryMethodSmooth = void 0;
    class Ys extends Bn {
        constructor(e, t, n, s){
            super(e, t, n, s);
        }
    }
    Ys.prototype.ValueTypeName = "vector";
    class Rc {
        constructor(e = "", t = -1, n = [], s = dh){
            this.name = e, this.tracks = n, this.duration = t, this.blendMode = s, this.uuid = In(), this.duration < 0 && this.resetDuration();
        }
        static parse(e) {
            const t = [], n = e.tracks, s = 1 / (e.fps || 1);
            for(let a = 0, o = n.length; a !== o; ++a)t.push(m0(n[a]).scale(s));
            const r = new this(e.name, e.duration, t, e.blendMode);
            return r.uuid = e.uuid, r;
        }
        static toJSON(e) {
            const t = [], n = e.tracks, s = {
                name: e.name,
                duration: e.duration,
                tracks: t,
                uuid: e.uuid,
                blendMode: e.blendMode
            };
            for(let r = 0, a = n.length; r !== a; ++r)t.push(Bn.toJSON(n[r]));
            return s;
        }
        static CreateFromMorphTargetSequence(e, t, n, s) {
            const r = t.length, a = [];
            for(let o = 0; o < r; o++){
                let l = [], h = [];
                l.push((o + r - 1) % r, o, (o + 1) % r), h.push(0, 1, 0);
                const d = h0(l);
                l = $u(l, 1, d), h = $u(h, 1, d), !s && l[0] === 0 && (l.push(r), h.push(h[0])), a.push(new Ws(".morphTargetInfluences[" + t[o].name + "]", l, h).scale(1 / n));
            }
            return new this(e, -1, a);
        }
        static findByName(e, t) {
            let n = e;
            if (!Array.isArray(e)) {
                const s = e;
                n = s.geometry && s.geometry.animations || s.animations;
            }
            for(let s = 0; s < n.length; s++)if (n[s].name === t) return n[s];
            return null;
        }
        static CreateClipsFromMorphTargetSequences(e, t, n) {
            const s = {}, r = /^([\w-]*?)([\d]+)$/;
            for(let o = 0, l = e.length; o < l; o++){
                const h = e[o], d = h.name.match(r);
                if (d && d.length > 1) {
                    const c = d[1];
                    let u = s[c];
                    u || (s[c] = u = []), u.push(h);
                }
            }
            const a = [];
            for(const o in s)a.push(this.CreateFromMorphTargetSequence(o, s[o], t, n));
            return a;
        }
        static parseAnimation(e, t) {
            if (console.warn("THREE.AnimationClip: parseAnimation() is deprecated and will be removed with r185"), !e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
            const n = function(c, u, f, _, g) {
                if (f.length !== 0) {
                    const m = [], p = [];
                    Cp(f, m, p, _), m.length !== 0 && g.push(new c(u, m, p));
                }
            }, s = [], r = e.name || "default", a = e.fps || 30, o = e.blendMode;
            let l = e.length || -1;
            const h = e.hierarchy || [];
            for(let c = 0; c < h.length; c++){
                const u = h[c].keys;
                if (!(!u || u.length === 0)) if (u[0].morphTargets) {
                    const f = {};
                    let _;
                    for(_ = 0; _ < u.length; _++)if (u[_].morphTargets) for(let g = 0; g < u[_].morphTargets.length; g++)f[u[_].morphTargets[g]] = -1;
                    for(const g in f){
                        const m = [], p = [];
                        for(let x = 0; x !== u[_].morphTargets.length; ++x){
                            const v = u[_];
                            m.push(v.time), p.push(v.morphTarget === g ? 1 : 0);
                        }
                        s.push(new Ws(".morphTargetInfluence[" + g + "]", m, p));
                    }
                    l = f.length * a;
                } else {
                    const f = ".bones[" + t[c].name + "]";
                    n(Ys, f + ".position", u, "pos", s), n(Xs, f + ".quaternion", u, "rot", s), n(Ys, f + ".scale", u, "scl", s);
                }
            }
            return s.length === 0 ? null : new this(r, l, s, o);
        }
        resetDuration() {
            const e = this.tracks;
            let t = 0;
            for(let n = 0, s = e.length; n !== s; ++n){
                const r = this.tracks[n];
                t = Math.max(t, r.times[r.times.length - 1]);
            }
            return this.duration = t, this;
        }
        trim() {
            for(let e = 0; e < this.tracks.length; e++)this.tracks[e].trim(0, this.duration);
            return this;
        }
        validate() {
            let e = !0;
            for(let t = 0; t < this.tracks.length; t++)e = e && this.tracks[t].validate();
            return e;
        }
        optimize() {
            for(let e = 0; e < this.tracks.length; e++)this.tracks[e].optimize();
            return this;
        }
        clone() {
            const e = [];
            for(let t = 0; t < this.tracks.length; t++)e.push(this.tracks[t].clone());
            return new this.constructor(this.name, this.duration, e, this.blendMode);
        }
        toJSON() {
            return this.constructor.toJSON(this);
        }
    }
    function p0(i) {
        switch(i.toLowerCase()){
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
                return Ws;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
                return Ys;
            case "color":
                return Ip;
            case "quaternion":
                return Xs;
            case "bool":
            case "boolean":
                return Js;
            case "string":
                return Qs;
        }
        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + i);
    }
    function m0(i) {
        if (i.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
        const e = p0(i.type);
        if (i.times === void 0) {
            const t = [], n = [];
            Cp(i.keys, t, n, "value"), i.times = t, i.values = n;
        }
        return e.parse !== void 0 ? e.parse(i) : new e(i.name, i.times, i.values, i.interpolation);
    }
    const bi = {
        enabled: !1,
        files: {},
        add: function(i, e) {
            this.enabled !== !1 && (this.files[i] = e);
        },
        get: function(i) {
            if (this.enabled !== !1) return this.files[i];
        },
        remove: function(i) {
            delete this.files[i];
        },
        clear: function() {
            this.files = {};
        }
    };
    class _0 {
        constructor(e, t, n){
            const s = this;
            let r = !1, a = 0, o = 0, l;
            const h = [];
            this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(d) {
                o++, r === !1 && s.onStart !== void 0 && s.onStart(d, a, o), r = !0;
            }, this.itemEnd = function(d) {
                a++, s.onProgress !== void 0 && s.onProgress(d, a, o), a === o && (r = !1, s.onLoad !== void 0 && s.onLoad());
            }, this.itemError = function(d) {
                s.onError !== void 0 && s.onError(d);
            }, this.resolveURL = function(d) {
                return l ? l(d) : d;
            }, this.setURLModifier = function(d) {
                return l = d, this;
            }, this.addHandler = function(d, c) {
                return h.push(d, c), this;
            }, this.removeHandler = function(d) {
                const c = h.indexOf(d);
                return c !== -1 && h.splice(c, 2), this;
            }, this.getHandler = function(d) {
                for(let c = 0, u = h.length; c < u; c += 2){
                    const f = h[c], _ = h[c + 1];
                    if (f.global && (f.lastIndex = 0), f.test(d)) return _;
                }
                return null;
            };
        }
    }
    const g0 = new _0;
    let er = class {
        constructor(e){
            this.manager = e !== void 0 ? e : g0, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
        }
        load() {}
        loadAsync(e, t) {
            const n = this;
            return new Promise(function(s, r) {
                n.load(e, s, t, r);
            });
        }
        parse() {}
        setCrossOrigin(e) {
            return this.crossOrigin = e, this;
        }
        setWithCredentials(e) {
            return this.withCredentials = e, this;
        }
        setPath(e) {
            return this.path = e, this;
        }
        setResourcePath(e) {
            return this.resourcePath = e, this;
        }
        setRequestHeader(e) {
            return this.requestHeader = e, this;
        }
    };
    er.DEFAULT_MATERIAL_NAME = "__DEFAULT";
    const Jn = {};
    class x0 extends Error {
        constructor(e, t){
            super(e), this.response = t;
        }
    }
    class Dp extends er {
        constructor(e){
            super(e), this.mimeType = "", this.responseType = "";
        }
        load(e, t, n, s) {
            e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
            const r = bi.get(e);
            if (r !== void 0) return this.manager.itemStart(e), setTimeout(()=>{
                t && t(r), this.manager.itemEnd(e);
            }, 0), r;
            if (Jn[e] !== void 0) {
                Jn[e].push({
                    onLoad: t,
                    onProgress: n,
                    onError: s
                });
                return;
            }
            Jn[e] = [], Jn[e].push({
                onLoad: t,
                onProgress: n,
                onError: s
            });
            const a = new Request(e, {
                headers: new Headers(this.requestHeader),
                credentials: this.withCredentials ? "include" : "same-origin"
            }), o = this.mimeType, l = this.responseType;
            fetch(a).then((h)=>{
                if (h.status === 200 || h.status === 0) {
                    if (h.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || h.body === void 0 || h.body.getReader === void 0) return h;
                    const d = Jn[e], c = h.body.getReader(), u = h.headers.get("X-File-Size") || h.headers.get("Content-Length"), f = u ? parseInt(u) : 0, _ = f !== 0;
                    let g = 0;
                    const m = new ReadableStream({
                        start (p) {
                            x();
                            function x() {
                                c.read().then(({ done: v, value: y })=>{
                                    if (v) p.close();
                                    else {
                                        g += y.byteLength;
                                        const P = new ProgressEvent("progress", {
                                            lengthComputable: _,
                                            loaded: g,
                                            total: f
                                        });
                                        for(let w = 0, R = d.length; w < R; w++){
                                            const B = d[w];
                                            B.onProgress && B.onProgress(P);
                                        }
                                        p.enqueue(y), x();
                                    }
                                }, (v)=>{
                                    p.error(v);
                                });
                            }
                        }
                    });
                    return new Response(m);
                } else throw new x0(`fetch for "${h.url}" responded with ${h.status}: ${h.statusText}`, h);
            }).then((h)=>{
                switch(l){
                    case "arraybuffer":
                        return h.arrayBuffer();
                    case "blob":
                        return h.blob();
                    case "document":
                        return h.text().then((d)=>new DOMParser().parseFromString(d, o));
                    case "json":
                        return h.json();
                    default:
                        if (o === "") return h.text();
                        {
                            const c = /charset="?([^;"\s]*)"?/i.exec(o), u = c && c[1] ? c[1].toLowerCase() : void 0, f = new TextDecoder(u);
                            return h.arrayBuffer().then((_)=>f.decode(_));
                        }
                }
            }).then((h)=>{
                bi.add(e, h);
                const d = Jn[e];
                delete Jn[e];
                for(let c = 0, u = d.length; c < u; c++){
                    const f = d[c];
                    f.onLoad && f.onLoad(h);
                }
            }).catch((h)=>{
                const d = Jn[e];
                if (d === void 0) throw this.manager.itemError(e), h;
                delete Jn[e];
                for(let c = 0, u = d.length; c < u; c++){
                    const f = d[c];
                    f.onError && f.onError(h);
                }
                this.manager.itemError(e);
            }).finally(()=>{
                this.manager.itemEnd(e);
            }), this.manager.itemStart(e);
        }
        setResponseType(e) {
            return this.responseType = e, this;
        }
        setMimeType(e) {
            return this.mimeType = e, this;
        }
    }
    class v0 extends er {
        constructor(e){
            super(e);
        }
        load(e, t, n, s) {
            this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
            const r = this, a = bi.get(e);
            if (a !== void 0) return r.manager.itemStart(e), setTimeout(function() {
                t && t(a), r.manager.itemEnd(e);
            }, 0), a;
            const o = Wr("img");
            function l() {
                d(), bi.add(e, this), t && t(this), r.manager.itemEnd(e);
            }
            function h(c) {
                d(), s && s(c), r.manager.itemError(e), r.manager.itemEnd(e);
            }
            function d() {
                o.removeEventListener("load", l, !1), o.removeEventListener("error", h, !1);
            }
            return o.addEventListener("load", l, !1), o.addEventListener("error", h, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (o.crossOrigin = this.crossOrigin), r.manager.itemStart(e), o.src = e, o;
        }
    }
    class Lp extends er {
        constructor(e){
            super(e);
        }
        load(e, t, n, s) {
            const r = new nn, a = new v0(this.manager);
            return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(e, function(o) {
                r.image = o, r.needsUpdate = !0, t !== void 0 && t(r);
            }, n, s), r;
        }
    }
    class fo extends yt {
        constructor(e, t = 1){
            super(), this.isLight = !0, this.type = "Light", this.color = new Oe(e), this.intensity = t;
        }
        dispose() {}
        copy(e, t) {
            return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (t.object.target = this.target.uuid), t;
        }
    }
    const Yo = new He, Ku = new k, Zu = new k;
    class vh {
        constructor(e){
            this.camera = e, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Ze(512, 512), this.map = null, this.mapPass = null, this.matrix = new He, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new gh, this._frameExtents = new Ze(1, 1), this._viewportCount = 1, this._viewports = [
                new rt(0, 0, 1, 1)
            ];
        }
        getViewportCount() {
            return this._viewportCount;
        }
        getFrustum() {
            return this._frustum;
        }
        updateMatrices(e) {
            const t = this.camera, n = this.matrix;
            Ku.setFromMatrixPosition(e.matrixWorld), t.position.copy(Ku), Zu.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(Zu), t.updateMatrixWorld(), Yo.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Yo), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(Yo);
        }
        getViewport(e) {
            return this._viewports[e];
        }
        getFrameExtents() {
            return this._frameExtents;
        }
        dispose() {
            this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
        }
        copy(e) {
            return this.camera = e.camera.clone(), this.intensity = e.intensity, this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
        }
        clone() {
            return new this.constructor().copy(this);
        }
        toJSON() {
            const e = {};
            return this.intensity !== 1 && (e.intensity = this.intensity), this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
        }
    }
    class y0 extends vh {
        constructor(){
            super(new jt(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
        }
        updateMatrices(e) {
            const t = this.camera, n = Hs * 2 * e.angle * this.focus, s = this.mapSize.width / this.mapSize.height, r = e.distance || t.far;
            (n !== t.fov || s !== t.aspect || r !== t.far) && (t.fov = n, t.aspect = s, t.far = r, t.updateProjectionMatrix()), super.updateMatrices(e);
        }
        copy(e) {
            return super.copy(e), this.focus = e.focus, this;
        }
    }
    class b0 extends fo {
        constructor(e, t, n = 0, s = Math.PI / 3, r = 0, a = 2){
            super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(yt.DEFAULT_UP), this.updateMatrix(), this.target = new yt, this.distance = n, this.angle = s, this.penumbra = r, this.decay = a, this.map = null, this.shadow = new y0;
        }
        get power() {
            return this.intensity * Math.PI;
        }
        set power(e) {
            this.intensity = e / Math.PI;
        }
        dispose() {
            this.shadow.dispose();
        }
        copy(e, t) {
            return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
        }
    }
    const Ju = new He, pr = new k, jo = new k;
    class S0 extends vh {
        constructor(){
            super(new jt(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new Ze(4, 2), this._viewportCount = 6, this._viewports = [
                new rt(2, 1, 1, 1),
                new rt(0, 1, 1, 1),
                new rt(3, 1, 1, 1),
                new rt(1, 1, 1, 1),
                new rt(3, 0, 1, 1),
                new rt(1, 0, 1, 1)
            ], this._cubeDirections = [
                new k(1, 0, 0),
                new k(-1, 0, 0),
                new k(0, 0, 1),
                new k(0, 0, -1),
                new k(0, 1, 0),
                new k(0, -1, 0)
            ], this._cubeUps = [
                new k(0, 1, 0),
                new k(0, 1, 0),
                new k(0, 1, 0),
                new k(0, 1, 0),
                new k(0, 0, 1),
                new k(0, 0, -1)
            ];
        }
        updateMatrices(e, t = 0) {
            const n = this.camera, s = this.matrix, r = e.distance || n.far;
            r !== n.far && (n.far = r, n.updateProjectionMatrix()), pr.setFromMatrixPosition(e.matrixWorld), n.position.copy(pr), jo.copy(n.position), jo.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(jo), n.updateMatrixWorld(), s.makeTranslation(-pr.x, -pr.y, -pr.z), Ju.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Ju);
        }
    }
    class T0 extends fo {
        constructor(e, t, n = 0, s = 2){
            super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = s, this.shadow = new S0;
        }
        get power() {
            return this.intensity * 4 * Math.PI;
        }
        set power(e) {
            this.intensity = e / (4 * Math.PI);
        }
        dispose() {
            this.shadow.dispose();
        }
        copy(e, t) {
            return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
        }
    }
    class yh extends Sp {
        constructor(e = -1, t = 1, n = 1, s = -1, r = .1, a = 2e3){
            super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = s, this.near = r, this.far = a, this.updateProjectionMatrix();
        }
        copy(e, t) {
            return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
        }
        setViewOffset(e, t, n, s, r, a) {
            this.view === null && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = s, this.view.width = r, this.view.height = a, this.updateProjectionMatrix();
        }
        clearViewOffset() {
            this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
            const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, s = (this.top + this.bottom) / 2;
            let r = n - e, a = n + e, o = s + t, l = s - t;
            if (this.view !== null && this.view.enabled) {
                const h = (this.right - this.left) / this.view.fullWidth / this.zoom, d = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                r += h * this.view.offsetX, a = r + h * this.view.width, o -= d * this.view.offsetY, l = o - d * this.view.height;
            }
            this.projectionMatrix.makeOrthographic(r, a, o, l, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
        }
    }
    class M0 extends vh {
        constructor(){
            super(new yh(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0;
        }
    }
    class bh extends fo {
        constructor(e, t){
            super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(yt.DEFAULT_UP), this.updateMatrix(), this.target = new yt, this.shadow = new M0;
        }
        dispose() {
            this.shadow.dispose();
        }
        copy(e) {
            return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
        }
    }
    class Bp extends fo {
        constructor(e, t){
            super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight";
        }
    }
    class Ir {
        static extractUrlBase(e) {
            const t = e.lastIndexOf("/");
            return t === -1 ? "./" : e.slice(0, t + 1);
        }
        static resolveURL(e, t) {
            return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
        }
    }
    class A0 extends er {
        constructor(e){
            super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
                premultiplyAlpha: "none"
            };
        }
        setOptions(e) {
            return this.options = e, this;
        }
        load(e, t, n, s) {
            e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
            const r = this, a = bi.get(e);
            if (a !== void 0) {
                if (r.manager.itemStart(e), a.then) {
                    a.then((h)=>{
                        t && t(h), r.manager.itemEnd(e);
                    }).catch((h)=>{
                        s && s(h);
                    });
                    return;
                }
                return setTimeout(function() {
                    t && t(a), r.manager.itemEnd(e);
                }, 0), a;
            }
            const o = {};
            o.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", o.headers = this.requestHeader;
            const l = fetch(e, o).then(function(h) {
                return h.blob();
            }).then(function(h) {
                return createImageBitmap(h, Object.assign(r.options, {
                    colorSpaceConversion: "none"
                }));
            }).then(function(h) {
                return bi.add(e, h), t && t(h), r.manager.itemEnd(e), h;
            }).catch(function(h) {
                s && s(h), bi.remove(e), r.manager.itemError(e), r.manager.itemEnd(e);
            });
            bi.add(e, l), r.manager.itemStart(e);
        }
    }
    class E0 extends jt {
        constructor(e = []){
            super(), this.isArrayCamera = !0, this.cameras = e, this.index = 0;
        }
    }
    class w0 {
        constructor(e = !0){
            this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
        }
        start() {
            this.startTime = Qu(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
        }
        stop() {
            this.getElapsedTime(), this.running = !1, this.autoStart = !1;
        }
        getElapsedTime() {
            return this.getDelta(), this.elapsedTime;
        }
        getDelta() {
            let e = 0;
            if (this.autoStart && !this.running) return this.start(), 0;
            if (this.running) {
                const t = Qu();
                e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
            }
            return e;
        }
    }
    function Qu() {
        return performance.now();
    }
    class R0 {
        constructor(e, t, n){
            this.binding = e, this.valueSize = n;
            let s, r, a;
            switch(t){
                case "quaternion":
                    s = this._slerp, r = this._slerpAdditive, a = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(n * 6), this._workIndex = 5;
                    break;
                case "string":
                case "bool":
                    s = this._select, r = this._select, a = this._setAdditiveIdentityOther, this.buffer = new Array(n * 5);
                    break;
                default:
                    s = this._lerp, r = this._lerpAdditive, a = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(n * 5);
            }
            this._mixBufferRegion = s, this._mixBufferRegionAdditive = r, this._setIdentity = a, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
        }
        accumulate(e, t) {
            const n = this.buffer, s = this.valueSize, r = e * s + s;
            let a = this.cumulativeWeight;
            if (a === 0) {
                for(let o = 0; o !== s; ++o)n[r + o] = n[o];
                a = t;
            } else {
                a += t;
                const o = t / a;
                this._mixBufferRegion(n, r, 0, o, s);
            }
            this.cumulativeWeight = a;
        }
        accumulateAdditive(e) {
            const t = this.buffer, n = this.valueSize, s = n * this._addIndex;
            this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, s, 0, e, n), this.cumulativeWeightAdditive += e;
        }
        apply(e) {
            const t = this.valueSize, n = this.buffer, s = e * t + t, r = this.cumulativeWeight, a = this.cumulativeWeightAdditive, o = this.binding;
            if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
                const l = t * this._origIndex;
                this._mixBufferRegion(n, s, l, 1 - r, t);
            }
            a > 0 && this._mixBufferRegionAdditive(n, s, this._addIndex * t, 1, t);
            for(let l = t, h = t + t; l !== h; ++l)if (n[l] !== n[l + t]) {
                o.setValue(n, s);
                break;
            }
        }
        saveOriginalState() {
            const e = this.binding, t = this.buffer, n = this.valueSize, s = n * this._origIndex;
            e.getValue(t, s);
            for(let r = n, a = s; r !== a; ++r)t[r] = t[s + r % n];
            this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
        }
        restoreOriginalState() {
            const e = this.valueSize * 3;
            this.binding.setValue(this.buffer, e);
        }
        _setAdditiveIdentityNumeric() {
            const e = this._addIndex * this.valueSize, t = e + this.valueSize;
            for(let n = e; n < t; n++)this.buffer[n] = 0;
        }
        _setAdditiveIdentityQuaternion() {
            this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
        }
        _setAdditiveIdentityOther() {
            const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize;
            for(let n = 0; n < this.valueSize; n++)this.buffer[t + n] = this.buffer[e + n];
        }
        _select(e, t, n, s, r) {
            if (s >= .5) for(let a = 0; a !== r; ++a)e[t + a] = e[n + a];
        }
        _slerp(e, t, n, s) {
            Dn.slerpFlat(e, t, e, t, e, n, s);
        }
        _slerpAdditive(e, t, n, s, r) {
            const a = this._workIndex * r;
            Dn.multiplyQuaternionsFlat(e, a, e, t, e, n), Dn.slerpFlat(e, t, e, t, e, a, s);
        }
        _lerp(e, t, n, s, r) {
            const a = 1 - s;
            for(let o = 0; o !== r; ++o){
                const l = t + o;
                e[l] = e[l] * a + e[n + o] * s;
            }
        }
        _lerpAdditive(e, t, n, s, r) {
            for(let a = 0; a !== r; ++a){
                const o = t + a;
                e[o] = e[o] + e[n + a] * s;
            }
        }
    }
    const Sh = "\\[\\]\\.:\\/", C0 = new RegExp("[" + Sh + "]", "g"), Th = "[^" + Sh + "]", P0 = "[^" + Sh.replace("\\.", "") + "]", I0 = /((?:WC+[\/:])*)/.source.replace("WC", Th), D0 = /(WCOD+)?/.source.replace("WCOD", P0), L0 = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Th), B0 = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Th), U0 = new RegExp("^" + I0 + D0 + L0 + B0 + "$"), F0 = [
        "material",
        "materials",
        "bones",
        "map"
    ];
    class N0 {
        constructor(e, t, n){
            const s = n || lt.parseTrackName(t);
            this._targetGroup = e, this._bindings = e.subscribe_(t, s);
        }
        getValue(e, t) {
            this.bind();
            const n = this._targetGroup.nCachedObjects_, s = this._bindings[n];
            s !== void 0 && s.getValue(e, t);
        }
        setValue(e, t) {
            const n = this._bindings;
            for(let s = this._targetGroup.nCachedObjects_, r = n.length; s !== r; ++s)n[s].setValue(e, t);
        }
        bind() {
            const e = this._bindings;
            for(let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)e[t].bind();
        }
        unbind() {
            const e = this._bindings;
            for(let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)e[t].unbind();
        }
    }
    class lt {
        constructor(e, t, n){
            this.path = t, this.parsedPath = n || lt.parseTrackName(t), this.node = lt.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
        }
        static create(e, t, n) {
            return e && e.isAnimationObjectGroup ? new lt.Composite(e, t, n) : new lt(e, t, n);
        }
        static sanitizeNodeName(e) {
            return e.replace(/\s/g, "_").replace(C0, "");
        }
        static parseTrackName(e) {
            const t = U0.exec(e);
            if (t === null) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
            const n = {
                nodeName: t[2],
                objectName: t[3],
                objectIndex: t[4],
                propertyName: t[5],
                propertyIndex: t[6]
            }, s = n.nodeName && n.nodeName.lastIndexOf(".");
            if (s !== void 0 && s !== -1) {
                const r = n.nodeName.substring(s + 1);
                F0.indexOf(r) !== -1 && (n.nodeName = n.nodeName.substring(0, s), n.objectName = r);
            }
            if (n.propertyName === null || n.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
            return n;
        }
        static findNode(e, t) {
            if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid) return e;
            if (e.skeleton) {
                const n = e.skeleton.getBoneByName(t);
                if (n !== void 0) return n;
            }
            if (e.children) {
                const n = function(r) {
                    for(let a = 0; a < r.length; a++){
                        const o = r[a];
                        if (o.name === t || o.uuid === t) return o;
                        const l = n(o.children);
                        if (l) return l;
                    }
                    return null;
                }, s = n(e.children);
                if (s) return s;
            }
            return null;
        }
        _getValue_unavailable() {}
        _setValue_unavailable() {}
        _getValue_direct(e, t) {
            e[t] = this.targetObject[this.propertyName];
        }
        _getValue_array(e, t) {
            const n = this.resolvedProperty;
            for(let s = 0, r = n.length; s !== r; ++s)e[t++] = n[s];
        }
        _getValue_arrayElement(e, t) {
            e[t] = this.resolvedProperty[this.propertyIndex];
        }
        _getValue_toArray(e, t) {
            this.resolvedProperty.toArray(e, t);
        }
        _setValue_direct(e, t) {
            this.targetObject[this.propertyName] = e[t];
        }
        _setValue_direct_setNeedsUpdate(e, t) {
            this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0;
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
            this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
        }
        _setValue_array(e, t) {
            const n = this.resolvedProperty;
            for(let s = 0, r = n.length; s !== r; ++s)n[s] = e[t++];
        }
        _setValue_array_setNeedsUpdate(e, t) {
            const n = this.resolvedProperty;
            for(let s = 0, r = n.length; s !== r; ++s)n[s] = e[t++];
            this.targetObject.needsUpdate = !0;
        }
        _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
            const n = this.resolvedProperty;
            for(let s = 0, r = n.length; s !== r; ++s)n[s] = e[t++];
            this.targetObject.matrixWorldNeedsUpdate = !0;
        }
        _setValue_arrayElement(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t];
        }
        _setValue_arrayElement_setNeedsUpdate(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0;
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
        }
        _setValue_fromArray(e, t) {
            this.resolvedProperty.fromArray(e, t);
        }
        _setValue_fromArray_setNeedsUpdate(e, t) {
            this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0;
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
            this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0;
        }
        _getValue_unbound(e, t) {
            this.bind(), this.getValue(e, t);
        }
        _setValue_unbound(e, t) {
            this.bind(), this.setValue(e, t);
        }
        bind() {
            let e = this.node;
            const t = this.parsedPath, n = t.objectName, s = t.propertyName;
            let r = t.propertyIndex;
            if (e || (e = lt.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
                console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
                return;
            }
            if (n) {
                let h = t.objectIndex;
                switch(n){
                    case "materials":
                        if (!e.material) {
                            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            return;
                        }
                        if (!e.material.materials) {
                            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                            return;
                        }
                        e = e.material.materials;
                        break;
                    case "bones":
                        if (!e.skeleton) {
                            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                            return;
                        }
                        e = e.skeleton.bones;
                        for(let d = 0; d < e.length; d++)if (e[d].name === h) {
                            h = d;
                            break;
                        }
                        break;
                    case "map":
                        if ("map" in e) {
                            e = e.map;
                            break;
                        }
                        if (!e.material) {
                            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            return;
                        }
                        if (!e.material.map) {
                            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                            return;
                        }
                        e = e.material.map;
                        break;
                    default:
                        if (e[n] === void 0) {
                            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                            return;
                        }
                        e = e[n];
                }
                if (h !== void 0) {
                    if (e[h] === void 0) {
                        console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                        return;
                    }
                    e = e[h];
                }
            }
            const a = e[s];
            if (a === void 0) {
                const h = t.nodeName;
                console.error("THREE.PropertyBinding: Trying to update property for track: " + h + "." + s + " but it wasn't found.", e);
                return;
            }
            let o = this.Versioning.None;
            this.targetObject = e, e.isMaterial === !0 ? o = this.Versioning.NeedsUpdate : e.isObject3D === !0 && (o = this.Versioning.MatrixWorldNeedsUpdate);
            let l = this.BindingType.Direct;
            if (r !== void 0) {
                if (s === "morphTargetInfluences") {
                    if (!e.geometry) {
                        console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                        return;
                    }
                    if (!e.geometry.morphAttributes) {
                        console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                        return;
                    }
                    e.morphTargetDictionary[r] !== void 0 && (r = e.morphTargetDictionary[r]);
                }
                l = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = r;
            } else a.fromArray !== void 0 && a.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = a) : Array.isArray(a) ? (l = this.BindingType.EntireArray, this.resolvedProperty = a) : this.propertyName = s;
            this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][o];
        }
        unbind() {
            this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
        }
    }
    lt.Composite = N0;
    lt.prototype.BindingType = {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3
    };
    lt.prototype.Versioning = {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2
    };
    lt.prototype.GetterByBindingType = [
        lt.prototype._getValue_direct,
        lt.prototype._getValue_array,
        lt.prototype._getValue_arrayElement,
        lt.prototype._getValue_toArray
    ];
    lt.prototype.SetterByBindingTypeAndVersioning = [
        [
            lt.prototype._setValue_direct,
            lt.prototype._setValue_direct_setNeedsUpdate,
            lt.prototype._setValue_direct_setMatrixWorldNeedsUpdate
        ],
        [
            lt.prototype._setValue_array,
            lt.prototype._setValue_array_setNeedsUpdate,
            lt.prototype._setValue_array_setMatrixWorldNeedsUpdate
        ],
        [
            lt.prototype._setValue_arrayElement,
            lt.prototype._setValue_arrayElement_setNeedsUpdate,
            lt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
        ],
        [
            lt.prototype._setValue_fromArray,
            lt.prototype._setValue_fromArray_setNeedsUpdate,
            lt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
        ]
    ];
    class O0 {
        constructor(e, t, n = null, s = t.blendMode){
            this._mixer = e, this._clip = t, this._localRoot = n, this.blendMode = s;
            const r = t.tracks, a = r.length, o = new Array(a), l = {
                endingStart: ws,
                endingEnd: ws
            };
            for(let h = 0; h !== a; ++h){
                const d = r[h].createInterpolant(null);
                o[h] = d, d.settings = l;
            }
            this._interpolantSettings = l, this._interpolants = o, this._propertyBindings = new Array(a), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = up, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
        }
        play() {
            return this._mixer._activateAction(this), this;
        }
        stop() {
            return this._mixer._deactivateAction(this), this.reset();
        }
        reset() {
            return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
        }
        isRunning() {
            return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
        }
        isScheduled() {
            return this._mixer._isActiveAction(this);
        }
        startAt(e) {
            return this._startTime = e, this;
        }
        setLoop(e, t) {
            return this.loop = e, this.repetitions = t, this;
        }
        setEffectiveWeight(e) {
            return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
        }
        getEffectiveWeight() {
            return this._effectiveWeight;
        }
        fadeIn(e) {
            return this._scheduleFading(e, 0, 1);
        }
        fadeOut(e) {
            return this._scheduleFading(e, 1, 0);
        }
        crossFadeFrom(e, t, n = !1) {
            if (e.fadeOut(t), this.fadeIn(t), n === !0) {
                const s = this._clip.duration, r = e._clip.duration, a = r / s, o = s / r;
                e.warp(1, a, t), this.warp(o, 1, t);
            }
            return this;
        }
        crossFadeTo(e, t, n = !1) {
            return e.crossFadeFrom(this, t, n);
        }
        stopFading() {
            const e = this._weightInterpolant;
            return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
        }
        setEffectiveTimeScale(e) {
            return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
        }
        getEffectiveTimeScale() {
            return this._effectiveTimeScale;
        }
        setDuration(e) {
            return this.timeScale = this._clip.duration / e, this.stopWarping();
        }
        syncWith(e) {
            return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
        }
        halt(e) {
            return this.warp(this._effectiveTimeScale, 0, e);
        }
        warp(e, t, n) {
            const s = this._mixer, r = s.time, a = this.timeScale;
            let o = this._timeScaleInterpolant;
            o === null && (o = s._lendControlInterpolant(), this._timeScaleInterpolant = o);
            const l = o.parameterPositions, h = o.sampleValues;
            return l[0] = r, l[1] = r + n, h[0] = e / a, h[1] = t / a, this;
        }
        stopWarping() {
            const e = this._timeScaleInterpolant;
            return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
        }
        getMixer() {
            return this._mixer;
        }
        getClip() {
            return this._clip;
        }
        getRoot() {
            return this._localRoot || this._mixer._root;
        }
        _update(e, t, n, s) {
            if (!this.enabled) {
                this._updateWeight(e);
                return;
            }
            const r = this._startTime;
            if (r !== null) {
                const l = (e - r) * n;
                l < 0 || n === 0 ? t = 0 : (this._startTime = null, t = n * l);
            }
            t *= this._updateTimeScale(e);
            const a = this._updateTime(t), o = this._updateWeight(e);
            if (o > 0) {
                const l = this._interpolants, h = this._propertyBindings;
                switch(this.blendMode){
                    case Yg:
                        for(let d = 0, c = l.length; d !== c; ++d)l[d].evaluate(a), h[d].accumulateAdditive(o);
                        break;
                    case dh:
                    default:
                        for(let d = 0, c = l.length; d !== c; ++d)l[d].evaluate(a), h[d].accumulate(s, o);
                }
            }
        }
        _updateWeight(e) {
            let t = 0;
            if (this.enabled) {
                t = this.weight;
                const n = this._weightInterpolant;
                if (n !== null) {
                    const s = n.evaluate(e)[0];
                    t *= s, e > n.parameterPositions[1] && (this.stopFading(), s === 0 && (this.enabled = !1));
                }
            }
            return this._effectiveWeight = t, t;
        }
        _updateTimeScale(e) {
            let t = 0;
            if (!this.paused) {
                t = this.timeScale;
                const n = this._timeScaleInterpolant;
                if (n !== null) {
                    const s = n.evaluate(e)[0];
                    t *= s, e > n.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t);
                }
            }
            return this._effectiveTimeScale = t, t;
        }
        _updateTime(e) {
            const t = this._clip.duration, n = this.loop;
            let s = this.time + e, r = this._loopCount;
            const a = n === Xg;
            if (e === 0) return r === -1 ? s : a && (r & 1) === 1 ? t - s : s;
            if (n === Wg) {
                r === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                e: {
                    if (s >= t) s = t;
                    else if (s < 0) s = 0;
                    else {
                        this.time = s;
                        break e;
                    }
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = s, this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: e < 0 ? -1 : 1
                    });
                }
            } else {
                if (r === -1 && (e >= 0 ? (r = 0, this._setEndings(!0, this.repetitions === 0, a)) : this._setEndings(this.repetitions === 0, !0, a)), s >= t || s < 0) {
                    const o = Math.floor(s / t);
                    s -= t * o, r += Math.abs(o);
                    const l = this.repetitions - r;
                    if (l <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, s = e > 0 ? t : 0, this.time = s, this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: e > 0 ? 1 : -1
                    });
                    else {
                        if (l === 1) {
                            const h = e < 0;
                            this._setEndings(h, !h, a);
                        } else this._setEndings(!1, !1, a);
                        this._loopCount = r, this.time = s, this._mixer.dispatchEvent({
                            type: "loop",
                            action: this,
                            loopDelta: o
                        });
                    }
                } else this.time = s;
                if (a && (r & 1) === 1) return t - s;
            }
            return s;
        }
        _setEndings(e, t, n) {
            const s = this._interpolantSettings;
            n ? (s.endingStart = Rs, s.endingEnd = Rs) : (e ? s.endingStart = this.zeroSlopeAtStart ? Rs : ws : s.endingStart = Qa, t ? s.endingEnd = this.zeroSlopeAtEnd ? Rs : ws : s.endingEnd = Qa);
        }
        _scheduleFading(e, t, n) {
            const s = this._mixer, r = s.time;
            let a = this._weightInterpolant;
            a === null && (a = s._lendControlInterpolant(), this._weightInterpolant = a);
            const o = a.parameterPositions, l = a.sampleValues;
            return o[0] = r, l[0] = t, o[1] = r + e, l[1] = n, this;
        }
    }
    const k0 = new Float32Array(1);
    class G0 extends ss {
        constructor(e){
            super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
        }
        _bindAction(e, t) {
            const n = e._localRoot || this._root, s = e._clip.tracks, r = s.length, a = e._propertyBindings, o = e._interpolants, l = n.uuid, h = this._bindingsByRootAndName;
            let d = h[l];
            d === void 0 && (d = {}, h[l] = d);
            for(let c = 0; c !== r; ++c){
                const u = s[c], f = u.name;
                let _ = d[f];
                if (_ !== void 0) ++_.referenceCount, a[c] = _;
                else {
                    if (_ = a[c], _ !== void 0) {
                        _._cacheIndex === null && (++_.referenceCount, this._addInactiveBinding(_, l, f));
                        continue;
                    }
                    const g = t && t._propertyBindings[c].binding.parsedPath;
                    _ = new R0(lt.create(n, f, g), u.ValueTypeName, u.getValueSize()), ++_.referenceCount, this._addInactiveBinding(_, l, f), a[c] = _;
                }
                o[c].resultBuffer = _.buffer;
            }
        }
        _activateAction(e) {
            if (!this._isActiveAction(e)) {
                if (e._cacheIndex === null) {
                    const n = (e._localRoot || this._root).uuid, s = e._clip.uuid, r = this._actionsByClip[s];
                    this._bindAction(e, r && r.knownActions[0]), this._addInactiveAction(e, s, n);
                }
                const t = e._propertyBindings;
                for(let n = 0, s = t.length; n !== s; ++n){
                    const r = t[n];
                    r.useCount++ === 0 && (this._lendBinding(r), r.saveOriginalState());
                }
                this._lendAction(e);
            }
        }
        _deactivateAction(e) {
            if (this._isActiveAction(e)) {
                const t = e._propertyBindings;
                for(let n = 0, s = t.length; n !== s; ++n){
                    const r = t[n];
                    --r.useCount === 0 && (r.restoreOriginalState(), this._takeBackBinding(r));
                }
                this._takeBackAction(e);
            }
        }
        _initMemoryManager() {
            this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
            const e = this;
            this.stats = {
                actions: {
                    get total () {
                        return e._actions.length;
                    },
                    get inUse () {
                        return e._nActiveActions;
                    }
                },
                bindings: {
                    get total () {
                        return e._bindings.length;
                    },
                    get inUse () {
                        return e._nActiveBindings;
                    }
                },
                controlInterpolants: {
                    get total () {
                        return e._controlInterpolants.length;
                    },
                    get inUse () {
                        return e._nActiveControlInterpolants;
                    }
                }
            };
        }
        _isActiveAction(e) {
            const t = e._cacheIndex;
            return t !== null && t < this._nActiveActions;
        }
        _addInactiveAction(e, t, n) {
            const s = this._actions, r = this._actionsByClip;
            let a = r[t];
            if (a === void 0) a = {
                knownActions: [
                    e
                ],
                actionByRoot: {}
            }, e._byClipCacheIndex = 0, r[t] = a;
            else {
                const o = a.knownActions;
                e._byClipCacheIndex = o.length, o.push(e);
            }
            e._cacheIndex = s.length, s.push(e), a.actionByRoot[n] = e;
        }
        _removeInactiveAction(e) {
            const t = this._actions, n = t[t.length - 1], s = e._cacheIndex;
            n._cacheIndex = s, t[s] = n, t.pop(), e._cacheIndex = null;
            const r = e._clip.uuid, a = this._actionsByClip, o = a[r], l = o.knownActions, h = l[l.length - 1], d = e._byClipCacheIndex;
            h._byClipCacheIndex = d, l[d] = h, l.pop(), e._byClipCacheIndex = null;
            const c = o.actionByRoot, u = (e._localRoot || this._root).uuid;
            delete c[u], l.length === 0 && delete a[r], this._removeInactiveBindingsForAction(e);
        }
        _removeInactiveBindingsForAction(e) {
            const t = e._propertyBindings;
            for(let n = 0, s = t.length; n !== s; ++n){
                const r = t[n];
                --r.referenceCount === 0 && this._removeInactiveBinding(r);
            }
        }
        _lendAction(e) {
            const t = this._actions, n = e._cacheIndex, s = this._nActiveActions++, r = t[s];
            e._cacheIndex = s, t[s] = e, r._cacheIndex = n, t[n] = r;
        }
        _takeBackAction(e) {
            const t = this._actions, n = e._cacheIndex, s = --this._nActiveActions, r = t[s];
            e._cacheIndex = s, t[s] = e, r._cacheIndex = n, t[n] = r;
        }
        _addInactiveBinding(e, t, n) {
            const s = this._bindingsByRootAndName, r = this._bindings;
            let a = s[t];
            a === void 0 && (a = {}, s[t] = a), a[n] = e, e._cacheIndex = r.length, r.push(e);
        }
        _removeInactiveBinding(e) {
            const t = this._bindings, n = e.binding, s = n.rootNode.uuid, r = n.path, a = this._bindingsByRootAndName, o = a[s], l = t[t.length - 1], h = e._cacheIndex;
            l._cacheIndex = h, t[h] = l, t.pop(), delete o[r], Object.keys(o).length === 0 && delete a[s];
        }
        _lendBinding(e) {
            const t = this._bindings, n = e._cacheIndex, s = this._nActiveBindings++, r = t[s];
            e._cacheIndex = s, t[s] = e, r._cacheIndex = n, t[n] = r;
        }
        _takeBackBinding(e) {
            const t = this._bindings, n = e._cacheIndex, s = --this._nActiveBindings, r = t[s];
            e._cacheIndex = s, t[s] = e, r._cacheIndex = n, t[n] = r;
        }
        _lendControlInterpolant() {
            const e = this._controlInterpolants, t = this._nActiveControlInterpolants++;
            let n = e[t];
            return n === void 0 && (n = new Pp(new Float32Array(2), new Float32Array(2), 1, k0), n.__cacheIndex = t, e[t] = n), n;
        }
        _takeBackControlInterpolant(e) {
            const t = this._controlInterpolants, n = e.__cacheIndex, s = --this._nActiveControlInterpolants, r = t[s];
            e.__cacheIndex = s, t[s] = e, r.__cacheIndex = n, t[n] = r;
        }
        clipAction(e, t, n) {
            const s = t || this._root, r = s.uuid;
            let a = typeof e == "string" ? Rc.findByName(s, e) : e;
            const o = a !== null ? a.uuid : e, l = this._actionsByClip[o];
            let h = null;
            if (n === void 0 && (a !== null ? n = a.blendMode : n = dh), l !== void 0) {
                const c = l.actionByRoot[r];
                if (c !== void 0 && c.blendMode === n) return c;
                h = l.knownActions[0], a === null && (a = h._clip);
            }
            if (a === null) return null;
            const d = new O0(this, a, t, n);
            return this._bindAction(d, h), this._addInactiveAction(d, o, r), d;
        }
        existingAction(e, t) {
            const n = t || this._root, s = n.uuid, r = typeof e == "string" ? Rc.findByName(n, e) : e, a = r ? r.uuid : e, o = this._actionsByClip[a];
            return o !== void 0 && o.actionByRoot[s] || null;
        }
        stopAllAction() {
            const e = this._actions, t = this._nActiveActions;
            for(let n = t - 1; n >= 0; --n)e[n].stop();
            return this;
        }
        update(e) {
            e *= this.timeScale;
            const t = this._actions, n = this._nActiveActions, s = this.time += e, r = Math.sign(e), a = this._accuIndex ^= 1;
            for(let h = 0; h !== n; ++h)t[h]._update(s, e, r, a);
            const o = this._bindings, l = this._nActiveBindings;
            for(let h = 0; h !== l; ++h)o[h].apply(a);
            return this;
        }
        setTime(e) {
            this.time = 0;
            for(let t = 0; t < this._actions.length; t++)this._actions[t].time = 0;
            return this.update(e);
        }
        getRoot() {
            return this._root;
        }
        uncacheClip(e) {
            const t = this._actions, n = e.uuid, s = this._actionsByClip, r = s[n];
            if (r !== void 0) {
                const a = r.knownActions;
                for(let o = 0, l = a.length; o !== l; ++o){
                    const h = a[o];
                    this._deactivateAction(h);
                    const d = h._cacheIndex, c = t[t.length - 1];
                    h._cacheIndex = null, h._byClipCacheIndex = null, c._cacheIndex = d, t[d] = c, t.pop(), this._removeInactiveBindingsForAction(h);
                }
                delete s[n];
            }
        }
        uncacheRoot(e) {
            const t = e.uuid, n = this._actionsByClip;
            for(const a in n){
                const o = n[a].actionByRoot, l = o[t];
                l !== void 0 && (this._deactivateAction(l), this._removeInactiveAction(l));
            }
            const s = this._bindingsByRootAndName, r = s[t];
            if (r !== void 0) for(const a in r){
                const o = r[a];
                o.restoreOriginalState(), this._removeInactiveBinding(o);
            }
        }
        uncacheAction(e, t) {
            const n = this.existingAction(e, t);
            n !== null && (this._deactivateAction(n), this._removeInactiveAction(n));
        }
    }
    function ed(i, e, t, n) {
        const s = H0(n);
        switch(t){
            case rp:
                return i * e;
            case op:
                return i * e;
            case lp:
                return i * e * 2;
            case lh:
                return i * e / s.components * s.byteLength;
            case ch:
                return i * e / s.components * s.byteLength;
            case cp:
                return i * e * 2 / s.components * s.byteLength;
            case hh:
                return i * e * 2 / s.components * s.byteLength;
            case ap:
                return i * e * 3 / s.components * s.byteLength;
            case xn:
                return i * e * 4 / s.components * s.byteLength;
            case uh:
                return i * e * 4 / s.components * s.byteLength;
            case ka:
            case Ga:
                return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 8;
            case Ha:
            case za:
                return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 16;
            case Ql:
            case tc:
                return Math.max(i, 16) * Math.max(e, 8) / 4;
            case Jl:
            case ec:
                return Math.max(i, 8) * Math.max(e, 8) / 2;
            case nc:
            case ic:
                return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 8;
            case sc:
                return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 16;
            case rc:
                return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 16;
            case ac:
                return Math.floor((i + 4) / 5) * Math.floor((e + 3) / 4) * 16;
            case oc:
                return Math.floor((i + 4) / 5) * Math.floor((e + 4) / 5) * 16;
            case lc:
                return Math.floor((i + 5) / 6) * Math.floor((e + 4) / 5) * 16;
            case cc:
                return Math.floor((i + 5) / 6) * Math.floor((e + 5) / 6) * 16;
            case hc:
                return Math.floor((i + 7) / 8) * Math.floor((e + 4) / 5) * 16;
            case uc:
                return Math.floor((i + 7) / 8) * Math.floor((e + 5) / 6) * 16;
            case dc:
                return Math.floor((i + 7) / 8) * Math.floor((e + 7) / 8) * 16;
            case fc:
                return Math.floor((i + 9) / 10) * Math.floor((e + 4) / 5) * 16;
            case pc:
                return Math.floor((i + 9) / 10) * Math.floor((e + 5) / 6) * 16;
            case mc:
                return Math.floor((i + 9) / 10) * Math.floor((e + 7) / 8) * 16;
            case _c:
                return Math.floor((i + 9) / 10) * Math.floor((e + 9) / 10) * 16;
            case gc:
                return Math.floor((i + 11) / 12) * Math.floor((e + 9) / 10) * 16;
            case xc:
                return Math.floor((i + 11) / 12) * Math.floor((e + 11) / 12) * 16;
            case Va:
            case vc:
            case yc:
                return Math.ceil(i / 4) * Math.ceil(e / 4) * 16;
            case hp:
            case bc:
                return Math.ceil(i / 4) * Math.ceil(e / 4) * 8;
            case Sc:
            case Tc:
                return Math.ceil(i / 4) * Math.ceil(e / 4) * 16;
        }
        throw new Error(`Unable to determine texture byte length for ${t} format.`);
    }
    function H0(i) {
        switch(i){
            case hi:
            case np:
                return {
                    byteLength: 1,
                    components: 1
                };
            case Or:
            case ip:
            case jr:
                return {
                    byteLength: 2,
                    components: 1
                };
            case ah:
            case oh:
                return {
                    byteLength: 2,
                    components: 4
                };
            case Ji:
            case rh:
            case Pn:
                return {
                    byteLength: 4,
                    components: 1
                };
            case sp:
                return {
                    byteLength: 4,
                    components: 3
                };
        }
        throw new Error(`Unknown texture type ${i}.`);
    }
    typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
        detail: {
            revision: sh
        }
    }));
    typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = sh);
    function Up() {
        let i = null, e = !1, t = null, n = null;
        function s(r, a) {
            t(r, a), n = i.requestAnimationFrame(s);
        }
        return {
            start: function() {
                e !== !0 && t !== null && (n = i.requestAnimationFrame(s), e = !0);
            },
            stop: function() {
                i.cancelAnimationFrame(n), e = !1;
            },
            setAnimationLoop: function(r) {
                t = r;
            },
            setContext: function(r) {
                i = r;
            }
        };
    }
    function z0(i) {
        const e = new WeakMap;
        function t(o, l) {
            const h = o.array, d = o.usage, c = h.byteLength, u = i.createBuffer();
            i.bindBuffer(l, u), i.bufferData(l, h, d), o.onUploadCallback();
            let f;
            if (h instanceof Float32Array) f = i.FLOAT;
            else if (h instanceof Uint16Array) o.isFloat16BufferAttribute ? f = i.HALF_FLOAT : f = i.UNSIGNED_SHORT;
            else if (h instanceof Int16Array) f = i.SHORT;
            else if (h instanceof Uint32Array) f = i.UNSIGNED_INT;
            else if (h instanceof Int32Array) f = i.INT;
            else if (h instanceof Int8Array) f = i.BYTE;
            else if (h instanceof Uint8Array) f = i.UNSIGNED_BYTE;
            else if (h instanceof Uint8ClampedArray) f = i.UNSIGNED_BYTE;
            else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + h);
            return {
                buffer: u,
                type: f,
                bytesPerElement: h.BYTES_PER_ELEMENT,
                version: o.version,
                size: c
            };
        }
        function n(o, l, h) {
            const d = l.array, c = l.updateRanges;
            if (i.bindBuffer(h, o), c.length === 0) i.bufferSubData(h, 0, d);
            else {
                c.sort((f, _)=>f.start - _.start);
                let u = 0;
                for(let f = 1; f < c.length; f++){
                    const _ = c[u], g = c[f];
                    g.start <= _.start + _.count + 1 ? _.count = Math.max(_.count, g.start + g.count - _.start) : (++u, c[u] = g);
                }
                c.length = u + 1;
                for(let f = 0, _ = c.length; f < _; f++){
                    const g = c[f];
                    i.bufferSubData(h, g.start * d.BYTES_PER_ELEMENT, d, g.start, g.count);
                }
                l.clearUpdateRanges();
            }
            l.onUploadCallback();
        }
        function s(o) {
            return o.isInterleavedBufferAttribute && (o = o.data), e.get(o);
        }
        function r(o) {
            o.isInterleavedBufferAttribute && (o = o.data);
            const l = e.get(o);
            l && (i.deleteBuffer(l.buffer), e.delete(o));
        }
        function a(o, l) {
            if (o.isInterleavedBufferAttribute && (o = o.data), o.isGLBufferAttribute) {
                const d = e.get(o);
                (!d || d.version < o.version) && e.set(o, {
                    buffer: o.buffer,
                    type: o.type,
                    bytesPerElement: o.elementSize,
                    version: o.version
                });
                return;
            }
            const h = e.get(o);
            if (h === void 0) e.set(o, t(o, l));
            else if (h.version < o.version) {
                if (h.size !== o.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
                n(h.buffer, o, l), h.version = o.version;
            }
        }
        return {
            get: s,
            remove: r,
            update: a
        };
    }
    var V0 = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, W0 = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, X0 = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, Y0 = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, j0 = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, q0 = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, $0 = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, K0 = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, Z0 = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`, J0 = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`, Q0 = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, ev = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, tv = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, nv = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, iv = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, sv = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, rv = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, av = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, ov = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, lv = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, cv = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, hv = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`, uv = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`, dv = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, fv = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, pv = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, mv = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, _v = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, gv = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, xv = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, vv = "gl_FragColor = linearToOutputTexel( gl_FragColor );", yv = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, bv = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, Sv = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, Tv = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, Mv = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, Av = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, Ev = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, wv = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, Rv = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, Cv = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, Pv = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, Iv = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, Dv = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, Lv = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, Bv = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, Uv = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, Fv = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, Nv = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, Ov = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, kv = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, Gv = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, Hv = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, zv = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, Vv = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, Wv = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, Xv = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, Yv = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, jv = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, qv = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, $v = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, Kv = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, Zv = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, Jv = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, Qv = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, ey = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, ty = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, ny = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, iy = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, sy = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`, ry = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, ay = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, oy = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, ly = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, cy = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, hy = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, uy = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, dy = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, fy = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, py = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, my = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, _y = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, gy = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, xy = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, vy = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, yy = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, by = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, Sy = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, Ty = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, My = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`, Ay = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, Ey = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, wy = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, Ry = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, Cy = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, Py = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, Iy = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, Dy = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, Ly = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, By = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, Uy = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, Fy = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, Ny = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, Oy = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, ky = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, Gy = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, Hy = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
    const zy = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, Vy = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, Wy = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, Xy = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, Yy = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, jy = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, qy = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, $y = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`, Ky = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, Zy = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, Jy = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, Qy = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, eb = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, tb = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, nb = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, ib = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, sb = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, rb = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, ab = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, ob = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, lb = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, cb = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, hb = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, ub = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, db = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, fb = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, pb = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, mb = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, _b = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, gb = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, xb = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, vb = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, yb = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, bb = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, Ve = {
        alphahash_fragment: V0,
        alphahash_pars_fragment: W0,
        alphamap_fragment: X0,
        alphamap_pars_fragment: Y0,
        alphatest_fragment: j0,
        alphatest_pars_fragment: q0,
        aomap_fragment: $0,
        aomap_pars_fragment: K0,
        batching_pars_vertex: Z0,
        batching_vertex: J0,
        begin_vertex: Q0,
        beginnormal_vertex: ev,
        bsdfs: tv,
        iridescence_fragment: nv,
        bumpmap_pars_fragment: iv,
        clipping_planes_fragment: sv,
        clipping_planes_pars_fragment: rv,
        clipping_planes_pars_vertex: av,
        clipping_planes_vertex: ov,
        color_fragment: lv,
        color_pars_fragment: cv,
        color_pars_vertex: hv,
        color_vertex: uv,
        common: dv,
        cube_uv_reflection_fragment: fv,
        defaultnormal_vertex: pv,
        displacementmap_pars_vertex: mv,
        displacementmap_vertex: _v,
        emissivemap_fragment: gv,
        emissivemap_pars_fragment: xv,
        colorspace_fragment: vv,
        colorspace_pars_fragment: yv,
        envmap_fragment: bv,
        envmap_common_pars_fragment: Sv,
        envmap_pars_fragment: Tv,
        envmap_pars_vertex: Mv,
        envmap_physical_pars_fragment: Uv,
        envmap_vertex: Av,
        fog_vertex: Ev,
        fog_pars_vertex: wv,
        fog_fragment: Rv,
        fog_pars_fragment: Cv,
        gradientmap_pars_fragment: Pv,
        lightmap_pars_fragment: Iv,
        lights_lambert_fragment: Dv,
        lights_lambert_pars_fragment: Lv,
        lights_pars_begin: Bv,
        lights_toon_fragment: Fv,
        lights_toon_pars_fragment: Nv,
        lights_phong_fragment: Ov,
        lights_phong_pars_fragment: kv,
        lights_physical_fragment: Gv,
        lights_physical_pars_fragment: Hv,
        lights_fragment_begin: zv,
        lights_fragment_maps: Vv,
        lights_fragment_end: Wv,
        logdepthbuf_fragment: Xv,
        logdepthbuf_pars_fragment: Yv,
        logdepthbuf_pars_vertex: jv,
        logdepthbuf_vertex: qv,
        map_fragment: $v,
        map_pars_fragment: Kv,
        map_particle_fragment: Zv,
        map_particle_pars_fragment: Jv,
        metalnessmap_fragment: Qv,
        metalnessmap_pars_fragment: ey,
        morphinstance_vertex: ty,
        morphcolor_vertex: ny,
        morphnormal_vertex: iy,
        morphtarget_pars_vertex: sy,
        morphtarget_vertex: ry,
        normal_fragment_begin: ay,
        normal_fragment_maps: oy,
        normal_pars_fragment: ly,
        normal_pars_vertex: cy,
        normal_vertex: hy,
        normalmap_pars_fragment: uy,
        clearcoat_normal_fragment_begin: dy,
        clearcoat_normal_fragment_maps: fy,
        clearcoat_pars_fragment: py,
        iridescence_pars_fragment: my,
        opaque_fragment: _y,
        packing: gy,
        premultiplied_alpha_fragment: xy,
        project_vertex: vy,
        dithering_fragment: yy,
        dithering_pars_fragment: by,
        roughnessmap_fragment: Sy,
        roughnessmap_pars_fragment: Ty,
        shadowmap_pars_fragment: My,
        shadowmap_pars_vertex: Ay,
        shadowmap_vertex: Ey,
        shadowmask_pars_fragment: wy,
        skinbase_vertex: Ry,
        skinning_pars_vertex: Cy,
        skinning_vertex: Py,
        skinnormal_vertex: Iy,
        specularmap_fragment: Dy,
        specularmap_pars_fragment: Ly,
        tonemapping_fragment: By,
        tonemapping_pars_fragment: Uy,
        transmission_fragment: Fy,
        transmission_pars_fragment: Ny,
        uv_pars_fragment: Oy,
        uv_pars_vertex: ky,
        uv_vertex: Gy,
        worldpos_vertex: Hy,
        background_vert: zy,
        background_frag: Vy,
        backgroundCube_vert: Wy,
        backgroundCube_frag: Xy,
        cube_vert: Yy,
        cube_frag: jy,
        depth_vert: qy,
        depth_frag: $y,
        distanceRGBA_vert: Ky,
        distanceRGBA_frag: Zy,
        equirect_vert: Jy,
        equirect_frag: Qy,
        linedashed_vert: eb,
        linedashed_frag: tb,
        meshbasic_vert: nb,
        meshbasic_frag: ib,
        meshlambert_vert: sb,
        meshlambert_frag: rb,
        meshmatcap_vert: ab,
        meshmatcap_frag: ob,
        meshnormal_vert: lb,
        meshnormal_frag: cb,
        meshphong_vert: hb,
        meshphong_frag: ub,
        meshphysical_vert: db,
        meshphysical_frag: fb,
        meshtoon_vert: pb,
        meshtoon_frag: mb,
        points_vert: _b,
        points_frag: gb,
        shadow_vert: xb,
        shadow_frag: vb,
        sprite_vert: yb,
        sprite_frag: bb
    }, ue = {
        common: {
            diffuse: {
                value: new Oe(16777215)
            },
            opacity: {
                value: 1
            },
            map: {
                value: null
            },
            mapTransform: {
                value: new Ge
            },
            alphaMap: {
                value: null
            },
            alphaMapTransform: {
                value: new Ge
            },
            alphaTest: {
                value: 0
            }
        },
        specularmap: {
            specularMap: {
                value: null
            },
            specularMapTransform: {
                value: new Ge
            }
        },
        envmap: {
            envMap: {
                value: null
            },
            envMapRotation: {
                value: new Ge
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1
            },
            ior: {
                value: 1.5
            },
            refractionRatio: {
                value: .98
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            },
            aoMapTransform: {
                value: new Ge
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            },
            lightMapTransform: {
                value: new Ge
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpMapTransform: {
                value: new Ge
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalMapTransform: {
                value: new Ge
            },
            normalScale: {
                value: new Ze(1, 1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementMapTransform: {
                value: new Ge
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            },
            emissiveMapTransform: {
                value: new Ge
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            },
            metalnessMapTransform: {
                value: new Ge
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            },
            roughnessMapTransform: {
                value: new Ge
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 25e-5
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2e3
            },
            fogColor: {
                value: new Oe(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            lightProbe: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {},
                    color: {}
                }
            },
            directionalLightShadows: {
                value: [],
                properties: {
                    shadowIntensity: 1,
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {}
                }
            },
            spotLightShadows: {
                value: [],
                properties: {
                    shadowIntensity: 1,
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotLightMap: {
                value: []
            },
            spotShadowMap: {
                value: []
            },
            spotLightMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {}
                }
            },
            pointLightShadows: {
                value: [],
                properties: {
                    shadowIntensity: 1,
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            },
            rectAreaLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            },
            ltc_1: {
                value: null
            },
            ltc_2: {
                value: null
            }
        },
        points: {
            diffuse: {
                value: new Oe(16777215)
            },
            opacity: {
                value: 1
            },
            size: {
                value: 1
            },
            scale: {
                value: 1
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            alphaMapTransform: {
                value: new Ge
            },
            alphaTest: {
                value: 0
            },
            uvTransform: {
                value: new Ge
            }
        },
        sprite: {
            diffuse: {
                value: new Oe(16777215)
            },
            opacity: {
                value: 1
            },
            center: {
                value: new Ze(.5, .5)
            },
            rotation: {
                value: 0
            },
            map: {
                value: null
            },
            mapTransform: {
                value: new Ge
            },
            alphaMap: {
                value: null
            },
            alphaMapTransform: {
                value: new Ge
            },
            alphaTest: {
                value: 0
            }
        }
    }, kn = {
        basic: {
            uniforms: Yt([
                ue.common,
                ue.specularmap,
                ue.envmap,
                ue.aomap,
                ue.lightmap,
                ue.fog
            ]),
            vertexShader: Ve.meshbasic_vert,
            fragmentShader: Ve.meshbasic_frag
        },
        lambert: {
            uniforms: Yt([
                ue.common,
                ue.specularmap,
                ue.envmap,
                ue.aomap,
                ue.lightmap,
                ue.emissivemap,
                ue.bumpmap,
                ue.normalmap,
                ue.displacementmap,
                ue.fog,
                ue.lights,
                {
                    emissive: {
                        value: new Oe(0)
                    }
                }
            ]),
            vertexShader: Ve.meshlambert_vert,
            fragmentShader: Ve.meshlambert_frag
        },
        phong: {
            uniforms: Yt([
                ue.common,
                ue.specularmap,
                ue.envmap,
                ue.aomap,
                ue.lightmap,
                ue.emissivemap,
                ue.bumpmap,
                ue.normalmap,
                ue.displacementmap,
                ue.fog,
                ue.lights,
                {
                    emissive: {
                        value: new Oe(0)
                    },
                    specular: {
                        value: new Oe(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }
            ]),
            vertexShader: Ve.meshphong_vert,
            fragmentShader: Ve.meshphong_frag
        },
        standard: {
            uniforms: Yt([
                ue.common,
                ue.envmap,
                ue.aomap,
                ue.lightmap,
                ue.emissivemap,
                ue.bumpmap,
                ue.normalmap,
                ue.displacementmap,
                ue.roughnessmap,
                ue.metalnessmap,
                ue.fog,
                ue.lights,
                {
                    emissive: {
                        value: new Oe(0)
                    },
                    roughness: {
                        value: 1
                    },
                    metalness: {
                        value: 0
                    },
                    envMapIntensity: {
                        value: 1
                    }
                }
            ]),
            vertexShader: Ve.meshphysical_vert,
            fragmentShader: Ve.meshphysical_frag
        },
        toon: {
            uniforms: Yt([
                ue.common,
                ue.aomap,
                ue.lightmap,
                ue.emissivemap,
                ue.bumpmap,
                ue.normalmap,
                ue.displacementmap,
                ue.gradientmap,
                ue.fog,
                ue.lights,
                {
                    emissive: {
                        value: new Oe(0)
                    }
                }
            ]),
            vertexShader: Ve.meshtoon_vert,
            fragmentShader: Ve.meshtoon_frag
        },
        matcap: {
            uniforms: Yt([
                ue.common,
                ue.bumpmap,
                ue.normalmap,
                ue.displacementmap,
                ue.fog,
                {
                    matcap: {
                        value: null
                    }
                }
            ]),
            vertexShader: Ve.meshmatcap_vert,
            fragmentShader: Ve.meshmatcap_frag
        },
        points: {
            uniforms: Yt([
                ue.points,
                ue.fog
            ]),
            vertexShader: Ve.points_vert,
            fragmentShader: Ve.points_frag
        },
        dashed: {
            uniforms: Yt([
                ue.common,
                ue.fog,
                {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }
            ]),
            vertexShader: Ve.linedashed_vert,
            fragmentShader: Ve.linedashed_frag
        },
        depth: {
            uniforms: Yt([
                ue.common,
                ue.displacementmap
            ]),
            vertexShader: Ve.depth_vert,
            fragmentShader: Ve.depth_frag
        },
        normal: {
            uniforms: Yt([
                ue.common,
                ue.bumpmap,
                ue.normalmap,
                ue.displacementmap,
                {
                    opacity: {
                        value: 1
                    }
                }
            ]),
            vertexShader: Ve.meshnormal_vert,
            fragmentShader: Ve.meshnormal_frag
        },
        sprite: {
            uniforms: Yt([
                ue.sprite,
                ue.fog
            ]),
            vertexShader: Ve.sprite_vert,
            fragmentShader: Ve.sprite_frag
        },
        background: {
            uniforms: {
                uvTransform: {
                    value: new Ge
                },
                t2D: {
                    value: null
                },
                backgroundIntensity: {
                    value: 1
                }
            },
            vertexShader: Ve.background_vert,
            fragmentShader: Ve.background_frag
        },
        backgroundCube: {
            uniforms: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                },
                backgroundBlurriness: {
                    value: 0
                },
                backgroundIntensity: {
                    value: 1
                },
                backgroundRotation: {
                    value: new Ge
                }
            },
            vertexShader: Ve.backgroundCube_vert,
            fragmentShader: Ve.backgroundCube_frag
        },
        cube: {
            uniforms: {
                tCube: {
                    value: null
                },
                tFlip: {
                    value: -1
                },
                opacity: {
                    value: 1
                }
            },
            vertexShader: Ve.cube_vert,
            fragmentShader: Ve.cube_frag
        },
        equirect: {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: Ve.equirect_vert,
            fragmentShader: Ve.equirect_frag
        },
        distanceRGBA: {
            uniforms: Yt([
                ue.common,
                ue.displacementmap,
                {
                    referencePosition: {
                        value: new k
                    },
                    nearDistance: {
                        value: 1
                    },
                    farDistance: {
                        value: 1e3
                    }
                }
            ]),
            vertexShader: Ve.distanceRGBA_vert,
            fragmentShader: Ve.distanceRGBA_frag
        },
        shadow: {
            uniforms: Yt([
                ue.lights,
                ue.fog,
                {
                    color: {
                        value: new Oe(0)
                    },
                    opacity: {
                        value: 1
                    }
                }
            ]),
            vertexShader: Ve.shadow_vert,
            fragmentShader: Ve.shadow_frag
        }
    };
    kn.physical = {
        uniforms: Yt([
            kn.standard.uniforms,
            {
                clearcoat: {
                    value: 0
                },
                clearcoatMap: {
                    value: null
                },
                clearcoatMapTransform: {
                    value: new Ge
                },
                clearcoatNormalMap: {
                    value: null
                },
                clearcoatNormalMapTransform: {
                    value: new Ge
                },
                clearcoatNormalScale: {
                    value: new Ze(1, 1)
                },
                clearcoatRoughness: {
                    value: 0
                },
                clearcoatRoughnessMap: {
                    value: null
                },
                clearcoatRoughnessMapTransform: {
                    value: new Ge
                },
                dispersion: {
                    value: 0
                },
                iridescence: {
                    value: 0
                },
                iridescenceMap: {
                    value: null
                },
                iridescenceMapTransform: {
                    value: new Ge
                },
                iridescenceIOR: {
                    value: 1.3
                },
                iridescenceThicknessMinimum: {
                    value: 100
                },
                iridescenceThicknessMaximum: {
                    value: 400
                },
                iridescenceThicknessMap: {
                    value: null
                },
                iridescenceThicknessMapTransform: {
                    value: new Ge
                },
                sheen: {
                    value: 0
                },
                sheenColor: {
                    value: new Oe(0)
                },
                sheenColorMap: {
                    value: null
                },
                sheenColorMapTransform: {
                    value: new Ge
                },
                sheenRoughness: {
                    value: 1
                },
                sheenRoughnessMap: {
                    value: null
                },
                sheenRoughnessMapTransform: {
                    value: new Ge
                },
                transmission: {
                    value: 0
                },
                transmissionMap: {
                    value: null
                },
                transmissionMapTransform: {
                    value: new Ge
                },
                transmissionSamplerSize: {
                    value: new Ze
                },
                transmissionSamplerMap: {
                    value: null
                },
                thickness: {
                    value: 0
                },
                thicknessMap: {
                    value: null
                },
                thicknessMapTransform: {
                    value: new Ge
                },
                attenuationDistance: {
                    value: 0
                },
                attenuationColor: {
                    value: new Oe(0)
                },
                specularColor: {
                    value: new Oe(1, 1, 1)
                },
                specularColorMap: {
                    value: null
                },
                specularColorMapTransform: {
                    value: new Ge
                },
                specularIntensity: {
                    value: 1
                },
                specularIntensityMap: {
                    value: null
                },
                specularIntensityMapTransform: {
                    value: new Ge
                },
                anisotropyVector: {
                    value: new Ze
                },
                anisotropyMap: {
                    value: null
                },
                anisotropyMapTransform: {
                    value: new Ge
                }
            }
        ]),
        vertexShader: Ve.meshphysical_vert,
        fragmentShader: Ve.meshphysical_frag
    };
    const Ta = {
        r: 0,
        b: 0,
        g: 0
    }, Fi = new Hn, Sb = new He;
    function Tb(i, e, t, n, s, r, a) {
        const o = new Oe(0);
        let l = r === !0 ? 0 : 1, h, d, c = null, u = 0, f = null;
        function _(v) {
            let y = v.isScene === !0 ? v.background : null;
            return y && y.isTexture && (y = (v.backgroundBlurriness > 0 ? t : e).get(y)), y;
        }
        function g(v) {
            let y = !1;
            const P = _(v);
            P === null ? p(o, l) : P && P.isColor && (p(P, 1), y = !0);
            const w = i.xr.getEnvironmentBlendMode();
            w === "additive" ? n.buffers.color.setClear(0, 0, 0, 1, a) : w === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, a), (i.autoClear || y) && (n.buffers.depth.setTest(!0), n.buffers.depth.setMask(!0), n.buffers.color.setMask(!0), i.clear(i.autoClearColor, i.autoClearDepth, i.autoClearStencil));
        }
        function m(v, y) {
            const P = _(y);
            P && (P.isCubeTexture || P.mapping === ho) ? (d === void 0 && (d = new Nt(new Ks(1, 1, 1), new wi({
                name: "BackgroundCubeMaterial",
                uniforms: zs(kn.backgroundCube.uniforms),
                vertexShader: kn.backgroundCube.vertexShader,
                fragmentShader: kn.backgroundCube.fragmentShader,
                side: tn,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
                allowOverride: !1
            })), d.geometry.deleteAttribute("normal"), d.geometry.deleteAttribute("uv"), d.onBeforeRender = function(w, R, B) {
                this.matrixWorld.copyPosition(B.matrixWorld);
            }, Object.defineProperty(d.material, "envMap", {
                get: function() {
                    return this.uniforms.envMap.value;
                }
            }), s.update(d)), Fi.copy(y.backgroundRotation), Fi.x *= -1, Fi.y *= -1, Fi.z *= -1, P.isCubeTexture && P.isRenderTargetTexture === !1 && (Fi.y *= -1, Fi.z *= -1), d.material.uniforms.envMap.value = P, d.material.uniforms.flipEnvMap.value = P.isCubeTexture && P.isRenderTargetTexture === !1 ? -1 : 1, d.material.uniforms.backgroundBlurriness.value = y.backgroundBlurriness, d.material.uniforms.backgroundIntensity.value = y.backgroundIntensity, d.material.uniforms.backgroundRotation.value.setFromMatrix4(Sb.makeRotationFromEuler(Fi)), d.material.toneMapped = Ke.getTransfer(P.colorSpace) !== ut, (c !== P || u !== P.version || f !== i.toneMapping) && (d.material.needsUpdate = !0, c = P, u = P.version, f = i.toneMapping), d.layers.enableAll(), v.unshift(d, d.geometry, d.material, 0, 0, null)) : P && P.isTexture && (h === void 0 && (h = new Nt(new Zs(2, 2), new wi({
                name: "BackgroundMaterial",
                uniforms: zs(kn.background.uniforms),
                vertexShader: kn.background.vertexShader,
                fragmentShader: kn.background.fragmentShader,
                side: ci,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
                allowOverride: !1
            })), h.geometry.deleteAttribute("normal"), Object.defineProperty(h.material, "map", {
                get: function() {
                    return this.uniforms.t2D.value;
                }
            }), s.update(h)), h.material.uniforms.t2D.value = P, h.material.uniforms.backgroundIntensity.value = y.backgroundIntensity, h.material.toneMapped = Ke.getTransfer(P.colorSpace) !== ut, P.matrixAutoUpdate === !0 && P.updateMatrix(), h.material.uniforms.uvTransform.value.copy(P.matrix), (c !== P || u !== P.version || f !== i.toneMapping) && (h.material.needsUpdate = !0, c = P, u = P.version, f = i.toneMapping), h.layers.enableAll(), v.unshift(h, h.geometry, h.material, 0, 0, null));
        }
        function p(v, y) {
            v.getRGB(Ta, bp(i)), n.buffers.color.setClear(Ta.r, Ta.g, Ta.b, y, a);
        }
        function x() {
            d !== void 0 && (d.geometry.dispose(), d.material.dispose(), d = void 0), h !== void 0 && (h.geometry.dispose(), h.material.dispose(), h = void 0);
        }
        return {
            getClearColor: function() {
                return o;
            },
            setClearColor: function(v, y = 1) {
                o.set(v), l = y, p(o, l);
            },
            getClearAlpha: function() {
                return l;
            },
            setClearAlpha: function(v) {
                l = v, p(o, l);
            },
            render: g,
            addToRenderList: m,
            dispose: x
        };
    }
    function Mb(i, e) {
        const t = i.getParameter(i.MAX_VERTEX_ATTRIBS), n = {}, s = u(null);
        let r = s, a = !1;
        function o(S, D, q, H, $) {
            let ne = !1;
            const b = c(H, q, D);
            r !== b && (r = b, h(r.object)), ne = f(S, H, q, $), ne && _(S, H, q, $), $ !== null && e.update($, i.ELEMENT_ARRAY_BUFFER), (ne || a) && (a = !1, y(S, D, q, H), $ !== null && i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, e.get($).buffer));
        }
        function l() {
            return i.createVertexArray();
        }
        function h(S) {
            return i.bindVertexArray(S);
        }
        function d(S) {
            return i.deleteVertexArray(S);
        }
        function c(S, D, q) {
            const H = q.wireframe === !0;
            let $ = n[S.id];
            $ === void 0 && ($ = {}, n[S.id] = $);
            let ne = $[D.id];
            ne === void 0 && (ne = {}, $[D.id] = ne);
            let b = ne[H];
            return b === void 0 && (b = u(l()), ne[H] = b), b;
        }
        function u(S) {
            const D = [], q = [], H = [];
            for(let $ = 0; $ < t; $++)D[$] = 0, q[$] = 0, H[$] = 0;
            return {
                geometry: null,
                program: null,
                wireframe: !1,
                newAttributes: D,
                enabledAttributes: q,
                attributeDivisors: H,
                object: S,
                attributes: {},
                index: null
            };
        }
        function f(S, D, q, H) {
            const $ = r.attributes, ne = D.attributes;
            let b = 0;
            const C = q.getAttributes();
            for(const E in C)if (C[E].location >= 0) {
                const F = $[E];
                let V = ne[E];
                if (V === void 0 && (E === "instanceMatrix" && S.instanceMatrix && (V = S.instanceMatrix), E === "instanceColor" && S.instanceColor && (V = S.instanceColor)), F === void 0 || F.attribute !== V || V && F.data !== V.data) return !0;
                b++;
            }
            return r.attributesNum !== b || r.index !== H;
        }
        function _(S, D, q, H) {
            const $ = {}, ne = D.attributes;
            let b = 0;
            const C = q.getAttributes();
            for(const E in C)if (C[E].location >= 0) {
                let F = ne[E];
                F === void 0 && (E === "instanceMatrix" && S.instanceMatrix && (F = S.instanceMatrix), E === "instanceColor" && S.instanceColor && (F = S.instanceColor));
                const V = {};
                V.attribute = F, F && F.data && (V.data = F.data), $[E] = V, b++;
            }
            r.attributes = $, r.attributesNum = b, r.index = H;
        }
        function g() {
            const S = r.newAttributes;
            for(let D = 0, q = S.length; D < q; D++)S[D] = 0;
        }
        function m(S) {
            p(S, 0);
        }
        function p(S, D) {
            const q = r.newAttributes, H = r.enabledAttributes, $ = r.attributeDivisors;
            q[S] = 1, H[S] === 0 && (i.enableVertexAttribArray(S), H[S] = 1), $[S] !== D && (i.vertexAttribDivisor(S, D), $[S] = D);
        }
        function x() {
            const S = r.newAttributes, D = r.enabledAttributes;
            for(let q = 0, H = D.length; q < H; q++)D[q] !== S[q] && (i.disableVertexAttribArray(q), D[q] = 0);
        }
        function v(S, D, q, H, $, ne, b) {
            b === !0 ? i.vertexAttribIPointer(S, D, q, $, ne) : i.vertexAttribPointer(S, D, q, H, $, ne);
        }
        function y(S, D, q, H) {
            g();
            const $ = H.attributes, ne = q.getAttributes(), b = D.defaultAttributeValues;
            for(const C in ne){
                const E = ne[C];
                if (E.location >= 0) {
                    let U = $[C];
                    if (U === void 0 && (C === "instanceMatrix" && S.instanceMatrix && (U = S.instanceMatrix), C === "instanceColor" && S.instanceColor && (U = S.instanceColor)), U !== void 0) {
                        const F = U.normalized, V = U.itemSize, j = e.get(U);
                        if (j === void 0) continue;
                        const ie = j.buffer, z = j.type, K = j.bytesPerElement, oe = z === i.INT || z === i.UNSIGNED_INT || U.gpuType === rh;
                        if (U.isInterleavedBufferAttribute) {
                            const se = U.data, ce = se.stride, we = U.offset;
                            if (se.isInstancedInterleavedBuffer) {
                                for(let he = 0; he < E.locationSize; he++)p(E.location + he, se.meshPerAttribute);
                                S.isInstancedMesh !== !0 && H._maxInstanceCount === void 0 && (H._maxInstanceCount = se.meshPerAttribute * se.count);
                            } else for(let he = 0; he < E.locationSize; he++)m(E.location + he);
                            i.bindBuffer(i.ARRAY_BUFFER, ie);
                            for(let he = 0; he < E.locationSize; he++)v(E.location + he, V / E.locationSize, z, F, ce * K, (we + V / E.locationSize * he) * K, oe);
                        } else {
                            if (U.isInstancedBufferAttribute) {
                                for(let se = 0; se < E.locationSize; se++)p(E.location + se, U.meshPerAttribute);
                                S.isInstancedMesh !== !0 && H._maxInstanceCount === void 0 && (H._maxInstanceCount = U.meshPerAttribute * U.count);
                            } else for(let se = 0; se < E.locationSize; se++)m(E.location + se);
                            i.bindBuffer(i.ARRAY_BUFFER, ie);
                            for(let se = 0; se < E.locationSize; se++)v(E.location + se, V / E.locationSize, z, F, V * K, V / E.locationSize * se * K, oe);
                        }
                    } else if (b !== void 0) {
                        const F = b[C];
                        if (F !== void 0) switch(F.length){
                            case 2:
                                i.vertexAttrib2fv(E.location, F);
                                break;
                            case 3:
                                i.vertexAttrib3fv(E.location, F);
                                break;
                            case 4:
                                i.vertexAttrib4fv(E.location, F);
                                break;
                            default:
                                i.vertexAttrib1fv(E.location, F);
                        }
                    }
                }
            }
            x();
        }
        function P() {
            B();
            for(const S in n){
                const D = n[S];
                for(const q in D){
                    const H = D[q];
                    for(const $ in H)d(H[$].object), delete H[$];
                    delete D[q];
                }
                delete n[S];
            }
        }
        function w(S) {
            if (n[S.id] === void 0) return;
            const D = n[S.id];
            for(const q in D){
                const H = D[q];
                for(const $ in H)d(H[$].object), delete H[$];
                delete D[q];
            }
            delete n[S.id];
        }
        function R(S) {
            for(const D in n){
                const q = n[D];
                if (q[S.id] === void 0) continue;
                const H = q[S.id];
                for(const $ in H)d(H[$].object), delete H[$];
                delete q[S.id];
            }
        }
        function B() {
            T(), a = !0, r !== s && (r = s, h(r.object));
        }
        function T() {
            s.geometry = null, s.program = null, s.wireframe = !1;
        }
        return {
            setup: o,
            reset: B,
            resetDefaultState: T,
            dispose: P,
            releaseStatesOfGeometry: w,
            releaseStatesOfProgram: R,
            initAttributes: g,
            enableAttribute: m,
            disableUnusedAttributes: x
        };
    }
    function Ab(i, e, t) {
        let n;
        function s(h) {
            n = h;
        }
        function r(h, d) {
            i.drawArrays(n, h, d), t.update(d, n, 1);
        }
        function a(h, d, c) {
            c !== 0 && (i.drawArraysInstanced(n, h, d, c), t.update(d, n, c));
        }
        function o(h, d, c) {
            if (c === 0) return;
            e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n, h, 0, d, 0, c);
            let f = 0;
            for(let _ = 0; _ < c; _++)f += d[_];
            t.update(f, n, 1);
        }
        function l(h, d, c, u) {
            if (c === 0) return;
            const f = e.get("WEBGL_multi_draw");
            if (f === null) for(let _ = 0; _ < h.length; _++)a(h[_], d[_], u[_]);
            else {
                f.multiDrawArraysInstancedWEBGL(n, h, 0, d, 0, u, 0, c);
                let _ = 0;
                for(let g = 0; g < c; g++)_ += d[g] * u[g];
                t.update(_, n, 1);
            }
        }
        this.setMode = s, this.render = r, this.renderInstances = a, this.renderMultiDraw = o, this.renderMultiDrawInstances = l;
    }
    function Eb(i, e, t, n) {
        let s;
        function r() {
            if (s !== void 0) return s;
            if (e.has("EXT_texture_filter_anisotropic") === !0) {
                const R = e.get("EXT_texture_filter_anisotropic");
                s = i.getParameter(R.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
            } else s = 0;
            return s;
        }
        function a(R) {
            return !(R !== xn && n.convert(R) !== i.getParameter(i.IMPLEMENTATION_COLOR_READ_FORMAT));
        }
        function o(R) {
            const B = R === jr && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
            return !(R !== hi && n.convert(R) !== i.getParameter(i.IMPLEMENTATION_COLOR_READ_TYPE) && R !== Pn && !B);
        }
        function l(R) {
            if (R === "highp") {
                if (i.getShaderPrecisionFormat(i.VERTEX_SHADER, i.HIGH_FLOAT).precision > 0 && i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.HIGH_FLOAT).precision > 0) return "highp";
                R = "mediump";
            }
            return R === "mediump" && i.getShaderPrecisionFormat(i.VERTEX_SHADER, i.MEDIUM_FLOAT).precision > 0 && i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
        }
        let h = t.precision !== void 0 ? t.precision : "highp";
        const d = l(h);
        d !== h && (console.warn("THREE.WebGLRenderer:", h, "not supported, using", d, "instead."), h = d);
        const c = t.logarithmicDepthBuffer === !0, u = t.reverseDepthBuffer === !0 && e.has("EXT_clip_control"), f = i.getParameter(i.MAX_TEXTURE_IMAGE_UNITS), _ = i.getParameter(i.MAX_VERTEX_TEXTURE_IMAGE_UNITS), g = i.getParameter(i.MAX_TEXTURE_SIZE), m = i.getParameter(i.MAX_CUBE_MAP_TEXTURE_SIZE), p = i.getParameter(i.MAX_VERTEX_ATTRIBS), x = i.getParameter(i.MAX_VERTEX_UNIFORM_VECTORS), v = i.getParameter(i.MAX_VARYING_VECTORS), y = i.getParameter(i.MAX_FRAGMENT_UNIFORM_VECTORS), P = _ > 0, w = i.getParameter(i.MAX_SAMPLES);
        return {
            isWebGL2: !0,
            getMaxAnisotropy: r,
            getMaxPrecision: l,
            textureFormatReadable: a,
            textureTypeReadable: o,
            precision: h,
            logarithmicDepthBuffer: c,
            reverseDepthBuffer: u,
            maxTextures: f,
            maxVertexTextures: _,
            maxTextureSize: g,
            maxCubemapSize: m,
            maxAttributes: p,
            maxVertexUniforms: x,
            maxVaryings: v,
            maxFragmentUniforms: y,
            vertexTextures: P,
            maxSamples: w
        };
    }
    function wb(i) {
        const e = this;
        let t = null, n = 0, s = !1, r = !1;
        const a = new Gi, o = new Ge, l = {
            value: null,
            needsUpdate: !1
        };
        this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(c, u) {
            const f = c.length !== 0 || u || n !== 0 || s;
            return s = u, n = c.length, f;
        }, this.beginShadows = function() {
            r = !0, d(null);
        }, this.endShadows = function() {
            r = !1;
        }, this.setGlobalState = function(c, u) {
            t = d(c, u, 0);
        }, this.setState = function(c, u, f) {
            const _ = c.clippingPlanes, g = c.clipIntersection, m = c.clipShadows, p = i.get(c);
            if (!s || _ === null || _.length === 0 || r && !m) r ? d(null) : h();
            else {
                const x = r ? 0 : n, v = x * 4;
                let y = p.clippingState || null;
                l.value = y, y = d(_, u, v, f);
                for(let P = 0; P !== v; ++P)y[P] = t[P];
                p.clippingState = y, this.numIntersection = g ? this.numPlanes : 0, this.numPlanes += x;
            }
        };
        function h() {
            l.value !== t && (l.value = t, l.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0;
        }
        function d(c, u, f, _) {
            const g = c !== null ? c.length : 0;
            let m = null;
            if (g !== 0) {
                if (m = l.value, _ !== !0 || m === null) {
                    const p = f + g * 4, x = u.matrixWorldInverse;
                    o.getNormalMatrix(x), (m === null || m.length < p) && (m = new Float32Array(p));
                    for(let v = 0, y = f; v !== g; ++v, y += 4)a.copy(c[v]).applyMatrix4(x, o), a.normal.toArray(m, y), m[y + 3] = a.constant;
                }
                l.value = m, l.needsUpdate = !0;
            }
            return e.numPlanes = g, e.numIntersection = 0, m;
        }
    }
    function Rb(i) {
        let e = new WeakMap;
        function t(a, o) {
            return o === Kl ? a.mapping = Os : o === Zl && (a.mapping = ks), a;
        }
        function n(a) {
            if (a && a.isTexture) {
                const o = a.mapping;
                if (o === Kl || o === Zl) if (e.has(a)) {
                    const l = e.get(a).texture;
                    return t(l, a.mapping);
                } else {
                    const l = a.image;
                    if (l && l.height > 0) {
                        const h = new jx(l.height);
                        return h.fromEquirectangularTexture(i, a), e.set(a, h), a.addEventListener("dispose", s), t(h.texture, a.mapping);
                    } else return null;
                }
            }
            return a;
        }
        function s(a) {
            const o = a.target;
            o.removeEventListener("dispose", s);
            const l = e.get(o);
            l !== void 0 && (e.delete(o), l.dispose());
        }
        function r() {
            e = new WeakMap;
        }
        return {
            get: n,
            dispose: r
        };
    }
    const Cs = 4, td = [
        .125,
        .215,
        .35,
        .446,
        .526,
        .582
    ], ji = 20, qo = new yh, nd = new Oe;
    let $o = null, Ko = 0, Zo = 0, Jo = !1;
    const Hi = (1 + Math.sqrt(5)) / 2, Ts = 1 / Hi, id = [
        new k(-Hi, Ts, 0),
        new k(Hi, Ts, 0),
        new k(-Ts, 0, Hi),
        new k(Ts, 0, Hi),
        new k(0, Hi, -Ts),
        new k(0, Hi, Ts),
        new k(-1, 1, -1),
        new k(1, 1, -1),
        new k(-1, 1, 1),
        new k(1, 1, 1)
    ], Cb = new k;
    class sd {
        constructor(e){
            this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
        }
        fromScene(e, t = 0, n = .1, s = 100, r = {}) {
            const { size: a = 256, position: o = Cb } = r;
            $o = this._renderer.getRenderTarget(), Ko = this._renderer.getActiveCubeFace(), Zo = this._renderer.getActiveMipmapLevel(), Jo = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(a);
            const l = this._allocateTargets();
            return l.depthBuffer = !0, this._sceneToCubeUV(e, n, s, l, o), t > 0 && this._blur(l, 0, 0, t), this._applyPMREM(l), this._cleanup(l), l;
        }
        fromEquirectangular(e, t = null) {
            return this._fromTexture(e, t);
        }
        fromCubemap(e, t = null) {
            return this._fromTexture(e, t);
        }
        compileCubemapShader() {
            this._cubemapMaterial === null && (this._cubemapMaterial = od(), this._compileMaterial(this._cubemapMaterial));
        }
        compileEquirectangularShader() {
            this._equirectMaterial === null && (this._equirectMaterial = ad(), this._compileMaterial(this._equirectMaterial));
        }
        dispose() {
            this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
        }
        _setSize(e) {
            this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
        }
        _dispose() {
            this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
            for(let e = 0; e < this._lodPlanes.length; e++)this._lodPlanes[e].dispose();
        }
        _cleanup(e) {
            this._renderer.setRenderTarget($o, Ko, Zo), this._renderer.xr.enabled = Jo, e.scissorTest = !1, Ma(e, 0, 0, e.width, e.height);
        }
        _fromTexture(e, t) {
            e.mapping === Os || e.mapping === ks ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), $o = this._renderer.getRenderTarget(), Ko = this._renderer.getActiveCubeFace(), Zo = this._renderer.getActiveMipmapLevel(), Jo = this._renderer.xr.enabled, this._renderer.xr.enabled = !1;
            const n = t || this._allocateTargets();
            return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n;
        }
        _allocateTargets() {
            const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, n = {
                magFilter: cn,
                minFilter: cn,
                generateMipmaps: !1,
                type: jr,
                format: xn,
                colorSpace: Zt,
                depthBuffer: !1
            }, s = rd(e, t, n);
            if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
                this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = rd(e, t, n);
                const { _lodMax: r } = this;
                ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = Pb(r)), this._blurMaterial = Ib(r, e, t);
            }
            return s;
        }
        _compileMaterial(e) {
            const t = new Nt(this._lodPlanes[0], e);
            this._renderer.compile(t, qo);
        }
        _sceneToCubeUV(e, t, n, s, r) {
            const l = new jt(90, 1, t, n), h = [
                1,
                -1,
                1,
                1,
                1,
                1
            ], d = [
                1,
                1,
                1,
                -1,
                -1,
                -1
            ], c = this._renderer, u = c.autoClear, f = c.toneMapping;
            c.getClearColor(nd), c.toneMapping = Mi, c.autoClear = !1;
            const _ = new qi({
                name: "PMREM.Background",
                side: tn,
                depthWrite: !1,
                depthTest: !1
            }), g = new Nt(new Ks, _);
            let m = !1;
            const p = e.background;
            p ? p.isColor && (_.color.copy(p), e.background = null, m = !0) : (_.color.copy(nd), m = !0);
            for(let x = 0; x < 6; x++){
                const v = x % 3;
                v === 0 ? (l.up.set(0, h[x], 0), l.position.set(r.x, r.y, r.z), l.lookAt(r.x + d[x], r.y, r.z)) : v === 1 ? (l.up.set(0, 0, h[x]), l.position.set(r.x, r.y, r.z), l.lookAt(r.x, r.y + d[x], r.z)) : (l.up.set(0, h[x], 0), l.position.set(r.x, r.y, r.z), l.lookAt(r.x, r.y, r.z + d[x]));
                const y = this._cubeSize;
                Ma(s, v * y, x > 2 ? y : 0, y, y), c.setRenderTarget(s), m && c.render(g, l), c.render(e, l);
            }
            g.geometry.dispose(), g.material.dispose(), c.toneMapping = f, c.autoClear = u, e.background = p;
        }
        _textureToCubeUV(e, t) {
            const n = this._renderer, s = e.mapping === Os || e.mapping === ks;
            s ? (this._cubemapMaterial === null && (this._cubemapMaterial = od()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = ad());
            const r = s ? this._cubemapMaterial : this._equirectMaterial, a = new Nt(this._lodPlanes[0], r), o = r.uniforms;
            o.envMap.value = e;
            const l = this._cubeSize;
            Ma(t, 0, 0, 3 * l, 2 * l), n.setRenderTarget(t), n.render(a, qo);
        }
        _applyPMREM(e) {
            const t = this._renderer, n = t.autoClear;
            t.autoClear = !1;
            const s = this._lodPlanes.length;
            for(let r = 1; r < s; r++){
                const a = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1]), o = id[(s - r - 1) % id.length];
                this._blur(e, r - 1, r, a, o);
            }
            t.autoClear = n;
        }
        _blur(e, t, n, s, r) {
            const a = this._pingPongRenderTarget;
            this._halfBlur(e, a, t, n, s, "latitudinal", r), this._halfBlur(a, e, n, n, s, "longitudinal", r);
        }
        _halfBlur(e, t, n, s, r, a, o) {
            const l = this._renderer, h = this._blurMaterial;
            a !== "latitudinal" && a !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
            const d = 3, c = new Nt(this._lodPlanes[s], h), u = h.uniforms, f = this._sizeLods[n] - 1, _ = isFinite(r) ? Math.PI / (2 * f) : 2 * Math.PI / (2 * ji - 1), g = r / _, m = isFinite(r) ? 1 + Math.floor(d * g) : ji;
            m > ji && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${m} samples when the maximum is set to ${ji}`);
            const p = [];
            let x = 0;
            for(let R = 0; R < ji; ++R){
                const B = R / g, T = Math.exp(-B * B / 2);
                p.push(T), R === 0 ? x += T : R < m && (x += 2 * T);
            }
            for(let R = 0; R < p.length; R++)p[R] = p[R] / x;
            u.envMap.value = e.texture, u.samples.value = m, u.weights.value = p, u.latitudinal.value = a === "latitudinal", o && (u.poleAxis.value = o);
            const { _lodMax: v } = this;
            u.dTheta.value = _, u.mipInt.value = v - n;
            const y = this._sizeLods[s], P = 3 * y * (s > v - Cs ? s - v + Cs : 0), w = 4 * (this._cubeSize - y);
            Ma(t, P, w, 3 * y, 2 * y), l.setRenderTarget(t), l.render(c, qo);
        }
    }
    function Pb(i) {
        const e = [], t = [], n = [];
        let s = i;
        const r = i - Cs + 1 + td.length;
        for(let a = 0; a < r; a++){
            const o = Math.pow(2, s);
            t.push(o);
            let l = 1 / o;
            a > i - Cs ? l = td[a - i + Cs - 1] : a === 0 && (l = 0), n.push(l);
            const h = 1 / (o - 2), d = -h, c = 1 + h, u = [
                d,
                d,
                c,
                d,
                c,
                c,
                d,
                d,
                c,
                c,
                d,
                c
            ], f = 6, _ = 6, g = 3, m = 2, p = 1, x = new Float32Array(g * _ * f), v = new Float32Array(m * _ * f), y = new Float32Array(p * _ * f);
            for(let w = 0; w < f; w++){
                const R = w % 3 * 2 / 3 - 1, B = w > 2 ? 0 : -1, T = [
                    R,
                    B,
                    0,
                    R + 2 / 3,
                    B,
                    0,
                    R + 2 / 3,
                    B + 1,
                    0,
                    R,
                    B,
                    0,
                    R + 2 / 3,
                    B + 1,
                    0,
                    R,
                    B + 1,
                    0
                ];
                x.set(T, g * _ * w), v.set(u, m * _ * w);
                const S = [
                    w,
                    w,
                    w,
                    w,
                    w,
                    w
                ];
                y.set(S, p * _ * w);
            }
            const P = new Wn;
            P.setAttribute("position", new Kt(x, g)), P.setAttribute("uv", new Kt(v, m)), P.setAttribute("faceIndex", new Kt(y, p)), e.push(P), s > Cs && s--;
        }
        return {
            lodPlanes: e,
            sizeLods: t,
            sigmas: n
        };
    }
    function rd(i, e, t) {
        const n = new Qi(i, e, t);
        return n.texture.mapping = ho, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n;
    }
    function Ma(i, e, t, n, s) {
        i.viewport.set(e, t, n, s), i.scissor.set(e, t, n, s);
    }
    function Ib(i, e, t) {
        const n = new Float32Array(ji), s = new k(0, 1, 0);
        return new wi({
            name: "SphericalGaussianBlur",
            defines: {
                n: ji,
                CUBEUV_TEXEL_WIDTH: 1 / e,
                CUBEUV_TEXEL_HEIGHT: 1 / t,
                CUBEUV_MAX_MIP: `${i}.0`
            },
            uniforms: {
                envMap: {
                    value: null
                },
                samples: {
                    value: 1
                },
                weights: {
                    value: n
                },
                latitudinal: {
                    value: !1
                },
                dTheta: {
                    value: 0
                },
                mipInt: {
                    value: 0
                },
                poleAxis: {
                    value: s
                }
            },
            vertexShader: Mh(),
            fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
            blending: Ti,
            depthTest: !1,
            depthWrite: !1
        });
    }
    function ad() {
        return new wi({
            name: "EquirectangularToCubeUV",
            uniforms: {
                envMap: {
                    value: null
                }
            },
            vertexShader: Mh(),
            fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
            blending: Ti,
            depthTest: !1,
            depthWrite: !1
        });
    }
    function od() {
        return new wi({
            name: "CubemapToCubeUV",
            uniforms: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                }
            },
            vertexShader: Mh(),
            fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
            blending: Ti,
            depthTest: !1,
            depthWrite: !1
        });
    }
    function Mh() {
        return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
    }
    function Db(i) {
        let e = new WeakMap, t = null;
        function n(o) {
            if (o && o.isTexture) {
                const l = o.mapping, h = l === Kl || l === Zl, d = l === Os || l === ks;
                if (h || d) {
                    let c = e.get(o);
                    const u = c !== void 0 ? c.texture.pmremVersion : 0;
                    if (o.isRenderTargetTexture && o.pmremVersion !== u) return t === null && (t = new sd(i)), c = h ? t.fromEquirectangular(o, c) : t.fromCubemap(o, c), c.texture.pmremVersion = o.pmremVersion, e.set(o, c), c.texture;
                    if (c !== void 0) return c.texture;
                    {
                        const f = o.image;
                        return h && f && f.height > 0 || d && f && s(f) ? (t === null && (t = new sd(i)), c = h ? t.fromEquirectangular(o) : t.fromCubemap(o), c.texture.pmremVersion = o.pmremVersion, e.set(o, c), o.addEventListener("dispose", r), c.texture) : null;
                    }
                }
            }
            return o;
        }
        function s(o) {
            let l = 0;
            const h = 6;
            for(let d = 0; d < h; d++)o[d] !== void 0 && l++;
            return l === h;
        }
        function r(o) {
            const l = o.target;
            l.removeEventListener("dispose", r);
            const h = e.get(l);
            h !== void 0 && (e.delete(l), h.dispose());
        }
        function a() {
            e = new WeakMap, t !== null && (t.dispose(), t = null);
        }
        return {
            get: n,
            dispose: a
        };
    }
    function Lb(i) {
        const e = {};
        function t(n) {
            if (e[n] !== void 0) return e[n];
            let s;
            switch(n){
                case "WEBGL_depth_texture":
                    s = i.getExtension("WEBGL_depth_texture") || i.getExtension("MOZ_WEBGL_depth_texture") || i.getExtension("WEBKIT_WEBGL_depth_texture");
                    break;
                case "EXT_texture_filter_anisotropic":
                    s = i.getExtension("EXT_texture_filter_anisotropic") || i.getExtension("MOZ_EXT_texture_filter_anisotropic") || i.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;
                case "WEBGL_compressed_texture_s3tc":
                    s = i.getExtension("WEBGL_compressed_texture_s3tc") || i.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;
                case "WEBGL_compressed_texture_pvrtc":
                    s = i.getExtension("WEBGL_compressed_texture_pvrtc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;
                default:
                    s = i.getExtension(n);
            }
            return e[n] = s, s;
        }
        return {
            has: function(n) {
                return t(n) !== null;
            },
            init: function() {
                t("EXT_color_buffer_float"), t("WEBGL_clip_cull_distance"), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture"), t("WEBGL_render_shared_exponent");
            },
            get: function(n) {
                const s = t(n);
                return s === null && Wa("THREE.WebGLRenderer: " + n + " extension not supported."), s;
            }
        };
    }
    function Bb(i, e, t, n) {
        const s = {}, r = new WeakMap;
        function a(c) {
            const u = c.target;
            u.index !== null && e.remove(u.index);
            for(const _ in u.attributes)e.remove(u.attributes[_]);
            u.removeEventListener("dispose", a), delete s[u.id];
            const f = r.get(u);
            f && (e.remove(f), r.delete(u)), n.releaseStatesOfGeometry(u), u.isInstancedBufferGeometry === !0 && delete u._maxInstanceCount, t.memory.geometries--;
        }
        function o(c, u) {
            return s[u.id] === !0 || (u.addEventListener("dispose", a), s[u.id] = !0, t.memory.geometries++), u;
        }
        function l(c) {
            const u = c.attributes;
            for(const f in u)e.update(u[f], i.ARRAY_BUFFER);
        }
        function h(c) {
            const u = [], f = c.index, _ = c.attributes.position;
            let g = 0;
            if (f !== null) {
                const x = f.array;
                g = f.version;
                for(let v = 0, y = x.length; v < y; v += 3){
                    const P = x[v + 0], w = x[v + 1], R = x[v + 2];
                    u.push(P, w, w, R, R, P);
                }
            } else if (_ !== void 0) {
                const x = _.array;
                g = _.version;
                for(let v = 0, y = x.length / 3 - 1; v < y; v += 3){
                    const P = v + 0, w = v + 1, R = v + 2;
                    u.push(P, w, w, R, R, P);
                }
            } else return;
            const m = new (mp(u) ? yp : vp)(u, 1);
            m.version = g;
            const p = r.get(c);
            p && e.remove(p), r.set(c, m);
        }
        function d(c) {
            const u = r.get(c);
            if (u) {
                const f = c.index;
                f !== null && u.version < f.version && h(c);
            } else h(c);
            return r.get(c);
        }
        return {
            get: o,
            update: l,
            getWireframeAttribute: d
        };
    }
    function Ub(i, e, t) {
        let n;
        function s(u) {
            n = u;
        }
        let r, a;
        function o(u) {
            r = u.type, a = u.bytesPerElement;
        }
        function l(u, f) {
            i.drawElements(n, f, r, u * a), t.update(f, n, 1);
        }
        function h(u, f, _) {
            _ !== 0 && (i.drawElementsInstanced(n, f, r, u * a, _), t.update(f, n, _));
        }
        function d(u, f, _) {
            if (_ === 0) return;
            e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n, f, 0, r, u, 0, _);
            let m = 0;
            for(let p = 0; p < _; p++)m += f[p];
            t.update(m, n, 1);
        }
        function c(u, f, _, g) {
            if (_ === 0) return;
            const m = e.get("WEBGL_multi_draw");
            if (m === null) for(let p = 0; p < u.length; p++)h(u[p] / a, f[p], g[p]);
            else {
                m.multiDrawElementsInstancedWEBGL(n, f, 0, r, u, 0, g, 0, _);
                let p = 0;
                for(let x = 0; x < _; x++)p += f[x] * g[x];
                t.update(p, n, 1);
            }
        }
        this.setMode = s, this.setIndex = o, this.render = l, this.renderInstances = h, this.renderMultiDraw = d, this.renderMultiDrawInstances = c;
    }
    function Fb(i) {
        const e = {
            geometries: 0,
            textures: 0
        }, t = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
        };
        function n(r, a, o) {
            switch(t.calls++, a){
                case i.TRIANGLES:
                    t.triangles += o * (r / 3);
                    break;
                case i.LINES:
                    t.lines += o * (r / 2);
                    break;
                case i.LINE_STRIP:
                    t.lines += o * (r - 1);
                    break;
                case i.LINE_LOOP:
                    t.lines += o * r;
                    break;
                case i.POINTS:
                    t.points += o * r;
                    break;
                default:
                    console.error("THREE.WebGLInfo: Unknown draw mode:", a);
                    break;
            }
        }
        function s() {
            t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
        }
        return {
            memory: e,
            render: t,
            programs: null,
            autoReset: !0,
            reset: s,
            update: n
        };
    }
    function Nb(i, e, t) {
        const n = new WeakMap, s = new rt;
        function r(a, o, l) {
            const h = a.morphTargetInfluences, d = o.morphAttributes.position || o.morphAttributes.normal || o.morphAttributes.color, c = d !== void 0 ? d.length : 0;
            let u = n.get(o);
            if (u === void 0 || u.count !== c) {
                let T = function() {
                    R.dispose(), n.delete(o), o.removeEventListener("dispose", T);
                };
                u !== void 0 && u.texture.dispose();
                const f = o.morphAttributes.position !== void 0, _ = o.morphAttributes.normal !== void 0, g = o.morphAttributes.color !== void 0, m = o.morphAttributes.position || [], p = o.morphAttributes.normal || [], x = o.morphAttributes.color || [];
                let v = 0;
                f === !0 && (v = 1), _ === !0 && (v = 2), g === !0 && (v = 3);
                let y = o.attributes.position.count * v, P = 1;
                y > e.maxTextureSize && (P = Math.ceil(y / e.maxTextureSize), y = e.maxTextureSize);
                const w = new Float32Array(y * P * 4 * c), R = new _p(w, y, P, c);
                R.type = Pn, R.needsUpdate = !0;
                const B = v * 4;
                for(let S = 0; S < c; S++){
                    const D = m[S], q = p[S], H = x[S], $ = y * P * 4 * S;
                    for(let ne = 0; ne < D.count; ne++){
                        const b = ne * B;
                        f === !0 && (s.fromBufferAttribute(D, ne), w[$ + b + 0] = s.x, w[$ + b + 1] = s.y, w[$ + b + 2] = s.z, w[$ + b + 3] = 0), _ === !0 && (s.fromBufferAttribute(q, ne), w[$ + b + 4] = s.x, w[$ + b + 5] = s.y, w[$ + b + 6] = s.z, w[$ + b + 7] = 0), g === !0 && (s.fromBufferAttribute(H, ne), w[$ + b + 8] = s.x, w[$ + b + 9] = s.y, w[$ + b + 10] = s.z, w[$ + b + 11] = H.itemSize === 4 ? s.w : 1);
                    }
                }
                u = {
                    count: c,
                    texture: R,
                    size: new Ze(y, P)
                }, n.set(o, u), o.addEventListener("dispose", T);
            }
            if (a.isInstancedMesh === !0 && a.morphTexture !== null) l.getUniforms().setValue(i, "morphTexture", a.morphTexture, t);
            else {
                let f = 0;
                for(let g = 0; g < h.length; g++)f += h[g];
                const _ = o.morphTargetsRelative ? 1 : 1 - f;
                l.getUniforms().setValue(i, "morphTargetBaseInfluence", _), l.getUniforms().setValue(i, "morphTargetInfluences", h);
            }
            l.getUniforms().setValue(i, "morphTargetsTexture", u.texture, t), l.getUniforms().setValue(i, "morphTargetsTextureSize", u.size);
        }
        return {
            update: r
        };
    }
    function Ob(i, e, t, n) {
        let s = new WeakMap;
        function r(l) {
            const h = n.render.frame, d = l.geometry, c = e.get(l, d);
            if (s.get(c) !== h && (e.update(c), s.set(c, h)), l.isInstancedMesh && (l.hasEventListener("dispose", o) === !1 && l.addEventListener("dispose", o), s.get(l) !== h && (t.update(l.instanceMatrix, i.ARRAY_BUFFER), l.instanceColor !== null && t.update(l.instanceColor, i.ARRAY_BUFFER), s.set(l, h))), l.isSkinnedMesh) {
                const u = l.skeleton;
                s.get(u) !== h && (u.update(), s.set(u, h));
            }
            return c;
        }
        function a() {
            s = new WeakMap;
        }
        function o(l) {
            const h = l.target;
            h.removeEventListener("dispose", o), t.remove(h.instanceMatrix), h.instanceColor !== null && t.remove(h.instanceColor);
        }
        return {
            update: r,
            dispose: a
        };
    }
    const Fp = new nn, ld = new Rp(1, 1), Np = new _p, Op = new Px, kp = new Tp, cd = [], hd = [], ud = new Float32Array(16), dd = new Float32Array(9), fd = new Float32Array(4);
    function tr(i, e, t) {
        const n = i[0];
        if (n <= 0 || n > 0) return i;
        const s = e * t;
        let r = cd[s];
        if (r === void 0 && (r = new Float32Array(s), cd[s] = r), e !== 0) {
            n.toArray(r, 0);
            for(let a = 1, o = 0; a !== e; ++a)o += t, i[a].toArray(r, o);
        }
        return r;
    }
    function Pt(i, e) {
        if (i.length !== e.length) return !1;
        for(let t = 0, n = i.length; t < n; t++)if (i[t] !== e[t]) return !1;
        return !0;
    }
    function It(i, e) {
        for(let t = 0, n = e.length; t < n; t++)i[t] = e[t];
    }
    function po(i, e) {
        let t = hd[e];
        t === void 0 && (t = new Int32Array(e), hd[e] = t);
        for(let n = 0; n !== e; ++n)t[n] = i.allocateTextureUnit();
        return t;
    }
    function kb(i, e) {
        const t = this.cache;
        t[0] !== e && (i.uniform1f(this.addr, e), t[0] = e);
    }
    function Gb(i, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (i.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
        else {
            if (Pt(t, e)) return;
            i.uniform2fv(this.addr, e), It(t, e);
        }
    }
    function Hb(i, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (i.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
        else if (e.r !== void 0) (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (i.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
        else {
            if (Pt(t, e)) return;
            i.uniform3fv(this.addr, e), It(t, e);
        }
    }
    function zb(i, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (i.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
        else {
            if (Pt(t, e)) return;
            i.uniform4fv(this.addr, e), It(t, e);
        }
    }
    function Vb(i, e) {
        const t = this.cache, n = e.elements;
        if (n === void 0) {
            if (Pt(t, e)) return;
            i.uniformMatrix2fv(this.addr, !1, e), It(t, e);
        } else {
            if (Pt(t, n)) return;
            fd.set(n), i.uniformMatrix2fv(this.addr, !1, fd), It(t, n);
        }
    }
    function Wb(i, e) {
        const t = this.cache, n = e.elements;
        if (n === void 0) {
            if (Pt(t, e)) return;
            i.uniformMatrix3fv(this.addr, !1, e), It(t, e);
        } else {
            if (Pt(t, n)) return;
            dd.set(n), i.uniformMatrix3fv(this.addr, !1, dd), It(t, n);
        }
    }
    function Xb(i, e) {
        const t = this.cache, n = e.elements;
        if (n === void 0) {
            if (Pt(t, e)) return;
            i.uniformMatrix4fv(this.addr, !1, e), It(t, e);
        } else {
            if (Pt(t, n)) return;
            ud.set(n), i.uniformMatrix4fv(this.addr, !1, ud), It(t, n);
        }
    }
    function Yb(i, e) {
        const t = this.cache;
        t[0] !== e && (i.uniform1i(this.addr, e), t[0] = e);
    }
    function jb(i, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (i.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
        else {
            if (Pt(t, e)) return;
            i.uniform2iv(this.addr, e), It(t, e);
        }
    }
    function qb(i, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (i.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
        else {
            if (Pt(t, e)) return;
            i.uniform3iv(this.addr, e), It(t, e);
        }
    }
    function $b(i, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (i.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
        else {
            if (Pt(t, e)) return;
            i.uniform4iv(this.addr, e), It(t, e);
        }
    }
    function Kb(i, e) {
        const t = this.cache;
        t[0] !== e && (i.uniform1ui(this.addr, e), t[0] = e);
    }
    function Zb(i, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (i.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
        else {
            if (Pt(t, e)) return;
            i.uniform2uiv(this.addr, e), It(t, e);
        }
    }
    function Jb(i, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (i.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
        else {
            if (Pt(t, e)) return;
            i.uniform3uiv(this.addr, e), It(t, e);
        }
    }
    function Qb(i, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (i.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
        else {
            if (Pt(t, e)) return;
            i.uniform4uiv(this.addr, e), It(t, e);
        }
    }
    function eS(i, e, t) {
        const n = this.cache, s = t.allocateTextureUnit();
        n[0] !== s && (i.uniform1i(this.addr, s), n[0] = s);
        let r;
        this.type === i.SAMPLER_2D_SHADOW ? (ld.compareFunction = pp, r = ld) : r = Fp, t.setTexture2D(e || r, s);
    }
    function tS(i, e, t) {
        const n = this.cache, s = t.allocateTextureUnit();
        n[0] !== s && (i.uniform1i(this.addr, s), n[0] = s), t.setTexture3D(e || Op, s);
    }
    function nS(i, e, t) {
        const n = this.cache, s = t.allocateTextureUnit();
        n[0] !== s && (i.uniform1i(this.addr, s), n[0] = s), t.setTextureCube(e || kp, s);
    }
    function iS(i, e, t) {
        const n = this.cache, s = t.allocateTextureUnit();
        n[0] !== s && (i.uniform1i(this.addr, s), n[0] = s), t.setTexture2DArray(e || Np, s);
    }
    function sS(i) {
        switch(i){
            case 5126:
                return kb;
            case 35664:
                return Gb;
            case 35665:
                return Hb;
            case 35666:
                return zb;
            case 35674:
                return Vb;
            case 35675:
                return Wb;
            case 35676:
                return Xb;
            case 5124:
            case 35670:
                return Yb;
            case 35667:
            case 35671:
                return jb;
            case 35668:
            case 35672:
                return qb;
            case 35669:
            case 35673:
                return $b;
            case 5125:
                return Kb;
            case 36294:
                return Zb;
            case 36295:
                return Jb;
            case 36296:
                return Qb;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
                return eS;
            case 35679:
            case 36299:
            case 36307:
                return tS;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
                return nS;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
                return iS;
        }
    }
    function rS(i, e) {
        i.uniform1fv(this.addr, e);
    }
    function aS(i, e) {
        const t = tr(e, this.size, 2);
        i.uniform2fv(this.addr, t);
    }
    function oS(i, e) {
        const t = tr(e, this.size, 3);
        i.uniform3fv(this.addr, t);
    }
    function lS(i, e) {
        const t = tr(e, this.size, 4);
        i.uniform4fv(this.addr, t);
    }
    function cS(i, e) {
        const t = tr(e, this.size, 4);
        i.uniformMatrix2fv(this.addr, !1, t);
    }
    function hS(i, e) {
        const t = tr(e, this.size, 9);
        i.uniformMatrix3fv(this.addr, !1, t);
    }
    function uS(i, e) {
        const t = tr(e, this.size, 16);
        i.uniformMatrix4fv(this.addr, !1, t);
    }
    function dS(i, e) {
        i.uniform1iv(this.addr, e);
    }
    function fS(i, e) {
        i.uniform2iv(this.addr, e);
    }
    function pS(i, e) {
        i.uniform3iv(this.addr, e);
    }
    function mS(i, e) {
        i.uniform4iv(this.addr, e);
    }
    function _S(i, e) {
        i.uniform1uiv(this.addr, e);
    }
    function gS(i, e) {
        i.uniform2uiv(this.addr, e);
    }
    function xS(i, e) {
        i.uniform3uiv(this.addr, e);
    }
    function vS(i, e) {
        i.uniform4uiv(this.addr, e);
    }
    function yS(i, e, t) {
        const n = this.cache, s = e.length, r = po(t, s);
        Pt(n, r) || (i.uniform1iv(this.addr, r), It(n, r));
        for(let a = 0; a !== s; ++a)t.setTexture2D(e[a] || Fp, r[a]);
    }
    function bS(i, e, t) {
        const n = this.cache, s = e.length, r = po(t, s);
        Pt(n, r) || (i.uniform1iv(this.addr, r), It(n, r));
        for(let a = 0; a !== s; ++a)t.setTexture3D(e[a] || Op, r[a]);
    }
    function SS(i, e, t) {
        const n = this.cache, s = e.length, r = po(t, s);
        Pt(n, r) || (i.uniform1iv(this.addr, r), It(n, r));
        for(let a = 0; a !== s; ++a)t.setTextureCube(e[a] || kp, r[a]);
    }
    function TS(i, e, t) {
        const n = this.cache, s = e.length, r = po(t, s);
        Pt(n, r) || (i.uniform1iv(this.addr, r), It(n, r));
        for(let a = 0; a !== s; ++a)t.setTexture2DArray(e[a] || Np, r[a]);
    }
    function MS(i) {
        switch(i){
            case 5126:
                return rS;
            case 35664:
                return aS;
            case 35665:
                return oS;
            case 35666:
                return lS;
            case 35674:
                return cS;
            case 35675:
                return hS;
            case 35676:
                return uS;
            case 5124:
            case 35670:
                return dS;
            case 35667:
            case 35671:
                return fS;
            case 35668:
            case 35672:
                return pS;
            case 35669:
            case 35673:
                return mS;
            case 5125:
                return _S;
            case 36294:
                return gS;
            case 36295:
                return xS;
            case 36296:
                return vS;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
                return yS;
            case 35679:
            case 36299:
            case 36307:
                return bS;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
                return SS;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
                return TS;
        }
    }
    class AS {
        constructor(e, t, n){
            this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.setValue = sS(t.type);
        }
    }
    class ES {
        constructor(e, t, n){
            this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = MS(t.type);
        }
    }
    class wS {
        constructor(e){
            this.id = e, this.seq = [], this.map = {};
        }
        setValue(e, t, n) {
            const s = this.seq;
            for(let r = 0, a = s.length; r !== a; ++r){
                const o = s[r];
                o.setValue(e, t[o.id], n);
            }
        }
    }
    const Qo = /(\w+)(\])?(\[|\.)?/g;
    function pd(i, e) {
        i.seq.push(e), i.map[e.id] = e;
    }
    function RS(i, e, t) {
        const n = i.name, s = n.length;
        for(Qo.lastIndex = 0;;){
            const r = Qo.exec(n), a = Qo.lastIndex;
            let o = r[1];
            const l = r[2] === "]", h = r[3];
            if (l && (o = o | 0), h === void 0 || h === "[" && a + 2 === s) {
                pd(t, h === void 0 ? new AS(o, i, e) : new ES(o, i, e));
                break;
            } else {
                let c = t.map[o];
                c === void 0 && (c = new wS(o), pd(t, c)), t = c;
            }
        }
    }
    class Ya {
        constructor(e, t){
            this.seq = [], this.map = {};
            const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
            for(let s = 0; s < n; ++s){
                const r = e.getActiveUniform(t, s), a = e.getUniformLocation(t, r.name);
                RS(r, a, this);
            }
        }
        setValue(e, t, n, s) {
            const r = this.map[t];
            r !== void 0 && r.setValue(e, n, s);
        }
        setOptional(e, t, n) {
            const s = t[n];
            s !== void 0 && this.setValue(e, n, s);
        }
        static upload(e, t, n, s) {
            for(let r = 0, a = t.length; r !== a; ++r){
                const o = t[r], l = n[o.id];
                l.needsUpdate !== !1 && o.setValue(e, l.value, s);
            }
        }
        static seqWithValue(e, t) {
            const n = [];
            for(let s = 0, r = e.length; s !== r; ++s){
                const a = e[s];
                a.id in t && n.push(a);
            }
            return n;
        }
    }
    function md(i, e, t) {
        const n = i.createShader(e);
        return i.shaderSource(n, t), i.compileShader(n), n;
    }
    const CS = 37297;
    let PS = 0;
    function IS(i, e) {
        const t = i.split(`
`), n = [], s = Math.max(e - 6, 0), r = Math.min(e + 6, t.length);
        for(let a = s; a < r; a++){
            const o = a + 1;
            n.push(`${o === e ? ">" : " "} ${o}: ${t[a]}`);
        }
        return n.join(`
`);
    }
    const _d = new Ge;
    function DS(i) {
        Ke._getMatrix(_d, Ke.workingColorSpace, i);
        const e = `mat3( ${_d.elements.map((t)=>t.toFixed(4))} )`;
        switch(Ke.getTransfer(i)){
            case eo:
                return [
                    e,
                    "LinearTransferOETF"
                ];
            case ut:
                return [
                    e,
                    "sRGBTransferOETF"
                ];
            default:
                return console.warn("THREE.WebGLProgram: Unsupported color space: ", i), [
                    e,
                    "LinearTransferOETF"
                ];
        }
    }
    function gd(i, e, t) {
        const n = i.getShaderParameter(e, i.COMPILE_STATUS), s = i.getShaderInfoLog(e).trim();
        if (n && s === "") return "";
        const r = /ERROR: 0:(\d+)/.exec(s);
        if (r) {
            const a = parseInt(r[1]);
            return t.toUpperCase() + `

` + s + `

` + IS(i.getShaderSource(e), a);
        } else return s;
    }
    function LS(i, e) {
        const t = DS(e);
        return [
            `vec4 ${i}( vec4 value ) {`,
            `	return ${t[1]}( vec4( value.rgb * ${t[0]}, value.a ) );`,
            "}"
        ].join(`
`);
    }
    function BS(i, e) {
        let t;
        switch(e){
            case Fg:
                t = "Linear";
                break;
            case Ng:
                t = "Reinhard";
                break;
            case Og:
                t = "Cineon";
                break;
            case kg:
                t = "ACESFilmic";
                break;
            case Hg:
                t = "AgX";
                break;
            case zg:
                t = "Neutral";
                break;
            case Gg:
                t = "Custom";
                break;
            default:
                console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear";
        }
        return "vec3 " + i + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
    }
    const Aa = new k;
    function US() {
        Ke.getLuminanceCoefficients(Aa);
        const i = Aa.x.toFixed(4), e = Aa.y.toFixed(4), t = Aa.z.toFixed(4);
        return [
            "float luminance( const in vec3 rgb ) {",
            `	const vec3 weights = vec3( ${i}, ${e}, ${t} );`,
            "	return dot( weights, rgb );",
            "}"
        ].join(`
`);
    }
    function FS(i) {
        return [
            i.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
            i.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
        ].filter(Mr).join(`
`);
    }
    function NS(i) {
        const e = [];
        for(const t in i){
            const n = i[t];
            n !== !1 && e.push("#define " + t + " " + n);
        }
        return e.join(`
`);
    }
    function OS(i, e) {
        const t = {}, n = i.getProgramParameter(e, i.ACTIVE_ATTRIBUTES);
        for(let s = 0; s < n; s++){
            const r = i.getActiveAttrib(e, s), a = r.name;
            let o = 1;
            r.type === i.FLOAT_MAT2 && (o = 2), r.type === i.FLOAT_MAT3 && (o = 3), r.type === i.FLOAT_MAT4 && (o = 4), t[a] = {
                type: r.type,
                location: i.getAttribLocation(e, a),
                locationSize: o
            };
        }
        return t;
    }
    function Mr(i) {
        return i !== "";
    }
    function xd(i, e) {
        const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
        return i.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
    }
    function vd(i, e) {
        return i.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
    }
    const kS = /^[ \t]*#include +<([\w\d./]+)>/gm;
    function Cc(i) {
        return i.replace(kS, HS);
    }
    const GS = new Map;
    function HS(i, e) {
        let t = Ve[e];
        if (t === void 0) {
            const n = GS.get(e);
            if (n !== void 0) t = Ve[n], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, n);
            else throw new Error("Can not resolve #include <" + e + ">");
        }
        return Cc(t);
    }
    const zS = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
    function yd(i) {
        return i.replace(zS, VS);
    }
    function VS(i, e, t, n) {
        let s = "";
        for(let r = parseInt(e); r < parseInt(t); r++)s += n.replace(/\[\s*i\s*\]/g, "[ " + r + " ]").replace(/UNROLLED_LOOP_INDEX/g, r);
        return s;
    }
    function bd(i) {
        let e = `precision ${i.precision} float;
	precision ${i.precision} int;
	precision ${i.precision} sampler2D;
	precision ${i.precision} samplerCube;
	precision ${i.precision} sampler3D;
	precision ${i.precision} sampler2DArray;
	precision ${i.precision} sampler2DShadow;
	precision ${i.precision} samplerCubeShadow;
	precision ${i.precision} sampler2DArrayShadow;
	precision ${i.precision} isampler2D;
	precision ${i.precision} isampler3D;
	precision ${i.precision} isamplerCube;
	precision ${i.precision} isampler2DArray;
	precision ${i.precision} usampler2D;
	precision ${i.precision} usampler3D;
	precision ${i.precision} usamplerCube;
	precision ${i.precision} usampler2DArray;
	`;
        return i.precision === "highp" ? e += `
#define HIGH_PRECISION` : i.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : i.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
    }
    function WS(i) {
        let e = "SHADOWMAP_TYPE_BASIC";
        return i.shadowMapType === Jf ? e = "SHADOWMAP_TYPE_PCF" : i.shadowMapType === mg ? e = "SHADOWMAP_TYPE_PCF_SOFT" : i.shadowMapType === ei && (e = "SHADOWMAP_TYPE_VSM"), e;
    }
    function XS(i) {
        let e = "ENVMAP_TYPE_CUBE";
        if (i.envMap) switch(i.envMapMode){
            case Os:
            case ks:
                e = "ENVMAP_TYPE_CUBE";
                break;
            case ho:
                e = "ENVMAP_TYPE_CUBE_UV";
                break;
        }
        return e;
    }
    function YS(i) {
        let e = "ENVMAP_MODE_REFLECTION";
        if (i.envMap) switch(i.envMapMode){
            case ks:
                e = "ENVMAP_MODE_REFRACTION";
                break;
        }
        return e;
    }
    function jS(i) {
        let e = "ENVMAP_BLENDING_NONE";
        if (i.envMap) switch(i.combine){
            case Qf:
                e = "ENVMAP_BLENDING_MULTIPLY";
                break;
            case Bg:
                e = "ENVMAP_BLENDING_MIX";
                break;
            case Ug:
                e = "ENVMAP_BLENDING_ADD";
                break;
        }
        return e;
    }
    function qS(i) {
        const e = i.envMapCubeUVHeight;
        if (e === null) return null;
        const t = Math.log2(e) - 2, n = 1 / e;
        return {
            texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
            texelHeight: n,
            maxMip: t
        };
    }
    function $S(i, e, t, n) {
        const s = i.getContext(), r = t.defines;
        let a = t.vertexShader, o = t.fragmentShader;
        const l = WS(t), h = XS(t), d = YS(t), c = jS(t), u = qS(t), f = FS(t), _ = NS(r), g = s.createProgram();
        let m, p, x = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
        t.isRawShaderMaterial ? (m = [
            "#define SHADER_TYPE " + t.shaderType,
            "#define SHADER_NAME " + t.shaderName,
            _
        ].filter(Mr).join(`
`), m.length > 0 && (m += `
`), p = [
            "#define SHADER_TYPE " + t.shaderType,
            "#define SHADER_NAME " + t.shaderName,
            _
        ].filter(Mr).join(`
`), p.length > 0 && (p += `
`)) : (m = [
            bd(t),
            "#define SHADER_TYPE " + t.shaderType,
            "#define SHADER_NAME " + t.shaderName,
            _,
            t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
            t.batching ? "#define USE_BATCHING" : "",
            t.batchingColor ? "#define USE_BATCHING_COLOR" : "",
            t.instancing ? "#define USE_INSTANCING" : "",
            t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
            t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
            t.useFog && t.fog ? "#define USE_FOG" : "",
            t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
            t.map ? "#define USE_MAP" : "",
            t.envMap ? "#define USE_ENVMAP" : "",
            t.envMap ? "#define " + d : "",
            t.lightMap ? "#define USE_LIGHTMAP" : "",
            t.aoMap ? "#define USE_AOMAP" : "",
            t.bumpMap ? "#define USE_BUMPMAP" : "",
            t.normalMap ? "#define USE_NORMALMAP" : "",
            t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
            t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
            t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
            t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
            t.anisotropy ? "#define USE_ANISOTROPY" : "",
            t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
            t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
            t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
            t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
            t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
            t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
            t.specularMap ? "#define USE_SPECULARMAP" : "",
            t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
            t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
            t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
            t.metalnessMap ? "#define USE_METALNESSMAP" : "",
            t.alphaMap ? "#define USE_ALPHAMAP" : "",
            t.alphaHash ? "#define USE_ALPHAHASH" : "",
            t.transmission ? "#define USE_TRANSMISSION" : "",
            t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
            t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
            t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
            t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
            t.mapUv ? "#define MAP_UV " + t.mapUv : "",
            t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
            t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
            t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
            t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
            t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
            t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
            t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "",
            t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
            t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
            t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "",
            t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
            t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "",
            t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "",
            t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "",
            t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "",
            t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "",
            t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "",
            t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
            t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "",
            t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "",
            t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "",
            t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
            t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
            t.vertexColors ? "#define USE_COLOR" : "",
            t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
            t.vertexUv1s ? "#define USE_UV1" : "",
            t.vertexUv2s ? "#define USE_UV2" : "",
            t.vertexUv3s ? "#define USE_UV3" : "",
            t.pointsUvs ? "#define USE_POINTS_UV" : "",
            t.flatShading ? "#define FLAT_SHADED" : "",
            t.skinning ? "#define USE_SKINNING" : "",
            t.morphTargets ? "#define USE_MORPHTARGETS" : "",
            t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
            t.morphColors ? "#define USE_MORPHCOLORS" : "",
            t.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "",
            t.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "",
            t.doubleSided ? "#define DOUBLE_SIDED" : "",
            t.flipSided ? "#define FLIP_SIDED" : "",
            t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
            t.shadowMapEnabled ? "#define " + l : "",
            t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
            t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
            t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
            t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
            "uniform mat4 modelMatrix;",
            "uniform mat4 modelViewMatrix;",
            "uniform mat4 projectionMatrix;",
            "uniform mat4 viewMatrix;",
            "uniform mat3 normalMatrix;",
            "uniform vec3 cameraPosition;",
            "uniform bool isOrthographic;",
            "#ifdef USE_INSTANCING",
            "	attribute mat4 instanceMatrix;",
            "#endif",
            "#ifdef USE_INSTANCING_COLOR",
            "	attribute vec3 instanceColor;",
            "#endif",
            "#ifdef USE_INSTANCING_MORPH",
            "	uniform sampler2D morphTexture;",
            "#endif",
            "attribute vec3 position;",
            "attribute vec3 normal;",
            "attribute vec2 uv;",
            "#ifdef USE_UV1",
            "	attribute vec2 uv1;",
            "#endif",
            "#ifdef USE_UV2",
            "	attribute vec2 uv2;",
            "#endif",
            "#ifdef USE_UV3",
            "	attribute vec2 uv3;",
            "#endif",
            "#ifdef USE_TANGENT",
            "	attribute vec4 tangent;",
            "#endif",
            "#if defined( USE_COLOR_ALPHA )",
            "	attribute vec4 color;",
            "#elif defined( USE_COLOR )",
            "	attribute vec3 color;",
            "#endif",
            "#ifdef USE_SKINNING",
            "	attribute vec4 skinIndex;",
            "	attribute vec4 skinWeight;",
            "#endif",
            `
`
        ].filter(Mr).join(`
`), p = [
            bd(t),
            "#define SHADER_TYPE " + t.shaderType,
            "#define SHADER_NAME " + t.shaderName,
            _,
            t.useFog && t.fog ? "#define USE_FOG" : "",
            t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
            t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
            t.map ? "#define USE_MAP" : "",
            t.matcap ? "#define USE_MATCAP" : "",
            t.envMap ? "#define USE_ENVMAP" : "",
            t.envMap ? "#define " + h : "",
            t.envMap ? "#define " + d : "",
            t.envMap ? "#define " + c : "",
            u ? "#define CUBEUV_TEXEL_WIDTH " + u.texelWidth : "",
            u ? "#define CUBEUV_TEXEL_HEIGHT " + u.texelHeight : "",
            u ? "#define CUBEUV_MAX_MIP " + u.maxMip + ".0" : "",
            t.lightMap ? "#define USE_LIGHTMAP" : "",
            t.aoMap ? "#define USE_AOMAP" : "",
            t.bumpMap ? "#define USE_BUMPMAP" : "",
            t.normalMap ? "#define USE_NORMALMAP" : "",
            t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
            t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
            t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
            t.anisotropy ? "#define USE_ANISOTROPY" : "",
            t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
            t.clearcoat ? "#define USE_CLEARCOAT" : "",
            t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
            t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
            t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
            t.dispersion ? "#define USE_DISPERSION" : "",
            t.iridescence ? "#define USE_IRIDESCENCE" : "",
            t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
            t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
            t.specularMap ? "#define USE_SPECULARMAP" : "",
            t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
            t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
            t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
            t.metalnessMap ? "#define USE_METALNESSMAP" : "",
            t.alphaMap ? "#define USE_ALPHAMAP" : "",
            t.alphaTest ? "#define USE_ALPHATEST" : "",
            t.alphaHash ? "#define USE_ALPHAHASH" : "",
            t.sheen ? "#define USE_SHEEN" : "",
            t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
            t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
            t.transmission ? "#define USE_TRANSMISSION" : "",
            t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
            t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
            t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
            t.vertexColors || t.instancingColor || t.batchingColor ? "#define USE_COLOR" : "",
            t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
            t.vertexUv1s ? "#define USE_UV1" : "",
            t.vertexUv2s ? "#define USE_UV2" : "",
            t.vertexUv3s ? "#define USE_UV3" : "",
            t.pointsUvs ? "#define USE_POINTS_UV" : "",
            t.gradientMap ? "#define USE_GRADIENTMAP" : "",
            t.flatShading ? "#define FLAT_SHADED" : "",
            t.doubleSided ? "#define DOUBLE_SIDED" : "",
            t.flipSided ? "#define FLIP_SIDED" : "",
            t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
            t.shadowMapEnabled ? "#define " + l : "",
            t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
            t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
            t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
            t.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "",
            t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
            t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
            "uniform mat4 viewMatrix;",
            "uniform vec3 cameraPosition;",
            "uniform bool isOrthographic;",
            t.toneMapping !== Mi ? "#define TONE_MAPPING" : "",
            t.toneMapping !== Mi ? Ve.tonemapping_pars_fragment : "",
            t.toneMapping !== Mi ? BS("toneMapping", t.toneMapping) : "",
            t.dithering ? "#define DITHERING" : "",
            t.opaque ? "#define OPAQUE" : "",
            Ve.colorspace_pars_fragment,
            LS("linearToOutputTexel", t.outputColorSpace),
            US(),
            t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
            `
`
        ].filter(Mr).join(`
`)), a = Cc(a), a = xd(a, t), a = vd(a, t), o = Cc(o), o = xd(o, t), o = vd(o, t), a = yd(a), o = yd(o), t.isRawShaderMaterial !== !0 && (x = `#version 300 es
`, m = [
            f,
            "#define attribute in",
            "#define varying out",
            "#define texture2D texture"
        ].join(`
`) + `
` + m, p = [
            "#define varying in",
            t.glslVersion === _u ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
            t.glslVersion === _u ? "" : "#define gl_FragColor pc_fragColor",
            "#define gl_FragDepthEXT gl_FragDepth",
            "#define texture2D texture",
            "#define textureCube texture",
            "#define texture2DProj textureProj",
            "#define texture2DLodEXT textureLod",
            "#define texture2DProjLodEXT textureProjLod",
            "#define textureCubeLodEXT textureLod",
            "#define texture2DGradEXT textureGrad",
            "#define texture2DProjGradEXT textureProjGrad",
            "#define textureCubeGradEXT textureGrad"
        ].join(`
`) + `
` + p);
        const v = x + m + a, y = x + p + o, P = md(s, s.VERTEX_SHADER, v), w = md(s, s.FRAGMENT_SHADER, y);
        s.attachShader(g, P), s.attachShader(g, w), t.index0AttributeName !== void 0 ? s.bindAttribLocation(g, 0, t.index0AttributeName) : t.morphTargets === !0 && s.bindAttribLocation(g, 0, "position"), s.linkProgram(g);
        function R(D) {
            if (i.debug.checkShaderErrors) {
                const q = s.getProgramInfoLog(g).trim(), H = s.getShaderInfoLog(P).trim(), $ = s.getShaderInfoLog(w).trim();
                let ne = !0, b = !0;
                if (s.getProgramParameter(g, s.LINK_STATUS) === !1) if (ne = !1, typeof i.debug.onShaderError == "function") i.debug.onShaderError(s, g, P, w);
                else {
                    const C = gd(s, P, "vertex"), E = gd(s, w, "fragment");
                    console.error("THREE.WebGLProgram: Shader Error " + s.getError() + " - VALIDATE_STATUS " + s.getProgramParameter(g, s.VALIDATE_STATUS) + `

Material Name: ` + D.name + `
Material Type: ` + D.type + `

Program Info Log: ` + q + `
` + C + `
` + E);
                }
                else q !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", q) : (H === "" || $ === "") && (b = !1);
                b && (D.diagnostics = {
                    runnable: ne,
                    programLog: q,
                    vertexShader: {
                        log: H,
                        prefix: m
                    },
                    fragmentShader: {
                        log: $,
                        prefix: p
                    }
                });
            }
            s.deleteShader(P), s.deleteShader(w), B = new Ya(s, g), T = OS(s, g);
        }
        let B;
        this.getUniforms = function() {
            return B === void 0 && R(this), B;
        };
        let T;
        this.getAttributes = function() {
            return T === void 0 && R(this), T;
        };
        let S = t.rendererExtensionParallelShaderCompile === !1;
        return this.isReady = function() {
            return S === !1 && (S = s.getProgramParameter(g, CS)), S;
        }, this.destroy = function() {
            n.releaseStatesOfProgram(this), s.deleteProgram(g), this.program = void 0;
        }, this.type = t.shaderType, this.name = t.shaderName, this.id = PS++, this.cacheKey = e, this.usedTimes = 1, this.program = g, this.vertexShader = P, this.fragmentShader = w, this;
    }
    let KS = 0;
    class ZS {
        constructor(){
            this.shaderCache = new Map, this.materialCache = new Map;
        }
        update(e) {
            const t = e.vertexShader, n = e.fragmentShader, s = this._getShaderStage(t), r = this._getShaderStage(n), a = this._getShaderCacheForMaterial(e);
            return a.has(s) === !1 && (a.add(s), s.usedTimes++), a.has(r) === !1 && (a.add(r), r.usedTimes++), this;
        }
        remove(e) {
            const t = this.materialCache.get(e);
            for (const n of t)n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
            return this.materialCache.delete(e), this;
        }
        getVertexShaderID(e) {
            return this._getShaderStage(e.vertexShader).id;
        }
        getFragmentShaderID(e) {
            return this._getShaderStage(e.fragmentShader).id;
        }
        dispose() {
            this.shaderCache.clear(), this.materialCache.clear();
        }
        _getShaderCacheForMaterial(e) {
            const t = this.materialCache;
            let n = t.get(e);
            return n === void 0 && (n = new Set, t.set(e, n)), n;
        }
        _getShaderStage(e) {
            const t = this.shaderCache;
            let n = t.get(e);
            return n === void 0 && (n = new JS(e), t.set(e, n)), n;
        }
    }
    class JS {
        constructor(e){
            this.id = KS++, this.code = e, this.usedTimes = 0;
        }
    }
    function QS(i, e, t, n, s, r, a) {
        const o = new gp, l = new ZS, h = new Set, d = [], c = s.logarithmicDepthBuffer, u = s.vertexTextures;
        let f = s.precision;
        const _ = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "toon",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            MeshMatcapMaterial: "matcap",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow",
            SpriteMaterial: "sprite"
        };
        function g(T) {
            return h.add(T), T === 0 ? "uv" : `uv${T}`;
        }
        function m(T, S, D, q, H) {
            const $ = q.fog, ne = H.geometry, b = T.isMeshStandardMaterial ? q.environment : null, C = (T.isMeshStandardMaterial ? t : e).get(T.envMap || b), E = C && C.mapping === ho ? C.image.height : null, U = _[T.type];
            T.precision !== null && (f = s.getMaxPrecision(T.precision), f !== T.precision && console.warn("THREE.WebGLProgram.getParameters:", T.precision, "not supported, using", f, "instead."));
            const F = ne.morphAttributes.position || ne.morphAttributes.normal || ne.morphAttributes.color, V = F !== void 0 ? F.length : 0;
            let j = 0;
            ne.morphAttributes.position !== void 0 && (j = 1), ne.morphAttributes.normal !== void 0 && (j = 2), ne.morphAttributes.color !== void 0 && (j = 3);
            let ie, z, K, oe;
            if (U) {
                const ct = kn[U];
                ie = ct.vertexShader, z = ct.fragmentShader;
            } else ie = T.vertexShader, z = T.fragmentShader, l.update(T), K = l.getVertexShaderID(T), oe = l.getFragmentShaderID(T);
            const se = i.getRenderTarget(), ce = i.state.buffers.depth.getReversed(), we = H.isInstancedMesh === !0, he = H.isBatchedMesh === !0, st = !!T.map, We = !!T.matcap, Be = !!C, L = !!T.aoMap, Ce = !!T.lightMap, ge = !!T.bumpMap, Xe = !!T.normalMap, Ae = !!T.displacementMap, ft = !!T.emissiveMap, Ee = !!T.metalnessMap, I = !!T.roughnessMap, M = T.anisotropy > 0, W = T.clearcoat > 0, ee = T.dispersion > 0, re = T.iridescence > 0, Q = T.sheen > 0, Me = T.transmission > 0, fe = M && !!T.anisotropyMap, ve = W && !!T.clearcoatMap, Je = W && !!T.clearcoatNormalMap, le = W && !!T.clearcoatRoughnessMap, ye = re && !!T.iridescenceMap, De = re && !!T.iridescenceThicknessMap, Ue = Q && !!T.sheenColorMap, be = Q && !!T.sheenRoughnessMap, $e = !!T.specularMap, ze = !!T.specularColorMap, pt = !!T.specularIntensityMap, N = Me && !!T.transmissionMap, pe = Me && !!T.thicknessMap, Z = !!T.gradientMap, te = !!T.alphaMap, _e = T.alphaTest > 0, me = !!T.alphaHash, ke = !!T.extensions;
            let bt = Mi;
            T.toneMapped && (se === null || se.isXRRenderTarget === !0) && (bt = i.toneMapping);
            const Gt = {
                shaderID: U,
                shaderType: T.type,
                shaderName: T.name,
                vertexShader: ie,
                fragmentShader: z,
                defines: T.defines,
                customVertexShaderID: K,
                customFragmentShaderID: oe,
                isRawShaderMaterial: T.isRawShaderMaterial === !0,
                glslVersion: T.glslVersion,
                precision: f,
                batching: he,
                batchingColor: he && H._colorsTexture !== null,
                instancing: we,
                instancingColor: we && H.instanceColor !== null,
                instancingMorph: we && H.morphTexture !== null,
                supportsVertexTextures: u,
                outputColorSpace: se === null ? i.outputColorSpace : se.isXRRenderTarget === !0 ? se.texture.colorSpace : Zt,
                alphaToCoverage: !!T.alphaToCoverage,
                map: st,
                matcap: We,
                envMap: Be,
                envMapMode: Be && C.mapping,
                envMapCubeUVHeight: E,
                aoMap: L,
                lightMap: Ce,
                bumpMap: ge,
                normalMap: Xe,
                displacementMap: u && Ae,
                emissiveMap: ft,
                normalMapObjectSpace: Xe && T.normalMapType === Kg,
                normalMapTangentSpace: Xe && T.normalMapType === fp,
                metalnessMap: Ee,
                roughnessMap: I,
                anisotropy: M,
                anisotropyMap: fe,
                clearcoat: W,
                clearcoatMap: ve,
                clearcoatNormalMap: Je,
                clearcoatRoughnessMap: le,
                dispersion: ee,
                iridescence: re,
                iridescenceMap: ye,
                iridescenceThicknessMap: De,
                sheen: Q,
                sheenColorMap: Ue,
                sheenRoughnessMap: be,
                specularMap: $e,
                specularColorMap: ze,
                specularIntensityMap: pt,
                transmission: Me,
                transmissionMap: N,
                thicknessMap: pe,
                gradientMap: Z,
                opaque: T.transparent === !1 && T.blending === Is && T.alphaToCoverage === !1,
                alphaMap: te,
                alphaTest: _e,
                alphaHash: me,
                combine: T.combine,
                mapUv: st && g(T.map.channel),
                aoMapUv: L && g(T.aoMap.channel),
                lightMapUv: Ce && g(T.lightMap.channel),
                bumpMapUv: ge && g(T.bumpMap.channel),
                normalMapUv: Xe && g(T.normalMap.channel),
                displacementMapUv: Ae && g(T.displacementMap.channel),
                emissiveMapUv: ft && g(T.emissiveMap.channel),
                metalnessMapUv: Ee && g(T.metalnessMap.channel),
                roughnessMapUv: I && g(T.roughnessMap.channel),
                anisotropyMapUv: fe && g(T.anisotropyMap.channel),
                clearcoatMapUv: ve && g(T.clearcoatMap.channel),
                clearcoatNormalMapUv: Je && g(T.clearcoatNormalMap.channel),
                clearcoatRoughnessMapUv: le && g(T.clearcoatRoughnessMap.channel),
                iridescenceMapUv: ye && g(T.iridescenceMap.channel),
                iridescenceThicknessMapUv: De && g(T.iridescenceThicknessMap.channel),
                sheenColorMapUv: Ue && g(T.sheenColorMap.channel),
                sheenRoughnessMapUv: be && g(T.sheenRoughnessMap.channel),
                specularMapUv: $e && g(T.specularMap.channel),
                specularColorMapUv: ze && g(T.specularColorMap.channel),
                specularIntensityMapUv: pt && g(T.specularIntensityMap.channel),
                transmissionMapUv: N && g(T.transmissionMap.channel),
                thicknessMapUv: pe && g(T.thicknessMap.channel),
                alphaMapUv: te && g(T.alphaMap.channel),
                vertexTangents: !!ne.attributes.tangent && (Xe || M),
                vertexColors: T.vertexColors,
                vertexAlphas: T.vertexColors === !0 && !!ne.attributes.color && ne.attributes.color.itemSize === 4,
                pointsUvs: H.isPoints === !0 && !!ne.attributes.uv && (st || te),
                fog: !!$,
                useFog: T.fog === !0,
                fogExp2: !!$ && $.isFogExp2,
                flatShading: T.flatShading === !0,
                sizeAttenuation: T.sizeAttenuation === !0,
                logarithmicDepthBuffer: c,
                reverseDepthBuffer: ce,
                skinning: H.isSkinnedMesh === !0,
                morphTargets: ne.morphAttributes.position !== void 0,
                morphNormals: ne.morphAttributes.normal !== void 0,
                morphColors: ne.morphAttributes.color !== void 0,
                morphTargetsCount: V,
                morphTextureStride: j,
                numDirLights: S.directional.length,
                numPointLights: S.point.length,
                numSpotLights: S.spot.length,
                numSpotLightMaps: S.spotLightMap.length,
                numRectAreaLights: S.rectArea.length,
                numHemiLights: S.hemi.length,
                numDirLightShadows: S.directionalShadowMap.length,
                numPointLightShadows: S.pointShadowMap.length,
                numSpotLightShadows: S.spotShadowMap.length,
                numSpotLightShadowsWithMaps: S.numSpotLightShadowsWithMaps,
                numLightProbes: S.numLightProbes,
                numClippingPlanes: a.numPlanes,
                numClipIntersection: a.numIntersection,
                dithering: T.dithering,
                shadowMapEnabled: i.shadowMap.enabled && D.length > 0,
                shadowMapType: i.shadowMap.type,
                toneMapping: bt,
                decodeVideoTexture: st && T.map.isVideoTexture === !0 && Ke.getTransfer(T.map.colorSpace) === ut,
                decodeVideoTextureEmissive: ft && T.emissiveMap.isVideoTexture === !0 && Ke.getTransfer(T.emissiveMap.colorSpace) === ut,
                premultipliedAlpha: T.premultipliedAlpha,
                doubleSided: T.side === gn,
                flipSided: T.side === tn,
                useDepthPacking: T.depthPacking >= 0,
                depthPacking: T.depthPacking || 0,
                index0AttributeName: T.index0AttributeName,
                extensionClipCullDistance: ke && T.extensions.clipCullDistance === !0 && n.has("WEBGL_clip_cull_distance"),
                extensionMultiDraw: (ke && T.extensions.multiDraw === !0 || he) && n.has("WEBGL_multi_draw"),
                rendererExtensionParallelShaderCompile: n.has("KHR_parallel_shader_compile"),
                customProgramCacheKey: T.customProgramCacheKey()
            };
            return Gt.vertexUv1s = h.has(1), Gt.vertexUv2s = h.has(2), Gt.vertexUv3s = h.has(3), h.clear(), Gt;
        }
        function p(T) {
            const S = [];
            if (T.shaderID ? S.push(T.shaderID) : (S.push(T.customVertexShaderID), S.push(T.customFragmentShaderID)), T.defines !== void 0) for(const D in T.defines)S.push(D), S.push(T.defines[D]);
            return T.isRawShaderMaterial === !1 && (x(S, T), v(S, T), S.push(i.outputColorSpace)), S.push(T.customProgramCacheKey), S.join();
        }
        function x(T, S) {
            T.push(S.precision), T.push(S.outputColorSpace), T.push(S.envMapMode), T.push(S.envMapCubeUVHeight), T.push(S.mapUv), T.push(S.alphaMapUv), T.push(S.lightMapUv), T.push(S.aoMapUv), T.push(S.bumpMapUv), T.push(S.normalMapUv), T.push(S.displacementMapUv), T.push(S.emissiveMapUv), T.push(S.metalnessMapUv), T.push(S.roughnessMapUv), T.push(S.anisotropyMapUv), T.push(S.clearcoatMapUv), T.push(S.clearcoatNormalMapUv), T.push(S.clearcoatRoughnessMapUv), T.push(S.iridescenceMapUv), T.push(S.iridescenceThicknessMapUv), T.push(S.sheenColorMapUv), T.push(S.sheenRoughnessMapUv), T.push(S.specularMapUv), T.push(S.specularColorMapUv), T.push(S.specularIntensityMapUv), T.push(S.transmissionMapUv), T.push(S.thicknessMapUv), T.push(S.combine), T.push(S.fogExp2), T.push(S.sizeAttenuation), T.push(S.morphTargetsCount), T.push(S.morphAttributeCount), T.push(S.numDirLights), T.push(S.numPointLights), T.push(S.numSpotLights), T.push(S.numSpotLightMaps), T.push(S.numHemiLights), T.push(S.numRectAreaLights), T.push(S.numDirLightShadows), T.push(S.numPointLightShadows), T.push(S.numSpotLightShadows), T.push(S.numSpotLightShadowsWithMaps), T.push(S.numLightProbes), T.push(S.shadowMapType), T.push(S.toneMapping), T.push(S.numClippingPlanes), T.push(S.numClipIntersection), T.push(S.depthPacking);
        }
        function v(T, S) {
            o.disableAll(), S.supportsVertexTextures && o.enable(0), S.instancing && o.enable(1), S.instancingColor && o.enable(2), S.instancingMorph && o.enable(3), S.matcap && o.enable(4), S.envMap && o.enable(5), S.normalMapObjectSpace && o.enable(6), S.normalMapTangentSpace && o.enable(7), S.clearcoat && o.enable(8), S.iridescence && o.enable(9), S.alphaTest && o.enable(10), S.vertexColors && o.enable(11), S.vertexAlphas && o.enable(12), S.vertexUv1s && o.enable(13), S.vertexUv2s && o.enable(14), S.vertexUv3s && o.enable(15), S.vertexTangents && o.enable(16), S.anisotropy && o.enable(17), S.alphaHash && o.enable(18), S.batching && o.enable(19), S.dispersion && o.enable(20), S.batchingColor && o.enable(21), T.push(o.mask), o.disableAll(), S.fog && o.enable(0), S.useFog && o.enable(1), S.flatShading && o.enable(2), S.logarithmicDepthBuffer && o.enable(3), S.reverseDepthBuffer && o.enable(4), S.skinning && o.enable(5), S.morphTargets && o.enable(6), S.morphNormals && o.enable(7), S.morphColors && o.enable(8), S.premultipliedAlpha && o.enable(9), S.shadowMapEnabled && o.enable(10), S.doubleSided && o.enable(11), S.flipSided && o.enable(12), S.useDepthPacking && o.enable(13), S.dithering && o.enable(14), S.transmission && o.enable(15), S.sheen && o.enable(16), S.opaque && o.enable(17), S.pointsUvs && o.enable(18), S.decodeVideoTexture && o.enable(19), S.decodeVideoTextureEmissive && o.enable(20), S.alphaToCoverage && o.enable(21), T.push(o.mask);
        }
        function y(T) {
            const S = _[T.type];
            let D;
            if (S) {
                const q = kn[S];
                D = Vx.clone(q.uniforms);
            } else D = T.uniforms;
            return D;
        }
        function P(T, S) {
            let D;
            for(let q = 0, H = d.length; q < H; q++){
                const $ = d[q];
                if ($.cacheKey === S) {
                    D = $, ++D.usedTimes;
                    break;
                }
            }
            return D === void 0 && (D = new $S(i, S, T, r), d.push(D)), D;
        }
        function w(T) {
            if (--T.usedTimes === 0) {
                const S = d.indexOf(T);
                d[S] = d[d.length - 1], d.pop(), T.destroy();
            }
        }
        function R(T) {
            l.remove(T);
        }
        function B() {
            l.dispose();
        }
        return {
            getParameters: m,
            getProgramCacheKey: p,
            getUniforms: y,
            acquireProgram: P,
            releaseProgram: w,
            releaseShaderCache: R,
            programs: d,
            dispose: B
        };
    }
    function eT() {
        let i = new WeakMap;
        function e(a) {
            return i.has(a);
        }
        function t(a) {
            let o = i.get(a);
            return o === void 0 && (o = {}, i.set(a, o)), o;
        }
        function n(a) {
            i.delete(a);
        }
        function s(a, o, l) {
            i.get(a)[o] = l;
        }
        function r() {
            i = new WeakMap;
        }
        return {
            has: e,
            get: t,
            remove: n,
            update: s,
            dispose: r
        };
    }
    function tT(i, e) {
        return i.groupOrder !== e.groupOrder ? i.groupOrder - e.groupOrder : i.renderOrder !== e.renderOrder ? i.renderOrder - e.renderOrder : i.material.id !== e.material.id ? i.material.id - e.material.id : i.z !== e.z ? i.z - e.z : i.id - e.id;
    }
    function Sd(i, e) {
        return i.groupOrder !== e.groupOrder ? i.groupOrder - e.groupOrder : i.renderOrder !== e.renderOrder ? i.renderOrder - e.renderOrder : i.z !== e.z ? e.z - i.z : i.id - e.id;
    }
    function Td() {
        const i = [];
        let e = 0;
        const t = [], n = [], s = [];
        function r() {
            e = 0, t.length = 0, n.length = 0, s.length = 0;
        }
        function a(c, u, f, _, g, m) {
            let p = i[e];
            return p === void 0 ? (p = {
                id: c.id,
                object: c,
                geometry: u,
                material: f,
                groupOrder: _,
                renderOrder: c.renderOrder,
                z: g,
                group: m
            }, i[e] = p) : (p.id = c.id, p.object = c, p.geometry = u, p.material = f, p.groupOrder = _, p.renderOrder = c.renderOrder, p.z = g, p.group = m), e++, p;
        }
        function o(c, u, f, _, g, m) {
            const p = a(c, u, f, _, g, m);
            f.transmission > 0 ? n.push(p) : f.transparent === !0 ? s.push(p) : t.push(p);
        }
        function l(c, u, f, _, g, m) {
            const p = a(c, u, f, _, g, m);
            f.transmission > 0 ? n.unshift(p) : f.transparent === !0 ? s.unshift(p) : t.unshift(p);
        }
        function h(c, u) {
            t.length > 1 && t.sort(c || tT), n.length > 1 && n.sort(u || Sd), s.length > 1 && s.sort(u || Sd);
        }
        function d() {
            for(let c = e, u = i.length; c < u; c++){
                const f = i[c];
                if (f.id === null) break;
                f.id = null, f.object = null, f.geometry = null, f.material = null, f.group = null;
            }
        }
        return {
            opaque: t,
            transmissive: n,
            transparent: s,
            init: r,
            push: o,
            unshift: l,
            finish: d,
            sort: h
        };
    }
    function nT() {
        let i = new WeakMap;
        function e(n, s) {
            const r = i.get(n);
            let a;
            return r === void 0 ? (a = new Td, i.set(n, [
                a
            ])) : s >= r.length ? (a = new Td, r.push(a)) : a = r[s], a;
        }
        function t() {
            i = new WeakMap;
        }
        return {
            get: e,
            dispose: t
        };
    }
    function iT() {
        const i = {};
        return {
            get: function(e) {
                if (i[e.id] !== void 0) return i[e.id];
                let t;
                switch(e.type){
                    case "DirectionalLight":
                        t = {
                            direction: new k,
                            color: new Oe
                        };
                        break;
                    case "SpotLight":
                        t = {
                            position: new k,
                            direction: new k,
                            color: new Oe,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0
                        };
                        break;
                    case "PointLight":
                        t = {
                            position: new k,
                            color: new Oe,
                            distance: 0,
                            decay: 0
                        };
                        break;
                    case "HemisphereLight":
                        t = {
                            direction: new k,
                            skyColor: new Oe,
                            groundColor: new Oe
                        };
                        break;
                    case "RectAreaLight":
                        t = {
                            color: new Oe,
                            position: new k,
                            halfWidth: new k,
                            halfHeight: new k
                        };
                        break;
                }
                return i[e.id] = t, t;
            }
        };
    }
    function sT() {
        const i = {};
        return {
            get: function(e) {
                if (i[e.id] !== void 0) return i[e.id];
                let t;
                switch(e.type){
                    case "DirectionalLight":
                        t = {
                            shadowIntensity: 1,
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new Ze
                        };
                        break;
                    case "SpotLight":
                        t = {
                            shadowIntensity: 1,
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new Ze
                        };
                        break;
                    case "PointLight":
                        t = {
                            shadowIntensity: 1,
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new Ze,
                            shadowCameraNear: 1,
                            shadowCameraFar: 1e3
                        };
                        break;
                }
                return i[e.id] = t, t;
            }
        };
    }
    let rT = 0;
    function aT(i, e) {
        return (e.castShadow ? 2 : 0) - (i.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (i.map ? 1 : 0);
    }
    function oT(i) {
        const e = new iT, t = sT(), n = {
            version: 0,
            hash: {
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1,
                numSpotMaps: -1,
                numLightProbes: -1
            },
            ambient: [
                0,
                0,
                0
            ],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotLightMap: [],
            spotShadow: [],
            spotShadowMap: [],
            spotLightMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
            numSpotLightShadowsWithMaps: 0,
            numLightProbes: 0
        };
        for(let h = 0; h < 9; h++)n.probe.push(new k);
        const s = new k, r = new He, a = new He;
        function o(h) {
            let d = 0, c = 0, u = 0;
            for(let T = 0; T < 9; T++)n.probe[T].set(0, 0, 0);
            let f = 0, _ = 0, g = 0, m = 0, p = 0, x = 0, v = 0, y = 0, P = 0, w = 0, R = 0;
            h.sort(aT);
            for(let T = 0, S = h.length; T < S; T++){
                const D = h[T], q = D.color, H = D.intensity, $ = D.distance, ne = D.shadow && D.shadow.map ? D.shadow.map.texture : null;
                if (D.isAmbientLight) d += q.r * H, c += q.g * H, u += q.b * H;
                else if (D.isLightProbe) {
                    for(let b = 0; b < 9; b++)n.probe[b].addScaledVector(D.sh.coefficients[b], H);
                    R++;
                } else if (D.isDirectionalLight) {
                    const b = e.get(D);
                    if (b.color.copy(D.color).multiplyScalar(D.intensity), D.castShadow) {
                        const C = D.shadow, E = t.get(D);
                        E.shadowIntensity = C.intensity, E.shadowBias = C.bias, E.shadowNormalBias = C.normalBias, E.shadowRadius = C.radius, E.shadowMapSize = C.mapSize, n.directionalShadow[f] = E, n.directionalShadowMap[f] = ne, n.directionalShadowMatrix[f] = D.shadow.matrix, x++;
                    }
                    n.directional[f] = b, f++;
                } else if (D.isSpotLight) {
                    const b = e.get(D);
                    b.position.setFromMatrixPosition(D.matrixWorld), b.color.copy(q).multiplyScalar(H), b.distance = $, b.coneCos = Math.cos(D.angle), b.penumbraCos = Math.cos(D.angle * (1 - D.penumbra)), b.decay = D.decay, n.spot[g] = b;
                    const C = D.shadow;
                    if (D.map && (n.spotLightMap[P] = D.map, P++, C.updateMatrices(D), D.castShadow && w++), n.spotLightMatrix[g] = C.matrix, D.castShadow) {
                        const E = t.get(D);
                        E.shadowIntensity = C.intensity, E.shadowBias = C.bias, E.shadowNormalBias = C.normalBias, E.shadowRadius = C.radius, E.shadowMapSize = C.mapSize, n.spotShadow[g] = E, n.spotShadowMap[g] = ne, y++;
                    }
                    g++;
                } else if (D.isRectAreaLight) {
                    const b = e.get(D);
                    b.color.copy(q).multiplyScalar(H), b.halfWidth.set(D.width * .5, 0, 0), b.halfHeight.set(0, D.height * .5, 0), n.rectArea[m] = b, m++;
                } else if (D.isPointLight) {
                    const b = e.get(D);
                    if (b.color.copy(D.color).multiplyScalar(D.intensity), b.distance = D.distance, b.decay = D.decay, D.castShadow) {
                        const C = D.shadow, E = t.get(D);
                        E.shadowIntensity = C.intensity, E.shadowBias = C.bias, E.shadowNormalBias = C.normalBias, E.shadowRadius = C.radius, E.shadowMapSize = C.mapSize, E.shadowCameraNear = C.camera.near, E.shadowCameraFar = C.camera.far, n.pointShadow[_] = E, n.pointShadowMap[_] = ne, n.pointShadowMatrix[_] = D.shadow.matrix, v++;
                    }
                    n.point[_] = b, _++;
                } else if (D.isHemisphereLight) {
                    const b = e.get(D);
                    b.skyColor.copy(D.color).multiplyScalar(H), b.groundColor.copy(D.groundColor).multiplyScalar(H), n.hemi[p] = b, p++;
                }
            }
            m > 0 && (i.has("OES_texture_float_linear") === !0 ? (n.rectAreaLTC1 = ue.LTC_FLOAT_1, n.rectAreaLTC2 = ue.LTC_FLOAT_2) : (n.rectAreaLTC1 = ue.LTC_HALF_1, n.rectAreaLTC2 = ue.LTC_HALF_2)), n.ambient[0] = d, n.ambient[1] = c, n.ambient[2] = u;
            const B = n.hash;
            (B.directionalLength !== f || B.pointLength !== _ || B.spotLength !== g || B.rectAreaLength !== m || B.hemiLength !== p || B.numDirectionalShadows !== x || B.numPointShadows !== v || B.numSpotShadows !== y || B.numSpotMaps !== P || B.numLightProbes !== R) && (n.directional.length = f, n.spot.length = g, n.rectArea.length = m, n.point.length = _, n.hemi.length = p, n.directionalShadow.length = x, n.directionalShadowMap.length = x, n.pointShadow.length = v, n.pointShadowMap.length = v, n.spotShadow.length = y, n.spotShadowMap.length = y, n.directionalShadowMatrix.length = x, n.pointShadowMatrix.length = v, n.spotLightMatrix.length = y + P - w, n.spotLightMap.length = P, n.numSpotLightShadowsWithMaps = w, n.numLightProbes = R, B.directionalLength = f, B.pointLength = _, B.spotLength = g, B.rectAreaLength = m, B.hemiLength = p, B.numDirectionalShadows = x, B.numPointShadows = v, B.numSpotShadows = y, B.numSpotMaps = P, B.numLightProbes = R, n.version = rT++);
        }
        function l(h, d) {
            let c = 0, u = 0, f = 0, _ = 0, g = 0;
            const m = d.matrixWorldInverse;
            for(let p = 0, x = h.length; p < x; p++){
                const v = h[p];
                if (v.isDirectionalLight) {
                    const y = n.directional[c];
                    y.direction.setFromMatrixPosition(v.matrixWorld), s.setFromMatrixPosition(v.target.matrixWorld), y.direction.sub(s), y.direction.transformDirection(m), c++;
                } else if (v.isSpotLight) {
                    const y = n.spot[f];
                    y.position.setFromMatrixPosition(v.matrixWorld), y.position.applyMatrix4(m), y.direction.setFromMatrixPosition(v.matrixWorld), s.setFromMatrixPosition(v.target.matrixWorld), y.direction.sub(s), y.direction.transformDirection(m), f++;
                } else if (v.isRectAreaLight) {
                    const y = n.rectArea[_];
                    y.position.setFromMatrixPosition(v.matrixWorld), y.position.applyMatrix4(m), a.identity(), r.copy(v.matrixWorld), r.premultiply(m), a.extractRotation(r), y.halfWidth.set(v.width * .5, 0, 0), y.halfHeight.set(0, v.height * .5, 0), y.halfWidth.applyMatrix4(a), y.halfHeight.applyMatrix4(a), _++;
                } else if (v.isPointLight) {
                    const y = n.point[u];
                    y.position.setFromMatrixPosition(v.matrixWorld), y.position.applyMatrix4(m), u++;
                } else if (v.isHemisphereLight) {
                    const y = n.hemi[g];
                    y.direction.setFromMatrixPosition(v.matrixWorld), y.direction.transformDirection(m), g++;
                }
            }
        }
        return {
            setup: o,
            setupView: l,
            state: n
        };
    }
    function Md(i) {
        const e = new oT(i), t = [], n = [];
        function s(d) {
            h.camera = d, t.length = 0, n.length = 0;
        }
        function r(d) {
            t.push(d);
        }
        function a(d) {
            n.push(d);
        }
        function o() {
            e.setup(t);
        }
        function l(d) {
            e.setupView(t, d);
        }
        const h = {
            lightsArray: t,
            shadowsArray: n,
            camera: null,
            lights: e,
            transmissionRenderTarget: {}
        };
        return {
            init: s,
            state: h,
            setupLights: o,
            setupLightsView: l,
            pushLight: r,
            pushShadow: a
        };
    }
    function lT(i) {
        let e = new WeakMap;
        function t(s, r = 0) {
            const a = e.get(s);
            let o;
            return a === void 0 ? (o = new Md(i), e.set(s, [
                o
            ])) : r >= a.length ? (o = new Md(i), a.push(o)) : o = a[r], o;
        }
        function n() {
            e = new WeakMap;
        }
        return {
            get: t,
            dispose: n
        };
    }
    const cT = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, hT = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
    function uT(i, e, t) {
        let n = new gh;
        const s = new Ze, r = new Ze, a = new rt, o = new o0({
            depthPacking: $g
        }), l = new l0, h = {}, d = t.maxTextureSize, c = {
            [ci]: tn,
            [tn]: ci,
            [gn]: gn
        }, u = new wi({
            defines: {
                VSM_SAMPLES: 8
            },
            uniforms: {
                shadow_pass: {
                    value: null
                },
                resolution: {
                    value: new Ze
                },
                radius: {
                    value: 4
                }
            },
            vertexShader: cT,
            fragmentShader: hT
        }), f = u.clone();
        f.defines.HORIZONTAL_PASS = 1;
        const _ = new Wn;
        _.setAttribute("position", new Kt(new Float32Array([
            -1,
            -1,
            .5,
            3,
            -1,
            .5,
            -1,
            3,
            .5
        ]), 3));
        const g = new Nt(_, u), m = this;
        this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = Jf;
        let p = this.type;
        this.render = function(w, R, B) {
            if (m.enabled === !1 || m.autoUpdate === !1 && m.needsUpdate === !1 || w.length === 0) return;
            const T = i.getRenderTarget(), S = i.getActiveCubeFace(), D = i.getActiveMipmapLevel(), q = i.state;
            q.setBlending(Ti), q.buffers.color.setClear(1, 1, 1, 1), q.buffers.depth.setTest(!0), q.setScissorTest(!1);
            const H = p !== ei && this.type === ei, $ = p === ei && this.type !== ei;
            for(let ne = 0, b = w.length; ne < b; ne++){
                const C = w[ne], E = C.shadow;
                if (E === void 0) {
                    console.warn("THREE.WebGLShadowMap:", C, "has no shadow.");
                    continue;
                }
                if (E.autoUpdate === !1 && E.needsUpdate === !1) continue;
                s.copy(E.mapSize);
                const U = E.getFrameExtents();
                if (s.multiply(U), r.copy(E.mapSize), (s.x > d || s.y > d) && (s.x > d && (r.x = Math.floor(d / U.x), s.x = r.x * U.x, E.mapSize.x = r.x), s.y > d && (r.y = Math.floor(d / U.y), s.y = r.y * U.y, E.mapSize.y = r.y)), E.map === null || H === !0 || $ === !0) {
                    const V = this.type !== ei ? {
                        minFilter: $t,
                        magFilter: $t
                    } : {};
                    E.map !== null && E.map.dispose(), E.map = new Qi(s.x, s.y, V), E.map.texture.name = C.name + ".shadowMap", E.camera.updateProjectionMatrix();
                }
                i.setRenderTarget(E.map), i.clear();
                const F = E.getViewportCount();
                for(let V = 0; V < F; V++){
                    const j = E.getViewport(V);
                    a.set(r.x * j.x, r.y * j.y, r.x * j.z, r.y * j.w), q.viewport(a), E.updateMatrices(C, V), n = E.getFrustum(), y(R, B, E.camera, C, this.type);
                }
                E.isPointLightShadow !== !0 && this.type === ei && x(E, B), E.needsUpdate = !1;
            }
            p = this.type, m.needsUpdate = !1, i.setRenderTarget(T, S, D);
        };
        function x(w, R) {
            const B = e.update(g);
            u.defines.VSM_SAMPLES !== w.blurSamples && (u.defines.VSM_SAMPLES = w.blurSamples, f.defines.VSM_SAMPLES = w.blurSamples, u.needsUpdate = !0, f.needsUpdate = !0), w.mapPass === null && (w.mapPass = new Qi(s.x, s.y)), u.uniforms.shadow_pass.value = w.map.texture, u.uniforms.resolution.value = w.mapSize, u.uniforms.radius.value = w.radius, i.setRenderTarget(w.mapPass), i.clear(), i.renderBufferDirect(R, null, B, u, g, null), f.uniforms.shadow_pass.value = w.mapPass.texture, f.uniforms.resolution.value = w.mapSize, f.uniforms.radius.value = w.radius, i.setRenderTarget(w.map), i.clear(), i.renderBufferDirect(R, null, B, f, g, null);
        }
        function v(w, R, B, T) {
            let S = null;
            const D = B.isPointLight === !0 ? w.customDistanceMaterial : w.customDepthMaterial;
            if (D !== void 0) S = D;
            else if (S = B.isPointLight === !0 ? l : o, i.localClippingEnabled && R.clipShadows === !0 && Array.isArray(R.clippingPlanes) && R.clippingPlanes.length !== 0 || R.displacementMap && R.displacementScale !== 0 || R.alphaMap && R.alphaTest > 0 || R.map && R.alphaTest > 0) {
                const q = S.uuid, H = R.uuid;
                let $ = h[q];
                $ === void 0 && ($ = {}, h[q] = $);
                let ne = $[H];
                ne === void 0 && (ne = S.clone(), $[H] = ne, R.addEventListener("dispose", P)), S = ne;
            }
            if (S.visible = R.visible, S.wireframe = R.wireframe, T === ei ? S.side = R.shadowSide !== null ? R.shadowSide : R.side : S.side = R.shadowSide !== null ? R.shadowSide : c[R.side], S.alphaMap = R.alphaMap, S.alphaTest = R.alphaTest, S.map = R.map, S.clipShadows = R.clipShadows, S.clippingPlanes = R.clippingPlanes, S.clipIntersection = R.clipIntersection, S.displacementMap = R.displacementMap, S.displacementScale = R.displacementScale, S.displacementBias = R.displacementBias, S.wireframeLinewidth = R.wireframeLinewidth, S.linewidth = R.linewidth, B.isPointLight === !0 && S.isMeshDistanceMaterial === !0) {
                const q = i.properties.get(S);
                q.light = B;
            }
            return S;
        }
        function y(w, R, B, T, S) {
            if (w.visible === !1) return;
            if (w.layers.test(R.layers) && (w.isMesh || w.isLine || w.isPoints) && (w.castShadow || w.receiveShadow && S === ei) && (!w.frustumCulled || n.intersectsObject(w))) {
                w.modelViewMatrix.multiplyMatrices(B.matrixWorldInverse, w.matrixWorld);
                const H = e.update(w), $ = w.material;
                if (Array.isArray($)) {
                    const ne = H.groups;
                    for(let b = 0, C = ne.length; b < C; b++){
                        const E = ne[b], U = $[E.materialIndex];
                        if (U && U.visible) {
                            const F = v(w, U, T, S);
                            w.onBeforeShadow(i, w, R, B, H, F, E), i.renderBufferDirect(B, null, H, F, w, E), w.onAfterShadow(i, w, R, B, H, F, E);
                        }
                    }
                } else if ($.visible) {
                    const ne = v(w, $, T, S);
                    w.onBeforeShadow(i, w, R, B, H, ne, null), i.renderBufferDirect(B, null, H, ne, w, null), w.onAfterShadow(i, w, R, B, H, ne, null);
                }
            }
            const q = w.children;
            for(let H = 0, $ = q.length; H < $; H++)y(q[H], R, B, T, S);
        }
        function P(w) {
            w.target.removeEventListener("dispose", P);
            for(const B in h){
                const T = h[B], S = w.target.uuid;
                S in T && (T[S].dispose(), delete T[S]);
            }
        }
    }
    const dT = {
        [Vl]: Wl,
        [Xl]: ql,
        [Yl]: $l,
        [Ns]: jl,
        [Wl]: Vl,
        [ql]: Xl,
        [$l]: Yl,
        [jl]: Ns
    };
    function fT(i, e) {
        function t() {
            let N = !1;
            const pe = new rt;
            let Z = null;
            const te = new rt(0, 0, 0, 0);
            return {
                setMask: function(_e) {
                    Z !== _e && !N && (i.colorMask(_e, _e, _e, _e), Z = _e);
                },
                setLocked: function(_e) {
                    N = _e;
                },
                setClear: function(_e, me, ke, bt, Gt) {
                    Gt === !0 && (_e *= bt, me *= bt, ke *= bt), pe.set(_e, me, ke, bt), te.equals(pe) === !1 && (i.clearColor(_e, me, ke, bt), te.copy(pe));
                },
                reset: function() {
                    N = !1, Z = null, te.set(-1, 0, 0, 0);
                }
            };
        }
        function n() {
            let N = !1, pe = !1, Z = null, te = null, _e = null;
            return {
                setReversed: function(me) {
                    if (pe !== me) {
                        const ke = e.get("EXT_clip_control");
                        me ? ke.clipControlEXT(ke.LOWER_LEFT_EXT, ke.ZERO_TO_ONE_EXT) : ke.clipControlEXT(ke.LOWER_LEFT_EXT, ke.NEGATIVE_ONE_TO_ONE_EXT), pe = me;
                        const bt = _e;
                        _e = null, this.setClear(bt);
                    }
                },
                getReversed: function() {
                    return pe;
                },
                setTest: function(me) {
                    me ? se(i.DEPTH_TEST) : ce(i.DEPTH_TEST);
                },
                setMask: function(me) {
                    Z !== me && !N && (i.depthMask(me), Z = me);
                },
                setFunc: function(me) {
                    if (pe && (me = dT[me]), te !== me) {
                        switch(me){
                            case Vl:
                                i.depthFunc(i.NEVER);
                                break;
                            case Wl:
                                i.depthFunc(i.ALWAYS);
                                break;
                            case Xl:
                                i.depthFunc(i.LESS);
                                break;
                            case Ns:
                                i.depthFunc(i.LEQUAL);
                                break;
                            case Yl:
                                i.depthFunc(i.EQUAL);
                                break;
                            case jl:
                                i.depthFunc(i.GEQUAL);
                                break;
                            case ql:
                                i.depthFunc(i.GREATER);
                                break;
                            case $l:
                                i.depthFunc(i.NOTEQUAL);
                                break;
                            default:
                                i.depthFunc(i.LEQUAL);
                        }
                        te = me;
                    }
                },
                setLocked: function(me) {
                    N = me;
                },
                setClear: function(me) {
                    _e !== me && (pe && (me = 1 - me), i.clearDepth(me), _e = me);
                },
                reset: function() {
                    N = !1, Z = null, te = null, _e = null, pe = !1;
                }
            };
        }
        function s() {
            let N = !1, pe = null, Z = null, te = null, _e = null, me = null, ke = null, bt = null, Gt = null;
            return {
                setTest: function(ct) {
                    N || (ct ? se(i.STENCIL_TEST) : ce(i.STENCIL_TEST));
                },
                setMask: function(ct) {
                    pe !== ct && !N && (i.stencilMask(ct), pe = ct);
                },
                setFunc: function(ct, bn, Yn) {
                    (Z !== ct || te !== bn || _e !== Yn) && (i.stencilFunc(ct, bn, Yn), Z = ct, te = bn, _e = Yn);
                },
                setOp: function(ct, bn, Yn) {
                    (me !== ct || ke !== bn || bt !== Yn) && (i.stencilOp(ct, bn, Yn), me = ct, ke = bn, bt = Yn);
                },
                setLocked: function(ct) {
                    N = ct;
                },
                setClear: function(ct) {
                    Gt !== ct && (i.clearStencil(ct), Gt = ct);
                },
                reset: function() {
                    N = !1, pe = null, Z = null, te = null, _e = null, me = null, ke = null, bt = null, Gt = null;
                }
            };
        }
        const r = new t, a = new n, o = new s, l = new WeakMap, h = new WeakMap;
        let d = {}, c = {}, u = new WeakMap, f = [], _ = null, g = !1, m = null, p = null, x = null, v = null, y = null, P = null, w = null, R = new Oe(0, 0, 0), B = 0, T = !1, S = null, D = null, q = null, H = null, $ = null;
        const ne = i.getParameter(i.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        let b = !1, C = 0;
        const E = i.getParameter(i.VERSION);
        E.indexOf("WebGL") !== -1 ? (C = parseFloat(/^WebGL (\d)/.exec(E)[1]), b = C >= 1) : E.indexOf("OpenGL ES") !== -1 && (C = parseFloat(/^OpenGL ES (\d)/.exec(E)[1]), b = C >= 2);
        let U = null, F = {};
        const V = i.getParameter(i.SCISSOR_BOX), j = i.getParameter(i.VIEWPORT), ie = new rt().fromArray(V), z = new rt().fromArray(j);
        function K(N, pe, Z, te) {
            const _e = new Uint8Array(4), me = i.createTexture();
            i.bindTexture(N, me), i.texParameteri(N, i.TEXTURE_MIN_FILTER, i.NEAREST), i.texParameteri(N, i.TEXTURE_MAG_FILTER, i.NEAREST);
            for(let ke = 0; ke < Z; ke++)N === i.TEXTURE_3D || N === i.TEXTURE_2D_ARRAY ? i.texImage3D(pe, 0, i.RGBA, 1, 1, te, 0, i.RGBA, i.UNSIGNED_BYTE, _e) : i.texImage2D(pe + ke, 0, i.RGBA, 1, 1, 0, i.RGBA, i.UNSIGNED_BYTE, _e);
            return me;
        }
        const oe = {};
        oe[i.TEXTURE_2D] = K(i.TEXTURE_2D, i.TEXTURE_2D, 1), oe[i.TEXTURE_CUBE_MAP] = K(i.TEXTURE_CUBE_MAP, i.TEXTURE_CUBE_MAP_POSITIVE_X, 6), oe[i.TEXTURE_2D_ARRAY] = K(i.TEXTURE_2D_ARRAY, i.TEXTURE_2D_ARRAY, 1, 1), oe[i.TEXTURE_3D] = K(i.TEXTURE_3D, i.TEXTURE_3D, 1, 1), r.setClear(0, 0, 0, 1), a.setClear(1), o.setClear(0), se(i.DEPTH_TEST), a.setFunc(Ns), ge(!1), Xe(hu), se(i.CULL_FACE), L(Ti);
        function se(N) {
            d[N] !== !0 && (i.enable(N), d[N] = !0);
        }
        function ce(N) {
            d[N] !== !1 && (i.disable(N), d[N] = !1);
        }
        function we(N, pe) {
            return c[N] !== pe ? (i.bindFramebuffer(N, pe), c[N] = pe, N === i.DRAW_FRAMEBUFFER && (c[i.FRAMEBUFFER] = pe), N === i.FRAMEBUFFER && (c[i.DRAW_FRAMEBUFFER] = pe), !0) : !1;
        }
        function he(N, pe) {
            let Z = f, te = !1;
            if (N) {
                Z = u.get(pe), Z === void 0 && (Z = [], u.set(pe, Z));
                const _e = N.textures;
                if (Z.length !== _e.length || Z[0] !== i.COLOR_ATTACHMENT0) {
                    for(let me = 0, ke = _e.length; me < ke; me++)Z[me] = i.COLOR_ATTACHMENT0 + me;
                    Z.length = _e.length, te = !0;
                }
            } else Z[0] !== i.BACK && (Z[0] = i.BACK, te = !0);
            te && i.drawBuffers(Z);
        }
        function st(N) {
            return _ !== N ? (i.useProgram(N), _ = N, !0) : !1;
        }
        const We = {
            [Yi]: i.FUNC_ADD,
            [gg]: i.FUNC_SUBTRACT,
            [xg]: i.FUNC_REVERSE_SUBTRACT
        };
        We[vg] = i.MIN, We[yg] = i.MAX;
        const Be = {
            [bg]: i.ZERO,
            [Sg]: i.ONE,
            [Tg]: i.SRC_COLOR,
            [Hl]: i.SRC_ALPHA,
            [Cg]: i.SRC_ALPHA_SATURATE,
            [wg]: i.DST_COLOR,
            [Ag]: i.DST_ALPHA,
            [Mg]: i.ONE_MINUS_SRC_COLOR,
            [zl]: i.ONE_MINUS_SRC_ALPHA,
            [Rg]: i.ONE_MINUS_DST_COLOR,
            [Eg]: i.ONE_MINUS_DST_ALPHA,
            [Pg]: i.CONSTANT_COLOR,
            [Ig]: i.ONE_MINUS_CONSTANT_COLOR,
            [Dg]: i.CONSTANT_ALPHA,
            [Lg]: i.ONE_MINUS_CONSTANT_ALPHA
        };
        function L(N, pe, Z, te, _e, me, ke, bt, Gt, ct) {
            if (N === Ti) {
                g === !0 && (ce(i.BLEND), g = !1);
                return;
            }
            if (g === !1 && (se(i.BLEND), g = !0), N !== _g) {
                if (N !== m || ct !== T) {
                    if ((p !== Yi || y !== Yi) && (i.blendEquation(i.FUNC_ADD), p = Yi, y = Yi), ct) switch(N){
                        case Is:
                            i.blendFuncSeparate(i.ONE, i.ONE_MINUS_SRC_ALPHA, i.ONE, i.ONE_MINUS_SRC_ALPHA);
                            break;
                        case uu:
                            i.blendFunc(i.ONE, i.ONE);
                            break;
                        case du:
                            i.blendFuncSeparate(i.ZERO, i.ONE_MINUS_SRC_COLOR, i.ZERO, i.ONE);
                            break;
                        case fu:
                            i.blendFuncSeparate(i.ZERO, i.SRC_COLOR, i.ZERO, i.SRC_ALPHA);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", N);
                            break;
                    }
                    else switch(N){
                        case Is:
                            i.blendFuncSeparate(i.SRC_ALPHA, i.ONE_MINUS_SRC_ALPHA, i.ONE, i.ONE_MINUS_SRC_ALPHA);
                            break;
                        case uu:
                            i.blendFunc(i.SRC_ALPHA, i.ONE);
                            break;
                        case du:
                            i.blendFuncSeparate(i.ZERO, i.ONE_MINUS_SRC_COLOR, i.ZERO, i.ONE);
                            break;
                        case fu:
                            i.blendFunc(i.ZERO, i.SRC_COLOR);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", N);
                            break;
                    }
                    x = null, v = null, P = null, w = null, R.set(0, 0, 0), B = 0, m = N, T = ct;
                }
                return;
            }
            _e = _e || pe, me = me || Z, ke = ke || te, (pe !== p || _e !== y) && (i.blendEquationSeparate(We[pe], We[_e]), p = pe, y = _e), (Z !== x || te !== v || me !== P || ke !== w) && (i.blendFuncSeparate(Be[Z], Be[te], Be[me], Be[ke]), x = Z, v = te, P = me, w = ke), (bt.equals(R) === !1 || Gt !== B) && (i.blendColor(bt.r, bt.g, bt.b, Gt), R.copy(bt), B = Gt), m = N, T = !1;
        }
        function Ce(N, pe) {
            N.side === gn ? ce(i.CULL_FACE) : se(i.CULL_FACE);
            let Z = N.side === tn;
            pe && (Z = !Z), ge(Z), N.blending === Is && N.transparent === !1 ? L(Ti) : L(N.blending, N.blendEquation, N.blendSrc, N.blendDst, N.blendEquationAlpha, N.blendSrcAlpha, N.blendDstAlpha, N.blendColor, N.blendAlpha, N.premultipliedAlpha), a.setFunc(N.depthFunc), a.setTest(N.depthTest), a.setMask(N.depthWrite), r.setMask(N.colorWrite);
            const te = N.stencilWrite;
            o.setTest(te), te && (o.setMask(N.stencilWriteMask), o.setFunc(N.stencilFunc, N.stencilRef, N.stencilFuncMask), o.setOp(N.stencilFail, N.stencilZFail, N.stencilZPass)), ft(N.polygonOffset, N.polygonOffsetFactor, N.polygonOffsetUnits), N.alphaToCoverage === !0 ? se(i.SAMPLE_ALPHA_TO_COVERAGE) : ce(i.SAMPLE_ALPHA_TO_COVERAGE);
        }
        function ge(N) {
            S !== N && (N ? i.frontFace(i.CW) : i.frontFace(i.CCW), S = N);
        }
        function Xe(N) {
            N !== fg ? (se(i.CULL_FACE), N !== D && (N === hu ? i.cullFace(i.BACK) : N === pg ? i.cullFace(i.FRONT) : i.cullFace(i.FRONT_AND_BACK))) : ce(i.CULL_FACE), D = N;
        }
        function Ae(N) {
            N !== q && (b && i.lineWidth(N), q = N);
        }
        function ft(N, pe, Z) {
            N ? (se(i.POLYGON_OFFSET_FILL), (H !== pe || $ !== Z) && (i.polygonOffset(pe, Z), H = pe, $ = Z)) : ce(i.POLYGON_OFFSET_FILL);
        }
        function Ee(N) {
            N ? se(i.SCISSOR_TEST) : ce(i.SCISSOR_TEST);
        }
        function I(N) {
            N === void 0 && (N = i.TEXTURE0 + ne - 1), U !== N && (i.activeTexture(N), U = N);
        }
        function M(N, pe, Z) {
            Z === void 0 && (U === null ? Z = i.TEXTURE0 + ne - 1 : Z = U);
            let te = F[Z];
            te === void 0 && (te = {
                type: void 0,
                texture: void 0
            }, F[Z] = te), (te.type !== N || te.texture !== pe) && (U !== Z && (i.activeTexture(Z), U = Z), i.bindTexture(N, pe || oe[N]), te.type = N, te.texture = pe);
        }
        function W() {
            const N = F[U];
            N !== void 0 && N.type !== void 0 && (i.bindTexture(N.type, null), N.type = void 0, N.texture = void 0);
        }
        function ee() {
            try {
                i.compressedTexImage2D(...arguments);
            } catch (N) {
                console.error("THREE.WebGLState:", N);
            }
        }
        function re() {
            try {
                i.compressedTexImage3D(...arguments);
            } catch (N) {
                console.error("THREE.WebGLState:", N);
            }
        }
        function Q() {
            try {
                i.texSubImage2D(...arguments);
            } catch (N) {
                console.error("THREE.WebGLState:", N);
            }
        }
        function Me() {
            try {
                i.texSubImage3D(...arguments);
            } catch (N) {
                console.error("THREE.WebGLState:", N);
            }
        }
        function fe() {
            try {
                i.compressedTexSubImage2D(...arguments);
            } catch (N) {
                console.error("THREE.WebGLState:", N);
            }
        }
        function ve() {
            try {
                i.compressedTexSubImage3D(...arguments);
            } catch (N) {
                console.error("THREE.WebGLState:", N);
            }
        }
        function Je() {
            try {
                i.texStorage2D(...arguments);
            } catch (N) {
                console.error("THREE.WebGLState:", N);
            }
        }
        function le() {
            try {
                i.texStorage3D(...arguments);
            } catch (N) {
                console.error("THREE.WebGLState:", N);
            }
        }
        function ye() {
            try {
                i.texImage2D(...arguments);
            } catch (N) {
                console.error("THREE.WebGLState:", N);
            }
        }
        function De() {
            try {
                i.texImage3D(...arguments);
            } catch (N) {
                console.error("THREE.WebGLState:", N);
            }
        }
        function Ue(N) {
            ie.equals(N) === !1 && (i.scissor(N.x, N.y, N.z, N.w), ie.copy(N));
        }
        function be(N) {
            z.equals(N) === !1 && (i.viewport(N.x, N.y, N.z, N.w), z.copy(N));
        }
        function $e(N, pe) {
            let Z = h.get(pe);
            Z === void 0 && (Z = new WeakMap, h.set(pe, Z));
            let te = Z.get(N);
            te === void 0 && (te = i.getUniformBlockIndex(pe, N.name), Z.set(N, te));
        }
        function ze(N, pe) {
            const te = h.get(pe).get(N);
            l.get(pe) !== te && (i.uniformBlockBinding(pe, te, N.__bindingPointIndex), l.set(pe, te));
        }
        function pt() {
            i.disable(i.BLEND), i.disable(i.CULL_FACE), i.disable(i.DEPTH_TEST), i.disable(i.POLYGON_OFFSET_FILL), i.disable(i.SCISSOR_TEST), i.disable(i.STENCIL_TEST), i.disable(i.SAMPLE_ALPHA_TO_COVERAGE), i.blendEquation(i.FUNC_ADD), i.blendFunc(i.ONE, i.ZERO), i.blendFuncSeparate(i.ONE, i.ZERO, i.ONE, i.ZERO), i.blendColor(0, 0, 0, 0), i.colorMask(!0, !0, !0, !0), i.clearColor(0, 0, 0, 0), i.depthMask(!0), i.depthFunc(i.LESS), a.setReversed(!1), i.clearDepth(1), i.stencilMask(4294967295), i.stencilFunc(i.ALWAYS, 0, 4294967295), i.stencilOp(i.KEEP, i.KEEP, i.KEEP), i.clearStencil(0), i.cullFace(i.BACK), i.frontFace(i.CCW), i.polygonOffset(0, 0), i.activeTexture(i.TEXTURE0), i.bindFramebuffer(i.FRAMEBUFFER, null), i.bindFramebuffer(i.DRAW_FRAMEBUFFER, null), i.bindFramebuffer(i.READ_FRAMEBUFFER, null), i.useProgram(null), i.lineWidth(1), i.scissor(0, 0, i.canvas.width, i.canvas.height), i.viewport(0, 0, i.canvas.width, i.canvas.height), d = {}, U = null, F = {}, c = {}, u = new WeakMap, f = [], _ = null, g = !1, m = null, p = null, x = null, v = null, y = null, P = null, w = null, R = new Oe(0, 0, 0), B = 0, T = !1, S = null, D = null, q = null, H = null, $ = null, ie.set(0, 0, i.canvas.width, i.canvas.height), z.set(0, 0, i.canvas.width, i.canvas.height), r.reset(), a.reset(), o.reset();
        }
        return {
            buffers: {
                color: r,
                depth: a,
                stencil: o
            },
            enable: se,
            disable: ce,
            bindFramebuffer: we,
            drawBuffers: he,
            useProgram: st,
            setBlending: L,
            setMaterial: Ce,
            setFlipSided: ge,
            setCullFace: Xe,
            setLineWidth: Ae,
            setPolygonOffset: ft,
            setScissorTest: Ee,
            activeTexture: I,
            bindTexture: M,
            unbindTexture: W,
            compressedTexImage2D: ee,
            compressedTexImage3D: re,
            texImage2D: ye,
            texImage3D: De,
            updateUBOMapping: $e,
            uniformBlockBinding: ze,
            texStorage2D: Je,
            texStorage3D: le,
            texSubImage2D: Q,
            texSubImage3D: Me,
            compressedTexSubImage2D: fe,
            compressedTexSubImage3D: ve,
            scissor: Ue,
            viewport: be,
            reset: pt
        };
    }
    function pT(i, e, t, n, s, r, a) {
        const o = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, l = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), h = new Ze, d = new WeakMap;
        let c;
        const u = new WeakMap;
        let f = !1;
        try {
            f = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
        } catch  {}
        function _(I, M) {
            return f ? new OffscreenCanvas(I, M) : Wr("canvas");
        }
        function g(I, M, W) {
            let ee = 1;
            const re = Ee(I);
            if ((re.width > W || re.height > W) && (ee = W / Math.max(re.width, re.height)), ee < 1) if (typeof HTMLImageElement < "u" && I instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && I instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && I instanceof ImageBitmap || typeof VideoFrame < "u" && I instanceof VideoFrame) {
                const Q = Math.floor(ee * re.width), Me = Math.floor(ee * re.height);
                c === void 0 && (c = _(Q, Me));
                const fe = M ? _(Q, Me) : c;
                return fe.width = Q, fe.height = Me, fe.getContext("2d").drawImage(I, 0, 0, Q, Me), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + re.width + "x" + re.height + ") to (" + Q + "x" + Me + ")."), fe;
            } else return "data" in I && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + re.width + "x" + re.height + ")."), I;
            return I;
        }
        function m(I) {
            return I.generateMipmaps;
        }
        function p(I) {
            i.generateMipmap(I);
        }
        function x(I) {
            return I.isWebGLCubeRenderTarget ? i.TEXTURE_CUBE_MAP : I.isWebGL3DRenderTarget ? i.TEXTURE_3D : I.isWebGLArrayRenderTarget || I.isCompressedArrayTexture ? i.TEXTURE_2D_ARRAY : i.TEXTURE_2D;
        }
        function v(I, M, W, ee, re = !1) {
            if (I !== null) {
                if (i[I] !== void 0) return i[I];
                console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + I + "'");
            }
            let Q = M;
            if (M === i.RED && (W === i.FLOAT && (Q = i.R32F), W === i.HALF_FLOAT && (Q = i.R16F), W === i.UNSIGNED_BYTE && (Q = i.R8)), M === i.RED_INTEGER && (W === i.UNSIGNED_BYTE && (Q = i.R8UI), W === i.UNSIGNED_SHORT && (Q = i.R16UI), W === i.UNSIGNED_INT && (Q = i.R32UI), W === i.BYTE && (Q = i.R8I), W === i.SHORT && (Q = i.R16I), W === i.INT && (Q = i.R32I)), M === i.RG && (W === i.FLOAT && (Q = i.RG32F), W === i.HALF_FLOAT && (Q = i.RG16F), W === i.UNSIGNED_BYTE && (Q = i.RG8)), M === i.RG_INTEGER && (W === i.UNSIGNED_BYTE && (Q = i.RG8UI), W === i.UNSIGNED_SHORT && (Q = i.RG16UI), W === i.UNSIGNED_INT && (Q = i.RG32UI), W === i.BYTE && (Q = i.RG8I), W === i.SHORT && (Q = i.RG16I), W === i.INT && (Q = i.RG32I)), M === i.RGB_INTEGER && (W === i.UNSIGNED_BYTE && (Q = i.RGB8UI), W === i.UNSIGNED_SHORT && (Q = i.RGB16UI), W === i.UNSIGNED_INT && (Q = i.RGB32UI), W === i.BYTE && (Q = i.RGB8I), W === i.SHORT && (Q = i.RGB16I), W === i.INT && (Q = i.RGB32I)), M === i.RGBA_INTEGER && (W === i.UNSIGNED_BYTE && (Q = i.RGBA8UI), W === i.UNSIGNED_SHORT && (Q = i.RGBA16UI), W === i.UNSIGNED_INT && (Q = i.RGBA32UI), W === i.BYTE && (Q = i.RGBA8I), W === i.SHORT && (Q = i.RGBA16I), W === i.INT && (Q = i.RGBA32I)), M === i.RGB && W === i.UNSIGNED_INT_5_9_9_9_REV && (Q = i.RGB9_E5), M === i.RGBA) {
                const Me = re ? eo : Ke.getTransfer(ee);
                W === i.FLOAT && (Q = i.RGBA32F), W === i.HALF_FLOAT && (Q = i.RGBA16F), W === i.UNSIGNED_BYTE && (Q = Me === ut ? i.SRGB8_ALPHA8 : i.RGBA8), W === i.UNSIGNED_SHORT_4_4_4_4 && (Q = i.RGBA4), W === i.UNSIGNED_SHORT_5_5_5_1 && (Q = i.RGB5_A1);
            }
            return (Q === i.R16F || Q === i.R32F || Q === i.RG16F || Q === i.RG32F || Q === i.RGBA16F || Q === i.RGBA32F) && e.get("EXT_color_buffer_float"), Q;
        }
        function y(I, M) {
            let W;
            return I ? M === null || M === Ji || M === kr ? W = i.DEPTH24_STENCIL8 : M === Pn ? W = i.DEPTH32F_STENCIL8 : M === Or && (W = i.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : M === null || M === Ji || M === kr ? W = i.DEPTH_COMPONENT24 : M === Pn ? W = i.DEPTH_COMPONENT32F : M === Or && (W = i.DEPTH_COMPONENT16), W;
        }
        function P(I, M) {
            return m(I) === !0 || I.isFramebufferTexture && I.minFilter !== $t && I.minFilter !== cn ? Math.log2(Math.max(M.width, M.height)) + 1 : I.mipmaps !== void 0 && I.mipmaps.length > 0 ? I.mipmaps.length : I.isCompressedTexture && Array.isArray(I.image) ? M.mipmaps.length : 1;
        }
        function w(I) {
            const M = I.target;
            M.removeEventListener("dispose", w), B(M), M.isVideoTexture && d.delete(M);
        }
        function R(I) {
            const M = I.target;
            M.removeEventListener("dispose", R), S(M);
        }
        function B(I) {
            const M = n.get(I);
            if (M.__webglInit === void 0) return;
            const W = I.source, ee = u.get(W);
            if (ee) {
                const re = ee[M.__cacheKey];
                re.usedTimes--, re.usedTimes === 0 && T(I), Object.keys(ee).length === 0 && u.delete(W);
            }
            n.remove(I);
        }
        function T(I) {
            const M = n.get(I);
            i.deleteTexture(M.__webglTexture);
            const W = I.source, ee = u.get(W);
            delete ee[M.__cacheKey], a.memory.textures--;
        }
        function S(I) {
            const M = n.get(I);
            if (I.depthTexture && (I.depthTexture.dispose(), n.remove(I.depthTexture)), I.isWebGLCubeRenderTarget) for(let ee = 0; ee < 6; ee++){
                if (Array.isArray(M.__webglFramebuffer[ee])) for(let re = 0; re < M.__webglFramebuffer[ee].length; re++)i.deleteFramebuffer(M.__webglFramebuffer[ee][re]);
                else i.deleteFramebuffer(M.__webglFramebuffer[ee]);
                M.__webglDepthbuffer && i.deleteRenderbuffer(M.__webglDepthbuffer[ee]);
            }
            else {
                if (Array.isArray(M.__webglFramebuffer)) for(let ee = 0; ee < M.__webglFramebuffer.length; ee++)i.deleteFramebuffer(M.__webglFramebuffer[ee]);
                else i.deleteFramebuffer(M.__webglFramebuffer);
                if (M.__webglDepthbuffer && i.deleteRenderbuffer(M.__webglDepthbuffer), M.__webglMultisampledFramebuffer && i.deleteFramebuffer(M.__webglMultisampledFramebuffer), M.__webglColorRenderbuffer) for(let ee = 0; ee < M.__webglColorRenderbuffer.length; ee++)M.__webglColorRenderbuffer[ee] && i.deleteRenderbuffer(M.__webglColorRenderbuffer[ee]);
                M.__webglDepthRenderbuffer && i.deleteRenderbuffer(M.__webglDepthRenderbuffer);
            }
            const W = I.textures;
            for(let ee = 0, re = W.length; ee < re; ee++){
                const Q = n.get(W[ee]);
                Q.__webglTexture && (i.deleteTexture(Q.__webglTexture), a.memory.textures--), n.remove(W[ee]);
            }
            n.remove(I);
        }
        let D = 0;
        function q() {
            D = 0;
        }
        function H() {
            const I = D;
            return I >= s.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + I + " texture units while this GPU supports only " + s.maxTextures), D += 1, I;
        }
        function $(I) {
            const M = [];
            return M.push(I.wrapS), M.push(I.wrapT), M.push(I.wrapR || 0), M.push(I.magFilter), M.push(I.minFilter), M.push(I.anisotropy), M.push(I.internalFormat), M.push(I.format), M.push(I.type), M.push(I.generateMipmaps), M.push(I.premultiplyAlpha), M.push(I.flipY), M.push(I.unpackAlignment), M.push(I.colorSpace), M.join();
        }
        function ne(I, M) {
            const W = n.get(I);
            if (I.isVideoTexture && Ae(I), I.isRenderTargetTexture === !1 && I.version > 0 && W.__version !== I.version) {
                const ee = I.image;
                if (ee === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
                else if (ee.complete === !1) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
                else {
                    z(W, I, M);
                    return;
                }
            }
            t.bindTexture(i.TEXTURE_2D, W.__webglTexture, i.TEXTURE0 + M);
        }
        function b(I, M) {
            const W = n.get(I);
            if (I.version > 0 && W.__version !== I.version) {
                z(W, I, M);
                return;
            }
            t.bindTexture(i.TEXTURE_2D_ARRAY, W.__webglTexture, i.TEXTURE0 + M);
        }
        function C(I, M) {
            const W = n.get(I);
            if (I.version > 0 && W.__version !== I.version) {
                z(W, I, M);
                return;
            }
            t.bindTexture(i.TEXTURE_3D, W.__webglTexture, i.TEXTURE0 + M);
        }
        function E(I, M) {
            const W = n.get(I);
            if (I.version > 0 && W.__version !== I.version) {
                K(W, I, M);
                return;
            }
            t.bindTexture(i.TEXTURE_CUBE_MAP, W.__webglTexture, i.TEXTURE0 + M);
        }
        const U = {
            [Gs]: i.REPEAT,
            [yi]: i.CLAMP_TO_EDGE,
            [Ja]: i.MIRRORED_REPEAT
        }, F = {
            [$t]: i.NEAREST,
            [tp]: i.NEAREST_MIPMAP_NEAREST,
            [Tr]: i.NEAREST_MIPMAP_LINEAR,
            [cn]: i.LINEAR,
            [Oa]: i.LINEAR_MIPMAP_NEAREST,
            [ni]: i.LINEAR_MIPMAP_LINEAR
        }, V = {
            [Zg]: i.NEVER,
            [ix]: i.ALWAYS,
            [Jg]: i.LESS,
            [pp]: i.LEQUAL,
            [Qg]: i.EQUAL,
            [nx]: i.GEQUAL,
            [ex]: i.GREATER,
            [tx]: i.NOTEQUAL
        };
        function j(I, M) {
            if (M.type === Pn && e.has("OES_texture_float_linear") === !1 && (M.magFilter === cn || M.magFilter === Oa || M.magFilter === Tr || M.magFilter === ni || M.minFilter === cn || M.minFilter === Oa || M.minFilter === Tr || M.minFilter === ni) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), i.texParameteri(I, i.TEXTURE_WRAP_S, U[M.wrapS]), i.texParameteri(I, i.TEXTURE_WRAP_T, U[M.wrapT]), (I === i.TEXTURE_3D || I === i.TEXTURE_2D_ARRAY) && i.texParameteri(I, i.TEXTURE_WRAP_R, U[M.wrapR]), i.texParameteri(I, i.TEXTURE_MAG_FILTER, F[M.magFilter]), i.texParameteri(I, i.TEXTURE_MIN_FILTER, F[M.minFilter]), M.compareFunction && (i.texParameteri(I, i.TEXTURE_COMPARE_MODE, i.COMPARE_REF_TO_TEXTURE), i.texParameteri(I, i.TEXTURE_COMPARE_FUNC, V[M.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
                if (M.magFilter === $t || M.minFilter !== Tr && M.minFilter !== ni || M.type === Pn && e.has("OES_texture_float_linear") === !1) return;
                if (M.anisotropy > 1 || n.get(M).__currentAnisotropy) {
                    const W = e.get("EXT_texture_filter_anisotropic");
                    i.texParameterf(I, W.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(M.anisotropy, s.getMaxAnisotropy())), n.get(M).__currentAnisotropy = M.anisotropy;
                }
            }
        }
        function ie(I, M) {
            let W = !1;
            I.__webglInit === void 0 && (I.__webglInit = !0, M.addEventListener("dispose", w));
            const ee = M.source;
            let re = u.get(ee);
            re === void 0 && (re = {}, u.set(ee, re));
            const Q = $(M);
            if (Q !== I.__cacheKey) {
                re[Q] === void 0 && (re[Q] = {
                    texture: i.createTexture(),
                    usedTimes: 0
                }, a.memory.textures++, W = !0), re[Q].usedTimes++;
                const Me = re[I.__cacheKey];
                Me !== void 0 && (re[I.__cacheKey].usedTimes--, Me.usedTimes === 0 && T(M)), I.__cacheKey = Q, I.__webglTexture = re[Q].texture;
            }
            return W;
        }
        function z(I, M, W) {
            let ee = i.TEXTURE_2D;
            (M.isDataArrayTexture || M.isCompressedArrayTexture) && (ee = i.TEXTURE_2D_ARRAY), M.isData3DTexture && (ee = i.TEXTURE_3D);
            const re = ie(I, M), Q = M.source;
            t.bindTexture(ee, I.__webglTexture, i.TEXTURE0 + W);
            const Me = n.get(Q);
            if (Q.version !== Me.__version || re === !0) {
                t.activeTexture(i.TEXTURE0 + W);
                const fe = Ke.getPrimaries(Ke.workingColorSpace), ve = M.colorSpace === vi ? null : Ke.getPrimaries(M.colorSpace), Je = M.colorSpace === vi || fe === ve ? i.NONE : i.BROWSER_DEFAULT_WEBGL;
                i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, M.flipY), i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, M.premultiplyAlpha), i.pixelStorei(i.UNPACK_ALIGNMENT, M.unpackAlignment), i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL, Je);
                let le = g(M.image, !1, s.maxTextureSize);
                le = ft(M, le);
                const ye = r.convert(M.format, M.colorSpace), De = r.convert(M.type);
                let Ue = v(M.internalFormat, ye, De, M.colorSpace, M.isVideoTexture);
                j(ee, M);
                let be;
                const $e = M.mipmaps, ze = M.isVideoTexture !== !0, pt = Me.__version === void 0 || re === !0, N = Q.dataReady, pe = P(M, le);
                if (M.isDepthTexture) Ue = y(M.format === Hr, M.type), pt && (ze ? t.texStorage2D(i.TEXTURE_2D, 1, Ue, le.width, le.height) : t.texImage2D(i.TEXTURE_2D, 0, Ue, le.width, le.height, 0, ye, De, null));
                else if (M.isDataTexture) if ($e.length > 0) {
                    ze && pt && t.texStorage2D(i.TEXTURE_2D, pe, Ue, $e[0].width, $e[0].height);
                    for(let Z = 0, te = $e.length; Z < te; Z++)be = $e[Z], ze ? N && t.texSubImage2D(i.TEXTURE_2D, Z, 0, 0, be.width, be.height, ye, De, be.data) : t.texImage2D(i.TEXTURE_2D, Z, Ue, be.width, be.height, 0, ye, De, be.data);
                    M.generateMipmaps = !1;
                } else ze ? (pt && t.texStorage2D(i.TEXTURE_2D, pe, Ue, le.width, le.height), N && t.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, le.width, le.height, ye, De, le.data)) : t.texImage2D(i.TEXTURE_2D, 0, Ue, le.width, le.height, 0, ye, De, le.data);
                else if (M.isCompressedTexture) if (M.isCompressedArrayTexture) {
                    ze && pt && t.texStorage3D(i.TEXTURE_2D_ARRAY, pe, Ue, $e[0].width, $e[0].height, le.depth);
                    for(let Z = 0, te = $e.length; Z < te; Z++)if (be = $e[Z], M.format !== xn) if (ye !== null) if (ze) {
                        if (N) if (M.layerUpdates.size > 0) {
                            const _e = ed(be.width, be.height, M.format, M.type);
                            for (const me of M.layerUpdates){
                                const ke = be.data.subarray(me * _e / be.data.BYTES_PER_ELEMENT, (me + 1) * _e / be.data.BYTES_PER_ELEMENT);
                                t.compressedTexSubImage3D(i.TEXTURE_2D_ARRAY, Z, 0, 0, me, be.width, be.height, 1, ye, ke);
                            }
                            M.clearLayerUpdates();
                        } else t.compressedTexSubImage3D(i.TEXTURE_2D_ARRAY, Z, 0, 0, 0, be.width, be.height, le.depth, ye, be.data);
                    } else t.compressedTexImage3D(i.TEXTURE_2D_ARRAY, Z, Ue, be.width, be.height, le.depth, 0, be.data, 0, 0);
                    else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                    else ze ? N && t.texSubImage3D(i.TEXTURE_2D_ARRAY, Z, 0, 0, 0, be.width, be.height, le.depth, ye, De, be.data) : t.texImage3D(i.TEXTURE_2D_ARRAY, Z, Ue, be.width, be.height, le.depth, 0, ye, De, be.data);
                } else {
                    ze && pt && t.texStorage2D(i.TEXTURE_2D, pe, Ue, $e[0].width, $e[0].height);
                    for(let Z = 0, te = $e.length; Z < te; Z++)be = $e[Z], M.format !== xn ? ye !== null ? ze ? N && t.compressedTexSubImage2D(i.TEXTURE_2D, Z, 0, 0, be.width, be.height, ye, be.data) : t.compressedTexImage2D(i.TEXTURE_2D, Z, Ue, be.width, be.height, 0, be.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : ze ? N && t.texSubImage2D(i.TEXTURE_2D, Z, 0, 0, be.width, be.height, ye, De, be.data) : t.texImage2D(i.TEXTURE_2D, Z, Ue, be.width, be.height, 0, ye, De, be.data);
                }
                else if (M.isDataArrayTexture) if (ze) {
                    if (pt && t.texStorage3D(i.TEXTURE_2D_ARRAY, pe, Ue, le.width, le.height, le.depth), N) if (M.layerUpdates.size > 0) {
                        const Z = ed(le.width, le.height, M.format, M.type);
                        for (const te of M.layerUpdates){
                            const _e = le.data.subarray(te * Z / le.data.BYTES_PER_ELEMENT, (te + 1) * Z / le.data.BYTES_PER_ELEMENT);
                            t.texSubImage3D(i.TEXTURE_2D_ARRAY, 0, 0, 0, te, le.width, le.height, 1, ye, De, _e);
                        }
                        M.clearLayerUpdates();
                    } else t.texSubImage3D(i.TEXTURE_2D_ARRAY, 0, 0, 0, 0, le.width, le.height, le.depth, ye, De, le.data);
                } else t.texImage3D(i.TEXTURE_2D_ARRAY, 0, Ue, le.width, le.height, le.depth, 0, ye, De, le.data);
                else if (M.isData3DTexture) ze ? (pt && t.texStorage3D(i.TEXTURE_3D, pe, Ue, le.width, le.height, le.depth), N && t.texSubImage3D(i.TEXTURE_3D, 0, 0, 0, 0, le.width, le.height, le.depth, ye, De, le.data)) : t.texImage3D(i.TEXTURE_3D, 0, Ue, le.width, le.height, le.depth, 0, ye, De, le.data);
                else if (M.isFramebufferTexture) {
                    if (pt) if (ze) t.texStorage2D(i.TEXTURE_2D, pe, Ue, le.width, le.height);
                    else {
                        let Z = le.width, te = le.height;
                        for(let _e = 0; _e < pe; _e++)t.texImage2D(i.TEXTURE_2D, _e, Ue, Z, te, 0, ye, De, null), Z >>= 1, te >>= 1;
                    }
                } else if ($e.length > 0) {
                    if (ze && pt) {
                        const Z = Ee($e[0]);
                        t.texStorage2D(i.TEXTURE_2D, pe, Ue, Z.width, Z.height);
                    }
                    for(let Z = 0, te = $e.length; Z < te; Z++)be = $e[Z], ze ? N && t.texSubImage2D(i.TEXTURE_2D, Z, 0, 0, ye, De, be) : t.texImage2D(i.TEXTURE_2D, Z, Ue, ye, De, be);
                    M.generateMipmaps = !1;
                } else if (ze) {
                    if (pt) {
                        const Z = Ee(le);
                        t.texStorage2D(i.TEXTURE_2D, pe, Ue, Z.width, Z.height);
                    }
                    N && t.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, ye, De, le);
                } else t.texImage2D(i.TEXTURE_2D, 0, Ue, ye, De, le);
                m(M) && p(ee), Me.__version = Q.version, M.onUpdate && M.onUpdate(M);
            }
            I.__version = M.version;
        }
        function K(I, M, W) {
            if (M.image.length !== 6) return;
            const ee = ie(I, M), re = M.source;
            t.bindTexture(i.TEXTURE_CUBE_MAP, I.__webglTexture, i.TEXTURE0 + W);
            const Q = n.get(re);
            if (re.version !== Q.__version || ee === !0) {
                t.activeTexture(i.TEXTURE0 + W);
                const Me = Ke.getPrimaries(Ke.workingColorSpace), fe = M.colorSpace === vi ? null : Ke.getPrimaries(M.colorSpace), ve = M.colorSpace === vi || Me === fe ? i.NONE : i.BROWSER_DEFAULT_WEBGL;
                i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, M.flipY), i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, M.premultiplyAlpha), i.pixelStorei(i.UNPACK_ALIGNMENT, M.unpackAlignment), i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL, ve);
                const Je = M.isCompressedTexture || M.image[0].isCompressedTexture, le = M.image[0] && M.image[0].isDataTexture, ye = [];
                for(let te = 0; te < 6; te++)!Je && !le ? ye[te] = g(M.image[te], !0, s.maxCubemapSize) : ye[te] = le ? M.image[te].image : M.image[te], ye[te] = ft(M, ye[te]);
                const De = ye[0], Ue = r.convert(M.format, M.colorSpace), be = r.convert(M.type), $e = v(M.internalFormat, Ue, be, M.colorSpace), ze = M.isVideoTexture !== !0, pt = Q.__version === void 0 || ee === !0, N = re.dataReady;
                let pe = P(M, De);
                j(i.TEXTURE_CUBE_MAP, M);
                let Z;
                if (Je) {
                    ze && pt && t.texStorage2D(i.TEXTURE_CUBE_MAP, pe, $e, De.width, De.height);
                    for(let te = 0; te < 6; te++){
                        Z = ye[te].mipmaps;
                        for(let _e = 0; _e < Z.length; _e++){
                            const me = Z[_e];
                            M.format !== xn ? Ue !== null ? ze ? N && t.compressedTexSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + te, _e, 0, 0, me.width, me.height, Ue, me.data) : t.compressedTexImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + te, _e, $e, me.width, me.height, 0, me.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : ze ? N && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + te, _e, 0, 0, me.width, me.height, Ue, be, me.data) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + te, _e, $e, me.width, me.height, 0, Ue, be, me.data);
                        }
                    }
                } else {
                    if (Z = M.mipmaps, ze && pt) {
                        Z.length > 0 && pe++;
                        const te = Ee(ye[0]);
                        t.texStorage2D(i.TEXTURE_CUBE_MAP, pe, $e, te.width, te.height);
                    }
                    for(let te = 0; te < 6; te++)if (le) {
                        ze ? N && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + te, 0, 0, 0, ye[te].width, ye[te].height, Ue, be, ye[te].data) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + te, 0, $e, ye[te].width, ye[te].height, 0, Ue, be, ye[te].data);
                        for(let _e = 0; _e < Z.length; _e++){
                            const ke = Z[_e].image[te].image;
                            ze ? N && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + te, _e + 1, 0, 0, ke.width, ke.height, Ue, be, ke.data) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + te, _e + 1, $e, ke.width, ke.height, 0, Ue, be, ke.data);
                        }
                    } else {
                        ze ? N && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + te, 0, 0, 0, Ue, be, ye[te]) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + te, 0, $e, Ue, be, ye[te]);
                        for(let _e = 0; _e < Z.length; _e++){
                            const me = Z[_e];
                            ze ? N && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + te, _e + 1, 0, 0, Ue, be, me.image[te]) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + te, _e + 1, $e, Ue, be, me.image[te]);
                        }
                    }
                }
                m(M) && p(i.TEXTURE_CUBE_MAP), Q.__version = re.version, M.onUpdate && M.onUpdate(M);
            }
            I.__version = M.version;
        }
        function oe(I, M, W, ee, re, Q) {
            const Me = r.convert(W.format, W.colorSpace), fe = r.convert(W.type), ve = v(W.internalFormat, Me, fe, W.colorSpace), Je = n.get(M), le = n.get(W);
            if (le.__renderTarget = M, !Je.__hasExternalTextures) {
                const ye = Math.max(1, M.width >> Q), De = Math.max(1, M.height >> Q);
                re === i.TEXTURE_3D || re === i.TEXTURE_2D_ARRAY ? t.texImage3D(re, Q, ve, ye, De, M.depth, 0, Me, fe, null) : t.texImage2D(re, Q, ve, ye, De, 0, Me, fe, null);
            }
            t.bindFramebuffer(i.FRAMEBUFFER, I), Xe(M) ? o.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER, ee, re, le.__webglTexture, 0, ge(M)) : (re === i.TEXTURE_2D || re >= i.TEXTURE_CUBE_MAP_POSITIVE_X && re <= i.TEXTURE_CUBE_MAP_NEGATIVE_Z) && i.framebufferTexture2D(i.FRAMEBUFFER, ee, re, le.__webglTexture, Q), t.bindFramebuffer(i.FRAMEBUFFER, null);
        }
        function se(I, M, W) {
            if (i.bindRenderbuffer(i.RENDERBUFFER, I), M.depthBuffer) {
                const ee = M.depthTexture, re = ee && ee.isDepthTexture ? ee.type : null, Q = y(M.stencilBuffer, re), Me = M.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT, fe = ge(M);
                Xe(M) ? o.renderbufferStorageMultisampleEXT(i.RENDERBUFFER, fe, Q, M.width, M.height) : W ? i.renderbufferStorageMultisample(i.RENDERBUFFER, fe, Q, M.width, M.height) : i.renderbufferStorage(i.RENDERBUFFER, Q, M.width, M.height), i.framebufferRenderbuffer(i.FRAMEBUFFER, Me, i.RENDERBUFFER, I);
            } else {
                const ee = M.textures;
                for(let re = 0; re < ee.length; re++){
                    const Q = ee[re], Me = r.convert(Q.format, Q.colorSpace), fe = r.convert(Q.type), ve = v(Q.internalFormat, Me, fe, Q.colorSpace), Je = ge(M);
                    W && Xe(M) === !1 ? i.renderbufferStorageMultisample(i.RENDERBUFFER, Je, ve, M.width, M.height) : Xe(M) ? o.renderbufferStorageMultisampleEXT(i.RENDERBUFFER, Je, ve, M.width, M.height) : i.renderbufferStorage(i.RENDERBUFFER, ve, M.width, M.height);
                }
            }
            i.bindRenderbuffer(i.RENDERBUFFER, null);
        }
        function ce(I, M) {
            if (M && M.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
            if (t.bindFramebuffer(i.FRAMEBUFFER, I), !(M.depthTexture && M.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
            const ee = n.get(M.depthTexture);
            ee.__renderTarget = M, (!ee.__webglTexture || M.depthTexture.image.width !== M.width || M.depthTexture.image.height !== M.height) && (M.depthTexture.image.width = M.width, M.depthTexture.image.height = M.height, M.depthTexture.needsUpdate = !0), ne(M.depthTexture, 0);
            const re = ee.__webglTexture, Q = ge(M);
            if (M.depthTexture.format === Gr) Xe(M) ? o.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.TEXTURE_2D, re, 0, Q) : i.framebufferTexture2D(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.TEXTURE_2D, re, 0);
            else if (M.depthTexture.format === Hr) Xe(M) ? o.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.TEXTURE_2D, re, 0, Q) : i.framebufferTexture2D(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.TEXTURE_2D, re, 0);
            else throw new Error("Unknown depthTexture format");
        }
        function we(I) {
            const M = n.get(I), W = I.isWebGLCubeRenderTarget === !0;
            if (M.__boundDepthTexture !== I.depthTexture) {
                const ee = I.depthTexture;
                if (M.__depthDisposeCallback && M.__depthDisposeCallback(), ee) {
                    const re = ()=>{
                        delete M.__boundDepthTexture, delete M.__depthDisposeCallback, ee.removeEventListener("dispose", re);
                    };
                    ee.addEventListener("dispose", re), M.__depthDisposeCallback = re;
                }
                M.__boundDepthTexture = ee;
            }
            if (I.depthTexture && !M.__autoAllocateDepthBuffer) {
                if (W) throw new Error("target.depthTexture not supported in Cube render targets");
                ce(M.__webglFramebuffer, I);
            } else if (W) {
                M.__webglDepthbuffer = [];
                for(let ee = 0; ee < 6; ee++)if (t.bindFramebuffer(i.FRAMEBUFFER, M.__webglFramebuffer[ee]), M.__webglDepthbuffer[ee] === void 0) M.__webglDepthbuffer[ee] = i.createRenderbuffer(), se(M.__webglDepthbuffer[ee], I, !1);
                else {
                    const re = I.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT, Q = M.__webglDepthbuffer[ee];
                    i.bindRenderbuffer(i.RENDERBUFFER, Q), i.framebufferRenderbuffer(i.FRAMEBUFFER, re, i.RENDERBUFFER, Q);
                }
            } else if (t.bindFramebuffer(i.FRAMEBUFFER, M.__webglFramebuffer), M.__webglDepthbuffer === void 0) M.__webglDepthbuffer = i.createRenderbuffer(), se(M.__webglDepthbuffer, I, !1);
            else {
                const ee = I.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT, re = M.__webglDepthbuffer;
                i.bindRenderbuffer(i.RENDERBUFFER, re), i.framebufferRenderbuffer(i.FRAMEBUFFER, ee, i.RENDERBUFFER, re);
            }
            t.bindFramebuffer(i.FRAMEBUFFER, null);
        }
        function he(I, M, W) {
            const ee = n.get(I);
            M !== void 0 && oe(ee.__webglFramebuffer, I, I.texture, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, 0), W !== void 0 && we(I);
        }
        function st(I) {
            const M = I.texture, W = n.get(I), ee = n.get(M);
            I.addEventListener("dispose", R);
            const re = I.textures, Q = I.isWebGLCubeRenderTarget === !0, Me = re.length > 1;
            if (Me || (ee.__webglTexture === void 0 && (ee.__webglTexture = i.createTexture()), ee.__version = M.version, a.memory.textures++), Q) {
                W.__webglFramebuffer = [];
                for(let fe = 0; fe < 6; fe++)if (M.mipmaps && M.mipmaps.length > 0) {
                    W.__webglFramebuffer[fe] = [];
                    for(let ve = 0; ve < M.mipmaps.length; ve++)W.__webglFramebuffer[fe][ve] = i.createFramebuffer();
                } else W.__webglFramebuffer[fe] = i.createFramebuffer();
            } else {
                if (M.mipmaps && M.mipmaps.length > 0) {
                    W.__webglFramebuffer = [];
                    for(let fe = 0; fe < M.mipmaps.length; fe++)W.__webglFramebuffer[fe] = i.createFramebuffer();
                } else W.__webglFramebuffer = i.createFramebuffer();
                if (Me) for(let fe = 0, ve = re.length; fe < ve; fe++){
                    const Je = n.get(re[fe]);
                    Je.__webglTexture === void 0 && (Je.__webglTexture = i.createTexture(), a.memory.textures++);
                }
                if (I.samples > 0 && Xe(I) === !1) {
                    W.__webglMultisampledFramebuffer = i.createFramebuffer(), W.__webglColorRenderbuffer = [], t.bindFramebuffer(i.FRAMEBUFFER, W.__webglMultisampledFramebuffer);
                    for(let fe = 0; fe < re.length; fe++){
                        const ve = re[fe];
                        W.__webglColorRenderbuffer[fe] = i.createRenderbuffer(), i.bindRenderbuffer(i.RENDERBUFFER, W.__webglColorRenderbuffer[fe]);
                        const Je = r.convert(ve.format, ve.colorSpace), le = r.convert(ve.type), ye = v(ve.internalFormat, Je, le, ve.colorSpace, I.isXRRenderTarget === !0), De = ge(I);
                        i.renderbufferStorageMultisample(i.RENDERBUFFER, De, ye, I.width, I.height), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + fe, i.RENDERBUFFER, W.__webglColorRenderbuffer[fe]);
                    }
                    i.bindRenderbuffer(i.RENDERBUFFER, null), I.depthBuffer && (W.__webglDepthRenderbuffer = i.createRenderbuffer(), se(W.__webglDepthRenderbuffer, I, !0)), t.bindFramebuffer(i.FRAMEBUFFER, null);
                }
            }
            if (Q) {
                t.bindTexture(i.TEXTURE_CUBE_MAP, ee.__webglTexture), j(i.TEXTURE_CUBE_MAP, M);
                for(let fe = 0; fe < 6; fe++)if (M.mipmaps && M.mipmaps.length > 0) for(let ve = 0; ve < M.mipmaps.length; ve++)oe(W.__webglFramebuffer[fe][ve], I, M, i.COLOR_ATTACHMENT0, i.TEXTURE_CUBE_MAP_POSITIVE_X + fe, ve);
                else oe(W.__webglFramebuffer[fe], I, M, i.COLOR_ATTACHMENT0, i.TEXTURE_CUBE_MAP_POSITIVE_X + fe, 0);
                m(M) && p(i.TEXTURE_CUBE_MAP), t.unbindTexture();
            } else if (Me) {
                for(let fe = 0, ve = re.length; fe < ve; fe++){
                    const Je = re[fe], le = n.get(Je);
                    t.bindTexture(i.TEXTURE_2D, le.__webglTexture), j(i.TEXTURE_2D, Je), oe(W.__webglFramebuffer, I, Je, i.COLOR_ATTACHMENT0 + fe, i.TEXTURE_2D, 0), m(Je) && p(i.TEXTURE_2D);
                }
                t.unbindTexture();
            } else {
                let fe = i.TEXTURE_2D;
                if ((I.isWebGL3DRenderTarget || I.isWebGLArrayRenderTarget) && (fe = I.isWebGL3DRenderTarget ? i.TEXTURE_3D : i.TEXTURE_2D_ARRAY), t.bindTexture(fe, ee.__webglTexture), j(fe, M), M.mipmaps && M.mipmaps.length > 0) for(let ve = 0; ve < M.mipmaps.length; ve++)oe(W.__webglFramebuffer[ve], I, M, i.COLOR_ATTACHMENT0, fe, ve);
                else oe(W.__webglFramebuffer, I, M, i.COLOR_ATTACHMENT0, fe, 0);
                m(M) && p(fe), t.unbindTexture();
            }
            I.depthBuffer && we(I);
        }
        function We(I) {
            const M = I.textures;
            for(let W = 0, ee = M.length; W < ee; W++){
                const re = M[W];
                if (m(re)) {
                    const Q = x(I), Me = n.get(re).__webglTexture;
                    t.bindTexture(Q, Me), p(Q), t.unbindTexture();
                }
            }
        }
        const Be = [], L = [];
        function Ce(I) {
            if (I.samples > 0) {
                if (Xe(I) === !1) {
                    const M = I.textures, W = I.width, ee = I.height;
                    let re = i.COLOR_BUFFER_BIT;
                    const Q = I.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT, Me = n.get(I), fe = M.length > 1;
                    if (fe) for(let ve = 0; ve < M.length; ve++)t.bindFramebuffer(i.FRAMEBUFFER, Me.__webglMultisampledFramebuffer), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + ve, i.RENDERBUFFER, null), t.bindFramebuffer(i.FRAMEBUFFER, Me.__webglFramebuffer), i.framebufferTexture2D(i.DRAW_FRAMEBUFFER, i.COLOR_ATTACHMENT0 + ve, i.TEXTURE_2D, null, 0);
                    t.bindFramebuffer(i.READ_FRAMEBUFFER, Me.__webglMultisampledFramebuffer), t.bindFramebuffer(i.DRAW_FRAMEBUFFER, Me.__webglFramebuffer);
                    for(let ve = 0; ve < M.length; ve++){
                        if (I.resolveDepthBuffer && (I.depthBuffer && (re |= i.DEPTH_BUFFER_BIT), I.stencilBuffer && I.resolveStencilBuffer && (re |= i.STENCIL_BUFFER_BIT)), fe) {
                            i.framebufferRenderbuffer(i.READ_FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.RENDERBUFFER, Me.__webglColorRenderbuffer[ve]);
                            const Je = n.get(M[ve]).__webglTexture;
                            i.framebufferTexture2D(i.DRAW_FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, Je, 0);
                        }
                        i.blitFramebuffer(0, 0, W, ee, 0, 0, W, ee, re, i.NEAREST), l === !0 && (Be.length = 0, L.length = 0, Be.push(i.COLOR_ATTACHMENT0 + ve), I.depthBuffer && I.resolveDepthBuffer === !1 && (Be.push(Q), L.push(Q), i.invalidateFramebuffer(i.DRAW_FRAMEBUFFER, L)), i.invalidateFramebuffer(i.READ_FRAMEBUFFER, Be));
                    }
                    if (t.bindFramebuffer(i.READ_FRAMEBUFFER, null), t.bindFramebuffer(i.DRAW_FRAMEBUFFER, null), fe) for(let ve = 0; ve < M.length; ve++){
                        t.bindFramebuffer(i.FRAMEBUFFER, Me.__webglMultisampledFramebuffer), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + ve, i.RENDERBUFFER, Me.__webglColorRenderbuffer[ve]);
                        const Je = n.get(M[ve]).__webglTexture;
                        t.bindFramebuffer(i.FRAMEBUFFER, Me.__webglFramebuffer), i.framebufferTexture2D(i.DRAW_FRAMEBUFFER, i.COLOR_ATTACHMENT0 + ve, i.TEXTURE_2D, Je, 0);
                    }
                    t.bindFramebuffer(i.DRAW_FRAMEBUFFER, Me.__webglMultisampledFramebuffer);
                } else if (I.depthBuffer && I.resolveDepthBuffer === !1 && l) {
                    const M = I.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT;
                    i.invalidateFramebuffer(i.DRAW_FRAMEBUFFER, [
                        M
                    ]);
                }
            }
        }
        function ge(I) {
            return Math.min(s.maxSamples, I.samples);
        }
        function Xe(I) {
            const M = n.get(I);
            return I.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && M.__useRenderToTexture !== !1;
        }
        function Ae(I) {
            const M = a.render.frame;
            d.get(I) !== M && (d.set(I, M), I.update());
        }
        function ft(I, M) {
            const W = I.colorSpace, ee = I.format, re = I.type;
            return I.isCompressedTexture === !0 || I.isVideoTexture === !0 || W !== Zt && W !== vi && (Ke.getTransfer(W) === ut ? (ee !== xn || re !== hi) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", W)), M;
        }
        function Ee(I) {
            return typeof HTMLImageElement < "u" && I instanceof HTMLImageElement ? (h.width = I.naturalWidth || I.width, h.height = I.naturalHeight || I.height) : typeof VideoFrame < "u" && I instanceof VideoFrame ? (h.width = I.displayWidth, h.height = I.displayHeight) : (h.width = I.width, h.height = I.height), h;
        }
        this.allocateTextureUnit = H, this.resetTextureUnits = q, this.setTexture2D = ne, this.setTexture2DArray = b, this.setTexture3D = C, this.setTextureCube = E, this.rebindTextures = he, this.setupRenderTarget = st, this.updateRenderTargetMipmap = We, this.updateMultisampleRenderTarget = Ce, this.setupDepthRenderbuffer = we, this.setupFrameBufferTexture = oe, this.useMultisampledRTT = Xe;
    }
    function mT(i, e) {
        function t(n, s = vi) {
            let r;
            const a = Ke.getTransfer(s);
            if (n === hi) return i.UNSIGNED_BYTE;
            if (n === ah) return i.UNSIGNED_SHORT_4_4_4_4;
            if (n === oh) return i.UNSIGNED_SHORT_5_5_5_1;
            if (n === sp) return i.UNSIGNED_INT_5_9_9_9_REV;
            if (n === np) return i.BYTE;
            if (n === ip) return i.SHORT;
            if (n === Or) return i.UNSIGNED_SHORT;
            if (n === rh) return i.INT;
            if (n === Ji) return i.UNSIGNED_INT;
            if (n === Pn) return i.FLOAT;
            if (n === jr) return i.HALF_FLOAT;
            if (n === rp) return i.ALPHA;
            if (n === ap) return i.RGB;
            if (n === xn) return i.RGBA;
            if (n === op) return i.LUMINANCE;
            if (n === lp) return i.LUMINANCE_ALPHA;
            if (n === Gr) return i.DEPTH_COMPONENT;
            if (n === Hr) return i.DEPTH_STENCIL;
            if (n === lh) return i.RED;
            if (n === ch) return i.RED_INTEGER;
            if (n === cp) return i.RG;
            if (n === hh) return i.RG_INTEGER;
            if (n === uh) return i.RGBA_INTEGER;
            if (n === ka || n === Ga || n === Ha || n === za) if (a === ut) if (r = e.get("WEBGL_compressed_texture_s3tc_srgb"), r !== null) {
                if (n === ka) return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                if (n === Ga) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                if (n === Ha) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                if (n === za) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
            } else return null;
            else if (r = e.get("WEBGL_compressed_texture_s3tc"), r !== null) {
                if (n === ka) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (n === Ga) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (n === Ha) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (n === za) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            } else return null;
            if (n === Jl || n === Ql || n === ec || n === tc) if (r = e.get("WEBGL_compressed_texture_pvrtc"), r !== null) {
                if (n === Jl) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (n === Ql) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (n === ec) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (n === tc) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            } else return null;
            if (n === nc || n === ic || n === sc) if (r = e.get("WEBGL_compressed_texture_etc"), r !== null) {
                if (n === nc || n === ic) return a === ut ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
                if (n === sc) return a === ut ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC;
            } else return null;
            if (n === rc || n === ac || n === oc || n === lc || n === cc || n === hc || n === uc || n === dc || n === fc || n === pc || n === mc || n === _c || n === gc || n === xc) if (r = e.get("WEBGL_compressed_texture_astc"), r !== null) {
                if (n === rc) return a === ut ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (n === ac) return a === ut ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (n === oc) return a === ut ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (n === lc) return a === ut ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (n === cc) return a === ut ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (n === hc) return a === ut ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (n === uc) return a === ut ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (n === dc) return a === ut ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (n === fc) return a === ut ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (n === pc) return a === ut ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (n === mc) return a === ut ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (n === _c) return a === ut ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (n === gc) return a === ut ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (n === xc) return a === ut ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR;
            } else return null;
            if (n === Va || n === vc || n === yc) if (r = e.get("EXT_texture_compression_bptc"), r !== null) {
                if (n === Va) return a === ut ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                if (n === vc) return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                if (n === yc) return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
            } else return null;
            if (n === hp || n === bc || n === Sc || n === Tc) if (r = e.get("EXT_texture_compression_rgtc"), r !== null) {
                if (n === Va) return r.COMPRESSED_RED_RGTC1_EXT;
                if (n === bc) return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                if (n === Sc) return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
                if (n === Tc) return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
            } else return null;
            return n === kr ? i.UNSIGNED_INT_24_8 : i[n] !== void 0 ? i[n] : null;
        }
        return {
            convert: t
        };
    }
    const _T = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, gT = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
    class xT {
        constructor(){
            this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
        }
        init(e, t, n) {
            if (this.texture === null) {
                const s = new nn, r = e.properties.get(s);
                r.__webglTexture = t.texture, (t.depthNear !== n.depthNear || t.depthFar !== n.depthFar) && (this.depthNear = t.depthNear, this.depthFar = t.depthFar), this.texture = s;
            }
        }
        getMesh(e) {
            if (this.texture !== null && this.mesh === null) {
                const t = e.cameras[0].viewport, n = new wi({
                    vertexShader: _T,
                    fragmentShader: gT,
                    uniforms: {
                        depthColor: {
                            value: this.texture
                        },
                        depthWidth: {
                            value: t.z
                        },
                        depthHeight: {
                            value: t.w
                        }
                    }
                });
                this.mesh = new Nt(new Zs(20, 20), n);
            }
            return this.mesh;
        }
        reset() {
            this.texture = null, this.mesh = null;
        }
        getDepthTexture() {
            return this.texture;
        }
    }
    class vT extends ss {
        constructor(e, t){
            super();
            const n = this;
            let s = null, r = 1, a = null, o = "local-floor", l = 1, h = null, d = null, c = null, u = null, f = null, _ = null;
            const g = new xT, m = t.getContextAttributes();
            let p = null, x = null;
            const v = [], y = [], P = new Ze;
            let w = null;
            const R = new jt;
            R.viewport = new rt;
            const B = new jt;
            B.viewport = new rt;
            const T = [
                R,
                B
            ], S = new E0;
            let D = null, q = null;
            this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(z) {
                let K = v[z];
                return K === void 0 && (K = new Ho, v[z] = K), K.getTargetRaySpace();
            }, this.getControllerGrip = function(z) {
                let K = v[z];
                return K === void 0 && (K = new Ho, v[z] = K), K.getGripSpace();
            }, this.getHand = function(z) {
                let K = v[z];
                return K === void 0 && (K = new Ho, v[z] = K), K.getHandSpace();
            };
            function H(z) {
                const K = y.indexOf(z.inputSource);
                if (K === -1) return;
                const oe = v[K];
                oe !== void 0 && (oe.update(z.inputSource, z.frame, h || a), oe.dispatchEvent({
                    type: z.type,
                    data: z.inputSource
                }));
            }
            function $() {
                s.removeEventListener("select", H), s.removeEventListener("selectstart", H), s.removeEventListener("selectend", H), s.removeEventListener("squeeze", H), s.removeEventListener("squeezestart", H), s.removeEventListener("squeezeend", H), s.removeEventListener("end", $), s.removeEventListener("inputsourceschange", ne);
                for(let z = 0; z < v.length; z++){
                    const K = y[z];
                    K !== null && (y[z] = null, v[z].disconnect(K));
                }
                D = null, q = null, g.reset(), e.setRenderTarget(p), f = null, u = null, c = null, s = null, x = null, ie.stop(), n.isPresenting = !1, e.setPixelRatio(w), e.setSize(P.width, P.height, !1), n.dispatchEvent({
                    type: "sessionend"
                });
            }
            this.setFramebufferScaleFactor = function(z) {
                r = z, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
            }, this.setReferenceSpaceType = function(z) {
                o = z, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
            }, this.getReferenceSpace = function() {
                return h || a;
            }, this.setReferenceSpace = function(z) {
                h = z;
            }, this.getBaseLayer = function() {
                return u !== null ? u : f;
            }, this.getBinding = function() {
                return c;
            }, this.getFrame = function() {
                return _;
            }, this.getSession = function() {
                return s;
            }, this.setSession = async function(z) {
                if (s = z, s !== null) {
                    if (p = e.getRenderTarget(), s.addEventListener("select", H), s.addEventListener("selectstart", H), s.addEventListener("selectend", H), s.addEventListener("squeeze", H), s.addEventListener("squeezestart", H), s.addEventListener("squeezeend", H), s.addEventListener("end", $), s.addEventListener("inputsourceschange", ne), m.xrCompatible !== !0 && await t.makeXRCompatible(), w = e.getPixelRatio(), e.getSize(P), typeof XRWebGLBinding < "u" && "createProjectionLayer" in XRWebGLBinding.prototype) {
                        let oe = null, se = null, ce = null;
                        m.depth && (ce = m.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, oe = m.stencil ? Hr : Gr, se = m.stencil ? kr : Ji);
                        const we = {
                            colorFormat: t.RGBA8,
                            depthFormat: ce,
                            scaleFactor: r
                        };
                        c = new XRWebGLBinding(s, t), u = c.createProjectionLayer(we), s.updateRenderState({
                            layers: [
                                u
                            ]
                        }), e.setPixelRatio(1), e.setSize(u.textureWidth, u.textureHeight, !1), x = new Qi(u.textureWidth, u.textureHeight, {
                            format: xn,
                            type: hi,
                            depthTexture: new Rp(u.textureWidth, u.textureHeight, se, void 0, void 0, void 0, void 0, void 0, void 0, oe),
                            stencilBuffer: m.stencil,
                            colorSpace: e.outputColorSpace,
                            samples: m.antialias ? 4 : 0,
                            resolveDepthBuffer: u.ignoreDepthValues === !1,
                            resolveStencilBuffer: u.ignoreDepthValues === !1
                        });
                    } else {
                        const oe = {
                            antialias: m.antialias,
                            alpha: !0,
                            depth: m.depth,
                            stencil: m.stencil,
                            framebufferScaleFactor: r
                        };
                        f = new XRWebGLLayer(s, t, oe), s.updateRenderState({
                            baseLayer: f
                        }), e.setPixelRatio(1), e.setSize(f.framebufferWidth, f.framebufferHeight, !1), x = new Qi(f.framebufferWidth, f.framebufferHeight, {
                            format: xn,
                            type: hi,
                            colorSpace: e.outputColorSpace,
                            stencilBuffer: m.stencil,
                            resolveDepthBuffer: f.ignoreDepthValues === !1,
                            resolveStencilBuffer: f.ignoreDepthValues === !1
                        });
                    }
                    x.isXRRenderTarget = !0, this.setFoveation(l), h = null, a = await s.requestReferenceSpace(o), ie.setContext(s), ie.start(), n.isPresenting = !0, n.dispatchEvent({
                        type: "sessionstart"
                    });
                }
            }, this.getEnvironmentBlendMode = function() {
                if (s !== null) return s.environmentBlendMode;
            }, this.getDepthTexture = function() {
                return g.getDepthTexture();
            };
            function ne(z) {
                for(let K = 0; K < z.removed.length; K++){
                    const oe = z.removed[K], se = y.indexOf(oe);
                    se >= 0 && (y[se] = null, v[se].disconnect(oe));
                }
                for(let K = 0; K < z.added.length; K++){
                    const oe = z.added[K];
                    let se = y.indexOf(oe);
                    if (se === -1) {
                        for(let we = 0; we < v.length; we++)if (we >= y.length) {
                            y.push(oe), se = we;
                            break;
                        } else if (y[we] === null) {
                            y[we] = oe, se = we;
                            break;
                        }
                        if (se === -1) break;
                    }
                    const ce = v[se];
                    ce && ce.connect(oe);
                }
            }
            const b = new k, C = new k;
            function E(z, K, oe) {
                b.setFromMatrixPosition(K.matrixWorld), C.setFromMatrixPosition(oe.matrixWorld);
                const se = b.distanceTo(C), ce = K.projectionMatrix.elements, we = oe.projectionMatrix.elements, he = ce[14] / (ce[10] - 1), st = ce[14] / (ce[10] + 1), We = (ce[9] + 1) / ce[5], Be = (ce[9] - 1) / ce[5], L = (ce[8] - 1) / ce[0], Ce = (we[8] + 1) / we[0], ge = he * L, Xe = he * Ce, Ae = se / (-L + Ce), ft = Ae * -L;
                if (K.matrixWorld.decompose(z.position, z.quaternion, z.scale), z.translateX(ft), z.translateZ(Ae), z.matrixWorld.compose(z.position, z.quaternion, z.scale), z.matrixWorldInverse.copy(z.matrixWorld).invert(), ce[10] === -1) z.projectionMatrix.copy(K.projectionMatrix), z.projectionMatrixInverse.copy(K.projectionMatrixInverse);
                else {
                    const Ee = he + Ae, I = st + Ae, M = ge - ft, W = Xe + (se - ft), ee = We * st / I * Ee, re = Be * st / I * Ee;
                    z.projectionMatrix.makePerspective(M, W, ee, re, Ee, I), z.projectionMatrixInverse.copy(z.projectionMatrix).invert();
                }
            }
            function U(z, K) {
                K === null ? z.matrixWorld.copy(z.matrix) : z.matrixWorld.multiplyMatrices(K.matrixWorld, z.matrix), z.matrixWorldInverse.copy(z.matrixWorld).invert();
            }
            this.updateCamera = function(z) {
                if (s === null) return;
                let K = z.near, oe = z.far;
                g.texture !== null && (g.depthNear > 0 && (K = g.depthNear), g.depthFar > 0 && (oe = g.depthFar)), S.near = B.near = R.near = K, S.far = B.far = R.far = oe, (D !== S.near || q !== S.far) && (s.updateRenderState({
                    depthNear: S.near,
                    depthFar: S.far
                }), D = S.near, q = S.far), R.layers.mask = z.layers.mask | 2, B.layers.mask = z.layers.mask | 4, S.layers.mask = R.layers.mask | B.layers.mask;
                const se = z.parent, ce = S.cameras;
                U(S, se);
                for(let we = 0; we < ce.length; we++)U(ce[we], se);
                ce.length === 2 ? E(S, R, B) : S.projectionMatrix.copy(R.projectionMatrix), F(z, S, se);
            };
            function F(z, K, oe) {
                oe === null ? z.matrix.copy(K.matrixWorld) : (z.matrix.copy(oe.matrixWorld), z.matrix.invert(), z.matrix.multiply(K.matrixWorld)), z.matrix.decompose(z.position, z.quaternion, z.scale), z.updateMatrixWorld(!0), z.projectionMatrix.copy(K.projectionMatrix), z.projectionMatrixInverse.copy(K.projectionMatrixInverse), z.isPerspectiveCamera && (z.fov = Hs * 2 * Math.atan(1 / z.projectionMatrix.elements[5]), z.zoom = 1);
            }
            this.getCamera = function() {
                return S;
            }, this.getFoveation = function() {
                if (!(u === null && f === null)) return l;
            }, this.setFoveation = function(z) {
                l = z, u !== null && (u.fixedFoveation = z), f !== null && f.fixedFoveation !== void 0 && (f.fixedFoveation = z);
            }, this.hasDepthSensing = function() {
                return g.texture !== null;
            }, this.getDepthSensingMesh = function() {
                return g.getMesh(S);
            };
            let V = null;
            function j(z, K) {
                if (d = K.getViewerPose(h || a), _ = K, d !== null) {
                    const oe = d.views;
                    f !== null && (e.setRenderTargetFramebuffer(x, f.framebuffer), e.setRenderTarget(x));
                    let se = !1;
                    oe.length !== S.cameras.length && (S.cameras.length = 0, se = !0);
                    for(let he = 0; he < oe.length; he++){
                        const st = oe[he];
                        let We = null;
                        if (f !== null) We = f.getViewport(st);
                        else {
                            const L = c.getViewSubImage(u, st);
                            We = L.viewport, he === 0 && (e.setRenderTargetTextures(x, L.colorTexture, L.depthStencilTexture), e.setRenderTarget(x));
                        }
                        let Be = T[he];
                        Be === void 0 && (Be = new jt, Be.layers.enable(he), Be.viewport = new rt, T[he] = Be), Be.matrix.fromArray(st.transform.matrix), Be.matrix.decompose(Be.position, Be.quaternion, Be.scale), Be.projectionMatrix.fromArray(st.projectionMatrix), Be.projectionMatrixInverse.copy(Be.projectionMatrix).invert(), Be.viewport.set(We.x, We.y, We.width, We.height), he === 0 && (S.matrix.copy(Be.matrix), S.matrix.decompose(S.position, S.quaternion, S.scale)), se === !0 && S.cameras.push(Be);
                    }
                    const ce = s.enabledFeatures;
                    if (ce && ce.includes("depth-sensing") && s.depthUsage == "gpu-optimized" && c) {
                        const he = c.getDepthInformation(oe[0]);
                        he && he.isValid && he.texture && g.init(e, he, s.renderState);
                    }
                }
                for(let oe = 0; oe < v.length; oe++){
                    const se = y[oe], ce = v[oe];
                    se !== null && ce !== void 0 && ce.update(se, K, h || a);
                }
                V && V(z, K), K.detectedPlanes && n.dispatchEvent({
                    type: "planesdetected",
                    data: K
                }), _ = null;
            }
            const ie = new Up;
            ie.setAnimationLoop(j), this.setAnimationLoop = function(z) {
                V = z;
            }, this.dispose = function() {};
        }
    }
    const Ni = new Hn, yT = new He;
    function bT(i, e) {
        function t(m, p) {
            m.matrixAutoUpdate === !0 && m.updateMatrix(), p.value.copy(m.matrix);
        }
        function n(m, p) {
            p.color.getRGB(m.fogColor.value, bp(i)), p.isFog ? (m.fogNear.value = p.near, m.fogFar.value = p.far) : p.isFogExp2 && (m.fogDensity.value = p.density);
        }
        function s(m, p, x, v, y) {
            p.isMeshBasicMaterial || p.isMeshLambertMaterial ? r(m, p) : p.isMeshToonMaterial ? (r(m, p), c(m, p)) : p.isMeshPhongMaterial ? (r(m, p), d(m, p)) : p.isMeshStandardMaterial ? (r(m, p), u(m, p), p.isMeshPhysicalMaterial && f(m, p, y)) : p.isMeshMatcapMaterial ? (r(m, p), _(m, p)) : p.isMeshDepthMaterial ? r(m, p) : p.isMeshDistanceMaterial ? (r(m, p), g(m, p)) : p.isMeshNormalMaterial ? r(m, p) : p.isLineBasicMaterial ? (a(m, p), p.isLineDashedMaterial && o(m, p)) : p.isPointsMaterial ? l(m, p, x, v) : p.isSpriteMaterial ? h(m, p) : p.isShadowMaterial ? (m.color.value.copy(p.color), m.opacity.value = p.opacity) : p.isShaderMaterial && (p.uniformsNeedUpdate = !1);
        }
        function r(m, p) {
            m.opacity.value = p.opacity, p.color && m.diffuse.value.copy(p.color), p.emissive && m.emissive.value.copy(p.emissive).multiplyScalar(p.emissiveIntensity), p.map && (m.map.value = p.map, t(p.map, m.mapTransform)), p.alphaMap && (m.alphaMap.value = p.alphaMap, t(p.alphaMap, m.alphaMapTransform)), p.bumpMap && (m.bumpMap.value = p.bumpMap, t(p.bumpMap, m.bumpMapTransform), m.bumpScale.value = p.bumpScale, p.side === tn && (m.bumpScale.value *= -1)), p.normalMap && (m.normalMap.value = p.normalMap, t(p.normalMap, m.normalMapTransform), m.normalScale.value.copy(p.normalScale), p.side === tn && m.normalScale.value.negate()), p.displacementMap && (m.displacementMap.value = p.displacementMap, t(p.displacementMap, m.displacementMapTransform), m.displacementScale.value = p.displacementScale, m.displacementBias.value = p.displacementBias), p.emissiveMap && (m.emissiveMap.value = p.emissiveMap, t(p.emissiveMap, m.emissiveMapTransform)), p.specularMap && (m.specularMap.value = p.specularMap, t(p.specularMap, m.specularMapTransform)), p.alphaTest > 0 && (m.alphaTest.value = p.alphaTest);
            const x = e.get(p), v = x.envMap, y = x.envMapRotation;
            v && (m.envMap.value = v, Ni.copy(y), Ni.x *= -1, Ni.y *= -1, Ni.z *= -1, v.isCubeTexture && v.isRenderTargetTexture === !1 && (Ni.y *= -1, Ni.z *= -1), m.envMapRotation.value.setFromMatrix4(yT.makeRotationFromEuler(Ni)), m.flipEnvMap.value = v.isCubeTexture && v.isRenderTargetTexture === !1 ? -1 : 1, m.reflectivity.value = p.reflectivity, m.ior.value = p.ior, m.refractionRatio.value = p.refractionRatio), p.lightMap && (m.lightMap.value = p.lightMap, m.lightMapIntensity.value = p.lightMapIntensity, t(p.lightMap, m.lightMapTransform)), p.aoMap && (m.aoMap.value = p.aoMap, m.aoMapIntensity.value = p.aoMapIntensity, t(p.aoMap, m.aoMapTransform));
        }
        function a(m, p) {
            m.diffuse.value.copy(p.color), m.opacity.value = p.opacity, p.map && (m.map.value = p.map, t(p.map, m.mapTransform));
        }
        function o(m, p) {
            m.dashSize.value = p.dashSize, m.totalSize.value = p.dashSize + p.gapSize, m.scale.value = p.scale;
        }
        function l(m, p, x, v) {
            m.diffuse.value.copy(p.color), m.opacity.value = p.opacity, m.size.value = p.size * x, m.scale.value = v * .5, p.map && (m.map.value = p.map, t(p.map, m.uvTransform)), p.alphaMap && (m.alphaMap.value = p.alphaMap, t(p.alphaMap, m.alphaMapTransform)), p.alphaTest > 0 && (m.alphaTest.value = p.alphaTest);
        }
        function h(m, p) {
            m.diffuse.value.copy(p.color), m.opacity.value = p.opacity, m.rotation.value = p.rotation, p.map && (m.map.value = p.map, t(p.map, m.mapTransform)), p.alphaMap && (m.alphaMap.value = p.alphaMap, t(p.alphaMap, m.alphaMapTransform)), p.alphaTest > 0 && (m.alphaTest.value = p.alphaTest);
        }
        function d(m, p) {
            m.specular.value.copy(p.specular), m.shininess.value = Math.max(p.shininess, 1e-4);
        }
        function c(m, p) {
            p.gradientMap && (m.gradientMap.value = p.gradientMap);
        }
        function u(m, p) {
            m.metalness.value = p.metalness, p.metalnessMap && (m.metalnessMap.value = p.metalnessMap, t(p.metalnessMap, m.metalnessMapTransform)), m.roughness.value = p.roughness, p.roughnessMap && (m.roughnessMap.value = p.roughnessMap, t(p.roughnessMap, m.roughnessMapTransform)), p.envMap && (m.envMapIntensity.value = p.envMapIntensity);
        }
        function f(m, p, x) {
            m.ior.value = p.ior, p.sheen > 0 && (m.sheenColor.value.copy(p.sheenColor).multiplyScalar(p.sheen), m.sheenRoughness.value = p.sheenRoughness, p.sheenColorMap && (m.sheenColorMap.value = p.sheenColorMap, t(p.sheenColorMap, m.sheenColorMapTransform)), p.sheenRoughnessMap && (m.sheenRoughnessMap.value = p.sheenRoughnessMap, t(p.sheenRoughnessMap, m.sheenRoughnessMapTransform))), p.clearcoat > 0 && (m.clearcoat.value = p.clearcoat, m.clearcoatRoughness.value = p.clearcoatRoughness, p.clearcoatMap && (m.clearcoatMap.value = p.clearcoatMap, t(p.clearcoatMap, m.clearcoatMapTransform)), p.clearcoatRoughnessMap && (m.clearcoatRoughnessMap.value = p.clearcoatRoughnessMap, t(p.clearcoatRoughnessMap, m.clearcoatRoughnessMapTransform)), p.clearcoatNormalMap && (m.clearcoatNormalMap.value = p.clearcoatNormalMap, t(p.clearcoatNormalMap, m.clearcoatNormalMapTransform), m.clearcoatNormalScale.value.copy(p.clearcoatNormalScale), p.side === tn && m.clearcoatNormalScale.value.negate())), p.dispersion > 0 && (m.dispersion.value = p.dispersion), p.iridescence > 0 && (m.iridescence.value = p.iridescence, m.iridescenceIOR.value = p.iridescenceIOR, m.iridescenceThicknessMinimum.value = p.iridescenceThicknessRange[0], m.iridescenceThicknessMaximum.value = p.iridescenceThicknessRange[1], p.iridescenceMap && (m.iridescenceMap.value = p.iridescenceMap, t(p.iridescenceMap, m.iridescenceMapTransform)), p.iridescenceThicknessMap && (m.iridescenceThicknessMap.value = p.iridescenceThicknessMap, t(p.iridescenceThicknessMap, m.iridescenceThicknessMapTransform))), p.transmission > 0 && (m.transmission.value = p.transmission, m.transmissionSamplerMap.value = x.texture, m.transmissionSamplerSize.value.set(x.width, x.height), p.transmissionMap && (m.transmissionMap.value = p.transmissionMap, t(p.transmissionMap, m.transmissionMapTransform)), m.thickness.value = p.thickness, p.thicknessMap && (m.thicknessMap.value = p.thicknessMap, t(p.thicknessMap, m.thicknessMapTransform)), m.attenuationDistance.value = p.attenuationDistance, m.attenuationColor.value.copy(p.attenuationColor)), p.anisotropy > 0 && (m.anisotropyVector.value.set(p.anisotropy * Math.cos(p.anisotropyRotation), p.anisotropy * Math.sin(p.anisotropyRotation)), p.anisotropyMap && (m.anisotropyMap.value = p.anisotropyMap, t(p.anisotropyMap, m.anisotropyMapTransform))), m.specularIntensity.value = p.specularIntensity, m.specularColor.value.copy(p.specularColor), p.specularColorMap && (m.specularColorMap.value = p.specularColorMap, t(p.specularColorMap, m.specularColorMapTransform)), p.specularIntensityMap && (m.specularIntensityMap.value = p.specularIntensityMap, t(p.specularIntensityMap, m.specularIntensityMapTransform));
        }
        function _(m, p) {
            p.matcap && (m.matcap.value = p.matcap);
        }
        function g(m, p) {
            const x = e.get(p).light;
            m.referencePosition.value.setFromMatrixPosition(x.matrixWorld), m.nearDistance.value = x.shadow.camera.near, m.farDistance.value = x.shadow.camera.far;
        }
        return {
            refreshFogUniforms: n,
            refreshMaterialUniforms: s
        };
    }
    function ST(i, e, t, n) {
        let s = {}, r = {}, a = [];
        const o = i.getParameter(i.MAX_UNIFORM_BUFFER_BINDINGS);
        function l(x, v) {
            const y = v.program;
            n.uniformBlockBinding(x, y);
        }
        function h(x, v) {
            let y = s[x.id];
            y === void 0 && (_(x), y = d(x), s[x.id] = y, x.addEventListener("dispose", m));
            const P = v.program;
            n.updateUBOMapping(x, P);
            const w = e.render.frame;
            r[x.id] !== w && (u(x), r[x.id] = w);
        }
        function d(x) {
            const v = c();
            x.__bindingPointIndex = v;
            const y = i.createBuffer(), P = x.__size, w = x.usage;
            return i.bindBuffer(i.UNIFORM_BUFFER, y), i.bufferData(i.UNIFORM_BUFFER, P, w), i.bindBuffer(i.UNIFORM_BUFFER, null), i.bindBufferBase(i.UNIFORM_BUFFER, v, y), y;
        }
        function c() {
            for(let x = 0; x < o; x++)if (a.indexOf(x) === -1) return a.push(x), x;
            return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
        }
        function u(x) {
            const v = s[x.id], y = x.uniforms, P = x.__cache;
            i.bindBuffer(i.UNIFORM_BUFFER, v);
            for(let w = 0, R = y.length; w < R; w++){
                const B = Array.isArray(y[w]) ? y[w] : [
                    y[w]
                ];
                for(let T = 0, S = B.length; T < S; T++){
                    const D = B[T];
                    if (f(D, w, T, P) === !0) {
                        const q = D.__offset, H = Array.isArray(D.value) ? D.value : [
                            D.value
                        ];
                        let $ = 0;
                        for(let ne = 0; ne < H.length; ne++){
                            const b = H[ne], C = g(b);
                            typeof b == "number" || typeof b == "boolean" ? (D.__data[0] = b, i.bufferSubData(i.UNIFORM_BUFFER, q + $, D.__data)) : b.isMatrix3 ? (D.__data[0] = b.elements[0], D.__data[1] = b.elements[1], D.__data[2] = b.elements[2], D.__data[3] = 0, D.__data[4] = b.elements[3], D.__data[5] = b.elements[4], D.__data[6] = b.elements[5], D.__data[7] = 0, D.__data[8] = b.elements[6], D.__data[9] = b.elements[7], D.__data[10] = b.elements[8], D.__data[11] = 0) : (b.toArray(D.__data, $), $ += C.storage / Float32Array.BYTES_PER_ELEMENT);
                        }
                        i.bufferSubData(i.UNIFORM_BUFFER, q, D.__data);
                    }
                }
            }
            i.bindBuffer(i.UNIFORM_BUFFER, null);
        }
        function f(x, v, y, P) {
            const w = x.value, R = v + "_" + y;
            if (P[R] === void 0) return typeof w == "number" || typeof w == "boolean" ? P[R] = w : P[R] = w.clone(), !0;
            {
                const B = P[R];
                if (typeof w == "number" || typeof w == "boolean") {
                    if (B !== w) return P[R] = w, !0;
                } else if (B.equals(w) === !1) return B.copy(w), !0;
            }
            return !1;
        }
        function _(x) {
            const v = x.uniforms;
            let y = 0;
            const P = 16;
            for(let R = 0, B = v.length; R < B; R++){
                const T = Array.isArray(v[R]) ? v[R] : [
                    v[R]
                ];
                for(let S = 0, D = T.length; S < D; S++){
                    const q = T[S], H = Array.isArray(q.value) ? q.value : [
                        q.value
                    ];
                    for(let $ = 0, ne = H.length; $ < ne; $++){
                        const b = H[$], C = g(b), E = y % P, U = E % C.boundary, F = E + U;
                        y += U, F !== 0 && P - F < C.storage && (y += P - F), q.__data = new Float32Array(C.storage / Float32Array.BYTES_PER_ELEMENT), q.__offset = y, y += C.storage;
                    }
                }
            }
            const w = y % P;
            return w > 0 && (y += P - w), x.__size = y, x.__cache = {}, this;
        }
        function g(x) {
            const v = {
                boundary: 0,
                storage: 0
            };
            return typeof x == "number" || typeof x == "boolean" ? (v.boundary = 4, v.storage = 4) : x.isVector2 ? (v.boundary = 8, v.storage = 8) : x.isVector3 || x.isColor ? (v.boundary = 16, v.storage = 12) : x.isVector4 ? (v.boundary = 16, v.storage = 16) : x.isMatrix3 ? (v.boundary = 48, v.storage = 48) : x.isMatrix4 ? (v.boundary = 64, v.storage = 64) : x.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", x), v;
        }
        function m(x) {
            const v = x.target;
            v.removeEventListener("dispose", m);
            const y = a.indexOf(v.__bindingPointIndex);
            a.splice(y, 1), i.deleteBuffer(s[v.id]), delete s[v.id], delete r[v.id];
        }
        function p() {
            for(const x in s)i.deleteBuffer(s[x]);
            a = [], s = {}, r = {};
        }
        return {
            bind: l,
            update: h,
            dispose: p
        };
    }
    let TT = class {
        constructor(e = {}){
            const { canvas: t = bx(), context: n = null, depth: s = !0, stencil: r = !1, alpha: a = !1, antialias: o = !1, premultipliedAlpha: l = !0, preserveDrawingBuffer: h = !1, powerPreference: d = "default", failIfMajorPerformanceCaveat: c = !1, reverseDepthBuffer: u = !1 } = e;
            this.isWebGLRenderer = !0;
            let f;
            if (n !== null) {
                if (typeof WebGLRenderingContext < "u" && n instanceof WebGLRenderingContext) throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
                f = n.getContextAttributes().alpha;
            } else f = a;
            const _ = new Uint32Array(4), g = new Int32Array(4);
            let m = null, p = null;
            const x = [], v = [];
            this.domElement = t, this.debug = {
                checkShaderErrors: !0,
                onShaderError: null
            }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.toneMapping = Mi, this.toneMappingExposure = 1, this.transmissionResolutionScale = 1;
            const y = this;
            let P = !1;
            this._outputColorSpace = Ft;
            let w = 0, R = 0, B = null, T = -1, S = null;
            const D = new rt, q = new rt;
            let H = null;
            const $ = new Oe(0);
            let ne = 0, b = t.width, C = t.height, E = 1, U = null, F = null;
            const V = new rt(0, 0, b, C), j = new rt(0, 0, b, C);
            let ie = !1;
            const z = new gh;
            let K = !1, oe = !1;
            const se = new He, ce = new He, we = new k, he = new rt, st = {
                background: null,
                fog: null,
                environment: null,
                overrideMaterial: null,
                isScene: !0
            };
            let We = !1;
            function Be() {
                return B === null ? E : 1;
            }
            let L = n;
            function Ce(A, O) {
                return t.getContext(A, O);
            }
            try {
                const A = {
                    alpha: !0,
                    depth: s,
                    stencil: r,
                    antialias: o,
                    premultipliedAlpha: l,
                    preserveDrawingBuffer: h,
                    powerPreference: d,
                    failIfMajorPerformanceCaveat: c
                };
                if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${sh}`), t.addEventListener("webglcontextlost", te, !1), t.addEventListener("webglcontextrestored", _e, !1), t.addEventListener("webglcontextcreationerror", me, !1), L === null) {
                    const O = "webgl2";
                    if (L = Ce(O, A), L === null) throw Ce(O) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
                }
            } catch (A) {
                throw console.error("THREE.WebGLRenderer: " + A.message), A;
            }
            let ge, Xe, Ae, ft, Ee, I, M, W, ee, re, Q, Me, fe, ve, Je, le, ye, De, Ue, be, $e, ze, pt, N;
            function pe() {
                ge = new Lb(L), ge.init(), ze = new mT(L, ge), Xe = new Eb(L, ge, e, ze), Ae = new fT(L, ge), Xe.reverseDepthBuffer && u && Ae.buffers.depth.setReversed(!0), ft = new Fb(L), Ee = new eT, I = new pT(L, ge, Ae, Ee, Xe, ze, ft), M = new Rb(y), W = new Db(y), ee = new z0(L), pt = new Mb(L, ee), re = new Bb(L, ee, ft, pt), Q = new Ob(L, re, ee, ft), Ue = new Nb(L, Xe, I), le = new wb(Ee), Me = new QS(y, M, W, ge, Xe, pt, le), fe = new bT(y, Ee), ve = new nT, Je = new lT(ge), De = new Tb(y, M, W, Ae, Q, f, l), ye = new uT(y, Q, Xe), N = new ST(L, ft, Xe, Ae), be = new Ab(L, ge, ft), $e = new Ub(L, ge, ft), ft.programs = Me.programs, y.capabilities = Xe, y.extensions = ge, y.properties = Ee, y.renderLists = ve, y.shadowMap = ye, y.state = Ae, y.info = ft;
            }
            pe();
            const Z = new vT(y, L);
            this.xr = Z, this.getContext = function() {
                return L;
            }, this.getContextAttributes = function() {
                return L.getContextAttributes();
            }, this.forceContextLoss = function() {
                const A = ge.get("WEBGL_lose_context");
                A && A.loseContext();
            }, this.forceContextRestore = function() {
                const A = ge.get("WEBGL_lose_context");
                A && A.restoreContext();
            }, this.getPixelRatio = function() {
                return E;
            }, this.setPixelRatio = function(A) {
                A !== void 0 && (E = A, this.setSize(b, C, !1));
            }, this.getSize = function(A) {
                return A.set(b, C);
            }, this.setSize = function(A, O, X = !0) {
                if (Z.isPresenting) {
                    console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                    return;
                }
                b = A, C = O, t.width = Math.floor(A * E), t.height = Math.floor(O * E), X === !0 && (t.style.width = A + "px", t.style.height = O + "px"), this.setViewport(0, 0, A, O);
            }, this.getDrawingBufferSize = function(A) {
                return A.set(b * E, C * E).floor();
            }, this.setDrawingBufferSize = function(A, O, X) {
                b = A, C = O, E = X, t.width = Math.floor(A * X), t.height = Math.floor(O * X), this.setViewport(0, 0, A, O);
            }, this.getCurrentViewport = function(A) {
                return A.copy(D);
            }, this.getViewport = function(A) {
                return A.copy(V);
            }, this.setViewport = function(A, O, X, Y) {
                A.isVector4 ? V.set(A.x, A.y, A.z, A.w) : V.set(A, O, X, Y), Ae.viewport(D.copy(V).multiplyScalar(E).round());
            }, this.getScissor = function(A) {
                return A.copy(j);
            }, this.setScissor = function(A, O, X, Y) {
                A.isVector4 ? j.set(A.x, A.y, A.z, A.w) : j.set(A, O, X, Y), Ae.scissor(q.copy(j).multiplyScalar(E).round());
            }, this.getScissorTest = function() {
                return ie;
            }, this.setScissorTest = function(A) {
                Ae.setScissorTest(ie = A);
            }, this.setOpaqueSort = function(A) {
                U = A;
            }, this.setTransparentSort = function(A) {
                F = A;
            }, this.getClearColor = function(A) {
                return A.copy(De.getClearColor());
            }, this.setClearColor = function() {
                De.setClearColor(...arguments);
            }, this.getClearAlpha = function() {
                return De.getClearAlpha();
            }, this.setClearAlpha = function() {
                De.setClearAlpha(...arguments);
            }, this.clear = function(A = !0, O = !0, X = !0) {
                let Y = 0;
                if (A) {
                    let G = !1;
                    if (B !== null) {
                        const ae = B.texture.format;
                        G = ae === uh || ae === hh || ae === ch;
                    }
                    if (G) {
                        const ae = B.texture.type, de = ae === hi || ae === Ji || ae === Or || ae === kr || ae === ah || ae === oh, xe = De.getClearColor(), Se = De.getClearAlpha(), Fe = xe.r, Le = xe.g, Re = xe.b;
                        de ? (_[0] = Fe, _[1] = Le, _[2] = Re, _[3] = Se, L.clearBufferuiv(L.COLOR, 0, _)) : (g[0] = Fe, g[1] = Le, g[2] = Re, g[3] = Se, L.clearBufferiv(L.COLOR, 0, g));
                    } else Y |= L.COLOR_BUFFER_BIT;
                }
                O && (Y |= L.DEPTH_BUFFER_BIT), X && (Y |= L.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), L.clear(Y);
            }, this.clearColor = function() {
                this.clear(!0, !1, !1);
            }, this.clearDepth = function() {
                this.clear(!1, !0, !1);
            }, this.clearStencil = function() {
                this.clear(!1, !1, !0);
            }, this.dispose = function() {
                t.removeEventListener("webglcontextlost", te, !1), t.removeEventListener("webglcontextrestored", _e, !1), t.removeEventListener("webglcontextcreationerror", me, !1), De.dispose(), ve.dispose(), Je.dispose(), Ee.dispose(), M.dispose(), W.dispose(), Q.dispose(), pt.dispose(), N.dispose(), Me.dispose(), Z.dispose(), Z.removeEventListener("sessionstart", iu), Z.removeEventListener("sessionend", su), Pi.stop();
            };
            function te(A) {
                A.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), P = !0;
            }
            function _e() {
                console.log("THREE.WebGLRenderer: Context Restored."), P = !1;
                const A = ft.autoReset, O = ye.enabled, X = ye.autoUpdate, Y = ye.needsUpdate, G = ye.type;
                pe(), ft.autoReset = A, ye.enabled = O, ye.autoUpdate = X, ye.needsUpdate = Y, ye.type = G;
            }
            function me(A) {
                console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", A.statusMessage);
            }
            function ke(A) {
                const O = A.target;
                O.removeEventListener("dispose", ke), bt(O);
            }
            function bt(A) {
                Gt(A), Ee.remove(A);
            }
            function Gt(A) {
                const O = Ee.get(A).programs;
                O !== void 0 && (O.forEach(function(X) {
                    Me.releaseProgram(X);
                }), A.isShaderMaterial && Me.releaseShaderCache(A));
            }
            this.renderBufferDirect = function(A, O, X, Y, G, ae) {
                O === null && (O = st);
                const de = G.isMesh && G.matrixWorld.determinant() < 0, xe = og(A, O, X, Y, G);
                Ae.setMaterial(Y, de);
                let Se = X.index, Fe = 1;
                if (Y.wireframe === !0) {
                    if (Se = re.getWireframeAttribute(X), Se === void 0) return;
                    Fe = 2;
                }
                const Le = X.drawRange, Re = X.attributes.position;
                let Qe = Le.start * Fe, at = (Le.start + Le.count) * Fe;
                ae !== null && (Qe = Math.max(Qe, ae.start * Fe), at = Math.min(at, (ae.start + ae.count) * Fe)), Se !== null ? (Qe = Math.max(Qe, 0), at = Math.min(at, Se.count)) : Re != null && (Qe = Math.max(Qe, 0), at = Math.min(at, Re.count));
                const Rt = at - Qe;
                if (Rt < 0 || Rt === 1 / 0) return;
                pt.setup(G, Y, xe, X, Se);
                let St, nt = be;
                if (Se !== null && (St = ee.get(Se), nt = $e, nt.setIndex(St)), G.isMesh) Y.wireframe === !0 ? (Ae.setLineWidth(Y.wireframeLinewidth * Be()), nt.setMode(L.LINES)) : nt.setMode(L.TRIANGLES);
                else if (G.isLine) {
                    let Pe = Y.linewidth;
                    Pe === void 0 && (Pe = 1), Ae.setLineWidth(Pe * Be()), G.isLineSegments ? nt.setMode(L.LINES) : G.isLineLoop ? nt.setMode(L.LINE_LOOP) : nt.setMode(L.LINE_STRIP);
                } else G.isPoints ? nt.setMode(L.POINTS) : G.isSprite && nt.setMode(L.TRIANGLES);
                if (G.isBatchedMesh) if (G._multiDrawInstances !== null) Wa("THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."), nt.renderMultiDrawInstances(G._multiDrawStarts, G._multiDrawCounts, G._multiDrawCount, G._multiDrawInstances);
                else if (ge.get("WEBGL_multi_draw")) nt.renderMultiDraw(G._multiDrawStarts, G._multiDrawCounts, G._multiDrawCount);
                else {
                    const Pe = G._multiDrawStarts, Ut = G._multiDrawCounts, ot = G._multiDrawCount, Sn = Se ? ee.get(Se).bytesPerElement : 1, ls = Ee.get(Y).currentProgram.getUniforms();
                    for(let rn = 0; rn < ot; rn++)ls.setValue(L, "_gl_DrawID", rn), nt.render(Pe[rn] / Sn, Ut[rn]);
                }
                else if (G.isInstancedMesh) nt.renderInstances(Qe, Rt, G.count);
                else if (X.isInstancedBufferGeometry) {
                    const Pe = X._maxInstanceCount !== void 0 ? X._maxInstanceCount : 1 / 0, Ut = Math.min(X.instanceCount, Pe);
                    nt.renderInstances(Qe, Rt, Ut);
                } else nt.render(Qe, Rt);
            };
            function ct(A, O, X) {
                A.transparent === !0 && A.side === gn && A.forceSinglePass === !1 ? (A.side = tn, A.needsUpdate = !0, Jr(A, O, X), A.side = ci, A.needsUpdate = !0, Jr(A, O, X), A.side = gn) : Jr(A, O, X);
            }
            this.compile = function(A, O, X = null) {
                X === null && (X = A), p = Je.get(X), p.init(O), v.push(p), X.traverseVisible(function(G) {
                    G.isLight && G.layers.test(O.layers) && (p.pushLight(G), G.castShadow && p.pushShadow(G));
                }), A !== X && A.traverseVisible(function(G) {
                    G.isLight && G.layers.test(O.layers) && (p.pushLight(G), G.castShadow && p.pushShadow(G));
                }), p.setupLights();
                const Y = new Set;
                return A.traverse(function(G) {
                    if (!(G.isMesh || G.isPoints || G.isLine || G.isSprite)) return;
                    const ae = G.material;
                    if (ae) if (Array.isArray(ae)) for(let de = 0; de < ae.length; de++){
                        const xe = ae[de];
                        ct(xe, X, G), Y.add(xe);
                    }
                    else ct(ae, X, G), Y.add(ae);
                }), p = v.pop(), Y;
            }, this.compileAsync = function(A, O, X = null) {
                const Y = this.compile(A, O, X);
                return new Promise((G)=>{
                    function ae() {
                        if (Y.forEach(function(de) {
                            Ee.get(de).currentProgram.isReady() && Y.delete(de);
                        }), Y.size === 0) {
                            G(A);
                            return;
                        }
                        setTimeout(ae, 10);
                    }
                    ge.get("KHR_parallel_shader_compile") !== null ? ae() : setTimeout(ae, 10);
                });
            };
            let bn = null;
            function Yn(A) {
                bn && bn(A);
            }
            function iu() {
                Pi.stop();
            }
            function su() {
                Pi.start();
            }
            const Pi = new Up;
            Pi.setAnimationLoop(Yn), typeof self < "u" && Pi.setContext(self), this.setAnimationLoop = function(A) {
                bn = A, Z.setAnimationLoop(A), A === null ? Pi.stop() : Pi.start();
            }, Z.addEventListener("sessionstart", iu), Z.addEventListener("sessionend", su), this.render = function(A, O) {
                if (O !== void 0 && O.isCamera !== !0) {
                    console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                    return;
                }
                if (P === !0) return;
                if (A.matrixWorldAutoUpdate === !0 && A.updateMatrixWorld(), O.parent === null && O.matrixWorldAutoUpdate === !0 && O.updateMatrixWorld(), Z.enabled === !0 && Z.isPresenting === !0 && (Z.cameraAutoUpdate === !0 && Z.updateCamera(O), O = Z.getCamera()), A.isScene === !0 && A.onBeforeRender(y, A, O, B), p = Je.get(A, v.length), p.init(O), v.push(p), ce.multiplyMatrices(O.projectionMatrix, O.matrixWorldInverse), z.setFromProjectionMatrix(ce), oe = this.localClippingEnabled, K = le.init(this.clippingPlanes, oe), m = ve.get(A, x.length), m.init(), x.push(m), Z.enabled === !0 && Z.isPresenting === !0) {
                    const ae = y.xr.getDepthSensingMesh();
                    ae !== null && vo(ae, O, -1 / 0, y.sortObjects);
                }
                vo(A, O, 0, y.sortObjects), m.finish(), y.sortObjects === !0 && m.sort(U, F), We = Z.enabled === !1 || Z.isPresenting === !1 || Z.hasDepthSensing() === !1, We && De.addToRenderList(m, A), this.info.render.frame++, K === !0 && le.beginShadows();
                const X = p.state.shadowsArray;
                ye.render(X, A, O), K === !0 && le.endShadows(), this.info.autoReset === !0 && this.info.reset();
                const Y = m.opaque, G = m.transmissive;
                if (p.setupLights(), O.isArrayCamera) {
                    const ae = O.cameras;
                    if (G.length > 0) for(let de = 0, xe = ae.length; de < xe; de++){
                        const Se = ae[de];
                        au(Y, G, A, Se);
                    }
                    We && De.render(A);
                    for(let de = 0, xe = ae.length; de < xe; de++){
                        const Se = ae[de];
                        ru(m, A, Se, Se.viewport);
                    }
                } else G.length > 0 && au(Y, G, A, O), We && De.render(A), ru(m, A, O);
                B !== null && R === 0 && (I.updateMultisampleRenderTarget(B), I.updateRenderTargetMipmap(B)), A.isScene === !0 && A.onAfterRender(y, A, O), pt.resetDefaultState(), T = -1, S = null, v.pop(), v.length > 0 ? (p = v[v.length - 1], K === !0 && le.setGlobalState(y.clippingPlanes, p.state.camera)) : p = null, x.pop(), x.length > 0 ? m = x[x.length - 1] : m = null;
            };
            function vo(A, O, X, Y) {
                if (A.visible === !1) return;
                if (A.layers.test(O.layers)) {
                    if (A.isGroup) X = A.renderOrder;
                    else if (A.isLOD) A.autoUpdate === !0 && A.update(O);
                    else if (A.isLight) p.pushLight(A), A.castShadow && p.pushShadow(A);
                    else if (A.isSprite) {
                        if (!A.frustumCulled || z.intersectsSprite(A)) {
                            Y && he.setFromMatrixPosition(A.matrixWorld).applyMatrix4(ce);
                            const de = Q.update(A), xe = A.material;
                            xe.visible && m.push(A, de, xe, X, he.z, null);
                        }
                    } else if ((A.isMesh || A.isLine || A.isPoints) && (!A.frustumCulled || z.intersectsObject(A))) {
                        const de = Q.update(A), xe = A.material;
                        if (Y && (A.boundingSphere !== void 0 ? (A.boundingSphere === null && A.computeBoundingSphere(), he.copy(A.boundingSphere.center)) : (de.boundingSphere === null && de.computeBoundingSphere(), he.copy(de.boundingSphere.center)), he.applyMatrix4(A.matrixWorld).applyMatrix4(ce)), Array.isArray(xe)) {
                            const Se = de.groups;
                            for(let Fe = 0, Le = Se.length; Fe < Le; Fe++){
                                const Re = Se[Fe], Qe = xe[Re.materialIndex];
                                Qe && Qe.visible && m.push(A, de, Qe, X, he.z, Re);
                            }
                        } else xe.visible && m.push(A, de, xe, X, he.z, null);
                    }
                }
                const ae = A.children;
                for(let de = 0, xe = ae.length; de < xe; de++)vo(ae[de], O, X, Y);
            }
            function ru(A, O, X, Y) {
                const G = A.opaque, ae = A.transmissive, de = A.transparent;
                p.setupLightsView(X), K === !0 && le.setGlobalState(y.clippingPlanes, X), Y && Ae.viewport(D.copy(Y)), G.length > 0 && Zr(G, O, X), ae.length > 0 && Zr(ae, O, X), de.length > 0 && Zr(de, O, X), Ae.buffers.depth.setTest(!0), Ae.buffers.depth.setMask(!0), Ae.buffers.color.setMask(!0), Ae.setPolygonOffset(!1);
            }
            function au(A, O, X, Y) {
                if ((X.isScene === !0 ? X.overrideMaterial : null) !== null) return;
                p.state.transmissionRenderTarget[Y.id] === void 0 && (p.state.transmissionRenderTarget[Y.id] = new Qi(1, 1, {
                    generateMipmaps: !0,
                    type: ge.has("EXT_color_buffer_half_float") || ge.has("EXT_color_buffer_float") ? jr : hi,
                    minFilter: ni,
                    samples: 4,
                    stencilBuffer: r,
                    resolveDepthBuffer: !1,
                    resolveStencilBuffer: !1,
                    colorSpace: Ke.workingColorSpace
                }));
                const ae = p.state.transmissionRenderTarget[Y.id], de = Y.viewport || D;
                ae.setSize(de.z * y.transmissionResolutionScale, de.w * y.transmissionResolutionScale);
                const xe = y.getRenderTarget();
                y.setRenderTarget(ae), y.getClearColor($), ne = y.getClearAlpha(), ne < 1 && y.setClearColor(16777215, .5), y.clear(), We && De.render(X);
                const Se = y.toneMapping;
                y.toneMapping = Mi;
                const Fe = Y.viewport;
                if (Y.viewport !== void 0 && (Y.viewport = void 0), p.setupLightsView(Y), K === !0 && le.setGlobalState(y.clippingPlanes, Y), Zr(A, X, Y), I.updateMultisampleRenderTarget(ae), I.updateRenderTargetMipmap(ae), ge.has("WEBGL_multisampled_render_to_texture") === !1) {
                    let Le = !1;
                    for(let Re = 0, Qe = O.length; Re < Qe; Re++){
                        const at = O[Re], Rt = at.object, St = at.geometry, nt = at.material, Pe = at.group;
                        if (nt.side === gn && Rt.layers.test(Y.layers)) {
                            const Ut = nt.side;
                            nt.side = tn, nt.needsUpdate = !0, ou(Rt, X, Y, St, nt, Pe), nt.side = Ut, nt.needsUpdate = !0, Le = !0;
                        }
                    }
                    Le === !0 && (I.updateMultisampleRenderTarget(ae), I.updateRenderTargetMipmap(ae));
                }
                y.setRenderTarget(xe), y.setClearColor($, ne), Fe !== void 0 && (Y.viewport = Fe), y.toneMapping = Se;
            }
            function Zr(A, O, X) {
                const Y = O.isScene === !0 ? O.overrideMaterial : null;
                for(let G = 0, ae = A.length; G < ae; G++){
                    const de = A[G], xe = de.object, Se = de.geometry, Fe = de.group;
                    let Le = de.material;
                    Le.allowOverride === !0 && Y !== null && (Le = Y), xe.layers.test(X.layers) && ou(xe, O, X, Se, Le, Fe);
                }
            }
            function ou(A, O, X, Y, G, ae) {
                A.onBeforeRender(y, O, X, Y, G, ae), A.modelViewMatrix.multiplyMatrices(X.matrixWorldInverse, A.matrixWorld), A.normalMatrix.getNormalMatrix(A.modelViewMatrix), G.onBeforeRender(y, O, X, Y, A, ae), G.transparent === !0 && G.side === gn && G.forceSinglePass === !1 ? (G.side = tn, G.needsUpdate = !0, y.renderBufferDirect(X, O, Y, G, A, ae), G.side = ci, G.needsUpdate = !0, y.renderBufferDirect(X, O, Y, G, A, ae), G.side = gn) : y.renderBufferDirect(X, O, Y, G, A, ae), A.onAfterRender(y, O, X, Y, G, ae);
            }
            function Jr(A, O, X) {
                O.isScene !== !0 && (O = st);
                const Y = Ee.get(A), G = p.state.lights, ae = p.state.shadowsArray, de = G.state.version, xe = Me.getParameters(A, G.state, ae, O, X), Se = Me.getProgramCacheKey(xe);
                let Fe = Y.programs;
                Y.environment = A.isMeshStandardMaterial ? O.environment : null, Y.fog = O.fog, Y.envMap = (A.isMeshStandardMaterial ? W : M).get(A.envMap || Y.environment), Y.envMapRotation = Y.environment !== null && A.envMap === null ? O.environmentRotation : A.envMapRotation, Fe === void 0 && (A.addEventListener("dispose", ke), Fe = new Map, Y.programs = Fe);
                let Le = Fe.get(Se);
                if (Le !== void 0) {
                    if (Y.currentProgram === Le && Y.lightsStateVersion === de) return cu(A, xe), Le;
                } else xe.uniforms = Me.getUniforms(A), A.onBeforeCompile(xe, y), Le = Me.acquireProgram(xe, Se), Fe.set(Se, Le), Y.uniforms = xe.uniforms;
                const Re = Y.uniforms;
                return (!A.isShaderMaterial && !A.isRawShaderMaterial || A.clipping === !0) && (Re.clippingPlanes = le.uniform), cu(A, xe), Y.needsLights = cg(A), Y.lightsStateVersion = de, Y.needsLights && (Re.ambientLightColor.value = G.state.ambient, Re.lightProbe.value = G.state.probe, Re.directionalLights.value = G.state.directional, Re.directionalLightShadows.value = G.state.directionalShadow, Re.spotLights.value = G.state.spot, Re.spotLightShadows.value = G.state.spotShadow, Re.rectAreaLights.value = G.state.rectArea, Re.ltc_1.value = G.state.rectAreaLTC1, Re.ltc_2.value = G.state.rectAreaLTC2, Re.pointLights.value = G.state.point, Re.pointLightShadows.value = G.state.pointShadow, Re.hemisphereLights.value = G.state.hemi, Re.directionalShadowMap.value = G.state.directionalShadowMap, Re.directionalShadowMatrix.value = G.state.directionalShadowMatrix, Re.spotShadowMap.value = G.state.spotShadowMap, Re.spotLightMatrix.value = G.state.spotLightMatrix, Re.spotLightMap.value = G.state.spotLightMap, Re.pointShadowMap.value = G.state.pointShadowMap, Re.pointShadowMatrix.value = G.state.pointShadowMatrix), Y.currentProgram = Le, Y.uniformsList = null, Le;
            }
            function lu(A) {
                if (A.uniformsList === null) {
                    const O = A.currentProgram.getUniforms();
                    A.uniformsList = Ya.seqWithValue(O.seq, A.uniforms);
                }
                return A.uniformsList;
            }
            function cu(A, O) {
                const X = Ee.get(A);
                X.outputColorSpace = O.outputColorSpace, X.batching = O.batching, X.batchingColor = O.batchingColor, X.instancing = O.instancing, X.instancingColor = O.instancingColor, X.instancingMorph = O.instancingMorph, X.skinning = O.skinning, X.morphTargets = O.morphTargets, X.morphNormals = O.morphNormals, X.morphColors = O.morphColors, X.morphTargetsCount = O.morphTargetsCount, X.numClippingPlanes = O.numClippingPlanes, X.numIntersection = O.numClipIntersection, X.vertexAlphas = O.vertexAlphas, X.vertexTangents = O.vertexTangents, X.toneMapping = O.toneMapping;
            }
            function og(A, O, X, Y, G) {
                O.isScene !== !0 && (O = st), I.resetTextureUnits();
                const ae = O.fog, de = Y.isMeshStandardMaterial ? O.environment : null, xe = B === null ? y.outputColorSpace : B.isXRRenderTarget === !0 ? B.texture.colorSpace : Zt, Se = (Y.isMeshStandardMaterial ? W : M).get(Y.envMap || de), Fe = Y.vertexColors === !0 && !!X.attributes.color && X.attributes.color.itemSize === 4, Le = !!X.attributes.tangent && (!!Y.normalMap || Y.anisotropy > 0), Re = !!X.morphAttributes.position, Qe = !!X.morphAttributes.normal, at = !!X.morphAttributes.color;
                let Rt = Mi;
                Y.toneMapped && (B === null || B.isXRRenderTarget === !0) && (Rt = y.toneMapping);
                const St = X.morphAttributes.position || X.morphAttributes.normal || X.morphAttributes.color, nt = St !== void 0 ? St.length : 0, Pe = Ee.get(Y), Ut = p.state.lights;
                if (K === !0 && (oe === !0 || A !== S)) {
                    const Wt = A === S && Y.id === T;
                    le.setState(Y, A, Wt);
                }
                let ot = !1;
                Y.version === Pe.__version ? (Pe.needsLights && Pe.lightsStateVersion !== Ut.state.version || Pe.outputColorSpace !== xe || G.isBatchedMesh && Pe.batching === !1 || !G.isBatchedMesh && Pe.batching === !0 || G.isBatchedMesh && Pe.batchingColor === !0 && G.colorTexture === null || G.isBatchedMesh && Pe.batchingColor === !1 && G.colorTexture !== null || G.isInstancedMesh && Pe.instancing === !1 || !G.isInstancedMesh && Pe.instancing === !0 || G.isSkinnedMesh && Pe.skinning === !1 || !G.isSkinnedMesh && Pe.skinning === !0 || G.isInstancedMesh && Pe.instancingColor === !0 && G.instanceColor === null || G.isInstancedMesh && Pe.instancingColor === !1 && G.instanceColor !== null || G.isInstancedMesh && Pe.instancingMorph === !0 && G.morphTexture === null || G.isInstancedMesh && Pe.instancingMorph === !1 && G.morphTexture !== null || Pe.envMap !== Se || Y.fog === !0 && Pe.fog !== ae || Pe.numClippingPlanes !== void 0 && (Pe.numClippingPlanes !== le.numPlanes || Pe.numIntersection !== le.numIntersection) || Pe.vertexAlphas !== Fe || Pe.vertexTangents !== Le || Pe.morphTargets !== Re || Pe.morphNormals !== Qe || Pe.morphColors !== at || Pe.toneMapping !== Rt || Pe.morphTargetsCount !== nt) && (ot = !0) : (ot = !0, Pe.__version = Y.version);
                let Sn = Pe.currentProgram;
                ot === !0 && (Sn = Jr(Y, O, G));
                let ls = !1, rn = !1, ar = !1;
                const gt = Sn.getUniforms(), un = Pe.uniforms;
                if (Ae.useProgram(Sn.program) && (ls = !0, rn = !0, ar = !0), Y.id !== T && (T = Y.id, rn = !0), ls || S !== A) {
                    Ae.buffers.depth.getReversed() ? (se.copy(A.projectionMatrix), Tx(se), Mx(se), gt.setValue(L, "projectionMatrix", se)) : gt.setValue(L, "projectionMatrix", A.projectionMatrix), gt.setValue(L, "viewMatrix", A.matrixWorldInverse);
                    const Qt = gt.map.cameraPosition;
                    Qt !== void 0 && Qt.setValue(L, we.setFromMatrixPosition(A.matrixWorld)), Xe.logarithmicDepthBuffer && gt.setValue(L, "logDepthBufFC", 2 / (Math.log(A.far + 1) / Math.LN2)), (Y.isMeshPhongMaterial || Y.isMeshToonMaterial || Y.isMeshLambertMaterial || Y.isMeshBasicMaterial || Y.isMeshStandardMaterial || Y.isShaderMaterial) && gt.setValue(L, "isOrthographic", A.isOrthographicCamera === !0), S !== A && (S = A, rn = !0, ar = !0);
                }
                if (G.isSkinnedMesh) {
                    gt.setOptional(L, G, "bindMatrix"), gt.setOptional(L, G, "bindMatrixInverse");
                    const Wt = G.skeleton;
                    Wt && (Wt.boneTexture === null && Wt.computeBoneTexture(), gt.setValue(L, "boneTexture", Wt.boneTexture, I));
                }
                G.isBatchedMesh && (gt.setOptional(L, G, "batchingTexture"), gt.setValue(L, "batchingTexture", G._matricesTexture, I), gt.setOptional(L, G, "batchingIdTexture"), gt.setValue(L, "batchingIdTexture", G._indirectTexture, I), gt.setOptional(L, G, "batchingColorTexture"), G._colorsTexture !== null && gt.setValue(L, "batchingColorTexture", G._colorsTexture, I));
                const dn = X.morphAttributes;
                if ((dn.position !== void 0 || dn.normal !== void 0 || dn.color !== void 0) && Ue.update(G, X, Sn), (rn || Pe.receiveShadow !== G.receiveShadow) && (Pe.receiveShadow = G.receiveShadow, gt.setValue(L, "receiveShadow", G.receiveShadow)), Y.isMeshGouraudMaterial && Y.envMap !== null && (un.envMap.value = Se, un.flipEnvMap.value = Se.isCubeTexture && Se.isRenderTargetTexture === !1 ? -1 : 1), Y.isMeshStandardMaterial && Y.envMap === null && O.environment !== null && (un.envMapIntensity.value = O.environmentIntensity), rn && (gt.setValue(L, "toneMappingExposure", y.toneMappingExposure), Pe.needsLights && lg(un, ar), ae && Y.fog === !0 && fe.refreshFogUniforms(un, ae), fe.refreshMaterialUniforms(un, Y, E, C, p.state.transmissionRenderTarget[A.id]), Ya.upload(L, lu(Pe), un, I)), Y.isShaderMaterial && Y.uniformsNeedUpdate === !0 && (Ya.upload(L, lu(Pe), un, I), Y.uniformsNeedUpdate = !1), Y.isSpriteMaterial && gt.setValue(L, "center", G.center), gt.setValue(L, "modelViewMatrix", G.modelViewMatrix), gt.setValue(L, "normalMatrix", G.normalMatrix), gt.setValue(L, "modelMatrix", G.matrixWorld), Y.isShaderMaterial || Y.isRawShaderMaterial) {
                    const Wt = Y.uniformsGroups;
                    for(let Qt = 0, yo = Wt.length; Qt < yo; Qt++){
                        const Ii = Wt[Qt];
                        N.update(Ii, Sn), N.bind(Ii, Sn);
                    }
                }
                return Sn;
            }
            function lg(A, O) {
                A.ambientLightColor.needsUpdate = O, A.lightProbe.needsUpdate = O, A.directionalLights.needsUpdate = O, A.directionalLightShadows.needsUpdate = O, A.pointLights.needsUpdate = O, A.pointLightShadows.needsUpdate = O, A.spotLights.needsUpdate = O, A.spotLightShadows.needsUpdate = O, A.rectAreaLights.needsUpdate = O, A.hemisphereLights.needsUpdate = O;
            }
            function cg(A) {
                return A.isMeshLambertMaterial || A.isMeshToonMaterial || A.isMeshPhongMaterial || A.isMeshStandardMaterial || A.isShadowMaterial || A.isShaderMaterial && A.lights === !0;
            }
            this.getActiveCubeFace = function() {
                return w;
            }, this.getActiveMipmapLevel = function() {
                return R;
            }, this.getRenderTarget = function() {
                return B;
            }, this.setRenderTargetTextures = function(A, O, X) {
                const Y = Ee.get(A);
                Y.__autoAllocateDepthBuffer = A.resolveDepthBuffer === !1, Y.__autoAllocateDepthBuffer === !1 && (Y.__useRenderToTexture = !1), Ee.get(A.texture).__webglTexture = O, Ee.get(A.depthTexture).__webglTexture = Y.__autoAllocateDepthBuffer ? void 0 : X, Y.__hasExternalTextures = !0;
            }, this.setRenderTargetFramebuffer = function(A, O) {
                const X = Ee.get(A);
                X.__webglFramebuffer = O, X.__useDefaultFramebuffer = O === void 0;
            };
            const hg = L.createFramebuffer();
            this.setRenderTarget = function(A, O = 0, X = 0) {
                B = A, w = O, R = X;
                let Y = !0, G = null, ae = !1, de = !1;
                if (A) {
                    const Se = Ee.get(A);
                    if (Se.__useDefaultFramebuffer !== void 0) Ae.bindFramebuffer(L.FRAMEBUFFER, null), Y = !1;
                    else if (Se.__webglFramebuffer === void 0) I.setupRenderTarget(A);
                    else if (Se.__hasExternalTextures) I.rebindTextures(A, Ee.get(A.texture).__webglTexture, Ee.get(A.depthTexture).__webglTexture);
                    else if (A.depthBuffer) {
                        const Re = A.depthTexture;
                        if (Se.__boundDepthTexture !== Re) {
                            if (Re !== null && Ee.has(Re) && (A.width !== Re.image.width || A.height !== Re.image.height)) throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
                            I.setupDepthRenderbuffer(A);
                        }
                    }
                    const Fe = A.texture;
                    (Fe.isData3DTexture || Fe.isDataArrayTexture || Fe.isCompressedArrayTexture) && (de = !0);
                    const Le = Ee.get(A).__webglFramebuffer;
                    A.isWebGLCubeRenderTarget ? (Array.isArray(Le[O]) ? G = Le[O][X] : G = Le[O], ae = !0) : A.samples > 0 && I.useMultisampledRTT(A) === !1 ? G = Ee.get(A).__webglMultisampledFramebuffer : Array.isArray(Le) ? G = Le[X] : G = Le, D.copy(A.viewport), q.copy(A.scissor), H = A.scissorTest;
                } else D.copy(V).multiplyScalar(E).floor(), q.copy(j).multiplyScalar(E).floor(), H = ie;
                if (X !== 0 && (G = hg), Ae.bindFramebuffer(L.FRAMEBUFFER, G) && Y && Ae.drawBuffers(A, G), Ae.viewport(D), Ae.scissor(q), Ae.setScissorTest(H), ae) {
                    const Se = Ee.get(A.texture);
                    L.framebufferTexture2D(L.FRAMEBUFFER, L.COLOR_ATTACHMENT0, L.TEXTURE_CUBE_MAP_POSITIVE_X + O, Se.__webglTexture, X);
                } else if (de) {
                    const Se = Ee.get(A.texture), Fe = O;
                    L.framebufferTextureLayer(L.FRAMEBUFFER, L.COLOR_ATTACHMENT0, Se.__webglTexture, X, Fe);
                } else if (A !== null && X !== 0) {
                    const Se = Ee.get(A.texture);
                    L.framebufferTexture2D(L.FRAMEBUFFER, L.COLOR_ATTACHMENT0, L.TEXTURE_2D, Se.__webglTexture, X);
                }
                T = -1;
            }, this.readRenderTargetPixels = function(A, O, X, Y, G, ae, de) {
                if (!(A && A.isWebGLRenderTarget)) {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                    return;
                }
                let xe = Ee.get(A).__webglFramebuffer;
                if (A.isWebGLCubeRenderTarget && de !== void 0 && (xe = xe[de]), xe) {
                    Ae.bindFramebuffer(L.FRAMEBUFFER, xe);
                    try {
                        const Se = A.texture, Fe = Se.format, Le = Se.type;
                        if (!Xe.textureFormatReadable(Fe)) {
                            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                            return;
                        }
                        if (!Xe.textureTypeReadable(Le)) {
                            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                            return;
                        }
                        O >= 0 && O <= A.width - Y && X >= 0 && X <= A.height - G && L.readPixels(O, X, Y, G, ze.convert(Fe), ze.convert(Le), ae);
                    } finally{
                        const Se = B !== null ? Ee.get(B).__webglFramebuffer : null;
                        Ae.bindFramebuffer(L.FRAMEBUFFER, Se);
                    }
                }
            }, this.readRenderTargetPixelsAsync = async function(A, O, X, Y, G, ae, de) {
                if (!(A && A.isWebGLRenderTarget)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                let xe = Ee.get(A).__webglFramebuffer;
                if (A.isWebGLCubeRenderTarget && de !== void 0 && (xe = xe[de]), xe) if (O >= 0 && O <= A.width - Y && X >= 0 && X <= A.height - G) {
                    Ae.bindFramebuffer(L.FRAMEBUFFER, xe);
                    const Se = A.texture, Fe = Se.format, Le = Se.type;
                    if (!Xe.textureFormatReadable(Fe)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
                    if (!Xe.textureTypeReadable(Le)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
                    const Re = L.createBuffer();
                    L.bindBuffer(L.PIXEL_PACK_BUFFER, Re), L.bufferData(L.PIXEL_PACK_BUFFER, ae.byteLength, L.STREAM_READ), L.readPixels(O, X, Y, G, ze.convert(Fe), ze.convert(Le), 0);
                    const Qe = B !== null ? Ee.get(B).__webglFramebuffer : null;
                    Ae.bindFramebuffer(L.FRAMEBUFFER, Qe);
                    const at = L.fenceSync(L.SYNC_GPU_COMMANDS_COMPLETE, 0);
                    return L.flush(), await Sx(L, at, 4), L.bindBuffer(L.PIXEL_PACK_BUFFER, Re), L.getBufferSubData(L.PIXEL_PACK_BUFFER, 0, ae), L.deleteBuffer(Re), L.deleteSync(at), ae;
                } else throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.");
            }, this.copyFramebufferToTexture = function(A, O = null, X = 0) {
                const Y = Math.pow(2, -X), G = Math.floor(A.image.width * Y), ae = Math.floor(A.image.height * Y), de = O !== null ? O.x : 0, xe = O !== null ? O.y : 0;
                I.setTexture2D(A, 0), L.copyTexSubImage2D(L.TEXTURE_2D, X, 0, 0, de, xe, G, ae), Ae.unbindTexture();
            };
            const ug = L.createFramebuffer(), dg = L.createFramebuffer();
            this.copyTextureToTexture = function(A, O, X = null, Y = null, G = 0, ae = null) {
                ae === null && (G !== 0 ? (Wa("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."), ae = G, G = 0) : ae = 0);
                let de, xe, Se, Fe, Le, Re, Qe, at, Rt;
                const St = A.isCompressedTexture ? A.mipmaps[ae] : A.image;
                if (X !== null) de = X.max.x - X.min.x, xe = X.max.y - X.min.y, Se = X.isBox3 ? X.max.z - X.min.z : 1, Fe = X.min.x, Le = X.min.y, Re = X.isBox3 ? X.min.z : 0;
                else {
                    const dn = Math.pow(2, -G);
                    de = Math.floor(St.width * dn), xe = Math.floor(St.height * dn), A.isDataArrayTexture ? Se = St.depth : A.isData3DTexture ? Se = Math.floor(St.depth * dn) : Se = 1, Fe = 0, Le = 0, Re = 0;
                }
                Y !== null ? (Qe = Y.x, at = Y.y, Rt = Y.z) : (Qe = 0, at = 0, Rt = 0);
                const nt = ze.convert(O.format), Pe = ze.convert(O.type);
                let Ut;
                O.isData3DTexture ? (I.setTexture3D(O, 0), Ut = L.TEXTURE_3D) : O.isDataArrayTexture || O.isCompressedArrayTexture ? (I.setTexture2DArray(O, 0), Ut = L.TEXTURE_2D_ARRAY) : (I.setTexture2D(O, 0), Ut = L.TEXTURE_2D), L.pixelStorei(L.UNPACK_FLIP_Y_WEBGL, O.flipY), L.pixelStorei(L.UNPACK_PREMULTIPLY_ALPHA_WEBGL, O.premultiplyAlpha), L.pixelStorei(L.UNPACK_ALIGNMENT, O.unpackAlignment);
                const ot = L.getParameter(L.UNPACK_ROW_LENGTH), Sn = L.getParameter(L.UNPACK_IMAGE_HEIGHT), ls = L.getParameter(L.UNPACK_SKIP_PIXELS), rn = L.getParameter(L.UNPACK_SKIP_ROWS), ar = L.getParameter(L.UNPACK_SKIP_IMAGES);
                L.pixelStorei(L.UNPACK_ROW_LENGTH, St.width), L.pixelStorei(L.UNPACK_IMAGE_HEIGHT, St.height), L.pixelStorei(L.UNPACK_SKIP_PIXELS, Fe), L.pixelStorei(L.UNPACK_SKIP_ROWS, Le), L.pixelStorei(L.UNPACK_SKIP_IMAGES, Re);
                const gt = A.isDataArrayTexture || A.isData3DTexture, un = O.isDataArrayTexture || O.isData3DTexture;
                if (A.isDepthTexture) {
                    const dn = Ee.get(A), Wt = Ee.get(O), Qt = Ee.get(dn.__renderTarget), yo = Ee.get(Wt.__renderTarget);
                    Ae.bindFramebuffer(L.READ_FRAMEBUFFER, Qt.__webglFramebuffer), Ae.bindFramebuffer(L.DRAW_FRAMEBUFFER, yo.__webglFramebuffer);
                    for(let Ii = 0; Ii < Se; Ii++)gt && (L.framebufferTextureLayer(L.READ_FRAMEBUFFER, L.COLOR_ATTACHMENT0, Ee.get(A).__webglTexture, G, Re + Ii), L.framebufferTextureLayer(L.DRAW_FRAMEBUFFER, L.COLOR_ATTACHMENT0, Ee.get(O).__webglTexture, ae, Rt + Ii)), L.blitFramebuffer(Fe, Le, de, xe, Qe, at, de, xe, L.DEPTH_BUFFER_BIT, L.NEAREST);
                    Ae.bindFramebuffer(L.READ_FRAMEBUFFER, null), Ae.bindFramebuffer(L.DRAW_FRAMEBUFFER, null);
                } else if (G !== 0 || A.isRenderTargetTexture || Ee.has(A)) {
                    const dn = Ee.get(A), Wt = Ee.get(O);
                    Ae.bindFramebuffer(L.READ_FRAMEBUFFER, ug), Ae.bindFramebuffer(L.DRAW_FRAMEBUFFER, dg);
                    for(let Qt = 0; Qt < Se; Qt++)gt ? L.framebufferTextureLayer(L.READ_FRAMEBUFFER, L.COLOR_ATTACHMENT0, dn.__webglTexture, G, Re + Qt) : L.framebufferTexture2D(L.READ_FRAMEBUFFER, L.COLOR_ATTACHMENT0, L.TEXTURE_2D, dn.__webglTexture, G), un ? L.framebufferTextureLayer(L.DRAW_FRAMEBUFFER, L.COLOR_ATTACHMENT0, Wt.__webglTexture, ae, Rt + Qt) : L.framebufferTexture2D(L.DRAW_FRAMEBUFFER, L.COLOR_ATTACHMENT0, L.TEXTURE_2D, Wt.__webglTexture, ae), G !== 0 ? L.blitFramebuffer(Fe, Le, de, xe, Qe, at, de, xe, L.COLOR_BUFFER_BIT, L.NEAREST) : un ? L.copyTexSubImage3D(Ut, ae, Qe, at, Rt + Qt, Fe, Le, de, xe) : L.copyTexSubImage2D(Ut, ae, Qe, at, Fe, Le, de, xe);
                    Ae.bindFramebuffer(L.READ_FRAMEBUFFER, null), Ae.bindFramebuffer(L.DRAW_FRAMEBUFFER, null);
                } else un ? A.isDataTexture || A.isData3DTexture ? L.texSubImage3D(Ut, ae, Qe, at, Rt, de, xe, Se, nt, Pe, St.data) : O.isCompressedArrayTexture ? L.compressedTexSubImage3D(Ut, ae, Qe, at, Rt, de, xe, Se, nt, St.data) : L.texSubImage3D(Ut, ae, Qe, at, Rt, de, xe, Se, nt, Pe, St) : A.isDataTexture ? L.texSubImage2D(L.TEXTURE_2D, ae, Qe, at, de, xe, nt, Pe, St.data) : A.isCompressedTexture ? L.compressedTexSubImage2D(L.TEXTURE_2D, ae, Qe, at, St.width, St.height, nt, St.data) : L.texSubImage2D(L.TEXTURE_2D, ae, Qe, at, de, xe, nt, Pe, St);
                L.pixelStorei(L.UNPACK_ROW_LENGTH, ot), L.pixelStorei(L.UNPACK_IMAGE_HEIGHT, Sn), L.pixelStorei(L.UNPACK_SKIP_PIXELS, ls), L.pixelStorei(L.UNPACK_SKIP_ROWS, rn), L.pixelStorei(L.UNPACK_SKIP_IMAGES, ar), ae === 0 && O.generateMipmaps && L.generateMipmap(Ut), Ae.unbindTexture();
            }, this.copyTextureToTexture3D = function(A, O, X = null, Y = null, G = 0) {
                return Wa('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'), this.copyTextureToTexture(A, O, X, Y, G);
            }, this.initRenderTarget = function(A) {
                Ee.get(A).__webglFramebuffer === void 0 && I.setupRenderTarget(A);
            }, this.initTexture = function(A) {
                A.isCubeTexture ? I.setTextureCube(A, 0) : A.isData3DTexture ? I.setTexture3D(A, 0) : A.isDataArrayTexture || A.isCompressedArrayTexture ? I.setTexture2DArray(A, 0) : I.setTexture2D(A, 0), Ae.unbindTexture();
            }, this.resetState = function() {
                w = 0, R = 0, B = null, Ae.reset(), pt.reset();
            }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                detail: this
            }));
        }
        get coordinateSystem() {
            return ii;
        }
        get outputColorSpace() {
            return this._outputColorSpace;
        }
        set outputColorSpace(e) {
            this._outputColorSpace = e;
            const t = this.getContext();
            t.drawingBufferColorSpace = Ke._getDrawingBufferColorSpace(e), t.unpackColorSpace = Ke._getUnpackColorSpace();
        }
    };
    var mr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
    function Ah(i) {
        return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
    }
    var el = {};
    var Ad;
    function MT() {
        return Ad || (Ad = 1, function(i) {
            (function() {
                var e = function() {
                    this.init();
                };
                e.prototype = {
                    init: function() {
                        var c = this || t;
                        return c._counter = 1e3, c._html5AudioPool = [], c.html5PoolSize = 10, c._codecs = {}, c._howls = [], c._muted = !1, c._volume = 1, c._canPlayEvent = "canplaythrough", c._navigator = typeof window < "u" && window.navigator ? window.navigator : null, c.masterGain = null, c.noAudio = !1, c.usingWebAudio = !0, c.autoSuspend = !0, c.ctx = null, c.autoUnlock = !0, c._setup(), c;
                    },
                    volume: function(c) {
                        var u = this || t;
                        if (c = parseFloat(c), u.ctx || d(), typeof c < "u" && c >= 0 && c <= 1) {
                            if (u._volume = c, u._muted) return u;
                            u.usingWebAudio && u.masterGain.gain.setValueAtTime(c, t.ctx.currentTime);
                            for(var f = 0; f < u._howls.length; f++)if (!u._howls[f]._webAudio) for(var _ = u._howls[f]._getSoundIds(), g = 0; g < _.length; g++){
                                var m = u._howls[f]._soundById(_[g]);
                                m && m._node && (m._node.volume = m._volume * c);
                            }
                            return u;
                        }
                        return u._volume;
                    },
                    mute: function(c) {
                        var u = this || t;
                        u.ctx || d(), u._muted = c, u.usingWebAudio && u.masterGain.gain.setValueAtTime(c ? 0 : u._volume, t.ctx.currentTime);
                        for(var f = 0; f < u._howls.length; f++)if (!u._howls[f]._webAudio) for(var _ = u._howls[f]._getSoundIds(), g = 0; g < _.length; g++){
                            var m = u._howls[f]._soundById(_[g]);
                            m && m._node && (m._node.muted = c ? !0 : m._muted);
                        }
                        return u;
                    },
                    stop: function() {
                        for(var c = this || t, u = 0; u < c._howls.length; u++)c._howls[u].stop();
                        return c;
                    },
                    unload: function() {
                        for(var c = this || t, u = c._howls.length - 1; u >= 0; u--)c._howls[u].unload();
                        return c.usingWebAudio && c.ctx && typeof c.ctx.close < "u" && (c.ctx.close(), c.ctx = null, d()), c;
                    },
                    codecs: function(c) {
                        return (this || t)._codecs[c.replace(/^x-/, "")];
                    },
                    _setup: function() {
                        var c = this || t;
                        if (c.state = c.ctx && c.ctx.state || "suspended", c._autoSuspend(), !c.usingWebAudio) if (typeof Audio < "u") try {
                            var u = new Audio;
                            typeof u.oncanplaythrough > "u" && (c._canPlayEvent = "canplay");
                        } catch  {
                            c.noAudio = !0;
                        }
                        else c.noAudio = !0;
                        try {
                            var u = new Audio;
                            u.muted && (c.noAudio = !0);
                        } catch  {}
                        return c.noAudio || c._setupCodecs(), c;
                    },
                    _setupCodecs: function() {
                        var c = this || t, u = null;
                        try {
                            u = typeof Audio < "u" ? new Audio : null;
                        } catch  {
                            return c;
                        }
                        if (!u || typeof u.canPlayType != "function") return c;
                        var f = u.canPlayType("audio/mpeg;").replace(/^no$/, ""), _ = c._navigator ? c._navigator.userAgent : "", g = _.match(/OPR\/(\d+)/g), m = g && parseInt(g[0].split("/")[1], 10) < 33, p = _.indexOf("Safari") !== -1 && _.indexOf("Chrome") === -1, x = _.match(/Version\/(.*?) /), v = p && x && parseInt(x[1], 10) < 15;
                        return c._codecs = {
                            mp3: !!(!m && (f || u.canPlayType("audio/mp3;").replace(/^no$/, ""))),
                            mpeg: !!f,
                            opus: !!u.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
                            ogg: !!u.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
                            oga: !!u.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
                            wav: !!(u.canPlayType('audio/wav; codecs="1"') || u.canPlayType("audio/wav")).replace(/^no$/, ""),
                            aac: !!u.canPlayType("audio/aac;").replace(/^no$/, ""),
                            caf: !!u.canPlayType("audio/x-caf;").replace(/^no$/, ""),
                            m4a: !!(u.canPlayType("audio/x-m4a;") || u.canPlayType("audio/m4a;") || u.canPlayType("audio/aac;")).replace(/^no$/, ""),
                            m4b: !!(u.canPlayType("audio/x-m4b;") || u.canPlayType("audio/m4b;") || u.canPlayType("audio/aac;")).replace(/^no$/, ""),
                            mp4: !!(u.canPlayType("audio/x-mp4;") || u.canPlayType("audio/mp4;") || u.canPlayType("audio/aac;")).replace(/^no$/, ""),
                            weba: !!(!v && u.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
                            webm: !!(!v && u.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
                            dolby: !!u.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""),
                            flac: !!(u.canPlayType("audio/x-flac;") || u.canPlayType("audio/flac;")).replace(/^no$/, "")
                        }, c;
                    },
                    _unlockAudio: function() {
                        var c = this || t;
                        if (!(c._audioUnlocked || !c.ctx)) {
                            c._audioUnlocked = !1, c.autoUnlock = !1, !c._mobileUnloaded && c.ctx.sampleRate !== 44100 && (c._mobileUnloaded = !0, c.unload()), c._scratchBuffer = c.ctx.createBuffer(1, 1, 22050);
                            var u = function(f) {
                                for(; c._html5AudioPool.length < c.html5PoolSize;)try {
                                    var _ = new Audio;
                                    _._unlocked = !0, c._releaseHtml5Audio(_);
                                } catch  {
                                    c.noAudio = !0;
                                    break;
                                }
                                for(var g = 0; g < c._howls.length; g++)if (!c._howls[g]._webAudio) for(var m = c._howls[g]._getSoundIds(), p = 0; p < m.length; p++){
                                    var x = c._howls[g]._soundById(m[p]);
                                    x && x._node && !x._node._unlocked && (x._node._unlocked = !0, x._node.load());
                                }
                                c._autoResume();
                                var v = c.ctx.createBufferSource();
                                v.buffer = c._scratchBuffer, v.connect(c.ctx.destination), typeof v.start > "u" ? v.noteOn(0) : v.start(0), typeof c.ctx.resume == "function" && c.ctx.resume(), v.onended = function() {
                                    v.disconnect(0), c._audioUnlocked = !0, document.removeEventListener("touchstart", u, !0), document.removeEventListener("touchend", u, !0), document.removeEventListener("click", u, !0), document.removeEventListener("keydown", u, !0);
                                    for(var y = 0; y < c._howls.length; y++)c._howls[y]._emit("unlock");
                                };
                            };
                            return document.addEventListener("touchstart", u, !0), document.addEventListener("touchend", u, !0), document.addEventListener("click", u, !0), document.addEventListener("keydown", u, !0), c;
                        }
                    },
                    _obtainHtml5Audio: function() {
                        var c = this || t;
                        if (c._html5AudioPool.length) return c._html5AudioPool.pop();
                        var u = new Audio().play();
                        return u && typeof Promise < "u" && (u instanceof Promise || typeof u.then == "function") && u.catch(function() {
                            console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.");
                        }), new Audio;
                    },
                    _releaseHtml5Audio: function(c) {
                        var u = this || t;
                        return c._unlocked && u._html5AudioPool.push(c), u;
                    },
                    _autoSuspend: function() {
                        var c = this;
                        if (!(!c.autoSuspend || !c.ctx || typeof c.ctx.suspend > "u" || !t.usingWebAudio)) {
                            for(var u = 0; u < c._howls.length; u++)if (c._howls[u]._webAudio) {
                                for(var f = 0; f < c._howls[u]._sounds.length; f++)if (!c._howls[u]._sounds[f]._paused) return c;
                            }
                            return c._suspendTimer && clearTimeout(c._suspendTimer), c._suspendTimer = setTimeout(function() {
                                if (c.autoSuspend) {
                                    c._suspendTimer = null, c.state = "suspending";
                                    var _ = function() {
                                        c.state = "suspended", c._resumeAfterSuspend && (delete c._resumeAfterSuspend, c._autoResume());
                                    };
                                    c.ctx.suspend().then(_, _);
                                }
                            }, 3e4), c;
                        }
                    },
                    _autoResume: function() {
                        var c = this;
                        if (!(!c.ctx || typeof c.ctx.resume > "u" || !t.usingWebAudio)) return c.state === "running" && c.ctx.state !== "interrupted" && c._suspendTimer ? (clearTimeout(c._suspendTimer), c._suspendTimer = null) : c.state === "suspended" || c.state === "running" && c.ctx.state === "interrupted" ? (c.ctx.resume().then(function() {
                            c.state = "running";
                            for(var u = 0; u < c._howls.length; u++)c._howls[u]._emit("resume");
                        }), c._suspendTimer && (clearTimeout(c._suspendTimer), c._suspendTimer = null)) : c.state === "suspending" && (c._resumeAfterSuspend = !0), c;
                    }
                };
                var t = new e, n = function(c) {
                    var u = this;
                    if (!c.src || c.src.length === 0) {
                        console.error("An array of source files must be passed with any new Howl.");
                        return;
                    }
                    u.init(c);
                };
                n.prototype = {
                    init: function(c) {
                        var u = this;
                        return t.ctx || d(), u._autoplay = c.autoplay || !1, u._format = typeof c.format != "string" ? c.format : [
                            c.format
                        ], u._html5 = c.html5 || !1, u._muted = c.mute || !1, u._loop = c.loop || !1, u._pool = c.pool || 5, u._preload = typeof c.preload == "boolean" || c.preload === "metadata" ? c.preload : !0, u._rate = c.rate || 1, u._sprite = c.sprite || {}, u._src = typeof c.src != "string" ? c.src : [
                            c.src
                        ], u._volume = c.volume !== void 0 ? c.volume : 1, u._xhr = {
                            method: c.xhr && c.xhr.method ? c.xhr.method : "GET",
                            headers: c.xhr && c.xhr.headers ? c.xhr.headers : null,
                            withCredentials: c.xhr && c.xhr.withCredentials ? c.xhr.withCredentials : !1
                        }, u._duration = 0, u._state = "unloaded", u._sounds = [], u._endTimers = {}, u._queue = [], u._playLock = !1, u._onend = c.onend ? [
                            {
                                fn: c.onend
                            }
                        ] : [], u._onfade = c.onfade ? [
                            {
                                fn: c.onfade
                            }
                        ] : [], u._onload = c.onload ? [
                            {
                                fn: c.onload
                            }
                        ] : [], u._onloaderror = c.onloaderror ? [
                            {
                                fn: c.onloaderror
                            }
                        ] : [], u._onplayerror = c.onplayerror ? [
                            {
                                fn: c.onplayerror
                            }
                        ] : [], u._onpause = c.onpause ? [
                            {
                                fn: c.onpause
                            }
                        ] : [], u._onplay = c.onplay ? [
                            {
                                fn: c.onplay
                            }
                        ] : [], u._onstop = c.onstop ? [
                            {
                                fn: c.onstop
                            }
                        ] : [], u._onmute = c.onmute ? [
                            {
                                fn: c.onmute
                            }
                        ] : [], u._onvolume = c.onvolume ? [
                            {
                                fn: c.onvolume
                            }
                        ] : [], u._onrate = c.onrate ? [
                            {
                                fn: c.onrate
                            }
                        ] : [], u._onseek = c.onseek ? [
                            {
                                fn: c.onseek
                            }
                        ] : [], u._onunlock = c.onunlock ? [
                            {
                                fn: c.onunlock
                            }
                        ] : [], u._onresume = [], u._webAudio = t.usingWebAudio && !u._html5, typeof t.ctx < "u" && t.ctx && t.autoUnlock && t._unlockAudio(), t._howls.push(u), u._autoplay && u._queue.push({
                            event: "play",
                            action: function() {
                                u.play();
                            }
                        }), u._preload && u._preload !== "none" && u.load(), u;
                    },
                    load: function() {
                        var c = this, u = null;
                        if (t.noAudio) {
                            c._emit("loaderror", null, "No audio support.");
                            return;
                        }
                        typeof c._src == "string" && (c._src = [
                            c._src
                        ]);
                        for(var f = 0; f < c._src.length; f++){
                            var _, g;
                            if (c._format && c._format[f]) _ = c._format[f];
                            else {
                                if (g = c._src[f], typeof g != "string") {
                                    c._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
                                    continue;
                                }
                                _ = /^data:audio\/([^;,]+);/i.exec(g), _ || (_ = /\.([^.]+)$/.exec(g.split("?", 1)[0])), _ && (_ = _[1].toLowerCase());
                            }
                            if (_ || console.warn('No file extension was found. Consider using the "format" property or specify an extension.'), _ && t.codecs(_)) {
                                u = c._src[f];
                                break;
                            }
                        }
                        if (!u) {
                            c._emit("loaderror", null, "No codec support for selected audio sources.");
                            return;
                        }
                        return c._src = u, c._state = "loading", window.location.protocol === "https:" && u.slice(0, 5) === "http:" && (c._html5 = !0, c._webAudio = !1), new s(c), c._webAudio && a(c), c;
                    },
                    play: function(c, u) {
                        var f = this, _ = null;
                        if (typeof c == "number") _ = c, c = null;
                        else {
                            if (typeof c == "string" && f._state === "loaded" && !f._sprite[c]) return null;
                            if (typeof c > "u" && (c = "__default", !f._playLock)) {
                                for(var g = 0, m = 0; m < f._sounds.length; m++)f._sounds[m]._paused && !f._sounds[m]._ended && (g++, _ = f._sounds[m]._id);
                                g === 1 ? c = null : _ = null;
                            }
                        }
                        var p = _ ? f._soundById(_) : f._inactiveSound();
                        if (!p) return null;
                        if (_ && !c && (c = p._sprite || "__default"), f._state !== "loaded") {
                            p._sprite = c, p._ended = !1;
                            var x = p._id;
                            return f._queue.push({
                                event: "play",
                                action: function() {
                                    f.play(x);
                                }
                            }), x;
                        }
                        if (_ && !p._paused) return u || f._loadQueue("play"), p._id;
                        f._webAudio && t._autoResume();
                        var v = Math.max(0, p._seek > 0 ? p._seek : f._sprite[c][0] / 1e3), y = Math.max(0, (f._sprite[c][0] + f._sprite[c][1]) / 1e3 - v), P = y * 1e3 / Math.abs(p._rate), w = f._sprite[c][0] / 1e3, R = (f._sprite[c][0] + f._sprite[c][1]) / 1e3;
                        p._sprite = c, p._ended = !1;
                        var B = function() {
                            p._paused = !1, p._seek = v, p._start = w, p._stop = R, p._loop = !!(p._loop || f._sprite[c][2]);
                        };
                        if (v >= R) {
                            f._ended(p);
                            return;
                        }
                        var T = p._node;
                        if (f._webAudio) {
                            var S = function() {
                                f._playLock = !1, B(), f._refreshBuffer(p);
                                var $ = p._muted || f._muted ? 0 : p._volume;
                                T.gain.setValueAtTime($, t.ctx.currentTime), p._playStart = t.ctx.currentTime, typeof T.bufferSource.start > "u" ? p._loop ? T.bufferSource.noteGrainOn(0, v, 86400) : T.bufferSource.noteGrainOn(0, v, y) : p._loop ? T.bufferSource.start(0, v, 86400) : T.bufferSource.start(0, v, y), P !== 1 / 0 && (f._endTimers[p._id] = setTimeout(f._ended.bind(f, p), P)), u || setTimeout(function() {
                                    f._emit("play", p._id), f._loadQueue();
                                }, 0);
                            };
                            t.state === "running" && t.ctx.state !== "interrupted" ? S() : (f._playLock = !0, f.once("resume", S), f._clearTimer(p._id));
                        } else {
                            var D = function() {
                                T.currentTime = v, T.muted = p._muted || f._muted || t._muted || T.muted, T.volume = p._volume * t.volume(), T.playbackRate = p._rate;
                                try {
                                    var $ = T.play();
                                    if ($ && typeof Promise < "u" && ($ instanceof Promise || typeof $.then == "function") ? (f._playLock = !0, B(), $.then(function() {
                                        f._playLock = !1, T._unlocked = !0, u ? f._loadQueue() : f._emit("play", p._id);
                                    }).catch(function() {
                                        f._playLock = !1, f._emit("playerror", p._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."), p._ended = !0, p._paused = !0;
                                    })) : u || (f._playLock = !1, B(), f._emit("play", p._id)), T.playbackRate = p._rate, T.paused) {
                                        f._emit("playerror", p._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                                        return;
                                    }
                                    c !== "__default" || p._loop ? f._endTimers[p._id] = setTimeout(f._ended.bind(f, p), P) : (f._endTimers[p._id] = function() {
                                        f._ended(p), T.removeEventListener("ended", f._endTimers[p._id], !1);
                                    }, T.addEventListener("ended", f._endTimers[p._id], !1));
                                } catch (ne) {
                                    f._emit("playerror", p._id, ne);
                                }
                            };
                            T.src === "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" && (T.src = f._src, T.load());
                            var q = window && window.ejecta || !T.readyState && t._navigator.isCocoonJS;
                            if (T.readyState >= 3 || q) D();
                            else {
                                f._playLock = !0, f._state = "loading";
                                var H = function() {
                                    f._state = "loaded", D(), T.removeEventListener(t._canPlayEvent, H, !1);
                                };
                                T.addEventListener(t._canPlayEvent, H, !1), f._clearTimer(p._id);
                            }
                        }
                        return p._id;
                    },
                    pause: function(c) {
                        var u = this;
                        if (u._state !== "loaded" || u._playLock) return u._queue.push({
                            event: "pause",
                            action: function() {
                                u.pause(c);
                            }
                        }), u;
                        for(var f = u._getSoundIds(c), _ = 0; _ < f.length; _++){
                            u._clearTimer(f[_]);
                            var g = u._soundById(f[_]);
                            if (g && !g._paused && (g._seek = u.seek(f[_]), g._rateSeek = 0, g._paused = !0, u._stopFade(f[_]), g._node)) if (u._webAudio) {
                                if (!g._node.bufferSource) continue;
                                typeof g._node.bufferSource.stop > "u" ? g._node.bufferSource.noteOff(0) : g._node.bufferSource.stop(0), u._cleanBuffer(g._node);
                            } else (!isNaN(g._node.duration) || g._node.duration === 1 / 0) && g._node.pause();
                            arguments[1] || u._emit("pause", g ? g._id : null);
                        }
                        return u;
                    },
                    stop: function(c, u) {
                        var f = this;
                        if (f._state !== "loaded" || f._playLock) return f._queue.push({
                            event: "stop",
                            action: function() {
                                f.stop(c);
                            }
                        }), f;
                        for(var _ = f._getSoundIds(c), g = 0; g < _.length; g++){
                            f._clearTimer(_[g]);
                            var m = f._soundById(_[g]);
                            m && (m._seek = m._start || 0, m._rateSeek = 0, m._paused = !0, m._ended = !0, f._stopFade(_[g]), m._node && (f._webAudio ? m._node.bufferSource && (typeof m._node.bufferSource.stop > "u" ? m._node.bufferSource.noteOff(0) : m._node.bufferSource.stop(0), f._cleanBuffer(m._node)) : (!isNaN(m._node.duration) || m._node.duration === 1 / 0) && (m._node.currentTime = m._start || 0, m._node.pause(), m._node.duration === 1 / 0 && f._clearSound(m._node))), u || f._emit("stop", m._id));
                        }
                        return f;
                    },
                    mute: function(c, u) {
                        var f = this;
                        if (f._state !== "loaded" || f._playLock) return f._queue.push({
                            event: "mute",
                            action: function() {
                                f.mute(c, u);
                            }
                        }), f;
                        if (typeof u > "u") if (typeof c == "boolean") f._muted = c;
                        else return f._muted;
                        for(var _ = f._getSoundIds(u), g = 0; g < _.length; g++){
                            var m = f._soundById(_[g]);
                            m && (m._muted = c, m._interval && f._stopFade(m._id), f._webAudio && m._node ? m._node.gain.setValueAtTime(c ? 0 : m._volume, t.ctx.currentTime) : m._node && (m._node.muted = t._muted ? !0 : c), f._emit("mute", m._id));
                        }
                        return f;
                    },
                    volume: function() {
                        var c = this, u = arguments, f, _;
                        if (u.length === 0) return c._volume;
                        if (u.length === 1 || u.length === 2 && typeof u[1] > "u") {
                            var g = c._getSoundIds(), m = g.indexOf(u[0]);
                            m >= 0 ? _ = parseInt(u[0], 10) : f = parseFloat(u[0]);
                        } else u.length >= 2 && (f = parseFloat(u[0]), _ = parseInt(u[1], 10));
                        var p;
                        if (typeof f < "u" && f >= 0 && f <= 1) {
                            if (c._state !== "loaded" || c._playLock) return c._queue.push({
                                event: "volume",
                                action: function() {
                                    c.volume.apply(c, u);
                                }
                            }), c;
                            typeof _ > "u" && (c._volume = f), _ = c._getSoundIds(_);
                            for(var x = 0; x < _.length; x++)p = c._soundById(_[x]), p && (p._volume = f, u[2] || c._stopFade(_[x]), c._webAudio && p._node && !p._muted ? p._node.gain.setValueAtTime(f, t.ctx.currentTime) : p._node && !p._muted && (p._node.volume = f * t.volume()), c._emit("volume", p._id));
                        } else return p = _ ? c._soundById(_) : c._sounds[0], p ? p._volume : 0;
                        return c;
                    },
                    fade: function(c, u, f, _) {
                        var g = this;
                        if (g._state !== "loaded" || g._playLock) return g._queue.push({
                            event: "fade",
                            action: function() {
                                g.fade(c, u, f, _);
                            }
                        }), g;
                        c = Math.min(Math.max(0, parseFloat(c)), 1), u = Math.min(Math.max(0, parseFloat(u)), 1), f = parseFloat(f), g.volume(c, _);
                        for(var m = g._getSoundIds(_), p = 0; p < m.length; p++){
                            var x = g._soundById(m[p]);
                            if (x) {
                                if (_ || g._stopFade(m[p]), g._webAudio && !x._muted) {
                                    var v = t.ctx.currentTime, y = v + f / 1e3;
                                    x._volume = c, x._node.gain.setValueAtTime(c, v), x._node.gain.linearRampToValueAtTime(u, y);
                                }
                                g._startFadeInterval(x, c, u, f, m[p], typeof _ > "u");
                            }
                        }
                        return g;
                    },
                    _startFadeInterval: function(c, u, f, _, g, m) {
                        var p = this, x = u, v = f - u, y = Math.abs(v / .01), P = Math.max(4, y > 0 ? _ / y : _), w = Date.now();
                        c._fadeTo = f, c._interval = setInterval(function() {
                            var R = (Date.now() - w) / _;
                            w = Date.now(), x += v * R, x = Math.round(x * 100) / 100, v < 0 ? x = Math.max(f, x) : x = Math.min(f, x), p._webAudio ? c._volume = x : p.volume(x, c._id, !0), m && (p._volume = x), (f < u && x <= f || f > u && x >= f) && (clearInterval(c._interval), c._interval = null, c._fadeTo = null, p.volume(f, c._id), p._emit("fade", c._id));
                        }, P);
                    },
                    _stopFade: function(c) {
                        var u = this, f = u._soundById(c);
                        return f && f._interval && (u._webAudio && f._node.gain.cancelScheduledValues(t.ctx.currentTime), clearInterval(f._interval), f._interval = null, u.volume(f._fadeTo, c), f._fadeTo = null, u._emit("fade", c)), u;
                    },
                    loop: function() {
                        var c = this, u = arguments, f, _, g;
                        if (u.length === 0) return c._loop;
                        if (u.length === 1) if (typeof u[0] == "boolean") f = u[0], c._loop = f;
                        else return g = c._soundById(parseInt(u[0], 10)), g ? g._loop : !1;
                        else u.length === 2 && (f = u[0], _ = parseInt(u[1], 10));
                        for(var m = c._getSoundIds(_), p = 0; p < m.length; p++)g = c._soundById(m[p]), g && (g._loop = f, c._webAudio && g._node && g._node.bufferSource && (g._node.bufferSource.loop = f, f && (g._node.bufferSource.loopStart = g._start || 0, g._node.bufferSource.loopEnd = g._stop, c.playing(m[p]) && (c.pause(m[p], !0), c.play(m[p], !0)))));
                        return c;
                    },
                    rate: function() {
                        var c = this, u = arguments, f, _;
                        if (u.length === 0) _ = c._sounds[0]._id;
                        else if (u.length === 1) {
                            var g = c._getSoundIds(), m = g.indexOf(u[0]);
                            m >= 0 ? _ = parseInt(u[0], 10) : f = parseFloat(u[0]);
                        } else u.length === 2 && (f = parseFloat(u[0]), _ = parseInt(u[1], 10));
                        var p;
                        if (typeof f == "number") {
                            if (c._state !== "loaded" || c._playLock) return c._queue.push({
                                event: "rate",
                                action: function() {
                                    c.rate.apply(c, u);
                                }
                            }), c;
                            typeof _ > "u" && (c._rate = f), _ = c._getSoundIds(_);
                            for(var x = 0; x < _.length; x++)if (p = c._soundById(_[x]), p) {
                                c.playing(_[x]) && (p._rateSeek = c.seek(_[x]), p._playStart = c._webAudio ? t.ctx.currentTime : p._playStart), p._rate = f, c._webAudio && p._node && p._node.bufferSource ? p._node.bufferSource.playbackRate.setValueAtTime(f, t.ctx.currentTime) : p._node && (p._node.playbackRate = f);
                                var v = c.seek(_[x]), y = (c._sprite[p._sprite][0] + c._sprite[p._sprite][1]) / 1e3 - v, P = y * 1e3 / Math.abs(p._rate);
                                (c._endTimers[_[x]] || !p._paused) && (c._clearTimer(_[x]), c._endTimers[_[x]] = setTimeout(c._ended.bind(c, p), P)), c._emit("rate", p._id);
                            }
                        } else return p = c._soundById(_), p ? p._rate : c._rate;
                        return c;
                    },
                    seek: function() {
                        var c = this, u = arguments, f, _;
                        if (u.length === 0) c._sounds.length && (_ = c._sounds[0]._id);
                        else if (u.length === 1) {
                            var g = c._getSoundIds(), m = g.indexOf(u[0]);
                            m >= 0 ? _ = parseInt(u[0], 10) : c._sounds.length && (_ = c._sounds[0]._id, f = parseFloat(u[0]));
                        } else u.length === 2 && (f = parseFloat(u[0]), _ = parseInt(u[1], 10));
                        if (typeof _ > "u") return 0;
                        if (typeof f == "number" && (c._state !== "loaded" || c._playLock)) return c._queue.push({
                            event: "seek",
                            action: function() {
                                c.seek.apply(c, u);
                            }
                        }), c;
                        var p = c._soundById(_);
                        if (p) if (typeof f == "number" && f >= 0) {
                            var x = c.playing(_);
                            x && c.pause(_, !0), p._seek = f, p._ended = !1, c._clearTimer(_), !c._webAudio && p._node && !isNaN(p._node.duration) && (p._node.currentTime = f);
                            var v = function() {
                                x && c.play(_, !0), c._emit("seek", _);
                            };
                            if (x && !c._webAudio) {
                                var y = function() {
                                    c._playLock ? setTimeout(y, 0) : v();
                                };
                                setTimeout(y, 0);
                            } else v();
                        } else if (c._webAudio) {
                            var P = c.playing(_) ? t.ctx.currentTime - p._playStart : 0, w = p._rateSeek ? p._rateSeek - p._seek : 0;
                            return p._seek + (w + P * Math.abs(p._rate));
                        } else return p._node.currentTime;
                        return c;
                    },
                    playing: function(c) {
                        var u = this;
                        if (typeof c == "number") {
                            var f = u._soundById(c);
                            return f ? !f._paused : !1;
                        }
                        for(var _ = 0; _ < u._sounds.length; _++)if (!u._sounds[_]._paused) return !0;
                        return !1;
                    },
                    duration: function(c) {
                        var u = this, f = u._duration, _ = u._soundById(c);
                        return _ && (f = u._sprite[_._sprite][1] / 1e3), f;
                    },
                    state: function() {
                        return this._state;
                    },
                    unload: function() {
                        for(var c = this, u = c._sounds, f = 0; f < u.length; f++)u[f]._paused || c.stop(u[f]._id), c._webAudio || (c._clearSound(u[f]._node), u[f]._node.removeEventListener("error", u[f]._errorFn, !1), u[f]._node.removeEventListener(t._canPlayEvent, u[f]._loadFn, !1), u[f]._node.removeEventListener("ended", u[f]._endFn, !1), t._releaseHtml5Audio(u[f]._node)), delete u[f]._node, c._clearTimer(u[f]._id);
                        var _ = t._howls.indexOf(c);
                        _ >= 0 && t._howls.splice(_, 1);
                        var g = !0;
                        for(f = 0; f < t._howls.length; f++)if (t._howls[f]._src === c._src || c._src.indexOf(t._howls[f]._src) >= 0) {
                            g = !1;
                            break;
                        }
                        return r && g && delete r[c._src], t.noAudio = !1, c._state = "unloaded", c._sounds = [], c = null, null;
                    },
                    on: function(c, u, f, _) {
                        var g = this, m = g["_on" + c];
                        return typeof u == "function" && m.push(_ ? {
                            id: f,
                            fn: u,
                            once: _
                        } : {
                            id: f,
                            fn: u
                        }), g;
                    },
                    off: function(c, u, f) {
                        var _ = this, g = _["_on" + c], m = 0;
                        if (typeof u == "number" && (f = u, u = null), u || f) for(m = 0; m < g.length; m++){
                            var p = f === g[m].id;
                            if (u === g[m].fn && p || !u && p) {
                                g.splice(m, 1);
                                break;
                            }
                        }
                        else if (c) _["_on" + c] = [];
                        else {
                            var x = Object.keys(_);
                            for(m = 0; m < x.length; m++)x[m].indexOf("_on") === 0 && Array.isArray(_[x[m]]) && (_[x[m]] = []);
                        }
                        return _;
                    },
                    once: function(c, u, f) {
                        var _ = this;
                        return _.on(c, u, f, 1), _;
                    },
                    _emit: function(c, u, f) {
                        for(var _ = this, g = _["_on" + c], m = g.length - 1; m >= 0; m--)(!g[m].id || g[m].id === u || c === "load") && (setTimeout(function(p) {
                            p.call(this, u, f);
                        }.bind(_, g[m].fn), 0), g[m].once && _.off(c, g[m].fn, g[m].id));
                        return _._loadQueue(c), _;
                    },
                    _loadQueue: function(c) {
                        var u = this;
                        if (u._queue.length > 0) {
                            var f = u._queue[0];
                            f.event === c && (u._queue.shift(), u._loadQueue()), c || f.action();
                        }
                        return u;
                    },
                    _ended: function(c) {
                        var u = this, f = c._sprite;
                        if (!u._webAudio && c._node && !c._node.paused && !c._node.ended && c._node.currentTime < c._stop) return setTimeout(u._ended.bind(u, c), 100), u;
                        var _ = !!(c._loop || u._sprite[f][2]);
                        if (u._emit("end", c._id), !u._webAudio && _ && u.stop(c._id, !0).play(c._id), u._webAudio && _) {
                            u._emit("play", c._id), c._seek = c._start || 0, c._rateSeek = 0, c._playStart = t.ctx.currentTime;
                            var g = (c._stop - c._start) * 1e3 / Math.abs(c._rate);
                            u._endTimers[c._id] = setTimeout(u._ended.bind(u, c), g);
                        }
                        return u._webAudio && !_ && (c._paused = !0, c._ended = !0, c._seek = c._start || 0, c._rateSeek = 0, u._clearTimer(c._id), u._cleanBuffer(c._node), t._autoSuspend()), !u._webAudio && !_ && u.stop(c._id, !0), u;
                    },
                    _clearTimer: function(c) {
                        var u = this;
                        if (u._endTimers[c]) {
                            if (typeof u._endTimers[c] != "function") clearTimeout(u._endTimers[c]);
                            else {
                                var f = u._soundById(c);
                                f && f._node && f._node.removeEventListener("ended", u._endTimers[c], !1);
                            }
                            delete u._endTimers[c];
                        }
                        return u;
                    },
                    _soundById: function(c) {
                        for(var u = this, f = 0; f < u._sounds.length; f++)if (c === u._sounds[f]._id) return u._sounds[f];
                        return null;
                    },
                    _inactiveSound: function() {
                        var c = this;
                        c._drain();
                        for(var u = 0; u < c._sounds.length; u++)if (c._sounds[u]._ended) return c._sounds[u].reset();
                        return new s(c);
                    },
                    _drain: function() {
                        var c = this, u = c._pool, f = 0, _ = 0;
                        if (!(c._sounds.length < u)) {
                            for(_ = 0; _ < c._sounds.length; _++)c._sounds[_]._ended && f++;
                            for(_ = c._sounds.length - 1; _ >= 0; _--){
                                if (f <= u) return;
                                c._sounds[_]._ended && (c._webAudio && c._sounds[_]._node && c._sounds[_]._node.disconnect(0), c._sounds.splice(_, 1), f--);
                            }
                        }
                    },
                    _getSoundIds: function(c) {
                        var u = this;
                        if (typeof c > "u") {
                            for(var f = [], _ = 0; _ < u._sounds.length; _++)f.push(u._sounds[_]._id);
                            return f;
                        } else return [
                            c
                        ];
                    },
                    _refreshBuffer: function(c) {
                        var u = this;
                        return c._node.bufferSource = t.ctx.createBufferSource(), c._node.bufferSource.buffer = r[u._src], c._panner ? c._node.bufferSource.connect(c._panner) : c._node.bufferSource.connect(c._node), c._node.bufferSource.loop = c._loop, c._loop && (c._node.bufferSource.loopStart = c._start || 0, c._node.bufferSource.loopEnd = c._stop || 0), c._node.bufferSource.playbackRate.setValueAtTime(c._rate, t.ctx.currentTime), u;
                    },
                    _cleanBuffer: function(c) {
                        var u = this, f = t._navigator && t._navigator.vendor.indexOf("Apple") >= 0;
                        if (!c.bufferSource) return u;
                        if (t._scratchBuffer && c.bufferSource && (c.bufferSource.onended = null, c.bufferSource.disconnect(0), f)) try {
                            c.bufferSource.buffer = t._scratchBuffer;
                        } catch  {}
                        return c.bufferSource = null, u;
                    },
                    _clearSound: function(c) {
                        var u = /MSIE |Trident\//.test(t._navigator && t._navigator.userAgent);
                        u || (c.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA");
                    }
                };
                var s = function(c) {
                    this._parent = c, this.init();
                };
                s.prototype = {
                    init: function() {
                        var c = this, u = c._parent;
                        return c._muted = u._muted, c._loop = u._loop, c._volume = u._volume, c._rate = u._rate, c._seek = 0, c._paused = !0, c._ended = !0, c._sprite = "__default", c._id = ++t._counter, u._sounds.push(c), c.create(), c;
                    },
                    create: function() {
                        var c = this, u = c._parent, f = t._muted || c._muted || c._parent._muted ? 0 : c._volume;
                        return u._webAudio ? (c._node = typeof t.ctx.createGain > "u" ? t.ctx.createGainNode() : t.ctx.createGain(), c._node.gain.setValueAtTime(f, t.ctx.currentTime), c._node.paused = !0, c._node.connect(t.masterGain)) : t.noAudio || (c._node = t._obtainHtml5Audio(), c._errorFn = c._errorListener.bind(c), c._node.addEventListener("error", c._errorFn, !1), c._loadFn = c._loadListener.bind(c), c._node.addEventListener(t._canPlayEvent, c._loadFn, !1), c._endFn = c._endListener.bind(c), c._node.addEventListener("ended", c._endFn, !1), c._node.src = u._src, c._node.preload = u._preload === !0 ? "auto" : u._preload, c._node.volume = f * t.volume(), c._node.load()), c;
                    },
                    reset: function() {
                        var c = this, u = c._parent;
                        return c._muted = u._muted, c._loop = u._loop, c._volume = u._volume, c._rate = u._rate, c._seek = 0, c._rateSeek = 0, c._paused = !0, c._ended = !0, c._sprite = "__default", c._id = ++t._counter, c;
                    },
                    _errorListener: function() {
                        var c = this;
                        c._parent._emit("loaderror", c._id, c._node.error ? c._node.error.code : 0), c._node.removeEventListener("error", c._errorFn, !1);
                    },
                    _loadListener: function() {
                        var c = this, u = c._parent;
                        u._duration = Math.ceil(c._node.duration * 10) / 10, Object.keys(u._sprite).length === 0 && (u._sprite = {
                            __default: [
                                0,
                                u._duration * 1e3
                            ]
                        }), u._state !== "loaded" && (u._state = "loaded", u._emit("load"), u._loadQueue()), c._node.removeEventListener(t._canPlayEvent, c._loadFn, !1);
                    },
                    _endListener: function() {
                        var c = this, u = c._parent;
                        u._duration === 1 / 0 && (u._duration = Math.ceil(c._node.duration * 10) / 10, u._sprite.__default[1] === 1 / 0 && (u._sprite.__default[1] = u._duration * 1e3), u._ended(c)), c._node.removeEventListener("ended", c._endFn, !1);
                    }
                };
                var r = {}, a = function(c) {
                    var u = c._src;
                    if (r[u]) {
                        c._duration = r[u].duration, h(c);
                        return;
                    }
                    if (/^data:[^;]+;base64,/.test(u)) {
                        for(var f = atob(u.split(",")[1]), _ = new Uint8Array(f.length), g = 0; g < f.length; ++g)_[g] = f.charCodeAt(g);
                        l(_.buffer, c);
                    } else {
                        var m = new XMLHttpRequest;
                        m.open(c._xhr.method, u, !0), m.withCredentials = c._xhr.withCredentials, m.responseType = "arraybuffer", c._xhr.headers && Object.keys(c._xhr.headers).forEach(function(p) {
                            m.setRequestHeader(p, c._xhr.headers[p]);
                        }), m.onload = function() {
                            var p = (m.status + "")[0];
                            if (p !== "0" && p !== "2" && p !== "3") {
                                c._emit("loaderror", null, "Failed loading audio file with status: " + m.status + ".");
                                return;
                            }
                            l(m.response, c);
                        }, m.onerror = function() {
                            c._webAudio && (c._html5 = !0, c._webAudio = !1, c._sounds = [], delete r[u], c.load());
                        }, o(m);
                    }
                }, o = function(c) {
                    try {
                        c.send();
                    } catch  {
                        c.onerror();
                    }
                }, l = function(c, u) {
                    var f = function() {
                        u._emit("loaderror", null, "Decoding audio data failed.");
                    }, _ = function(g) {
                        g && u._sounds.length > 0 ? (r[u._src] = g, h(u, g)) : f();
                    };
                    typeof Promise < "u" && t.ctx.decodeAudioData.length === 1 ? t.ctx.decodeAudioData(c).then(_).catch(f) : t.ctx.decodeAudioData(c, _, f);
                }, h = function(c, u) {
                    u && !c._duration && (c._duration = u.duration), Object.keys(c._sprite).length === 0 && (c._sprite = {
                        __default: [
                            0,
                            c._duration * 1e3
                        ]
                    }), c._state !== "loaded" && (c._state = "loaded", c._emit("load"), c._loadQueue());
                }, d = function() {
                    if (t.usingWebAudio) {
                        try {
                            typeof AudioContext < "u" ? t.ctx = new AudioContext : typeof webkitAudioContext < "u" ? t.ctx = new webkitAudioContext : t.usingWebAudio = !1;
                        } catch  {
                            t.usingWebAudio = !1;
                        }
                        t.ctx || (t.usingWebAudio = !1);
                        var c = /iP(hone|od|ad)/.test(t._navigator && t._navigator.platform), u = t._navigator && t._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/), f = u ? parseInt(u[1], 10) : null;
                        if (c && f && f < 9) {
                            var _ = /safari/.test(t._navigator && t._navigator.userAgent.toLowerCase());
                            t._navigator && !_ && (t.usingWebAudio = !1);
                        }
                        t.usingWebAudio && (t.masterGain = typeof t.ctx.createGain > "u" ? t.ctx.createGainNode() : t.ctx.createGain(), t.masterGain.gain.setValueAtTime(t._muted ? 0 : t._volume, t.ctx.currentTime), t.masterGain.connect(t.ctx.destination)), t._setup();
                    }
                };
                i.Howler = t, i.Howl = n, typeof mr < "u" ? (mr.HowlerGlobal = e, mr.Howler = t, mr.Howl = n, mr.Sound = s) : typeof window < "u" && (window.HowlerGlobal = e, window.Howler = t, window.Howl = n, window.Sound = s);
            })();
            (function() {
                HowlerGlobal.prototype._pos = [
                    0,
                    0,
                    0
                ], HowlerGlobal.prototype._orientation = [
                    0,
                    0,
                    -1,
                    0,
                    1,
                    0
                ], HowlerGlobal.prototype.stereo = function(t) {
                    var n = this;
                    if (!n.ctx || !n.ctx.listener) return n;
                    for(var s = n._howls.length - 1; s >= 0; s--)n._howls[s].stereo(t);
                    return n;
                }, HowlerGlobal.prototype.pos = function(t, n, s) {
                    var r = this;
                    if (!r.ctx || !r.ctx.listener) return r;
                    if (n = typeof n != "number" ? r._pos[1] : n, s = typeof s != "number" ? r._pos[2] : s, typeof t == "number") r._pos = [
                        t,
                        n,
                        s
                    ], typeof r.ctx.listener.positionX < "u" ? (r.ctx.listener.positionX.setTargetAtTime(r._pos[0], Howler.ctx.currentTime, .1), r.ctx.listener.positionY.setTargetAtTime(r._pos[1], Howler.ctx.currentTime, .1), r.ctx.listener.positionZ.setTargetAtTime(r._pos[2], Howler.ctx.currentTime, .1)) : r.ctx.listener.setPosition(r._pos[0], r._pos[1], r._pos[2]);
                    else return r._pos;
                    return r;
                }, HowlerGlobal.prototype.orientation = function(t, n, s, r, a, o) {
                    var l = this;
                    if (!l.ctx || !l.ctx.listener) return l;
                    var h = l._orientation;
                    if (n = typeof n != "number" ? h[1] : n, s = typeof s != "number" ? h[2] : s, r = typeof r != "number" ? h[3] : r, a = typeof a != "number" ? h[4] : a, o = typeof o != "number" ? h[5] : o, typeof t == "number") l._orientation = [
                        t,
                        n,
                        s,
                        r,
                        a,
                        o
                    ], typeof l.ctx.listener.forwardX < "u" ? (l.ctx.listener.forwardX.setTargetAtTime(t, Howler.ctx.currentTime, .1), l.ctx.listener.forwardY.setTargetAtTime(n, Howler.ctx.currentTime, .1), l.ctx.listener.forwardZ.setTargetAtTime(s, Howler.ctx.currentTime, .1), l.ctx.listener.upX.setTargetAtTime(r, Howler.ctx.currentTime, .1), l.ctx.listener.upY.setTargetAtTime(a, Howler.ctx.currentTime, .1), l.ctx.listener.upZ.setTargetAtTime(o, Howler.ctx.currentTime, .1)) : l.ctx.listener.setOrientation(t, n, s, r, a, o);
                    else return h;
                    return l;
                }, Howl.prototype.init = function(t) {
                    return function(n) {
                        var s = this;
                        return s._orientation = n.orientation || [
                            1,
                            0,
                            0
                        ], s._stereo = n.stereo || null, s._pos = n.pos || null, s._pannerAttr = {
                            coneInnerAngle: typeof n.coneInnerAngle < "u" ? n.coneInnerAngle : 360,
                            coneOuterAngle: typeof n.coneOuterAngle < "u" ? n.coneOuterAngle : 360,
                            coneOuterGain: typeof n.coneOuterGain < "u" ? n.coneOuterGain : 0,
                            distanceModel: typeof n.distanceModel < "u" ? n.distanceModel : "inverse",
                            maxDistance: typeof n.maxDistance < "u" ? n.maxDistance : 1e4,
                            panningModel: typeof n.panningModel < "u" ? n.panningModel : "HRTF",
                            refDistance: typeof n.refDistance < "u" ? n.refDistance : 1,
                            rolloffFactor: typeof n.rolloffFactor < "u" ? n.rolloffFactor : 1
                        }, s._onstereo = n.onstereo ? [
                            {
                                fn: n.onstereo
                            }
                        ] : [], s._onpos = n.onpos ? [
                            {
                                fn: n.onpos
                            }
                        ] : [], s._onorientation = n.onorientation ? [
                            {
                                fn: n.onorientation
                            }
                        ] : [], t.call(this, n);
                    };
                }(Howl.prototype.init), Howl.prototype.stereo = function(t, n) {
                    var s = this;
                    if (!s._webAudio) return s;
                    if (s._state !== "loaded") return s._queue.push({
                        event: "stereo",
                        action: function() {
                            s.stereo(t, n);
                        }
                    }), s;
                    var r = typeof Howler.ctx.createStereoPanner > "u" ? "spatial" : "stereo";
                    if (typeof n > "u") if (typeof t == "number") s._stereo = t, s._pos = [
                        t,
                        0,
                        0
                    ];
                    else return s._stereo;
                    for(var a = s._getSoundIds(n), o = 0; o < a.length; o++){
                        var l = s._soundById(a[o]);
                        if (l) if (typeof t == "number") l._stereo = t, l._pos = [
                            t,
                            0,
                            0
                        ], l._node && (l._pannerAttr.panningModel = "equalpower", (!l._panner || !l._panner.pan) && e(l, r), r === "spatial" ? typeof l._panner.positionX < "u" ? (l._panner.positionX.setValueAtTime(t, Howler.ctx.currentTime), l._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime), l._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime)) : l._panner.setPosition(t, 0, 0) : l._panner.pan.setValueAtTime(t, Howler.ctx.currentTime)), s._emit("stereo", l._id);
                        else return l._stereo;
                    }
                    return s;
                }, Howl.prototype.pos = function(t, n, s, r) {
                    var a = this;
                    if (!a._webAudio) return a;
                    if (a._state !== "loaded") return a._queue.push({
                        event: "pos",
                        action: function() {
                            a.pos(t, n, s, r);
                        }
                    }), a;
                    if (n = typeof n != "number" ? 0 : n, s = typeof s != "number" ? -.5 : s, typeof r > "u") if (typeof t == "number") a._pos = [
                        t,
                        n,
                        s
                    ];
                    else return a._pos;
                    for(var o = a._getSoundIds(r), l = 0; l < o.length; l++){
                        var h = a._soundById(o[l]);
                        if (h) if (typeof t == "number") h._pos = [
                            t,
                            n,
                            s
                        ], h._node && ((!h._panner || h._panner.pan) && e(h, "spatial"), typeof h._panner.positionX < "u" ? (h._panner.positionX.setValueAtTime(t, Howler.ctx.currentTime), h._panner.positionY.setValueAtTime(n, Howler.ctx.currentTime), h._panner.positionZ.setValueAtTime(s, Howler.ctx.currentTime)) : h._panner.setPosition(t, n, s)), a._emit("pos", h._id);
                        else return h._pos;
                    }
                    return a;
                }, Howl.prototype.orientation = function(t, n, s, r) {
                    var a = this;
                    if (!a._webAudio) return a;
                    if (a._state !== "loaded") return a._queue.push({
                        event: "orientation",
                        action: function() {
                            a.orientation(t, n, s, r);
                        }
                    }), a;
                    if (n = typeof n != "number" ? a._orientation[1] : n, s = typeof s != "number" ? a._orientation[2] : s, typeof r > "u") if (typeof t == "number") a._orientation = [
                        t,
                        n,
                        s
                    ];
                    else return a._orientation;
                    for(var o = a._getSoundIds(r), l = 0; l < o.length; l++){
                        var h = a._soundById(o[l]);
                        if (h) if (typeof t == "number") h._orientation = [
                            t,
                            n,
                            s
                        ], h._node && (h._panner || (h._pos || (h._pos = a._pos || [
                            0,
                            0,
                            -.5
                        ]), e(h, "spatial")), typeof h._panner.orientationX < "u" ? (h._panner.orientationX.setValueAtTime(t, Howler.ctx.currentTime), h._panner.orientationY.setValueAtTime(n, Howler.ctx.currentTime), h._panner.orientationZ.setValueAtTime(s, Howler.ctx.currentTime)) : h._panner.setOrientation(t, n, s)), a._emit("orientation", h._id);
                        else return h._orientation;
                    }
                    return a;
                }, Howl.prototype.pannerAttr = function() {
                    var t = this, n = arguments, s, r, a;
                    if (!t._webAudio) return t;
                    if (n.length === 0) return t._pannerAttr;
                    if (n.length === 1) if (typeof n[0] == "object") s = n[0], typeof r > "u" && (s.pannerAttr || (s.pannerAttr = {
                        coneInnerAngle: s.coneInnerAngle,
                        coneOuterAngle: s.coneOuterAngle,
                        coneOuterGain: s.coneOuterGain,
                        distanceModel: s.distanceModel,
                        maxDistance: s.maxDistance,
                        refDistance: s.refDistance,
                        rolloffFactor: s.rolloffFactor,
                        panningModel: s.panningModel
                    }), t._pannerAttr = {
                        coneInnerAngle: typeof s.pannerAttr.coneInnerAngle < "u" ? s.pannerAttr.coneInnerAngle : t._coneInnerAngle,
                        coneOuterAngle: typeof s.pannerAttr.coneOuterAngle < "u" ? s.pannerAttr.coneOuterAngle : t._coneOuterAngle,
                        coneOuterGain: typeof s.pannerAttr.coneOuterGain < "u" ? s.pannerAttr.coneOuterGain : t._coneOuterGain,
                        distanceModel: typeof s.pannerAttr.distanceModel < "u" ? s.pannerAttr.distanceModel : t._distanceModel,
                        maxDistance: typeof s.pannerAttr.maxDistance < "u" ? s.pannerAttr.maxDistance : t._maxDistance,
                        refDistance: typeof s.pannerAttr.refDistance < "u" ? s.pannerAttr.refDistance : t._refDistance,
                        rolloffFactor: typeof s.pannerAttr.rolloffFactor < "u" ? s.pannerAttr.rolloffFactor : t._rolloffFactor,
                        panningModel: typeof s.pannerAttr.panningModel < "u" ? s.pannerAttr.panningModel : t._panningModel
                    });
                    else return a = t._soundById(parseInt(n[0], 10)), a ? a._pannerAttr : t._pannerAttr;
                    else n.length === 2 && (s = n[0], r = parseInt(n[1], 10));
                    for(var o = t._getSoundIds(r), l = 0; l < o.length; l++)if (a = t._soundById(o[l]), a) {
                        var h = a._pannerAttr;
                        h = {
                            coneInnerAngle: typeof s.coneInnerAngle < "u" ? s.coneInnerAngle : h.coneInnerAngle,
                            coneOuterAngle: typeof s.coneOuterAngle < "u" ? s.coneOuterAngle : h.coneOuterAngle,
                            coneOuterGain: typeof s.coneOuterGain < "u" ? s.coneOuterGain : h.coneOuterGain,
                            distanceModel: typeof s.distanceModel < "u" ? s.distanceModel : h.distanceModel,
                            maxDistance: typeof s.maxDistance < "u" ? s.maxDistance : h.maxDistance,
                            refDistance: typeof s.refDistance < "u" ? s.refDistance : h.refDistance,
                            rolloffFactor: typeof s.rolloffFactor < "u" ? s.rolloffFactor : h.rolloffFactor,
                            panningModel: typeof s.panningModel < "u" ? s.panningModel : h.panningModel
                        };
                        var d = a._panner;
                        d || (a._pos || (a._pos = t._pos || [
                            0,
                            0,
                            -.5
                        ]), e(a, "spatial"), d = a._panner), d.coneInnerAngle = h.coneInnerAngle, d.coneOuterAngle = h.coneOuterAngle, d.coneOuterGain = h.coneOuterGain, d.distanceModel = h.distanceModel, d.maxDistance = h.maxDistance, d.refDistance = h.refDistance, d.rolloffFactor = h.rolloffFactor, d.panningModel = h.panningModel;
                    }
                    return t;
                }, Sound.prototype.init = function(t) {
                    return function() {
                        var n = this, s = n._parent;
                        n._orientation = s._orientation, n._stereo = s._stereo, n._pos = s._pos, n._pannerAttr = s._pannerAttr, t.call(this), n._stereo ? s.stereo(n._stereo) : n._pos && s.pos(n._pos[0], n._pos[1], n._pos[2], n._id);
                    };
                }(Sound.prototype.init), Sound.prototype.reset = function(t) {
                    return function() {
                        var n = this, s = n._parent;
                        return n._orientation = s._orientation, n._stereo = s._stereo, n._pos = s._pos, n._pannerAttr = s._pannerAttr, n._stereo ? s.stereo(n._stereo) : n._pos ? s.pos(n._pos[0], n._pos[1], n._pos[2], n._id) : n._panner && (n._panner.disconnect(0), n._panner = void 0, s._refreshBuffer(n)), t.call(this);
                    };
                }(Sound.prototype.reset);
                var e = function(t, n) {
                    n = n || "spatial", n === "spatial" ? (t._panner = Howler.ctx.createPanner(), t._panner.coneInnerAngle = t._pannerAttr.coneInnerAngle, t._panner.coneOuterAngle = t._pannerAttr.coneOuterAngle, t._panner.coneOuterGain = t._pannerAttr.coneOuterGain, t._panner.distanceModel = t._pannerAttr.distanceModel, t._panner.maxDistance = t._pannerAttr.maxDistance, t._panner.refDistance = t._pannerAttr.refDistance, t._panner.rolloffFactor = t._pannerAttr.rolloffFactor, t._panner.panningModel = t._pannerAttr.panningModel, typeof t._panner.positionX < "u" ? (t._panner.positionX.setValueAtTime(t._pos[0], Howler.ctx.currentTime), t._panner.positionY.setValueAtTime(t._pos[1], Howler.ctx.currentTime), t._panner.positionZ.setValueAtTime(t._pos[2], Howler.ctx.currentTime)) : t._panner.setPosition(t._pos[0], t._pos[1], t._pos[2]), typeof t._panner.orientationX < "u" ? (t._panner.orientationX.setValueAtTime(t._orientation[0], Howler.ctx.currentTime), t._panner.orientationY.setValueAtTime(t._orientation[1], Howler.ctx.currentTime), t._panner.orientationZ.setValueAtTime(t._orientation[2], Howler.ctx.currentTime)) : t._panner.setOrientation(t._orientation[0], t._orientation[1], t._orientation[2])) : (t._panner = Howler.ctx.createStereoPanner(), t._panner.pan.setValueAtTime(t._stereo, Howler.ctx.currentTime)), t._panner.connect(t._node), t._paused || t._parent.pause(t._id, !0).play(t._id, !0);
                };
            })();
        }(el)), el;
    }
    var Ed = MT();
    const AT = "modulepreload", ET = function(i) {
        return "/" + i;
    }, wd = {}, Gp = function(e, t, n) {
        let s = Promise.resolve();
        if (t && t.length > 0) {
            let a = function(h) {
                return Promise.all(h.map((d)=>Promise.resolve(d).then((c)=>({
                            status: "fulfilled",
                            value: c
                        }), (c)=>({
                            status: "rejected",
                            reason: c
                        }))));
            };
            document.getElementsByTagName("link");
            const o = document.querySelector("meta[property=csp-nonce]"), l = o?.nonce || o?.getAttribute("nonce");
            s = a(t.map((h)=>{
                if (h = ET(h), h in wd) return;
                wd[h] = !0;
                const d = h.endsWith(".css"), c = d ? '[rel="stylesheet"]' : "";
                if (document.querySelector(`link[href="${h}"]${c}`)) return;
                const u = document.createElement("link");
                if (u.rel = d ? "stylesheet" : AT, d || (u.as = "script"), u.crossOrigin = "", u.href = h, l && u.setAttribute("nonce", l), document.head.appendChild(u), d) return new Promise((f, _)=>{
                    u.addEventListener("load", f), u.addEventListener("error", ()=>_(new Error(`Unable to preload CSS for ${h}`)));
                });
            }));
        }
        function r(a) {
            const o = new Event("vite:preloadError", {
                cancelable: !0
            });
            if (o.payload = a, window.dispatchEvent(o), !o.defaultPrevented) throw a;
        }
        return s.then((a)=>{
            for (const o of a || [])o.status === "rejected" && r(o.reason);
            return e().catch(r);
        });
    };
    J = ((i)=>(i.Application = "application", i.WebGLPipes = "webgl-pipes", i.WebGLPipesAdaptor = "webgl-pipes-adaptor", i.WebGLSystem = "webgl-system", i.WebGPUPipes = "webgpu-pipes", i.WebGPUPipesAdaptor = "webgpu-pipes-adaptor", i.WebGPUSystem = "webgpu-system", i.CanvasSystem = "canvas-system", i.CanvasPipesAdaptor = "canvas-pipes-adaptor", i.CanvasPipes = "canvas-pipes", i.Asset = "asset", i.LoadParser = "load-parser", i.ResolveParser = "resolve-parser", i.CacheParser = "cache-parser", i.DetectionParser = "detection-parser", i.MaskEffect = "mask-effect", i.BlendMode = "blend-mode", i.TextureSource = "texture-source", i.Environment = "environment", i.ShapeBuilder = "shape-builder", i.Batcher = "batcher", i))(J || {});
    let Pc, Ea, wT, RT;
    Pc = (i)=>{
        if (typeof i == "function" || typeof i == "object" && i.extension) {
            if (!i.extension) throw new Error("Extension class must have an extension object");
            i = {
                ...typeof i.extension != "object" ? {
                    type: i.extension
                } : i.extension,
                ref: i
            };
        }
        if (typeof i == "object") i = {
            ...i
        };
        else throw new Error("Invalid extension type");
        return typeof i.type == "string" && (i.type = [
            i.type
        ]), i;
    };
    Ea = (i, e)=>Pc(i).priority ?? e;
    At = {
        _addHandlers: {},
        _removeHandlers: {},
        _queue: {},
        remove (...i) {
            return i.map(Pc).forEach((e)=>{
                e.type.forEach((t)=>this._removeHandlers[t]?.(e));
            }), this;
        },
        add (...i) {
            return i.map(Pc).forEach((e)=>{
                e.type.forEach((t)=>{
                    const n = this._addHandlers, s = this._queue;
                    n[t] ? n[t]?.(e) : (s[t] = s[t] || [], s[t]?.push(e));
                });
            }), this;
        },
        handle (i, e, t) {
            const n = this._addHandlers, s = this._removeHandlers;
            if (n[i] || s[i]) throw new Error(`Extension type ${i} already has a handler`);
            n[i] = e, s[i] = t;
            const r = this._queue;
            return r[i] && (r[i]?.forEach((a)=>e(a)), delete r[i]), this;
        },
        handleByMap (i, e) {
            return this.handle(i, (t)=>{
                t.name && (e[t.name] = t.ref);
            }, (t)=>{
                t.name && delete e[t.name];
            });
        },
        handleByNamedList (i, e, t = -1) {
            return this.handle(i, (n)=>{
                e.findIndex((r)=>r.name === n.name) >= 0 || (e.push({
                    name: n.name,
                    value: n.ref
                }), e.sort((r, a)=>Ea(a.value, t) - Ea(r.value, t)));
            }, (n)=>{
                const s = e.findIndex((r)=>r.name === n.name);
                s !== -1 && e.splice(s, 1);
            });
        },
        handleByList (i, e, t = -1) {
            return this.handle(i, (n)=>{
                e.includes(n.ref) || (e.push(n.ref), e.sort((s, r)=>Ea(r, t) - Ea(s, t)));
            }, (n)=>{
                const s = e.indexOf(n.ref);
                s !== -1 && e.splice(s, 1);
            });
        },
        mixin (i, ...e) {
            for (const t of e)Object.defineProperties(i.prototype, Object.getOwnPropertyDescriptors(t));
        }
    };
    wT = {
        extension: {
            type: J.Environment,
            name: "browser",
            priority: -1
        },
        test: ()=>!0,
        load: async ()=>{
            await Gp(()=>import("./browserAll-FGtH13EM.js"), __vite__mapDeps([0,1]));
        }
    };
    RT = {
        extension: {
            type: J.Environment,
            name: "webworker",
            priority: 0
        },
        test: ()=>typeof self < "u" && self.WorkerGlobalScope !== void 0,
        load: async ()=>{
            await Gp(()=>import("./webworkerAll-BEf_tPj_.js"), []);
        }
    };
    class en {
        constructor(e, t, n){
            this._x = t || 0, this._y = n || 0, this._observer = e;
        }
        clone(e) {
            return new en(e ?? this._observer, this._x, this._y);
        }
        set(e = 0, t = e) {
            return (this._x !== e || this._y !== t) && (this._x = e, this._y = t, this._observer._onUpdate(this)), this;
        }
        copyFrom(e) {
            return (this._x !== e.x || this._y !== e.y) && (this._x = e.x, this._y = e.y, this._observer._onUpdate(this)), this;
        }
        copyTo(e) {
            return e.set(this._x, this._y), e;
        }
        equals(e) {
            return e.x === this._x && e.y === this._y;
        }
        toString() {
            return `[pixi.js/math:ObservablePoint x=0 y=0 scope=${this._observer}]`;
        }
        get x() {
            return this._x;
        }
        set x(e) {
            this._x !== e && (this._x = e, this._observer._onUpdate(this));
        }
        get y() {
            return this._y;
        }
        set y(e) {
            this._y !== e && (this._y = e, this._observer._onUpdate(this));
        }
    }
    var tl = {
        exports: {}
    }, Rd;
    function CT() {
        return Rd || (Rd = 1, function(i) {
            var e = Object.prototype.hasOwnProperty, t = "~";
            function n() {}
            Object.create && (n.prototype = Object.create(null), new n().__proto__ || (t = !1));
            function s(l, h, d) {
                this.fn = l, this.context = h, this.once = d || !1;
            }
            function r(l, h, d, c, u) {
                if (typeof d != "function") throw new TypeError("The listener must be a function");
                var f = new s(d, c || l, u), _ = t ? t + h : h;
                return l._events[_] ? l._events[_].fn ? l._events[_] = [
                    l._events[_],
                    f
                ] : l._events[_].push(f) : (l._events[_] = f, l._eventsCount++), l;
            }
            function a(l, h) {
                --l._eventsCount === 0 ? l._events = new n : delete l._events[h];
            }
            function o() {
                this._events = new n, this._eventsCount = 0;
            }
            o.prototype.eventNames = function() {
                var h = [], d, c;
                if (this._eventsCount === 0) return h;
                for(c in d = this._events)e.call(d, c) && h.push(t ? c.slice(1) : c);
                return Object.getOwnPropertySymbols ? h.concat(Object.getOwnPropertySymbols(d)) : h;
            }, o.prototype.listeners = function(h) {
                var d = t ? t + h : h, c = this._events[d];
                if (!c) return [];
                if (c.fn) return [
                    c.fn
                ];
                for(var u = 0, f = c.length, _ = new Array(f); u < f; u++)_[u] = c[u].fn;
                return _;
            }, o.prototype.listenerCount = function(h) {
                var d = t ? t + h : h, c = this._events[d];
                return c ? c.fn ? 1 : c.length : 0;
            }, o.prototype.emit = function(h, d, c, u, f, _) {
                var g = t ? t + h : h;
                if (!this._events[g]) return !1;
                var m = this._events[g], p = arguments.length, x, v;
                if (m.fn) {
                    switch(m.once && this.removeListener(h, m.fn, void 0, !0), p){
                        case 1:
                            return m.fn.call(m.context), !0;
                        case 2:
                            return m.fn.call(m.context, d), !0;
                        case 3:
                            return m.fn.call(m.context, d, c), !0;
                        case 4:
                            return m.fn.call(m.context, d, c, u), !0;
                        case 5:
                            return m.fn.call(m.context, d, c, u, f), !0;
                        case 6:
                            return m.fn.call(m.context, d, c, u, f, _), !0;
                    }
                    for(v = 1, x = new Array(p - 1); v < p; v++)x[v - 1] = arguments[v];
                    m.fn.apply(m.context, x);
                } else {
                    var y = m.length, P;
                    for(v = 0; v < y; v++)switch(m[v].once && this.removeListener(h, m[v].fn, void 0, !0), p){
                        case 1:
                            m[v].fn.call(m[v].context);
                            break;
                        case 2:
                            m[v].fn.call(m[v].context, d);
                            break;
                        case 3:
                            m[v].fn.call(m[v].context, d, c);
                            break;
                        case 4:
                            m[v].fn.call(m[v].context, d, c, u);
                            break;
                        default:
                            if (!x) for(P = 1, x = new Array(p - 1); P < p; P++)x[P - 1] = arguments[P];
                            m[v].fn.apply(m[v].context, x);
                    }
                }
                return !0;
            }, o.prototype.on = function(h, d, c) {
                return r(this, h, d, c, !1);
            }, o.prototype.once = function(h, d, c) {
                return r(this, h, d, c, !0);
            }, o.prototype.removeListener = function(h, d, c, u) {
                var f = t ? t + h : h;
                if (!this._events[f]) return this;
                if (!d) return a(this, f), this;
                var _ = this._events[f];
                if (_.fn) _.fn === d && (!u || _.once) && (!c || _.context === c) && a(this, f);
                else {
                    for(var g = 0, m = [], p = _.length; g < p; g++)(_[g].fn !== d || u && !_[g].once || c && _[g].context !== c) && m.push(_[g]);
                    m.length ? this._events[f] = m.length === 1 ? m[0] : m : a(this, f);
                }
                return this;
            }, o.prototype.removeAllListeners = function(h) {
                var d;
                return h ? (d = t ? t + h : h, this._events[d] && a(this, d)) : (this._events = new n, this._eventsCount = 0), this;
            }, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prefixed = t, o.EventEmitter = o, i.exports = o;
        }(tl)), tl.exports;
    }
    var PT = CT();
    let IT, DT, LT;
    yn = Ah(PT);
    IT = Math.PI * 2;
    DT = 180 / Math.PI;
    LT = Math.PI / 180;
    Ot = class {
        constructor(e = 0, t = 0){
            this.x = 0, this.y = 0, this.x = e, this.y = t;
        }
        clone() {
            return new Ot(this.x, this.y);
        }
        copyFrom(e) {
            return this.set(e.x, e.y), this;
        }
        copyTo(e) {
            return e.set(this.x, this.y), e;
        }
        equals(e) {
            return e.x === this.x && e.y === this.y;
        }
        set(e = 0, t = e) {
            return this.x = e, this.y = t, this;
        }
        toString() {
            return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;
        }
        static get shared() {
            return nl.x = 0, nl.y = 0, nl;
        }
    };
    const nl = new Ot;
    Ne = class {
        constructor(e = 1, t = 0, n = 0, s = 1, r = 0, a = 0){
            this.array = null, this.a = e, this.b = t, this.c = n, this.d = s, this.tx = r, this.ty = a;
        }
        fromArray(e) {
            this.a = e[0], this.b = e[1], this.c = e[3], this.d = e[4], this.tx = e[2], this.ty = e[5];
        }
        set(e, t, n, s, r, a) {
            return this.a = e, this.b = t, this.c = n, this.d = s, this.tx = r, this.ty = a, this;
        }
        toArray(e, t) {
            this.array || (this.array = new Float32Array(9));
            const n = t || this.array;
            return e ? (n[0] = this.a, n[1] = this.b, n[2] = 0, n[3] = this.c, n[4] = this.d, n[5] = 0, n[6] = this.tx, n[7] = this.ty, n[8] = 1) : (n[0] = this.a, n[1] = this.c, n[2] = this.tx, n[3] = this.b, n[4] = this.d, n[5] = this.ty, n[6] = 0, n[7] = 0, n[8] = 1), n;
        }
        apply(e, t) {
            t = t || new Ot;
            const n = e.x, s = e.y;
            return t.x = this.a * n + this.c * s + this.tx, t.y = this.b * n + this.d * s + this.ty, t;
        }
        applyInverse(e, t) {
            t = t || new Ot;
            const n = this.a, s = this.b, r = this.c, a = this.d, o = this.tx, l = this.ty, h = 1 / (n * a + r * -s), d = e.x, c = e.y;
            return t.x = a * h * d + -r * h * c + (l * r - o * a) * h, t.y = n * h * c + -s * h * d + (-l * n + o * s) * h, t;
        }
        translate(e, t) {
            return this.tx += e, this.ty += t, this;
        }
        scale(e, t) {
            return this.a *= e, this.d *= t, this.c *= e, this.b *= t, this.tx *= e, this.ty *= t, this;
        }
        rotate(e) {
            const t = Math.cos(e), n = Math.sin(e), s = this.a, r = this.c, a = this.tx;
            return this.a = s * t - this.b * n, this.b = s * n + this.b * t, this.c = r * t - this.d * n, this.d = r * n + this.d * t, this.tx = a * t - this.ty * n, this.ty = a * n + this.ty * t, this;
        }
        append(e) {
            const t = this.a, n = this.b, s = this.c, r = this.d;
            return this.a = e.a * t + e.b * s, this.b = e.a * n + e.b * r, this.c = e.c * t + e.d * s, this.d = e.c * n + e.d * r, this.tx = e.tx * t + e.ty * s + this.tx, this.ty = e.tx * n + e.ty * r + this.ty, this;
        }
        appendFrom(e, t) {
            const n = e.a, s = e.b, r = e.c, a = e.d, o = e.tx, l = e.ty, h = t.a, d = t.b, c = t.c, u = t.d;
            return this.a = n * h + s * c, this.b = n * d + s * u, this.c = r * h + a * c, this.d = r * d + a * u, this.tx = o * h + l * c + t.tx, this.ty = o * d + l * u + t.ty, this;
        }
        setTransform(e, t, n, s, r, a, o, l, h) {
            return this.a = Math.cos(o + h) * r, this.b = Math.sin(o + h) * r, this.c = -Math.sin(o - l) * a, this.d = Math.cos(o - l) * a, this.tx = e - (n * this.a + s * this.c), this.ty = t - (n * this.b + s * this.d), this;
        }
        prepend(e) {
            const t = this.tx;
            if (e.a !== 1 || e.b !== 0 || e.c !== 0 || e.d !== 1) {
                const n = this.a, s = this.c;
                this.a = n * e.a + this.b * e.c, this.b = n * e.b + this.b * e.d, this.c = s * e.a + this.d * e.c, this.d = s * e.b + this.d * e.d;
            }
            return this.tx = t * e.a + this.ty * e.c + e.tx, this.ty = t * e.b + this.ty * e.d + e.ty, this;
        }
        decompose(e) {
            const t = this.a, n = this.b, s = this.c, r = this.d, a = e.pivot, o = -Math.atan2(-s, r), l = Math.atan2(n, t), h = Math.abs(o + l);
            return h < 1e-5 || Math.abs(IT - h) < 1e-5 ? (e.rotation = l, e.skew.x = e.skew.y = 0) : (e.rotation = 0, e.skew.x = o, e.skew.y = l), e.scale.x = Math.sqrt(t * t + n * n), e.scale.y = Math.sqrt(s * s + r * r), e.position.x = this.tx + (a.x * t + a.y * s), e.position.y = this.ty + (a.x * n + a.y * r), e;
        }
        invert() {
            const e = this.a, t = this.b, n = this.c, s = this.d, r = this.tx, a = e * s - t * n;
            return this.a = s / a, this.b = -t / a, this.c = -n / a, this.d = e / a, this.tx = (n * this.ty - s * r) / a, this.ty = -(e * this.ty - t * r) / a, this;
        }
        isIdentity() {
            return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;
        }
        identity() {
            return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;
        }
        clone() {
            const e = new Ne;
            return e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty, e;
        }
        copyTo(e) {
            return e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty, e;
        }
        copyFrom(e) {
            return this.a = e.a, this.b = e.b, this.c = e.c, this.d = e.d, this.tx = e.tx, this.ty = e.ty, this;
        }
        equals(e) {
            return e.a === this.a && e.b === this.b && e.c === this.c && e.d === this.d && e.tx === this.tx && e.ty === this.ty;
        }
        toString() {
            return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
        }
        static get IDENTITY() {
            return UT.identity();
        }
        static get shared() {
            return BT.identity();
        }
    };
    const BT = new Ne, UT = new Ne, zi = [
        1,
        1,
        0,
        -1,
        -1,
        -1,
        0,
        1,
        1,
        1,
        0,
        -1,
        -1,
        -1,
        0,
        1
    ], Vi = [
        0,
        1,
        1,
        1,
        0,
        -1,
        -1,
        -1,
        0,
        1,
        1,
        1,
        0,
        -1,
        -1,
        -1
    ], Wi = [
        0,
        -1,
        -1,
        -1,
        0,
        1,
        1,
        1,
        0,
        1,
        1,
        1,
        0,
        -1,
        -1,
        -1
    ], Xi = [
        1,
        1,
        0,
        -1,
        -1,
        -1,
        0,
        1,
        -1,
        -1,
        0,
        1,
        1,
        1,
        0,
        -1
    ], Ic = [], Hp = [], wa = Math.sign;
    function FT() {
        for(let i = 0; i < 16; i++){
            const e = [];
            Ic.push(e);
            for(let t = 0; t < 16; t++){
                const n = wa(zi[i] * zi[t] + Wi[i] * Vi[t]), s = wa(Vi[i] * zi[t] + Xi[i] * Vi[t]), r = wa(zi[i] * Wi[t] + Wi[i] * Xi[t]), a = wa(Vi[i] * Wi[t] + Xi[i] * Xi[t]);
                for(let o = 0; o < 16; o++)if (zi[o] === n && Vi[o] === s && Wi[o] === r && Xi[o] === a) {
                    e.push(o);
                    break;
                }
            }
        }
        for(let i = 0; i < 16; i++){
            const e = new Ne;
            e.set(zi[i], Vi[i], Wi[i], Xi[i], 0, 0), Hp.push(e);
        }
    }
    FT();
    const vt = {
        E: 0,
        SE: 1,
        S: 2,
        SW: 3,
        W: 4,
        NW: 5,
        N: 6,
        NE: 7,
        MIRROR_VERTICAL: 8,
        MAIN_DIAGONAL: 10,
        MIRROR_HORIZONTAL: 12,
        REVERSE_DIAGONAL: 14,
        uX: (i)=>zi[i],
        uY: (i)=>Vi[i],
        vX: (i)=>Wi[i],
        vY: (i)=>Xi[i],
        inv: (i)=>i & 8 ? i & 15 : -i & 7,
        add: (i, e)=>Ic[i][e],
        sub: (i, e)=>Ic[i][vt.inv(e)],
        rotate180: (i)=>i ^ 4,
        isVertical: (i)=>(i & 3) === 2,
        byDirection: (i, e)=>Math.abs(i) * 2 <= Math.abs(e) ? e >= 0 ? vt.S : vt.N : Math.abs(e) * 2 <= Math.abs(i) ? i > 0 ? vt.E : vt.W : e > 0 ? i > 0 ? vt.SE : vt.SW : i > 0 ? vt.NE : vt.NW,
        matrixAppendRotationInv: (i, e, t = 0, n = 0)=>{
            const s = Hp[vt.inv(e)];
            s.tx = t, s.ty = n, i.append(s);
        }
    }, Ra = [
        new Ot,
        new Ot,
        new Ot,
        new Ot
    ];
    mt = class {
        constructor(e = 0, t = 0, n = 0, s = 0){
            this.type = "rectangle", this.x = Number(e), this.y = Number(t), this.width = Number(n), this.height = Number(s);
        }
        get left() {
            return this.x;
        }
        get right() {
            return this.x + this.width;
        }
        get top() {
            return this.y;
        }
        get bottom() {
            return this.y + this.height;
        }
        isEmpty() {
            return this.left === this.right || this.top === this.bottom;
        }
        static get EMPTY() {
            return new mt(0, 0, 0, 0);
        }
        clone() {
            return new mt(this.x, this.y, this.width, this.height);
        }
        copyFromBounds(e) {
            return this.x = e.minX, this.y = e.minY, this.width = e.maxX - e.minX, this.height = e.maxY - e.minY, this;
        }
        copyFrom(e) {
            return this.x = e.x, this.y = e.y, this.width = e.width, this.height = e.height, this;
        }
        copyTo(e) {
            return e.copyFrom(this), e;
        }
        contains(e, t) {
            return this.width <= 0 || this.height <= 0 ? !1 : e >= this.x && e < this.x + this.width && t >= this.y && t < this.y + this.height;
        }
        strokeContains(e, t, n, s = .5) {
            const { width: r, height: a } = this;
            if (r <= 0 || a <= 0) return !1;
            const o = this.x, l = this.y, h = n * (1 - s), d = n - h, c = o - h, u = o + r + h, f = l - h, _ = l + a + h, g = o + d, m = o + r - d, p = l + d, x = l + a - d;
            return e >= c && e <= u && t >= f && t <= _ && !(e > g && e < m && t > p && t < x);
        }
        intersects(e, t) {
            if (!t) {
                const B = this.x < e.x ? e.x : this.x;
                if ((this.right > e.right ? e.right : this.right) <= B) return !1;
                const S = this.y < e.y ? e.y : this.y;
                return (this.bottom > e.bottom ? e.bottom : this.bottom) > S;
            }
            const n = this.left, s = this.right, r = this.top, a = this.bottom;
            if (s <= n || a <= r) return !1;
            const o = Ra[0].set(e.left, e.top), l = Ra[1].set(e.left, e.bottom), h = Ra[2].set(e.right, e.top), d = Ra[3].set(e.right, e.bottom);
            if (h.x <= o.x || l.y <= o.y) return !1;
            const c = Math.sign(t.a * t.d - t.b * t.c);
            if (c === 0 || (t.apply(o, o), t.apply(l, l), t.apply(h, h), t.apply(d, d), Math.max(o.x, l.x, h.x, d.x) <= n || Math.min(o.x, l.x, h.x, d.x) >= s || Math.max(o.y, l.y, h.y, d.y) <= r || Math.min(o.y, l.y, h.y, d.y) >= a)) return !1;
            const u = c * (l.y - o.y), f = c * (o.x - l.x), _ = u * n + f * r, g = u * s + f * r, m = u * n + f * a, p = u * s + f * a;
            if (Math.max(_, g, m, p) <= u * o.x + f * o.y || Math.min(_, g, m, p) >= u * d.x + f * d.y) return !1;
            const x = c * (o.y - h.y), v = c * (h.x - o.x), y = x * n + v * r, P = x * s + v * r, w = x * n + v * a, R = x * s + v * a;
            return !(Math.max(y, P, w, R) <= x * o.x + v * o.y || Math.min(y, P, w, R) >= x * d.x + v * d.y);
        }
        pad(e = 0, t = e) {
            return this.x -= e, this.y -= t, this.width += e * 2, this.height += t * 2, this;
        }
        fit(e) {
            const t = Math.max(this.x, e.x), n = Math.min(this.x + this.width, e.x + e.width), s = Math.max(this.y, e.y), r = Math.min(this.y + this.height, e.y + e.height);
            return this.x = t, this.width = Math.max(n - t, 0), this.y = s, this.height = Math.max(r - s, 0), this;
        }
        ceil(e = 1, t = .001) {
            const n = Math.ceil((this.x + this.width - t) * e) / e, s = Math.ceil((this.y + this.height - t) * e) / e;
            return this.x = Math.floor((this.x + t) * e) / e, this.y = Math.floor((this.y + t) * e) / e, this.width = n - this.x, this.height = s - this.y, this;
        }
        enlarge(e) {
            const t = Math.min(this.x, e.x), n = Math.max(this.x + this.width, e.x + e.width), s = Math.min(this.y, e.y), r = Math.max(this.y + this.height, e.y + e.height);
            return this.x = t, this.width = n - t, this.y = s, this.height = r - s, this;
        }
        getBounds(e) {
            return e || (e = new mt), e.copyFrom(this), e;
        }
        containsRect(e) {
            if (this.width <= 0 || this.height <= 0) return !1;
            const t = e.x, n = e.y, s = e.x + e.width, r = e.y + e.height;
            return t >= this.x && t < this.x + this.width && n >= this.y && n < this.y + this.height && s >= this.x && s < this.x + this.width && r >= this.y && r < this.y + this.height;
        }
        toString() {
            return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
        }
    };
    const il = {
        default: -1
    };
    function xt(i = "default") {
        return il[i] === void 0 && (il[i] = -1), ++il[i];
    }
    let Cd, NT;
    Cd = {};
    dt = "8.0.0";
    NT = "8.3.4";
    et = function(i, e, t = 3) {
        if (Cd[e]) return;
        let n = new Error().stack;
        typeof n > "u" ? console.warn("PixiJS Deprecation Warning: ", `${e}
Deprecated since v${i}`) : (n = n.split(`
`).splice(t).join(`
`), console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", `${e}
Deprecated since v${i}`), console.warn(n), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", `${e}
Deprecated since v${i}`), console.warn(n))), Cd[e] = !0;
    };
    const zp = ()=>{};
    so = function(i) {
        return i += i === 0 ? 1 : 0, --i, i |= i >>> 1, i |= i >>> 2, i |= i >>> 4, i |= i >>> 8, i |= i >>> 16, i + 1;
    };
    function Pd(i) {
        return !(i & i - 1) && !!i;
    }
    function Vp(i) {
        const e = {};
        for(const t in i)i[t] !== void 0 && (e[t] = i[t]);
        return e;
    }
    const Id = Object.create(null);
    function OT(i) {
        const e = Id[i];
        return e === void 0 && (Id[i] = xt("resource")), e;
    }
    const Wp = class Xp extends yn {
        constructor(e = {}){
            super(), this._resourceType = "textureSampler", this._touched = 0, this._maxAnisotropy = 1, this.destroyed = !1, e = {
                ...Xp.defaultOptions,
                ...e
            }, this.addressMode = e.addressMode, this.addressModeU = e.addressModeU ?? this.addressModeU, this.addressModeV = e.addressModeV ?? this.addressModeV, this.addressModeW = e.addressModeW ?? this.addressModeW, this.scaleMode = e.scaleMode, this.magFilter = e.magFilter ?? this.magFilter, this.minFilter = e.minFilter ?? this.minFilter, this.mipmapFilter = e.mipmapFilter ?? this.mipmapFilter, this.lodMinClamp = e.lodMinClamp, this.lodMaxClamp = e.lodMaxClamp, this.compare = e.compare, this.maxAnisotropy = e.maxAnisotropy ?? 1;
        }
        set addressMode(e) {
            this.addressModeU = e, this.addressModeV = e, this.addressModeW = e;
        }
        get addressMode() {
            return this.addressModeU;
        }
        set wrapMode(e) {
            et(dt, "TextureStyle.wrapMode is now TextureStyle.addressMode"), this.addressMode = e;
        }
        get wrapMode() {
            return this.addressMode;
        }
        set scaleMode(e) {
            this.magFilter = e, this.minFilter = e, this.mipmapFilter = e;
        }
        get scaleMode() {
            return this.magFilter;
        }
        set maxAnisotropy(e) {
            this._maxAnisotropy = Math.min(e, 16), this._maxAnisotropy > 1 && (this.scaleMode = "linear");
        }
        get maxAnisotropy() {
            return this._maxAnisotropy;
        }
        get _resourceId() {
            return this._sharedResourceId || this._generateResourceId();
        }
        update() {
            this.emit("change", this), this._sharedResourceId = null;
        }
        _generateResourceId() {
            const e = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
            return this._sharedResourceId = OT(e), this._resourceId;
        }
        destroy() {
            this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this.removeAllListeners();
        }
    };
    Wp.defaultOptions = {
        addressMode: "clamp-to-edge",
        scaleMode: "linear"
    };
    kT = Wp;
    const Yp = class jp extends yn {
        constructor(e = {}){
            super(), this.options = e, this.uid = xt("textureSource"), this._resourceType = "textureSource", this._resourceId = xt("resource"), this.uploadMethodId = "unknown", this._resolution = 1, this.pixelWidth = 1, this.pixelHeight = 1, this.width = 1, this.height = 1, this.sampleCount = 1, this.mipLevelCount = 1, this.autoGenerateMipmaps = !1, this.format = "rgba8unorm", this.dimension = "2d", this.antialias = !1, this._touched = 0, this._batchTick = -1, this._textureBindLocation = -1, e = {
                ...jp.defaultOptions,
                ...e
            }, this.label = e.label ?? "", this.resource = e.resource, this.autoGarbageCollect = e.autoGarbageCollect, this._resolution = e.resolution, e.width ? this.pixelWidth = e.width * this._resolution : this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1, e.height ? this.pixelHeight = e.height * this._resolution : this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1, this.width = this.pixelWidth / this._resolution, this.height = this.pixelHeight / this._resolution, this.format = e.format, this.dimension = e.dimensions, this.mipLevelCount = e.mipLevelCount, this.autoGenerateMipmaps = e.autoGenerateMipmaps, this.sampleCount = e.sampleCount, this.antialias = e.antialias, this.alphaMode = e.alphaMode, this.style = new kT(Vp(e)), this.destroyed = !1, this._refreshPOT();
        }
        get source() {
            return this;
        }
        get style() {
            return this._style;
        }
        set style(e) {
            this.style !== e && (this._style?.off("change", this._onStyleChange, this), this._style = e, this._style?.on("change", this._onStyleChange, this), this._onStyleChange());
        }
        get addressMode() {
            return this._style.addressMode;
        }
        set addressMode(e) {
            this._style.addressMode = e;
        }
        get repeatMode() {
            return this._style.addressMode;
        }
        set repeatMode(e) {
            this._style.addressMode = e;
        }
        get magFilter() {
            return this._style.magFilter;
        }
        set magFilter(e) {
            this._style.magFilter = e;
        }
        get minFilter() {
            return this._style.minFilter;
        }
        set minFilter(e) {
            this._style.minFilter = e;
        }
        get mipmapFilter() {
            return this._style.mipmapFilter;
        }
        set mipmapFilter(e) {
            this._style.mipmapFilter = e;
        }
        get lodMinClamp() {
            return this._style.lodMinClamp;
        }
        set lodMinClamp(e) {
            this._style.lodMinClamp = e;
        }
        get lodMaxClamp() {
            return this._style.lodMaxClamp;
        }
        set lodMaxClamp(e) {
            this._style.lodMaxClamp = e;
        }
        _onStyleChange() {
            this.emit("styleChange", this);
        }
        update() {
            if (this.resource) {
                const e = this._resolution;
                if (this.resize(this.resourceWidth / e, this.resourceHeight / e)) return;
            }
            this.emit("update", this);
        }
        destroy() {
            this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this._style && (this._style.destroy(), this._style = null), this.uploadMethodId = null, this.resource = null, this.removeAllListeners();
        }
        unload() {
            this._resourceId = xt("resource"), this.emit("change", this), this.emit("unload", this);
        }
        get resourceWidth() {
            const { resource: e } = this;
            return e.naturalWidth || e.videoWidth || e.displayWidth || e.width;
        }
        get resourceHeight() {
            const { resource: e } = this;
            return e.naturalHeight || e.videoHeight || e.displayHeight || e.height;
        }
        get resolution() {
            return this._resolution;
        }
        set resolution(e) {
            this._resolution !== e && (this._resolution = e, this.width = this.pixelWidth / e, this.height = this.pixelHeight / e);
        }
        resize(e, t, n) {
            n || (n = this._resolution), e || (e = this.width), t || (t = this.height);
            const s = Math.round(e * n), r = Math.round(t * n);
            return this.width = s / n, this.height = r / n, this._resolution = n, this.pixelWidth === s && this.pixelHeight === r ? !1 : (this._refreshPOT(), this.pixelWidth = s, this.pixelHeight = r, this.emit("resize", this), this._resourceId = xt("resource"), this.emit("change", this), !0);
        }
        updateMipmaps() {
            this.autoGenerateMipmaps && this.mipLevelCount > 1 && this.emit("updateMipmaps", this);
        }
        set wrapMode(e) {
            this._style.wrapMode = e;
        }
        get wrapMode() {
            return this._style.wrapMode;
        }
        set scaleMode(e) {
            this._style.scaleMode = e;
        }
        get scaleMode() {
            return this._style.scaleMode;
        }
        _refreshPOT() {
            this.isPowerOfTwo = Pd(this.pixelWidth) && Pd(this.pixelHeight);
        }
        static test(e) {
            throw new Error("Unimplemented");
        }
    };
    Yp.defaultOptions = {
        resolution: 1,
        format: "bgra8unorm",
        alphaMode: "premultiply-alpha-on-upload",
        dimensions: "2d",
        mipLevelCount: 1,
        autoGenerateMipmaps: !1,
        sampleCount: 1,
        antialias: !1,
        autoGarbageCollect: !1
    };
    let kt = Yp;
    class Eh extends kt {
        constructor(e){
            const t = e.resource || new Float32Array(e.width * e.height * 4);
            let n = e.format;
            n || (t instanceof Float32Array ? n = "rgba32float" : t instanceof Int32Array || t instanceof Uint32Array ? n = "rgba32uint" : t instanceof Int16Array || t instanceof Uint16Array ? n = "rgba16uint" : (t instanceof Int8Array, n = "bgra8unorm")), super({
                ...e,
                resource: t,
                format: n
            }), this.uploadMethodId = "buffer";
        }
        static test(e) {
            return e instanceof Int8Array || e instanceof Uint8Array || e instanceof Uint8ClampedArray || e instanceof Int16Array || e instanceof Uint16Array || e instanceof Int32Array || e instanceof Uint32Array || e instanceof Float32Array;
        }
    }
    Eh.extension = J.TextureSource;
    const Dd = new Ne;
    class qp {
        constructor(e, t){
            this.mapCoord = new Ne, this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, typeof t > "u" ? this.clampMargin = e.width < 10 ? 0 : .5 : this.clampMargin = t, this.isSimple = !1, this.texture = e;
        }
        get texture() {
            return this._texture;
        }
        set texture(e) {
            this.texture !== e && (this._texture?.removeListener("update", this.update, this), this._texture = e, this._texture.addListener("update", this.update, this), this.update());
        }
        multiplyUvs(e, t) {
            t === void 0 && (t = e);
            const n = this.mapCoord;
            for(let s = 0; s < e.length; s += 2){
                const r = e[s], a = e[s + 1];
                t[s] = r * n.a + a * n.c + n.tx, t[s + 1] = r * n.b + a * n.d + n.ty;
            }
            return t;
        }
        update() {
            const e = this._texture;
            this._updateID++;
            const t = e.uvs;
            this.mapCoord.set(t.x1 - t.x0, t.y1 - t.y0, t.x3 - t.x0, t.y3 - t.y0, t.x0, t.y0);
            const n = e.orig, s = e.trim;
            s && (Dd.set(n.width / s.width, 0, 0, n.height / s.height, -s.x / s.width, -s.y / s.height), this.mapCoord.append(Dd));
            const r = e.source, a = this.uClampFrame, o = this.clampMargin / r._resolution, l = this.clampOffset / r._resolution;
            return a[0] = (e.frame.x + o + l) / r.width, a[1] = (e.frame.y + o + l) / r.height, a[2] = (e.frame.x + e.frame.width - o + l) / r.width, a[3] = (e.frame.y + e.frame.height - o + l) / r.height, this.uClampOffset[0] = this.clampOffset / r.pixelWidth, this.uClampOffset[1] = this.clampOffset / r.pixelHeight, this.isSimple = e.frame.width === r.width && e.frame.height === r.height && e.rotate === 0, !0;
        }
    }
    Ie = class extends yn {
        constructor({ source: e, label: t, frame: n, orig: s, trim: r, defaultAnchor: a, defaultBorders: o, rotate: l, dynamic: h } = {}){
            if (super(), this.uid = xt("texture"), this.uvs = {
                x0: 0,
                y0: 0,
                x1: 0,
                y1: 0,
                x2: 0,
                y2: 0,
                x3: 0,
                y3: 0
            }, this.frame = new mt, this.noFrame = !1, this.dynamic = !1, this.isTexture = !0, this.label = t, this.source = e?.source ?? new kt, this.noFrame = !n, n) this.frame.copyFrom(n);
            else {
                const { width: d, height: c } = this._source;
                this.frame.width = d, this.frame.height = c;
            }
            this.orig = s || this.frame, this.trim = r, this.rotate = l ?? 0, this.defaultAnchor = a, this.defaultBorders = o, this.destroyed = !1, this.dynamic = h || !1, this.updateUvs();
        }
        set source(e) {
            this._source && this._source.off("resize", this.update, this), this._source = e, e.on("resize", this.update, this), this.emit("update", this);
        }
        get source() {
            return this._source;
        }
        get textureMatrix() {
            return this._textureMatrix || (this._textureMatrix = new qp(this)), this._textureMatrix;
        }
        get width() {
            return this.orig.width;
        }
        get height() {
            return this.orig.height;
        }
        updateUvs() {
            const { uvs: e, frame: t } = this, { width: n, height: s } = this._source, r = t.x / n, a = t.y / s, o = t.width / n, l = t.height / s;
            let h = this.rotate;
            if (h) {
                const d = o / 2, c = l / 2, u = r + d, f = a + c;
                h = vt.add(h, vt.NW), e.x0 = u + d * vt.uX(h), e.y0 = f + c * vt.uY(h), h = vt.add(h, 2), e.x1 = u + d * vt.uX(h), e.y1 = f + c * vt.uY(h), h = vt.add(h, 2), e.x2 = u + d * vt.uX(h), e.y2 = f + c * vt.uY(h), h = vt.add(h, 2), e.x3 = u + d * vt.uX(h), e.y3 = f + c * vt.uY(h);
            } else e.x0 = r, e.y0 = a, e.x1 = r + o, e.y1 = a, e.x2 = r + o, e.y2 = a + l, e.x3 = r, e.y3 = a + l;
        }
        destroy(e = !1) {
            this._source && e && (this._source.destroy(), this._source = null), this._textureMatrix = null, this.destroyed = !0, this.emit("destroy", this), this.removeAllListeners();
        }
        update() {
            this.noFrame && (this.frame.width = this._source.width, this.frame.height = this._source.height), this.updateUvs(), this.emit("update", this);
        }
        get baseTexture() {
            return et(dt, "Texture.baseTexture is now Texture.source"), this._source;
        }
    };
    Ie.EMPTY = new Ie({
        label: "EMPTY",
        source: new kt({
            label: "EMPTY"
        })
    });
    Ie.EMPTY.destroy = zp;
    Ie.WHITE = new Ie({
        source: new Eh({
            resource: new Uint8Array([
                255,
                255,
                255,
                255
            ]),
            width: 1,
            height: 1,
            alphaMode: "premultiply-alpha-on-upload",
            label: "WHITE"
        }),
        label: "WHITE"
    });
    Ie.WHITE.destroy = zp;
    GT = function(i, e, t) {
        const { width: n, height: s } = t.orig, r = t.trim;
        if (r) {
            const a = r.width, o = r.height;
            i.minX = r.x - e._x * n, i.maxX = i.minX + a, i.minY = r.y - e._y * s, i.maxY = i.minY + o;
        } else i.minX = -e._x * n, i.maxX = i.minX + n, i.minY = -e._y * s, i.maxY = i.minY + s;
    };
    const Ld = new Ne;
    sn = class {
        constructor(e = 1 / 0, t = 1 / 0, n = -1 / 0, s = -1 / 0){
            this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = Ld, this.minX = e, this.minY = t, this.maxX = n, this.maxY = s;
        }
        isEmpty() {
            return this.minX > this.maxX || this.minY > this.maxY;
        }
        get rectangle() {
            this._rectangle || (this._rectangle = new mt);
            const e = this._rectangle;
            return this.minX > this.maxX || this.minY > this.maxY ? (e.x = 0, e.y = 0, e.width = 0, e.height = 0) : e.copyFromBounds(this), e;
        }
        clear() {
            return this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = Ld, this;
        }
        set(e, t, n, s) {
            this.minX = e, this.minY = t, this.maxX = n, this.maxY = s;
        }
        addFrame(e, t, n, s, r) {
            r || (r = this.matrix);
            const a = r.a, o = r.b, l = r.c, h = r.d, d = r.tx, c = r.ty;
            let u = this.minX, f = this.minY, _ = this.maxX, g = this.maxY, m = a * e + l * t + d, p = o * e + h * t + c;
            m < u && (u = m), p < f && (f = p), m > _ && (_ = m), p > g && (g = p), m = a * n + l * t + d, p = o * n + h * t + c, m < u && (u = m), p < f && (f = p), m > _ && (_ = m), p > g && (g = p), m = a * e + l * s + d, p = o * e + h * s + c, m < u && (u = m), p < f && (f = p), m > _ && (_ = m), p > g && (g = p), m = a * n + l * s + d, p = o * n + h * s + c, m < u && (u = m), p < f && (f = p), m > _ && (_ = m), p > g && (g = p), this.minX = u, this.minY = f, this.maxX = _, this.maxY = g;
        }
        addRect(e, t) {
            this.addFrame(e.x, e.y, e.x + e.width, e.y + e.height, t);
        }
        addBounds(e, t) {
            this.addFrame(e.minX, e.minY, e.maxX, e.maxY, t);
        }
        addBoundsMask(e) {
            this.minX = this.minX > e.minX ? this.minX : e.minX, this.minY = this.minY > e.minY ? this.minY : e.minY, this.maxX = this.maxX < e.maxX ? this.maxX : e.maxX, this.maxY = this.maxY < e.maxY ? this.maxY : e.maxY;
        }
        applyMatrix(e) {
            const t = this.minX, n = this.minY, s = this.maxX, r = this.maxY, { a, b: o, c: l, d: h, tx: d, ty: c } = e;
            let u = a * t + l * n + d, f = o * t + h * n + c;
            this.minX = u, this.minY = f, this.maxX = u, this.maxY = f, u = a * s + l * n + d, f = o * s + h * n + c, this.minX = u < this.minX ? u : this.minX, this.minY = f < this.minY ? f : this.minY, this.maxX = u > this.maxX ? u : this.maxX, this.maxY = f > this.maxY ? f : this.maxY, u = a * t + l * r + d, f = o * t + h * r + c, this.minX = u < this.minX ? u : this.minX, this.minY = f < this.minY ? f : this.minY, this.maxX = u > this.maxX ? u : this.maxX, this.maxY = f > this.maxY ? f : this.maxY, u = a * s + l * r + d, f = o * s + h * r + c, this.minX = u < this.minX ? u : this.minX, this.minY = f < this.minY ? f : this.minY, this.maxX = u > this.maxX ? u : this.maxX, this.maxY = f > this.maxY ? f : this.maxY;
        }
        fit(e) {
            return this.minX < e.left && (this.minX = e.left), this.maxX > e.right && (this.maxX = e.right), this.minY < e.top && (this.minY = e.top), this.maxY > e.bottom && (this.maxY = e.bottom), this;
        }
        fitBounds(e, t, n, s) {
            return this.minX < e && (this.minX = e), this.maxX > t && (this.maxX = t), this.minY < n && (this.minY = n), this.maxY > s && (this.maxY = s), this;
        }
        pad(e, t = e) {
            return this.minX -= e, this.maxX += e, this.minY -= t, this.maxY += t, this;
        }
        ceil() {
            return this.minX = Math.floor(this.minX), this.minY = Math.floor(this.minY), this.maxX = Math.ceil(this.maxX), this.maxY = Math.ceil(this.maxY), this;
        }
        clone() {
            return new sn(this.minX, this.minY, this.maxX, this.maxY);
        }
        scale(e, t = e) {
            return this.minX *= e, this.minY *= t, this.maxX *= e, this.maxY *= t, this;
        }
        get x() {
            return this.minX;
        }
        set x(e) {
            const t = this.maxX - this.minX;
            this.minX = e, this.maxX = e + t;
        }
        get y() {
            return this.minY;
        }
        set y(e) {
            const t = this.maxY - this.minY;
            this.minY = e, this.maxY = e + t;
        }
        get width() {
            return this.maxX - this.minX;
        }
        set width(e) {
            this.maxX = this.minX + e;
        }
        get height() {
            return this.maxY - this.minY;
        }
        set height(e) {
            this.maxY = this.minY + e;
        }
        get left() {
            return this.minX;
        }
        get right() {
            return this.maxX;
        }
        get top() {
            return this.minY;
        }
        get bottom() {
            return this.maxY;
        }
        get isPositive() {
            return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;
        }
        get isValid() {
            return this.minX + this.minY !== 1 / 0;
        }
        addVertexData(e, t, n, s) {
            let r = this.minX, a = this.minY, o = this.maxX, l = this.maxY;
            s || (s = this.matrix);
            const h = s.a, d = s.b, c = s.c, u = s.d, f = s.tx, _ = s.ty;
            for(let g = t; g < n; g += 2){
                const m = e[g], p = e[g + 1], x = h * m + c * p + f, v = d * m + u * p + _;
                r = x < r ? x : r, a = v < a ? v : a, o = x > o ? x : o, l = v > l ? v : l;
            }
            this.minX = r, this.minY = a, this.maxX = o, this.maxY = l;
        }
        containsPoint(e, t) {
            return this.minX <= e && this.minY <= t && this.maxX >= e && this.maxY >= t;
        }
        toString() {
            return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;
        }
        copyFrom(e) {
            return this.minX = e.minX, this.minY = e.minY, this.maxX = e.maxX, this.maxY = e.maxY, this;
        }
    };
    var HT = {
        grad: .9,
        turn: 360,
        rad: 360 / (2 * Math.PI)
    }, Qn = function(i) {
        return typeof i == "string" ? i.length > 0 : typeof i == "number";
    }, Lt = function(i, e, t) {
        return e === void 0 && (e = 0), t === void 0 && (t = Math.pow(10, e)), Math.round(t * i) / t + 0;
    }, vn = function(i, e, t) {
        return e === void 0 && (e = 0), t === void 0 && (t = 1), i > t ? t : i > e ? i : e;
    }, $p = function(i) {
        return (i = isFinite(i) ? i % 360 : 0) > 0 ? i : i + 360;
    }, Bd = function(i) {
        return {
            r: vn(i.r, 0, 255),
            g: vn(i.g, 0, 255),
            b: vn(i.b, 0, 255),
            a: vn(i.a)
        };
    }, sl = function(i) {
        return {
            r: Lt(i.r),
            g: Lt(i.g),
            b: Lt(i.b),
            a: Lt(i.a, 3)
        };
    }, zT = /^#([0-9a-f]{3,8})$/i, Ca = function(i) {
        var e = i.toString(16);
        return e.length < 2 ? "0" + e : e;
    }, Kp = function(i) {
        var e = i.r, t = i.g, n = i.b, s = i.a, r = Math.max(e, t, n), a = r - Math.min(e, t, n), o = a ? r === e ? (t - n) / a : r === t ? 2 + (n - e) / a : 4 + (e - t) / a : 0;
        return {
            h: 60 * (o < 0 ? o + 6 : o),
            s: r ? a / r * 100 : 0,
            v: r / 255 * 100,
            a: s
        };
    }, Zp = function(i) {
        var e = i.h, t = i.s, n = i.v, s = i.a;
        e = e / 360 * 6, t /= 100, n /= 100;
        var r = Math.floor(e), a = n * (1 - t), o = n * (1 - (e - r) * t), l = n * (1 - (1 - e + r) * t), h = r % 6;
        return {
            r: 255 * [
                n,
                o,
                a,
                a,
                l,
                n
            ][h],
            g: 255 * [
                l,
                n,
                n,
                o,
                a,
                a
            ][h],
            b: 255 * [
                a,
                a,
                l,
                n,
                n,
                o
            ][h],
            a: s
        };
    }, Ud = function(i) {
        return {
            h: $p(i.h),
            s: vn(i.s, 0, 100),
            l: vn(i.l, 0, 100),
            a: vn(i.a)
        };
    }, Fd = function(i) {
        return {
            h: Lt(i.h),
            s: Lt(i.s),
            l: Lt(i.l),
            a: Lt(i.a, 3)
        };
    }, Nd = function(i) {
        return Zp((t = (e = i).s, {
            h: e.h,
            s: (t *= ((n = e.l) < 50 ? n : 100 - n) / 100) > 0 ? 2 * t / (n + t) * 100 : 0,
            v: n + t,
            a: e.a
        }));
        var e, t, n;
    }, Dr = function(i) {
        return {
            h: (e = Kp(i)).h,
            s: (s = (200 - (t = e.s)) * (n = e.v) / 100) > 0 && s < 200 ? t * n / 100 / (s <= 100 ? s : 200 - s) * 100 : 0,
            l: s / 2,
            a: e.a
        };
        var e, t, n, s;
    }, VT = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, WT = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, XT = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, YT = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, Dc = {
        string: [
            [
                function(i) {
                    var e = zT.exec(i);
                    return e ? (i = e[1]).length <= 4 ? {
                        r: parseInt(i[0] + i[0], 16),
                        g: parseInt(i[1] + i[1], 16),
                        b: parseInt(i[2] + i[2], 16),
                        a: i.length === 4 ? Lt(parseInt(i[3] + i[3], 16) / 255, 2) : 1
                    } : i.length === 6 || i.length === 8 ? {
                        r: parseInt(i.substr(0, 2), 16),
                        g: parseInt(i.substr(2, 2), 16),
                        b: parseInt(i.substr(4, 2), 16),
                        a: i.length === 8 ? Lt(parseInt(i.substr(6, 2), 16) / 255, 2) : 1
                    } : null : null;
                },
                "hex"
            ],
            [
                function(i) {
                    var e = XT.exec(i) || YT.exec(i);
                    return e ? e[2] !== e[4] || e[4] !== e[6] ? null : Bd({
                        r: Number(e[1]) / (e[2] ? 100 / 255 : 1),
                        g: Number(e[3]) / (e[4] ? 100 / 255 : 1),
                        b: Number(e[5]) / (e[6] ? 100 / 255 : 1),
                        a: e[7] === void 0 ? 1 : Number(e[7]) / (e[8] ? 100 : 1)
                    }) : null;
                },
                "rgb"
            ],
            [
                function(i) {
                    var e = VT.exec(i) || WT.exec(i);
                    if (!e) return null;
                    var t, n, s = Ud({
                        h: (t = e[1], n = e[2], n === void 0 && (n = "deg"), Number(t) * (HT[n] || 1)),
                        s: Number(e[3]),
                        l: Number(e[4]),
                        a: e[5] === void 0 ? 1 : Number(e[5]) / (e[6] ? 100 : 1)
                    });
                    return Nd(s);
                },
                "hsl"
            ]
        ],
        object: [
            [
                function(i) {
                    var e = i.r, t = i.g, n = i.b, s = i.a, r = s === void 0 ? 1 : s;
                    return Qn(e) && Qn(t) && Qn(n) ? Bd({
                        r: Number(e),
                        g: Number(t),
                        b: Number(n),
                        a: Number(r)
                    }) : null;
                },
                "rgb"
            ],
            [
                function(i) {
                    var e = i.h, t = i.s, n = i.l, s = i.a, r = s === void 0 ? 1 : s;
                    if (!Qn(e) || !Qn(t) || !Qn(n)) return null;
                    var a = Ud({
                        h: Number(e),
                        s: Number(t),
                        l: Number(n),
                        a: Number(r)
                    });
                    return Nd(a);
                },
                "hsl"
            ],
            [
                function(i) {
                    var e = i.h, t = i.s, n = i.v, s = i.a, r = s === void 0 ? 1 : s;
                    if (!Qn(e) || !Qn(t) || !Qn(n)) return null;
                    var a = function(o) {
                        return {
                            h: $p(o.h),
                            s: vn(o.s, 0, 100),
                            v: vn(o.v, 0, 100),
                            a: vn(o.a)
                        };
                    }({
                        h: Number(e),
                        s: Number(t),
                        v: Number(n),
                        a: Number(r)
                    });
                    return Zp(a);
                },
                "hsv"
            ]
        ]
    }, Od = function(i, e) {
        for(var t = 0; t < e.length; t++){
            var n = e[t][0](i);
            if (n) return [
                n,
                e[t][1]
            ];
        }
        return [
            null,
            void 0
        ];
    }, jT = function(i) {
        return typeof i == "string" ? Od(i.trim(), Dc.string) : typeof i == "object" && i !== null ? Od(i, Dc.object) : [
            null,
            void 0
        ];
    }, rl = function(i, e) {
        var t = Dr(i);
        return {
            h: t.h,
            s: vn(t.s + 100 * e, 0, 100),
            l: t.l,
            a: t.a
        };
    }, al = function(i) {
        return (299 * i.r + 587 * i.g + 114 * i.b) / 1e3 / 255;
    }, kd = function(i, e) {
        var t = Dr(i);
        return {
            h: t.h,
            s: t.s,
            l: vn(t.l + 100 * e, 0, 100),
            a: t.a
        };
    }, Lc = function() {
        function i(e) {
            this.parsed = jT(e)[0], this.rgba = this.parsed || {
                r: 0,
                g: 0,
                b: 0,
                a: 1
            };
        }
        return i.prototype.isValid = function() {
            return this.parsed !== null;
        }, i.prototype.brightness = function() {
            return Lt(al(this.rgba), 2);
        }, i.prototype.isDark = function() {
            return al(this.rgba) < .5;
        }, i.prototype.isLight = function() {
            return al(this.rgba) >= .5;
        }, i.prototype.toHex = function() {
            return e = sl(this.rgba), t = e.r, n = e.g, s = e.b, a = (r = e.a) < 1 ? Ca(Lt(255 * r)) : "", "#" + Ca(t) + Ca(n) + Ca(s) + a;
            var e, t, n, s, r, a;
        }, i.prototype.toRgb = function() {
            return sl(this.rgba);
        }, i.prototype.toRgbString = function() {
            return e = sl(this.rgba), t = e.r, n = e.g, s = e.b, (r = e.a) < 1 ? "rgba(" + t + ", " + n + ", " + s + ", " + r + ")" : "rgb(" + t + ", " + n + ", " + s + ")";
            var e, t, n, s, r;
        }, i.prototype.toHsl = function() {
            return Fd(Dr(this.rgba));
        }, i.prototype.toHslString = function() {
            return e = Fd(Dr(this.rgba)), t = e.h, n = e.s, s = e.l, (r = e.a) < 1 ? "hsla(" + t + ", " + n + "%, " + s + "%, " + r + ")" : "hsl(" + t + ", " + n + "%, " + s + "%)";
            var e, t, n, s, r;
        }, i.prototype.toHsv = function() {
            return e = Kp(this.rgba), {
                h: Lt(e.h),
                s: Lt(e.s),
                v: Lt(e.v),
                a: Lt(e.a, 3)
            };
            var e;
        }, i.prototype.invert = function() {
            return Fn({
                r: 255 - (e = this.rgba).r,
                g: 255 - e.g,
                b: 255 - e.b,
                a: e.a
            });
            var e;
        }, i.prototype.saturate = function(e) {
            return e === void 0 && (e = .1), Fn(rl(this.rgba, e));
        }, i.prototype.desaturate = function(e) {
            return e === void 0 && (e = .1), Fn(rl(this.rgba, -e));
        }, i.prototype.grayscale = function() {
            return Fn(rl(this.rgba, -1));
        }, i.prototype.lighten = function(e) {
            return e === void 0 && (e = .1), Fn(kd(this.rgba, e));
        }, i.prototype.darken = function(e) {
            return e === void 0 && (e = .1), Fn(kd(this.rgba, -e));
        }, i.prototype.rotate = function(e) {
            return e === void 0 && (e = 15), this.hue(this.hue() + e);
        }, i.prototype.alpha = function(e) {
            return typeof e == "number" ? Fn({
                r: (t = this.rgba).r,
                g: t.g,
                b: t.b,
                a: e
            }) : Lt(this.rgba.a, 3);
            var t;
        }, i.prototype.hue = function(e) {
            var t = Dr(this.rgba);
            return typeof e == "number" ? Fn({
                h: e,
                s: t.s,
                l: t.l,
                a: t.a
            }) : Lt(t.h);
        }, i.prototype.isEqual = function(e) {
            return this.toHex() === Fn(e).toHex();
        }, i;
    }(), Fn = function(i) {
        return i instanceof Lc ? i : new Lc(i);
    }, Gd = [], qT = function(i) {
        i.forEach(function(e) {
            Gd.indexOf(e) < 0 && (e(Lc, Dc), Gd.push(e));
        });
    };
    function $T(i, e) {
        var t = {
            white: "#ffffff",
            bisque: "#ffe4c4",
            blue: "#0000ff",
            cadetblue: "#5f9ea0",
            chartreuse: "#7fff00",
            chocolate: "#d2691e",
            coral: "#ff7f50",
            antiquewhite: "#faebd7",
            aqua: "#00ffff",
            azure: "#f0ffff",
            whitesmoke: "#f5f5f5",
            papayawhip: "#ffefd5",
            plum: "#dda0dd",
            blanchedalmond: "#ffebcd",
            black: "#000000",
            gold: "#ffd700",
            goldenrod: "#daa520",
            gainsboro: "#dcdcdc",
            cornsilk: "#fff8dc",
            cornflowerblue: "#6495ed",
            burlywood: "#deb887",
            aquamarine: "#7fffd4",
            beige: "#f5f5dc",
            crimson: "#dc143c",
            cyan: "#00ffff",
            darkblue: "#00008b",
            darkcyan: "#008b8b",
            darkgoldenrod: "#b8860b",
            darkkhaki: "#bdb76b",
            darkgray: "#a9a9a9",
            darkgreen: "#006400",
            darkgrey: "#a9a9a9",
            peachpuff: "#ffdab9",
            darkmagenta: "#8b008b",
            darkred: "#8b0000",
            darkorchid: "#9932cc",
            darkorange: "#ff8c00",
            darkslateblue: "#483d8b",
            gray: "#808080",
            darkslategray: "#2f4f4f",
            darkslategrey: "#2f4f4f",
            deeppink: "#ff1493",
            deepskyblue: "#00bfff",
            wheat: "#f5deb3",
            firebrick: "#b22222",
            floralwhite: "#fffaf0",
            ghostwhite: "#f8f8ff",
            darkviolet: "#9400d3",
            magenta: "#ff00ff",
            green: "#008000",
            dodgerblue: "#1e90ff",
            grey: "#808080",
            honeydew: "#f0fff0",
            hotpink: "#ff69b4",
            blueviolet: "#8a2be2",
            forestgreen: "#228b22",
            lawngreen: "#7cfc00",
            indianred: "#cd5c5c",
            indigo: "#4b0082",
            fuchsia: "#ff00ff",
            brown: "#a52a2a",
            maroon: "#800000",
            mediumblue: "#0000cd",
            lightcoral: "#f08080",
            darkturquoise: "#00ced1",
            lightcyan: "#e0ffff",
            ivory: "#fffff0",
            lightyellow: "#ffffe0",
            lightsalmon: "#ffa07a",
            lightseagreen: "#20b2aa",
            linen: "#faf0e6",
            mediumaquamarine: "#66cdaa",
            lemonchiffon: "#fffacd",
            lime: "#00ff00",
            khaki: "#f0e68c",
            mediumseagreen: "#3cb371",
            limegreen: "#32cd32",
            mediumspringgreen: "#00fa9a",
            lightskyblue: "#87cefa",
            lightblue: "#add8e6",
            midnightblue: "#191970",
            lightpink: "#ffb6c1",
            mistyrose: "#ffe4e1",
            moccasin: "#ffe4b5",
            mintcream: "#f5fffa",
            lightslategray: "#778899",
            lightslategrey: "#778899",
            navajowhite: "#ffdead",
            navy: "#000080",
            mediumvioletred: "#c71585",
            powderblue: "#b0e0e6",
            palegoldenrod: "#eee8aa",
            oldlace: "#fdf5e6",
            paleturquoise: "#afeeee",
            mediumturquoise: "#48d1cc",
            mediumorchid: "#ba55d3",
            rebeccapurple: "#663399",
            lightsteelblue: "#b0c4de",
            mediumslateblue: "#7b68ee",
            thistle: "#d8bfd8",
            tan: "#d2b48c",
            orchid: "#da70d6",
            mediumpurple: "#9370db",
            purple: "#800080",
            pink: "#ffc0cb",
            skyblue: "#87ceeb",
            springgreen: "#00ff7f",
            palegreen: "#98fb98",
            red: "#ff0000",
            yellow: "#ffff00",
            slateblue: "#6a5acd",
            lavenderblush: "#fff0f5",
            peru: "#cd853f",
            palevioletred: "#db7093",
            violet: "#ee82ee",
            teal: "#008080",
            slategray: "#708090",
            slategrey: "#708090",
            aliceblue: "#f0f8ff",
            darkseagreen: "#8fbc8f",
            darkolivegreen: "#556b2f",
            greenyellow: "#adff2f",
            seagreen: "#2e8b57",
            seashell: "#fff5ee",
            tomato: "#ff6347",
            silver: "#c0c0c0",
            sienna: "#a0522d",
            lavender: "#e6e6fa",
            lightgreen: "#90ee90",
            orange: "#ffa500",
            orangered: "#ff4500",
            steelblue: "#4682b4",
            royalblue: "#4169e1",
            turquoise: "#40e0d0",
            yellowgreen: "#9acd32",
            salmon: "#fa8072",
            saddlebrown: "#8b4513",
            sandybrown: "#f4a460",
            rosybrown: "#bc8f8f",
            darksalmon: "#e9967a",
            lightgoldenrodyellow: "#fafad2",
            snow: "#fffafa",
            lightgrey: "#d3d3d3",
            lightgray: "#d3d3d3",
            dimgray: "#696969",
            dimgrey: "#696969",
            olivedrab: "#6b8e23",
            olive: "#808000"
        }, n = {};
        for(var s in t)n[t[s]] = s;
        var r = {};
        i.prototype.toName = function(a) {
            if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent";
            var o, l, h = n[this.toHex()];
            if (h) return h;
            if (a?.closest) {
                var d = this.toRgb(), c = 1 / 0, u = "black";
                if (!r.length) for(var f in t)r[f] = new i(t[f]).toRgb();
                for(var _ in t){
                    var g = (o = d, l = r[_], Math.pow(o.r - l.r, 2) + Math.pow(o.g - l.g, 2) + Math.pow(o.b - l.b, 2));
                    g < c && (c = g, u = _);
                }
                return u;
            }
        }, e.string.push([
            function(a) {
                var o = a.toLowerCase(), l = o === "transparent" ? "#0000" : t[o];
                return l ? new i(l).toRgb() : null;
            },
            "name"
        ]);
    }
    qT([
        $T
    ]);
    const js = class Ar {
        constructor(e = 16777215){
            this._value = null, this._components = new Float32Array(4), this._components.fill(1), this._int = 16777215, this.value = e;
        }
        get red() {
            return this._components[0];
        }
        get green() {
            return this._components[1];
        }
        get blue() {
            return this._components[2];
        }
        get alpha() {
            return this._components[3];
        }
        setValue(e) {
            return this.value = e, this;
        }
        set value(e) {
            if (e instanceof Ar) this._value = this._cloneSource(e._value), this._int = e._int, this._components.set(e._components);
            else {
                if (e === null) throw new Error("Cannot set Color#value to null");
                (this._value === null || !this._isSourceEqual(this._value, e)) && (this._value = this._cloneSource(e), this._normalize(this._value));
            }
        }
        get value() {
            return this._value;
        }
        _cloneSource(e) {
            return typeof e == "string" || typeof e == "number" || e instanceof Number || e === null ? e : Array.isArray(e) || ArrayBuffer.isView(e) ? e.slice(0) : typeof e == "object" && e !== null ? {
                ...e
            } : e;
        }
        _isSourceEqual(e, t) {
            const n = typeof e;
            if (n !== typeof t) return !1;
            if (n === "number" || n === "string" || e instanceof Number) return e === t;
            if (Array.isArray(e) && Array.isArray(t) || ArrayBuffer.isView(e) && ArrayBuffer.isView(t)) return e.length !== t.length ? !1 : e.every((r, a)=>r === t[a]);
            if (e !== null && t !== null) {
                const r = Object.keys(e), a = Object.keys(t);
                return r.length !== a.length ? !1 : r.every((o)=>e[o] === t[o]);
            }
            return e === t;
        }
        toRgba() {
            const [e, t, n, s] = this._components;
            return {
                r: e,
                g: t,
                b: n,
                a: s
            };
        }
        toRgb() {
            const [e, t, n] = this._components;
            return {
                r: e,
                g: t,
                b: n
            };
        }
        toRgbaString() {
            const [e, t, n] = this.toUint8RgbArray();
            return `rgba(${e},${t},${n},${this.alpha})`;
        }
        toUint8RgbArray(e) {
            const [t, n, s] = this._components;
            return this._arrayRgb || (this._arrayRgb = []), e || (e = this._arrayRgb), e[0] = Math.round(t * 255), e[1] = Math.round(n * 255), e[2] = Math.round(s * 255), e;
        }
        toArray(e) {
            this._arrayRgba || (this._arrayRgba = []), e || (e = this._arrayRgba);
            const [t, n, s, r] = this._components;
            return e[0] = t, e[1] = n, e[2] = s, e[3] = r, e;
        }
        toRgbArray(e) {
            this._arrayRgb || (this._arrayRgb = []), e || (e = this._arrayRgb);
            const [t, n, s] = this._components;
            return e[0] = t, e[1] = n, e[2] = s, e;
        }
        toNumber() {
            return this._int;
        }
        toBgrNumber() {
            const [e, t, n] = this.toUint8RgbArray();
            return (n << 16) + (t << 8) + e;
        }
        toLittleEndianNumber() {
            const e = this._int;
            return (e >> 16) + (e & 65280) + ((e & 255) << 16);
        }
        multiply(e) {
            const [t, n, s, r] = Ar._temp.setValue(e)._components;
            return this._components[0] *= t, this._components[1] *= n, this._components[2] *= s, this._components[3] *= r, this._refreshInt(), this._value = null, this;
        }
        premultiply(e, t = !0) {
            return t && (this._components[0] *= e, this._components[1] *= e, this._components[2] *= e), this._components[3] = e, this._refreshInt(), this._value = null, this;
        }
        toPremultiplied(e, t = !0) {
            if (e === 1) return (255 << 24) + this._int;
            if (e === 0) return t ? 0 : this._int;
            let n = this._int >> 16 & 255, s = this._int >> 8 & 255, r = this._int & 255;
            return t && (n = n * e + .5 | 0, s = s * e + .5 | 0, r = r * e + .5 | 0), (e * 255 << 24) + (n << 16) + (s << 8) + r;
        }
        toHex() {
            const e = this._int.toString(16);
            return `#${"000000".substring(0, 6 - e.length) + e}`;
        }
        toHexa() {
            const t = Math.round(this._components[3] * 255).toString(16);
            return this.toHex() + "00".substring(0, 2 - t.length) + t;
        }
        setAlpha(e) {
            return this._components[3] = this._clamp(e), this;
        }
        _normalize(e) {
            let t, n, s, r;
            if ((typeof e == "number" || e instanceof Number) && e >= 0 && e <= 16777215) {
                const a = e;
                t = (a >> 16 & 255) / 255, n = (a >> 8 & 255) / 255, s = (a & 255) / 255, r = 1;
            } else if ((Array.isArray(e) || e instanceof Float32Array) && e.length >= 3 && e.length <= 4) e = this._clamp(e), [t, n, s, r = 1] = e;
            else if ((e instanceof Uint8Array || e instanceof Uint8ClampedArray) && e.length >= 3 && e.length <= 4) e = this._clamp(e, 0, 255), [t, n, s, r = 255] = e, t /= 255, n /= 255, s /= 255, r /= 255;
            else if (typeof e == "string" || typeof e == "object") {
                if (typeof e == "string") {
                    const o = Ar.HEX_PATTERN.exec(e);
                    o && (e = `#${o[2]}`);
                }
                const a = Fn(e);
                a.isValid() && ({ r: t, g: n, b: s, a: r } = a.rgba, t /= 255, n /= 255, s /= 255);
            }
            if (t !== void 0) this._components[0] = t, this._components[1] = n, this._components[2] = s, this._components[3] = r, this._refreshInt();
            else throw new Error(`Unable to convert color ${e}`);
        }
        _refreshInt() {
            this._clamp(this._components);
            const [e, t, n] = this._components;
            this._int = (e * 255 << 16) + (t * 255 << 8) + (n * 255 | 0);
        }
        _clamp(e, t = 0, n = 1) {
            return typeof e == "number" ? Math.min(Math.max(e, t), n) : (e.forEach((s, r)=>{
                e[r] = Math.min(Math.max(s, t), n);
            }), e);
        }
        static isColorLike(e) {
            return typeof e == "number" || typeof e == "string" || e instanceof Number || e instanceof Ar || Array.isArray(e) || e instanceof Uint8Array || e instanceof Uint8ClampedArray || e instanceof Float32Array || e.r !== void 0 && e.g !== void 0 && e.b !== void 0 || e.r !== void 0 && e.g !== void 0 && e.b !== void 0 && e.a !== void 0 || e.h !== void 0 && e.s !== void 0 && e.l !== void 0 || e.h !== void 0 && e.s !== void 0 && e.l !== void 0 && e.a !== void 0 || e.h !== void 0 && e.s !== void 0 && e.v !== void 0 || e.h !== void 0 && e.s !== void 0 && e.v !== void 0 && e.a !== void 0;
        }
    };
    js.shared = new js;
    js._temp = new js;
    js.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
    Et = js;
    const KT = {
        cullArea: null,
        cullable: !1,
        cullableChildren: !0
    };
    class wh {
        constructor(e, t){
            this._pool = [], this._count = 0, this._index = 0, this._classType = e, t && this.prepopulate(t);
        }
        prepopulate(e) {
            for(let t = 0; t < e; t++)this._pool[this._index++] = new this._classType;
            this._count += e;
        }
        get(e) {
            let t;
            return this._index > 0 ? t = this._pool[--this._index] : t = new this._classType, t.init?.(e), t;
        }
        return(e) {
            e.reset?.(), this._pool[this._index++] = e;
        }
        get totalSize() {
            return this._count;
        }
        get totalFree() {
            return this._index;
        }
        get totalUsed() {
            return this._count - this._index;
        }
        clear() {
            this._pool.length = 0, this._index = 0;
        }
    }
    class ZT {
        constructor(){
            this._poolsByClass = new Map;
        }
        prepopulate(e, t) {
            this.getPool(e).prepopulate(t);
        }
        get(e, t) {
            return this.getPool(e).get(t);
        }
        return(e) {
            this.getPool(e.constructor).return(e);
        }
        getPool(e) {
            return this._poolsByClass.has(e) || this._poolsByClass.set(e, new wh(e)), this._poolsByClass.get(e);
        }
        stats() {
            const e = {};
            return this._poolsByClass.forEach((t)=>{
                const n = e[t._classType.name] ? t._classType.name + t._classType.ID : t._classType.name;
                e[n] = {
                    free: t.totalFree,
                    used: t.totalUsed,
                    size: t.totalSize
                };
            }), e;
        }
    }
    let JT;
    Vt = new ZT;
    JT = {
        get isCachedAsTexture () {
            return !!this.renderGroup?.isCachedAsTexture;
        },
        cacheAsTexture (i) {
            typeof i == "boolean" && i === !1 ? this.disableRenderGroup() : (this.enableRenderGroup(), this.renderGroup.enableCacheAsTexture(i === !0 ? {} : i));
        },
        updateCacheTexture () {
            this.renderGroup?.updateCacheTexture();
        },
        get cacheAsBitmap () {
            return this.isCachedAsTexture;
        },
        set cacheAsBitmap (i){
            et("v8.6.0", "cacheAsBitmap is deprecated, use cacheAsTexture instead."), this.cacheAsTexture(i);
        }
    };
    QT = function(i, e, t) {
        const n = i.length;
        let s;
        if (e >= n || t === 0) return;
        t = e + t > n ? n - e : t;
        const r = n - t;
        for(s = e; s < r; ++s)i[s] = i[s + t];
        i.length = r;
    };
    const eM = {
        allowChildren: !0,
        removeChildren (i = 0, e) {
            const t = e ?? this.children.length, n = t - i, s = [];
            if (n > 0 && n <= t) {
                for(let a = t - 1; a >= i; a--){
                    const o = this.children[a];
                    o && (s.push(o), o.parent = null);
                }
                QT(this.children, i, t);
                const r = this.renderGroup || this.parentRenderGroup;
                r && r.removeChildren(s);
                for(let a = 0; a < s.length; ++a)this.emit("childRemoved", s[a], this, a), s[a].emit("removed", this);
                return s.length > 0 && this._didViewChangeTick++, s;
            } else if (n === 0 && this.children.length === 0) return s;
            throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
        },
        removeChildAt (i) {
            const e = this.getChildAt(i);
            return this.removeChild(e);
        },
        getChildAt (i) {
            if (i < 0 || i >= this.children.length) throw new Error(`getChildAt: Index (${i}) does not exist.`);
            return this.children[i];
        },
        setChildIndex (i, e) {
            if (e < 0 || e >= this.children.length) throw new Error(`The index ${e} supplied is out of bounds ${this.children.length}`);
            this.getChildIndex(i), this.addChildAt(i, e);
        },
        getChildIndex (i) {
            const e = this.children.indexOf(i);
            if (e === -1) throw new Error("The supplied Container must be a child of the caller");
            return e;
        },
        addChildAt (i, e) {
            this.allowChildren || et(dt, "addChildAt: Only Containers will be allowed to add children in v8.0.0");
            const { children: t } = this;
            if (e < 0 || e > t.length) throw new Error(`${i}addChildAt: The index ${e} supplied is out of bounds ${t.length}`);
            if (i.parent) {
                const s = i.parent.children.indexOf(i);
                if (i.parent === this && s === e) return i;
                s !== -1 && i.parent.children.splice(s, 1);
            }
            e === t.length ? t.push(i) : t.splice(e, 0, i), i.parent = this, i.didChange = !0, i._updateFlags = 15;
            const n = this.renderGroup || this.parentRenderGroup;
            return n && n.addChild(i), this.sortableChildren && (this.sortDirty = !0), this.emit("childAdded", i, this, e), i.emit("added", this), i;
        },
        swapChildren (i, e) {
            if (i === e) return;
            const t = this.getChildIndex(i), n = this.getChildIndex(e);
            this.children[t] = e, this.children[n] = i;
            const s = this.renderGroup || this.parentRenderGroup;
            s && (s.structureDidChange = !0), this._didContainerChangeTick++;
        },
        removeFromParent () {
            this.parent?.removeChild(this);
        },
        reparentChild (...i) {
            return i.length === 1 ? this.reparentChildAt(i[0], this.children.length) : (i.forEach((e)=>this.reparentChildAt(e, this.children.length)), i[0]);
        },
        reparentChildAt (i, e) {
            if (i.parent === this) return this.setChildIndex(i, e), i;
            const t = i.worldTransform.clone();
            i.removeFromParent(), this.addChildAt(i, e);
            const n = this.worldTransform.clone();
            return n.invert(), t.prepend(n), i.setFromMatrix(t), i;
        }
    }, tM = {
        collectRenderables (i, e, t) {
            this.parentRenderLayer && this.parentRenderLayer !== t || this.globalDisplayStatus < 7 || !this.includeInBuild || (this.sortableChildren && this.sortChildren(), this.isSimple ? this.collectRenderablesSimple(i, e, t) : this.renderGroup ? e.renderPipes.renderGroup.addRenderGroup(this.renderGroup, i) : this.collectRenderablesWithEffects(i, e, t));
        },
        collectRenderablesSimple (i, e, t) {
            const n = this.children, s = n.length;
            for(let r = 0; r < s; r++)n[r].collectRenderables(i, e, t);
        },
        collectRenderablesWithEffects (i, e, t) {
            const { renderPipes: n } = e;
            for(let s = 0; s < this.effects.length; s++){
                const r = this.effects[s];
                n[r.pipe].push(r, this, i);
            }
            this.collectRenderablesSimple(i, e, t);
            for(let s = this.effects.length - 1; s >= 0; s--){
                const r = this.effects[s];
                n[r.pipe].pop(r, this, i);
            }
        }
    };
    class ro {
        constructor(){
            this.pipe = "filter", this.priority = 1;
        }
        destroy() {
            for(let e = 0; e < this.filters.length; e++)this.filters[e].destroy();
            this.filters = null, this.filterArea = null;
        }
    }
    class nM {
        constructor(){
            this._effectClasses = [], this._tests = [], this._initialized = !1;
        }
        init() {
            this._initialized || (this._initialized = !0, this._effectClasses.forEach((e)=>{
                this.add({
                    test: e.test,
                    maskClass: e
                });
            }));
        }
        add(e) {
            this._tests.push(e);
        }
        getMaskEffect(e) {
            this._initialized || this.init();
            for(let t = 0; t < this._tests.length; t++){
                const n = this._tests[t];
                if (n.test(e)) return Vt.get(n.maskClass, e);
            }
            return e;
        }
        returnMaskEffect(e) {
            Vt.return(e);
        }
    }
    const Bc = new nM;
    At.handleByList(J.MaskEffect, Bc._effectClasses);
    const iM = {
        _maskEffect: null,
        _maskOptions: {
            inverse: !1
        },
        _filterEffect: null,
        effects: [],
        _markStructureAsChanged () {
            const i = this.renderGroup || this.parentRenderGroup;
            i && (i.structureDidChange = !0);
        },
        addEffect (i) {
            this.effects.indexOf(i) === -1 && (this.effects.push(i), this.effects.sort((t, n)=>t.priority - n.priority), this._markStructureAsChanged(), this._updateIsSimple());
        },
        removeEffect (i) {
            const e = this.effects.indexOf(i);
            e !== -1 && (this.effects.splice(e, 1), this._markStructureAsChanged(), this._updateIsSimple());
        },
        set mask (i){
            const e = this._maskEffect;
            e?.mask !== i && (e && (this.removeEffect(e), Bc.returnMaskEffect(e), this._maskEffect = null), i != null && (this._maskEffect = Bc.getMaskEffect(i), this.addEffect(this._maskEffect)));
        },
        setMask (i) {
            this._maskOptions = {
                ...this._maskOptions,
                ...i
            }, i.mask && (this.mask = i.mask), this._markStructureAsChanged();
        },
        get mask () {
            return this._maskEffect?.mask;
        },
        set filters (i){
            !Array.isArray(i) && i && (i = [
                i
            ]);
            const e = this._filterEffect || (this._filterEffect = new ro);
            i = i;
            const t = i?.length > 0, n = e.filters?.length > 0, s = t !== n;
            i = Array.isArray(i) ? i.slice(0) : i, e.filters = Object.freeze(i), s && (t ? this.addEffect(e) : (this.removeEffect(e), e.filters = i ?? null));
        },
        get filters () {
            return this._filterEffect?.filters;
        },
        set filterArea (i){
            this._filterEffect || (this._filterEffect = new ro), this._filterEffect.filterArea = i;
        },
        get filterArea () {
            return this._filterEffect?.filterArea;
        }
    }, sM = {
        label: null,
        get name () {
            return et(dt, "Container.name property has been removed, use Container.label instead"), this.label;
        },
        set name (i){
            et(dt, "Container.name property has been removed, use Container.label instead"), this.label = i;
        },
        getChildByName (i, e = !1) {
            return this.getChildByLabel(i, e);
        },
        getChildByLabel (i, e = !1) {
            const t = this.children;
            for(let n = 0; n < t.length; n++){
                const s = t[n];
                if (s.label === i || i instanceof RegExp && i.test(s.label)) return s;
            }
            if (e) for(let n = 0; n < t.length; n++){
                const r = t[n].getChildByLabel(i, !0);
                if (r) return r;
            }
            return null;
        },
        getChildrenByLabel (i, e = !1, t = []) {
            const n = this.children;
            for(let s = 0; s < n.length; s++){
                const r = n[s];
                (r.label === i || i instanceof RegExp && i.test(r.label)) && t.push(r);
            }
            if (e) for(let s = 0; s < n.length; s++)n[s].getChildrenByLabel(i, !0, t);
            return t;
        }
    }, qt = new wh(Ne), ai = new wh(sn), rM = new Ne, aM = {
        getFastGlobalBounds (i, e) {
            e || (e = new sn), e.clear(), this._getGlobalBoundsRecursive(!!i, e, this.parentRenderLayer), e.isValid || e.set(0, 0, 0, 0);
            const t = this.renderGroup || this.parentRenderGroup;
            return e.applyMatrix(t.worldTransform), e;
        },
        _getGlobalBoundsRecursive (i, e, t) {
            let n = e;
            if (i && this.parentRenderLayer && this.parentRenderLayer !== t || this.localDisplayStatus !== 7 || !this.measurable) return;
            const s = !!this.effects.length;
            if ((this.renderGroup || s) && (n = ai.get().clear()), this.boundsArea) e.addRect(this.boundsArea, this.worldTransform);
            else {
                if (this.renderPipeId) {
                    const a = this.bounds;
                    n.addFrame(a.minX, a.minY, a.maxX, a.maxY, this.groupTransform);
                }
                const r = this.children;
                for(let a = 0; a < r.length; a++)r[a]._getGlobalBoundsRecursive(i, n, t);
            }
            if (s) {
                let r = !1;
                const a = this.renderGroup || this.parentRenderGroup;
                for(let o = 0; o < this.effects.length; o++)this.effects[o].addBounds && (r || (r = !0, n.applyMatrix(a.worldTransform)), this.effects[o].addBounds(n, !0));
                r && (n.applyMatrix(a.worldTransform.copyTo(rM).invert()), e.addBounds(n, this.relativeGroupTransform)), e.addBounds(n), ai.return(n);
            } else this.renderGroup && (e.addBounds(n, this.relativeGroupTransform), ai.return(n));
        }
    };
    function Rh(i, e, t) {
        t.clear();
        let n, s;
        return i.parent ? e ? n = i.parent.worldTransform : (s = qt.get().identity(), n = Ch(i, s)) : n = Ne.IDENTITY, Jp(i, t, n, e), s && qt.return(s), t.isValid || t.set(0, 0, 0, 0), t;
    }
    function Jp(i, e, t, n) {
        if (!i.visible || !i.measurable) return;
        let s;
        n ? s = i.worldTransform : (i.updateLocalTransform(), s = qt.get(), s.appendFrom(i.localTransform, t));
        const r = e, a = !!i.effects.length;
        if (a && (e = ai.get().clear()), i.boundsArea) e.addRect(i.boundsArea, s);
        else {
            i.bounds && (e.matrix = s, e.addBounds(i.bounds));
            for(let o = 0; o < i.children.length; o++)Jp(i.children[o], e, s, n);
        }
        if (a) {
            for(let o = 0; o < i.effects.length; o++)i.effects[o].addBounds?.(e);
            r.addBounds(e, Ne.IDENTITY), ai.return(e);
        }
        n || qt.return(s);
    }
    function Ch(i, e) {
        const t = i.parent;
        return t && (Ch(t, e), t.updateLocalTransform(), e.append(t.localTransform)), e;
    }
    function Qp(i, e) {
        if (i === 16777215 || !e) return e;
        if (e === 16777215 || !i) return i;
        const t = i >> 16 & 255, n = i >> 8 & 255, s = i & 255, r = e >> 16 & 255, a = e >> 8 & 255, o = e & 255, l = t * r / 255 | 0, h = n * a / 255 | 0, d = s * o / 255 | 0;
        return (l << 16) + (h << 8) + d;
    }
    const Hd = 16777215;
    function ao(i, e) {
        return i === Hd ? e : e === Hd ? i : Qp(i, e);
    }
    function ja(i) {
        return ((i & 255) << 16) + (i & 65280) + (i >> 16 & 255);
    }
    const oM = {
        getGlobalAlpha (i) {
            if (i) return this.renderGroup ? this.renderGroup.worldAlpha : this.parentRenderGroup ? this.parentRenderGroup.worldAlpha * this.alpha : this.alpha;
            let e = this.alpha, t = this.parent;
            for(; t;)e *= t.alpha, t = t.parent;
            return e;
        },
        getGlobalTransform (i, e) {
            if (e) return i.copyFrom(this.worldTransform);
            this.updateLocalTransform();
            const t = Ch(this, qt.get().identity());
            return i.appendFrom(this.localTransform, t), qt.return(t), i;
        },
        getGlobalTint (i) {
            if (i) return this.renderGroup ? ja(this.renderGroup.worldColor) : this.parentRenderGroup ? ja(ao(this.localColor, this.parentRenderGroup.worldColor)) : this.tint;
            let e = this.localColor, t = this.parent;
            for(; t;)e = ao(e, t.localColor), t = t.parent;
            return ja(e);
        }
    };
    let ol = 0;
    const zd = 500;
    tt = function(...i) {
        ol !== zd && (ol++, ol === zd ? console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.") : console.warn("PixiJS Warning: ", ...i));
    };
    function Ph(i, e, t) {
        return e.clear(), t || (t = Ne.IDENTITY), em(i, e, t, i, !0), e.isValid || e.set(0, 0, 0, 0), e;
    }
    function em(i, e, t, n, s) {
        let r;
        if (s) r = qt.get(), r = t.copyTo(r);
        else {
            if (!i.visible || !i.measurable) return;
            i.updateLocalTransform();
            const l = i.localTransform;
            r = qt.get(), r.appendFrom(l, t);
        }
        const a = e, o = !!i.effects.length;
        if (o && (e = ai.get().clear()), i.boundsArea) e.addRect(i.boundsArea, r);
        else {
            i.renderPipeId && (e.matrix = r, e.addBounds(i.bounds));
            const l = i.children;
            for(let h = 0; h < l.length; h++)em(l[h], e, r, n, !1);
        }
        if (o) {
            for(let l = 0; l < i.effects.length; l++)i.effects[l].addLocalBounds?.(e, n);
            a.addBounds(e, Ne.IDENTITY), ai.return(e);
        }
        qt.return(r);
    }
    function tm(i, e) {
        const t = i.children;
        for(let n = 0; n < t.length; n++){
            const s = t[n], r = s.uid, a = (s._didViewChangeTick & 65535) << 16 | s._didContainerChangeTick & 65535, o = e.index;
            (e.data[o] !== r || e.data[o + 1] !== a) && (e.data[e.index] = r, e.data[e.index + 1] = a, e.didChange = !0), e.index = o + 2, s.children.length && tm(s, e);
        }
        return e.didChange;
    }
    const lM = new Ne, cM = {
        _localBoundsCacheId: -1,
        _localBoundsCacheData: null,
        _setWidth (i, e) {
            const t = Math.sign(this.scale.x) || 1;
            e !== 0 ? this.scale.x = i / e * t : this.scale.x = t;
        },
        _setHeight (i, e) {
            const t = Math.sign(this.scale.y) || 1;
            e !== 0 ? this.scale.y = i / e * t : this.scale.y = t;
        },
        getLocalBounds () {
            this._localBoundsCacheData || (this._localBoundsCacheData = {
                data: [],
                index: 1,
                didChange: !1,
                localBounds: new sn
            });
            const i = this._localBoundsCacheData;
            return i.index = 1, i.didChange = !1, i.data[0] !== this._didViewChangeTick && (i.didChange = !0, i.data[0] = this._didViewChangeTick), tm(this, i), i.didChange && Ph(this, i.localBounds, lM), i.localBounds;
        },
        getBounds (i, e) {
            return Rh(this, i, e || new sn);
        }
    }, hM = {
        _onRender: null,
        set onRender (i){
            const e = this.renderGroup || this.parentRenderGroup;
            if (!i) {
                this._onRender && e?.removeOnRender(this), this._onRender = null;
                return;
            }
            this._onRender || e?.addOnRender(this), this._onRender = i;
        },
        get onRender () {
            return this._onRender;
        }
    }, uM = {
        _zIndex: 0,
        sortDirty: !1,
        sortableChildren: !1,
        get zIndex () {
            return this._zIndex;
        },
        set zIndex (i){
            this._zIndex !== i && (this._zIndex = i, this.depthOfChildModified());
        },
        depthOfChildModified () {
            this.parent && (this.parent.sortableChildren = !0, this.parent.sortDirty = !0), this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0);
        },
        sortChildren () {
            this.sortDirty && (this.sortDirty = !1, this.children.sort(dM));
        }
    };
    function dM(i, e) {
        return i._zIndex - e._zIndex;
    }
    const fM = {
        getGlobalPosition (i = new Ot, e = !1) {
            return this.parent ? this.parent.toGlobal(this._position, i, e) : (i.x = this._position.x, i.y = this._position.y), i;
        },
        toGlobal (i, e, t = !1) {
            const n = this.getGlobalTransform(qt.get(), t);
            return e = n.apply(i, e), qt.return(n), e;
        },
        toLocal (i, e, t, n) {
            e && (i = e.toGlobal(i, t, n));
            const s = this.getGlobalTransform(qt.get(), n);
            return t = s.applyInverse(i, t), qt.return(s), t;
        }
    };
    class nm {
        constructor(){
            this.uid = xt("instructionSet"), this.instructions = [], this.instructionSize = 0, this.renderables = [], this.gcTick = 0;
        }
        reset() {
            this.instructionSize = 0;
        }
        add(e) {
            this.instructions[this.instructionSize++] = e;
        }
        log() {
            this.instructions.length = this.instructionSize, console.table(this.instructions, [
                "type",
                "action"
            ]);
        }
    }
    let pM = 0;
    class mM {
        constructor(e){
            this._poolKeyHash = Object.create(null), this._texturePool = {}, this.textureOptions = e || {}, this.enableFullScreen = !1;
        }
        createTexture(e, t, n) {
            const s = new kt({
                ...this.textureOptions,
                width: e,
                height: t,
                resolution: 1,
                antialias: n,
                autoGarbageCollect: !1
            });
            return new Ie({
                source: s,
                label: `texturePool_${pM++}`
            });
        }
        getOptimalTexture(e, t, n = 1, s) {
            let r = Math.ceil(e * n - 1e-6), a = Math.ceil(t * n - 1e-6);
            r = so(r), a = so(a);
            const o = (r << 17) + (a << 1) + (s ? 1 : 0);
            this._texturePool[o] || (this._texturePool[o] = []);
            let l = this._texturePool[o].pop();
            return l || (l = this.createTexture(r, a, s)), l.source._resolution = n, l.source.width = r / n, l.source.height = a / n, l.source.pixelWidth = r, l.source.pixelHeight = a, l.frame.x = 0, l.frame.y = 0, l.frame.width = e, l.frame.height = t, l.updateUvs(), this._poolKeyHash[l.uid] = o, l;
        }
        getSameSizeTexture(e, t = !1) {
            const n = e.source;
            return this.getOptimalTexture(e.width, e.height, n._resolution, t);
        }
        returnTexture(e) {
            const t = this._poolKeyHash[e.uid];
            this._texturePool[t].push(e);
        }
        clear(e) {
            if (e = e !== !1, e) for(const t in this._texturePool){
                const n = this._texturePool[t];
                if (n) for(let s = 0; s < n.length; s++)n[s].destroy(!0);
            }
            this._texturePool = {};
        }
    }
    Ls = new mM;
    class _M {
        constructor(){
            this.renderPipeId = "renderGroup", this.root = null, this.canBundle = !1, this.renderGroupParent = null, this.renderGroupChildren = [], this.worldTransform = new Ne, this.worldColorAlpha = 4294967295, this.worldColor = 16777215, this.worldAlpha = 1, this.childrenToUpdate = Object.create(null), this.updateTick = 0, this.gcTick = 0, this.childrenRenderablesToUpdate = {
                list: [],
                index: 0
            }, this.structureDidChange = !0, this.instructionSet = new nm, this._onRenderContainers = [], this.textureNeedsUpdate = !0, this.isCachedAsTexture = !1, this._matrixDirty = 7;
        }
        init(e) {
            this.root = e, e._onRender && this.addOnRender(e), e.didChange = !0;
            const t = e.children;
            for(let n = 0; n < t.length; n++){
                const s = t[n];
                s._updateFlags = 15, this.addChild(s);
            }
        }
        enableCacheAsTexture(e = {}) {
            this.textureOptions = e, this.isCachedAsTexture = !0, this.textureNeedsUpdate = !0;
        }
        disableCacheAsTexture() {
            this.isCachedAsTexture = !1, this.texture && (Ls.returnTexture(this.texture), this.texture = null);
        }
        updateCacheTexture() {
            this.textureNeedsUpdate = !0;
        }
        reset() {
            this.renderGroupChildren.length = 0;
            for(const e in this.childrenToUpdate){
                const t = this.childrenToUpdate[e];
                t.list.fill(null), t.index = 0;
            }
            this.childrenRenderablesToUpdate.index = 0, this.childrenRenderablesToUpdate.list.fill(null), this.root = null, this.updateTick = 0, this.structureDidChange = !0, this._onRenderContainers.length = 0, this.renderGroupParent = null, this.disableCacheAsTexture();
        }
        get localTransform() {
            return this.root.localTransform;
        }
        addRenderGroupChild(e) {
            e.renderGroupParent && e.renderGroupParent._removeRenderGroupChild(e), e.renderGroupParent = this, this.renderGroupChildren.push(e);
        }
        _removeRenderGroupChild(e) {
            const t = this.renderGroupChildren.indexOf(e);
            t > -1 && this.renderGroupChildren.splice(t, 1), e.renderGroupParent = null;
        }
        addChild(e) {
            if (this.structureDidChange = !0, e.parentRenderGroup = this, e.updateTick = -1, e.parent === this.root ? e.relativeRenderGroupDepth = 1 : e.relativeRenderGroupDepth = e.parent.relativeRenderGroupDepth + 1, e.didChange = !0, this.onChildUpdate(e), e.renderGroup) {
                this.addRenderGroupChild(e.renderGroup);
                return;
            }
            e._onRender && this.addOnRender(e);
            const t = e.children;
            for(let n = 0; n < t.length; n++)this.addChild(t[n]);
        }
        removeChild(e) {
            if (this.structureDidChange = !0, e._onRender && (e.renderGroup || this.removeOnRender(e)), e.parentRenderGroup = null, e.renderGroup) {
                this._removeRenderGroupChild(e.renderGroup);
                return;
            }
            const t = e.children;
            for(let n = 0; n < t.length; n++)this.removeChild(t[n]);
        }
        removeChildren(e) {
            for(let t = 0; t < e.length; t++)this.removeChild(e[t]);
        }
        onChildUpdate(e) {
            let t = this.childrenToUpdate[e.relativeRenderGroupDepth];
            t || (t = this.childrenToUpdate[e.relativeRenderGroupDepth] = {
                index: 0,
                list: []
            }), t.list[t.index++] = e;
        }
        updateRenderable(e) {
            e.globalDisplayStatus < 7 || (this.instructionSet.renderPipes[e.renderPipeId].updateRenderable(e), e.didViewUpdate = !1);
        }
        onChildViewUpdate(e) {
            this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = e;
        }
        get isRenderable() {
            return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;
        }
        addOnRender(e) {
            this._onRenderContainers.push(e);
        }
        removeOnRender(e) {
            this._onRenderContainers.splice(this._onRenderContainers.indexOf(e), 1);
        }
        runOnRender(e) {
            for(let t = 0; t < this._onRenderContainers.length; t++)this._onRenderContainers[t]._onRender(e);
        }
        destroy() {
            this.disableCacheAsTexture(), this.renderGroupParent = null, this.root = null, this.childrenRenderablesToUpdate = null, this.childrenToUpdate = null, this.renderGroupChildren = null, this._onRenderContainers = null, this.instructionSet = null;
        }
        getChildren(e = []) {
            const t = this.root.children;
            for(let n = 0; n < t.length; n++)this._getChildren(t[n], e);
            return e;
        }
        _getChildren(e, t = []) {
            if (t.push(e), e.renderGroup) return t;
            const n = e.children;
            for(let s = 0; s < n.length; s++)this._getChildren(n[s], t);
            return t;
        }
        invalidateMatrices() {
            this._matrixDirty = 7;
        }
        get inverseWorldTransform() {
            return (this._matrixDirty & 1) === 0 ? this._inverseWorldTransform : (this._matrixDirty &= -2, this._inverseWorldTransform || (this._inverseWorldTransform = new Ne), this._inverseWorldTransform.copyFrom(this.worldTransform).invert());
        }
        get textureOffsetInverseTransform() {
            return (this._matrixDirty & 2) === 0 ? this._textureOffsetInverseTransform : (this._matrixDirty &= -3, this._textureOffsetInverseTransform || (this._textureOffsetInverseTransform = new Ne), this._textureOffsetInverseTransform.copyFrom(this.inverseWorldTransform).translate(-this._textureBounds.x, -this._textureBounds.y));
        }
        get inverseParentTextureTransform() {
            if ((this._matrixDirty & 4) === 0) return this._inverseParentTextureTransform;
            this._matrixDirty &= -5;
            const e = this._parentCacheAsTextureRenderGroup;
            return e ? (this._inverseParentTextureTransform || (this._inverseParentTextureTransform = new Ne), this._inverseParentTextureTransform.copyFrom(this.worldTransform).prepend(e.inverseWorldTransform).translate(-e._textureBounds.x, -e._textureBounds.y)) : this.worldTransform;
        }
        get cacheToLocalTransform() {
            return this._parentCacheAsTextureRenderGroup ? this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform : null;
        }
    }
    function gM(i, e, t = {}) {
        for(const n in e)!t[n] && e[n] !== void 0 && (i[n] = e[n]);
    }
    const ll = new en(null), cl = new en(null), hl = new en(null, 1, 1), oo = 1, Ih = 2, Lr = 4;
    Jt = class extends yn {
        constructor(e = {}){
            super(), this.uid = xt("renderable"), this._updateFlags = 15, this.renderGroup = null, this.parentRenderGroup = null, this.parentRenderGroupIndex = 0, this.didChange = !1, this.didViewUpdate = !1, this.relativeRenderGroupDepth = 0, this.children = [], this.parent = null, this.includeInBuild = !0, this.measurable = !0, this.isSimple = !0, this.updateTick = -1, this.localTransform = new Ne, this.relativeGroupTransform = new Ne, this.groupTransform = this.relativeGroupTransform, this.destroyed = !1, this._position = new en(this, 0, 0), this._scale = hl, this._pivot = cl, this._skew = ll, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._rotation = 0, this.localColor = 16777215, this.localAlpha = 1, this.groupAlpha = 1, this.groupColor = 16777215, this.groupColorAlpha = 4294967295, this.localBlendMode = "inherit", this.groupBlendMode = "normal", this.localDisplayStatus = 7, this.globalDisplayStatus = 7, this._didContainerChangeTick = 0, this._didViewChangeTick = 0, this._didLocalTransformChangeId = -1, this.effects = [], gM(this, e, {
                children: !0,
                parent: !0,
                effects: !0
            }), e.children?.forEach((t)=>this.addChild(t)), e.parent?.addChild(this);
        }
        static mixin(e) {
            et("8.8.0", "Container.mixin is deprecated, please use extensions.mixin instead."), At.mixin(Jt, e);
        }
        set _didChangeId(e) {
            this._didViewChangeTick = e >> 12 & 4095, this._didContainerChangeTick = e & 4095;
        }
        get _didChangeId() {
            return this._didContainerChangeTick & 4095 | (this._didViewChangeTick & 4095) << 12;
        }
        addChild(...e) {
            if (this.allowChildren || et(dt, "addChild: Only Containers will be allowed to add children in v8.0.0"), e.length > 1) {
                for(let s = 0; s < e.length; s++)this.addChild(e[s]);
                return e[0];
            }
            const t = e[0], n = this.renderGroup || this.parentRenderGroup;
            return t.parent === this ? (this.children.splice(this.children.indexOf(t), 1), this.children.push(t), n && (n.structureDidChange = !0), t) : (t.parent && t.parent.removeChild(t), this.children.push(t), this.sortableChildren && (this.sortDirty = !0), t.parent = this, t.didChange = !0, t._updateFlags = 15, n && n.addChild(t), this.emit("childAdded", t, this, this.children.length - 1), t.emit("added", this), this._didViewChangeTick++, t._zIndex !== 0 && t.depthOfChildModified(), t);
        }
        removeChild(...e) {
            if (e.length > 1) {
                for(let s = 0; s < e.length; s++)this.removeChild(e[s]);
                return e[0];
            }
            const t = e[0], n = this.children.indexOf(t);
            return n > -1 && (this._didViewChangeTick++, this.children.splice(n, 1), this.renderGroup ? this.renderGroup.removeChild(t) : this.parentRenderGroup && this.parentRenderGroup.removeChild(t), t.parentRenderLayer && t.parentRenderLayer.detach(t), t.parent = null, this.emit("childRemoved", t, this, n), t.emit("removed", this)), t;
        }
        _onUpdate(e) {
            e && e === this._skew && this._updateSkew(), this._didContainerChangeTick++, !this.didChange && (this.didChange = !0, this.parentRenderGroup && this.parentRenderGroup.onChildUpdate(this));
        }
        set isRenderGroup(e) {
            !!this.renderGroup !== e && (e ? this.enableRenderGroup() : this.disableRenderGroup());
        }
        get isRenderGroup() {
            return !!this.renderGroup;
        }
        enableRenderGroup() {
            if (this.renderGroup) return;
            const e = this.parentRenderGroup;
            e?.removeChild(this), this.renderGroup = Vt.get(_M, this), this.groupTransform = Ne.IDENTITY, e?.addChild(this), this._updateIsSimple();
        }
        disableRenderGroup() {
            if (!this.renderGroup) return;
            const e = this.parentRenderGroup;
            e?.removeChild(this), Vt.return(this.renderGroup), this.renderGroup = null, this.groupTransform = this.relativeGroupTransform, e?.addChild(this), this._updateIsSimple();
        }
        _updateIsSimple() {
            this.isSimple = !this.renderGroup && this.effects.length === 0;
        }
        get worldTransform() {
            return this._worldTransform || (this._worldTransform = new Ne), this.renderGroup ? this._worldTransform.copyFrom(this.renderGroup.worldTransform) : this.parentRenderGroup && this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform), this._worldTransform;
        }
        get x() {
            return this._position.x;
        }
        set x(e) {
            this._position.x = e;
        }
        get y() {
            return this._position.y;
        }
        set y(e) {
            this._position.y = e;
        }
        get position() {
            return this._position;
        }
        set position(e) {
            this._position.copyFrom(e);
        }
        get rotation() {
            return this._rotation;
        }
        set rotation(e) {
            this._rotation !== e && (this._rotation = e, this._onUpdate(this._skew));
        }
        get angle() {
            return this.rotation * DT;
        }
        set angle(e) {
            this.rotation = e * LT;
        }
        get pivot() {
            return this._pivot === cl && (this._pivot = new en(this, 0, 0)), this._pivot;
        }
        set pivot(e) {
            this._pivot === cl && (this._pivot = new en(this, 0, 0)), typeof e == "number" ? this._pivot.set(e) : this._pivot.copyFrom(e);
        }
        get skew() {
            return this._skew === ll && (this._skew = new en(this, 0, 0)), this._skew;
        }
        set skew(e) {
            this._skew === ll && (this._skew = new en(this, 0, 0)), this._skew.copyFrom(e);
        }
        get scale() {
            return this._scale === hl && (this._scale = new en(this, 1, 1)), this._scale;
        }
        set scale(e) {
            this._scale === hl && (this._scale = new en(this, 0, 0)), typeof e == "number" ? this._scale.set(e) : this._scale.copyFrom(e);
        }
        get width() {
            return Math.abs(this.scale.x * this.getLocalBounds().width);
        }
        set width(e) {
            const t = this.getLocalBounds().width;
            this._setWidth(e, t);
        }
        get height() {
            return Math.abs(this.scale.y * this.getLocalBounds().height);
        }
        set height(e) {
            const t = this.getLocalBounds().height;
            this._setHeight(e, t);
        }
        getSize(e) {
            e || (e = {});
            const t = this.getLocalBounds();
            return e.width = Math.abs(this.scale.x * t.width), e.height = Math.abs(this.scale.y * t.height), e;
        }
        setSize(e, t) {
            const n = this.getLocalBounds();
            typeof e == "object" ? (t = e.height ?? e.width, e = e.width) : t ?? (t = e), e !== void 0 && this._setWidth(e, n.width), t !== void 0 && this._setHeight(t, n.height);
        }
        _updateSkew() {
            const e = this._rotation, t = this._skew;
            this._cx = Math.cos(e + t._y), this._sx = Math.sin(e + t._y), this._cy = -Math.sin(e - t._x), this._sy = Math.cos(e - t._x);
        }
        updateTransform(e) {
            return this.position.set(typeof e.x == "number" ? e.x : this.position.x, typeof e.y == "number" ? e.y : this.position.y), this.scale.set(typeof e.scaleX == "number" ? e.scaleX || 1 : this.scale.x, typeof e.scaleY == "number" ? e.scaleY || 1 : this.scale.y), this.rotation = typeof e.rotation == "number" ? e.rotation : this.rotation, this.skew.set(typeof e.skewX == "number" ? e.skewX : this.skew.x, typeof e.skewY == "number" ? e.skewY : this.skew.y), this.pivot.set(typeof e.pivotX == "number" ? e.pivotX : this.pivot.x, typeof e.pivotY == "number" ? e.pivotY : this.pivot.y), this;
        }
        setFromMatrix(e) {
            e.decompose(this);
        }
        updateLocalTransform() {
            const e = this._didContainerChangeTick;
            if (this._didLocalTransformChangeId === e) return;
            this._didLocalTransformChangeId = e;
            const t = this.localTransform, n = this._scale, s = this._pivot, r = this._position, a = n._x, o = n._y, l = s._x, h = s._y;
            t.a = this._cx * a, t.b = this._sx * a, t.c = this._cy * o, t.d = this._sy * o, t.tx = r._x - (l * t.a + h * t.c), t.ty = r._y - (l * t.b + h * t.d);
        }
        set alpha(e) {
            e !== this.localAlpha && (this.localAlpha = e, this._updateFlags |= oo, this._onUpdate());
        }
        get alpha() {
            return this.localAlpha;
        }
        set tint(e) {
            const n = Et.shared.setValue(e ?? 16777215).toBgrNumber();
            n !== this.localColor && (this.localColor = n, this._updateFlags |= oo, this._onUpdate());
        }
        get tint() {
            return ja(this.localColor);
        }
        set blendMode(e) {
            this.localBlendMode !== e && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._updateFlags |= Ih, this.localBlendMode = e, this._onUpdate());
        }
        get blendMode() {
            return this.localBlendMode;
        }
        get visible() {
            return !!(this.localDisplayStatus & 2);
        }
        set visible(e) {
            const t = e ? 2 : 0;
            (this.localDisplayStatus & 2) !== t && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._updateFlags |= Lr, this.localDisplayStatus ^= 2, this._onUpdate());
        }
        get culled() {
            return !(this.localDisplayStatus & 4);
        }
        set culled(e) {
            const t = e ? 0 : 4;
            (this.localDisplayStatus & 4) !== t && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._updateFlags |= Lr, this.localDisplayStatus ^= 4, this._onUpdate());
        }
        get renderable() {
            return !!(this.localDisplayStatus & 1);
        }
        set renderable(e) {
            const t = e ? 1 : 0;
            (this.localDisplayStatus & 1) !== t && (this._updateFlags |= Lr, this.localDisplayStatus ^= 1, this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._onUpdate());
        }
        get isRenderable() {
            return this.localDisplayStatus === 7 && this.groupAlpha > 0;
        }
        destroy(e = !1) {
            if (this.destroyed) return;
            this.destroyed = !0;
            let t;
            if (this.children.length && (t = this.removeChildren(0, this.children.length)), this.removeFromParent(), this.parent = null, this._maskEffect = null, this._filterEffect = null, this.effects = null, this._position = null, this._scale = null, this._pivot = null, this._skew = null, this.emit("destroyed", this), this.removeAllListeners(), (typeof e == "boolean" ? e : e?.children) && t) for(let s = 0; s < t.length; ++s)t[s].destroy(e);
            this.renderGroup?.destroy(), this.renderGroup = null;
        }
    };
    At.mixin(Jt, eM, aM, fM, hM, cM, iM, sM, uM, KT, JT, oM, tM);
    class Dh extends Jt {
        constructor(e){
            super(e), this.canBundle = !0, this.allowChildren = !1, this._roundPixels = 0, this._lastUsed = -1, this._bounds = new sn(0, 1, 0, 0), this._boundsDirty = !0;
        }
        get bounds() {
            return this._boundsDirty ? (this.updateBounds(), this._boundsDirty = !1, this._bounds) : this._bounds;
        }
        get roundPixels() {
            return !!this._roundPixels;
        }
        set roundPixels(e) {
            this._roundPixels = e ? 1 : 0;
        }
        containsPoint(e) {
            const t = this.bounds, { x: n, y: s } = e;
            return n >= t.minX && n <= t.maxX && s >= t.minY && s <= t.maxY;
        }
        onViewUpdate() {
            if (this._didViewChangeTick++, this._boundsDirty = !0, this.didViewUpdate) return;
            this.didViewUpdate = !0;
            const e = this.renderGroup || this.parentRenderGroup;
            e && e.onChildViewUpdate(this);
        }
        destroy(e) {
            super.destroy(e), this._bounds = null;
        }
        collectRenderablesSimple(e, t, n) {
            const { renderPipes: s, renderableGC: r } = t;
            s.blendMode.setBlendMode(this, this.groupBlendMode, e), s[this.renderPipeId].addRenderable(this, e), r.addRenderable(this), this.didViewUpdate = !1;
            const o = this.children, l = o.length;
            for(let h = 0; h < l; h++)o[h].collectRenderables(e, t, n);
        }
    }
    class es extends Dh {
        constructor(e = Ie.EMPTY){
            e instanceof Ie && (e = {
                texture: e
            });
            const { texture: t = Ie.EMPTY, anchor: n, roundPixels: s, width: r, height: a, ...o } = e;
            super({
                label: "Sprite",
                ...o
            }), this.renderPipeId = "sprite", this.batched = !0, this._visualBounds = {
                minX: 0,
                maxX: 1,
                minY: 0,
                maxY: 0
            }, this._anchor = new en({
                _onUpdate: ()=>{
                    this.onViewUpdate();
                }
            }), n ? this.anchor = n : t.defaultAnchor && (this.anchor = t.defaultAnchor), this.texture = t, this.allowChildren = !1, this.roundPixels = s ?? !1, r !== void 0 && (this.width = r), a !== void 0 && (this.height = a);
        }
        static from(e, t = !1) {
            return e instanceof Ie ? new es(e) : new es(Ie.from(e, t));
        }
        set texture(e) {
            e || (e = Ie.EMPTY);
            const t = this._texture;
            t !== e && (t && t.dynamic && t.off("update", this.onViewUpdate, this), e.dynamic && e.on("update", this.onViewUpdate, this), this._texture = e, this._width && this._setWidth(this._width, this._texture.orig.width), this._height && this._setHeight(this._height, this._texture.orig.height), this.onViewUpdate());
        }
        get texture() {
            return this._texture;
        }
        get visualBounds() {
            return GT(this._visualBounds, this._anchor, this._texture), this._visualBounds;
        }
        get sourceBounds() {
            return et("8.6.1", "Sprite.sourceBounds is deprecated, use visualBounds instead."), this.visualBounds;
        }
        updateBounds() {
            const e = this._anchor, t = this._texture, n = this._bounds, { width: s, height: r } = t.orig;
            n.minX = -e._x * s, n.maxX = n.minX + s, n.minY = -e._y * r, n.maxY = n.minY + r;
        }
        destroy(e = !1) {
            if (super.destroy(e), typeof e == "boolean" ? e : e?.texture) {
                const n = typeof e == "boolean" ? e : e?.textureSource;
                this._texture.destroy(n);
            }
            this._texture = null, this._visualBounds = null, this._bounds = null, this._anchor = null;
        }
        get anchor() {
            return this._anchor;
        }
        set anchor(e) {
            typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e);
        }
        get width() {
            return Math.abs(this.scale.x) * this._texture.orig.width;
        }
        set width(e) {
            this._setWidth(e, this._texture.orig.width), this._width = e;
        }
        get height() {
            return Math.abs(this.scale.y) * this._texture.orig.height;
        }
        set height(e) {
            this._setHeight(e, this._texture.orig.height), this._height = e;
        }
        getSize(e) {
            return e || (e = {}), e.width = Math.abs(this.scale.x) * this._texture.orig.width, e.height = Math.abs(this.scale.y) * this._texture.orig.height, e;
        }
        setSize(e, t) {
            typeof e == "object" ? (t = e.height ?? e.width, e = e.width) : t ?? (t = e), e !== void 0 && this._setWidth(e, this._texture.orig.width), t !== void 0 && this._setHeight(t, this._texture.orig.height);
        }
    }
    const xM = new sn;
    function im(i, e, t) {
        const n = xM;
        i.measurable = !0, Rh(i, t, n), e.addBoundsMask(n), i.measurable = !1;
    }
    function sm(i, e, t) {
        const n = ai.get();
        i.measurable = !0;
        const s = qt.get().identity(), r = rm(i, t, s);
        Ph(i, n, r), i.measurable = !1, e.addBoundsMask(n), qt.return(s), ai.return(n);
    }
    function rm(i, e, t) {
        return i ? (i !== e && (rm(i.parent, e, t), i.updateLocalTransform(), t.append(i.localTransform)), t) : (tt("Mask bounds, renderable is not inside the root container"), t);
    }
    class am {
        constructor(e){
            this.priority = 0, this.inverse = !1, this.pipe = "alphaMask", e?.mask && this.init(e.mask);
        }
        init(e) {
            this.mask = e, this.renderMaskToTexture = !(e instanceof es), this.mask.renderable = this.renderMaskToTexture, this.mask.includeInBuild = !this.renderMaskToTexture, this.mask.measurable = !1;
        }
        reset() {
            this.mask.measurable = !0, this.mask = null;
        }
        addBounds(e, t) {
            this.inverse || im(this.mask, e, t);
        }
        addLocalBounds(e, t) {
            sm(this.mask, e, t);
        }
        containsPoint(e, t) {
            const n = this.mask;
            return t(n, e);
        }
        destroy() {
            this.reset();
        }
        static test(e) {
            return e instanceof es;
        }
    }
    am.extension = J.MaskEffect;
    class om {
        constructor(e){
            this.priority = 0, this.pipe = "colorMask", e?.mask && this.init(e.mask);
        }
        init(e) {
            this.mask = e;
        }
        destroy() {}
        static test(e) {
            return typeof e == "number";
        }
    }
    om.extension = J.MaskEffect;
    class lm {
        constructor(e){
            this.priority = 0, this.pipe = "stencilMask", e?.mask && this.init(e.mask);
        }
        init(e) {
            this.mask = e, this.mask.includeInBuild = !1, this.mask.measurable = !1;
        }
        reset() {
            this.mask.measurable = !0, this.mask.includeInBuild = !0, this.mask = null;
        }
        addBounds(e, t) {
            im(this.mask, e, t);
        }
        addLocalBounds(e, t) {
            sm(this.mask, e, t);
        }
        containsPoint(e, t) {
            const n = this.mask;
            return t(n, e);
        }
        destroy() {
            this.reset();
        }
        static test(e) {
            return e instanceof Jt;
        }
    }
    lm.extension = J.MaskEffect;
    const vM = {
        createCanvas: (i, e)=>{
            const t = document.createElement("canvas");
            return t.width = i, t.height = e, t;
        },
        getCanvasRenderingContext2D: ()=>CanvasRenderingContext2D,
        getWebGLRenderingContext: ()=>WebGLRenderingContext,
        getNavigator: ()=>navigator,
        getBaseUrl: ()=>document.baseURI ?? window.location.href,
        getFontFaceSet: ()=>document.fonts,
        fetch: (i, e)=>fetch(i, e),
        parseXML: (i)=>new DOMParser().parseFromString(i, "text/xml")
    };
    let Vd = vM;
    _t = {
        get () {
            return Vd;
        },
        set (i) {
            Vd = i;
        }
    };
    class Ai extends kt {
        constructor(e){
            e.resource || (e.resource = _t.get().createCanvas()), e.width || (e.width = e.resource.width, e.autoDensity || (e.width /= e.resolution)), e.height || (e.height = e.resource.height, e.autoDensity || (e.height /= e.resolution)), super(e), this.uploadMethodId = "image", this.autoDensity = e.autoDensity, this.resizeCanvas(), this.transparent = !!e.transparent;
        }
        resizeCanvas() {
            this.autoDensity && "style" in this.resource && (this.resource.style.width = `${this.width}px`, this.resource.style.height = `${this.height}px`), (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) && (this.resource.width = this.pixelWidth, this.resource.height = this.pixelHeight);
        }
        resize(e = this.width, t = this.height, n = this._resolution) {
            const s = super.resize(e, t, n);
            return s && this.resizeCanvas(), s;
        }
        static test(e) {
            return globalThis.HTMLCanvasElement && e instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && e instanceof OffscreenCanvas;
        }
        get context2D() {
            return this._context2D || (this._context2D = this.resource.getContext("2d"));
        }
    }
    Ai.extension = J.TextureSource;
    class ts extends kt {
        constructor(e){
            if (e.resource && globalThis.HTMLImageElement && e.resource instanceof HTMLImageElement) {
                const t = _t.get().createCanvas(e.resource.width, e.resource.height);
                t.getContext("2d").drawImage(e.resource, 0, 0, e.resource.width, e.resource.height), e.resource = t, tt("ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.");
            }
            super(e), this.uploadMethodId = "image", this.autoGarbageCollect = !0;
        }
        static test(e) {
            return globalThis.HTMLImageElement && e instanceof HTMLImageElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap || globalThis.VideoFrame && e instanceof VideoFrame;
        }
    }
    ts.extension = J.TextureSource;
    Uc = ((i)=>(i[i.INTERACTION = 50] = "INTERACTION", i[i.HIGH = 25] = "HIGH", i[i.NORMAL = 0] = "NORMAL", i[i.LOW = -25] = "LOW", i[i.UTILITY = -50] = "UTILITY", i))(Uc || {});
    class ul {
        constructor(e, t = null, n = 0, s = !1){
            this.next = null, this.previous = null, this._destroyed = !1, this._fn = e, this._context = t, this.priority = n, this._once = s;
        }
        match(e, t = null) {
            return this._fn === e && this._context === t;
        }
        emit(e) {
            this._fn && (this._context ? this._fn.call(this._context, e) : this._fn(e));
            const t = this.next;
            return this._once && this.destroy(!0), this._destroyed && (this.next = null), t;
        }
        connect(e) {
            this.previous = e, e.next && (e.next.previous = this), this.next = e.next, e.next = this;
        }
        destroy(e = !1) {
            this._destroyed = !0, this._fn = null, this._context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
            const t = this.next;
            return this.next = e ? null : t, this.previous = null, t;
        }
    }
    const cm = class ln {
        constructor(){
            this.autoStart = !1, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = !1, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = !1, this._lastFrame = -1, this._head = new ul(null, null, 1 / 0), this.deltaMS = 1 / ln.targetFPMS, this.elapsedMS = 1 / ln.targetFPMS, this._tick = (e)=>{
                this._requestId = null, this.started && (this.update(e), this.started && this._requestId === null && this._head.next && (this._requestId = requestAnimationFrame(this._tick)));
            };
        }
        _requestIfNeeded() {
            this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));
        }
        _cancelIfNeeded() {
            this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null);
        }
        _startIfPossible() {
            this.started ? this._requestIfNeeded() : this.autoStart && this.start();
        }
        add(e, t, n = Uc.NORMAL) {
            return this._addListener(new ul(e, t, n));
        }
        addOnce(e, t, n = Uc.NORMAL) {
            return this._addListener(new ul(e, t, n, !0));
        }
        _addListener(e) {
            let t = this._head.next, n = this._head;
            if (!t) e.connect(n);
            else {
                for(; t;){
                    if (e.priority > t.priority) {
                        e.connect(n);
                        break;
                    }
                    n = t, t = t.next;
                }
                e.previous || e.connect(n);
            }
            return this._startIfPossible(), this;
        }
        remove(e, t) {
            let n = this._head.next;
            for(; n;)n.match(e, t) ? n = n.destroy() : n = n.next;
            return this._head.next || this._cancelIfNeeded(), this;
        }
        get count() {
            if (!this._head) return 0;
            let e = 0, t = this._head;
            for(; t = t.next;)e++;
            return e;
        }
        start() {
            this.started || (this.started = !0, this._requestIfNeeded());
        }
        stop() {
            this.started && (this.started = !1, this._cancelIfNeeded());
        }
        destroy() {
            if (!this._protected) {
                this.stop();
                let e = this._head.next;
                for(; e;)e = e.destroy(!0);
                this._head.destroy(), this._head = null;
            }
        }
        update(e = performance.now()) {
            let t;
            if (e > this.lastTime) {
                if (t = this.elapsedMS = e - this.lastTime, t > this._maxElapsedMS && (t = this._maxElapsedMS), t *= this.speed, this._minElapsedMS) {
                    const r = e - this._lastFrame | 0;
                    if (r < this._minElapsedMS) return;
                    this._lastFrame = e - r % this._minElapsedMS;
                }
                this.deltaMS = t, this.deltaTime = this.deltaMS * ln.targetFPMS;
                const n = this._head;
                let s = n.next;
                for(; s;)s = s.emit(this);
                n.next || this._cancelIfNeeded();
            } else this.deltaTime = this.deltaMS = this.elapsedMS = 0;
            this.lastTime = e;
        }
        get FPS() {
            return 1e3 / this.elapsedMS;
        }
        get minFPS() {
            return 1e3 / this._maxElapsedMS;
        }
        set minFPS(e) {
            const t = Math.min(this.maxFPS, e), n = Math.min(Math.max(0, t) / 1e3, ln.targetFPMS);
            this._maxElapsedMS = 1 / n;
        }
        get maxFPS() {
            return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;
        }
        set maxFPS(e) {
            if (e === 0) this._minElapsedMS = 0;
            else {
                const t = Math.max(this.minFPS, e);
                this._minElapsedMS = 1 / (t / 1e3);
            }
        }
        static get shared() {
            if (!ln._shared) {
                const e = ln._shared = new ln;
                e.autoStart = !0, e._protected = !0;
            }
            return ln._shared;
        }
        static get system() {
            if (!ln._system) {
                const e = ln._system = new ln;
                e.autoStart = !0, e._protected = !0;
            }
            return ln._system;
        }
    };
    cm.targetFPMS = .06;
    let dl;
    Ps = cm;
    async function hm() {
        return dl ?? (dl = (async ()=>{
            const e = document.createElement("canvas").getContext("webgl");
            if (!e) return "premultiply-alpha-on-upload";
            const t = await new Promise((a)=>{
                const o = document.createElement("video");
                o.onloadeddata = ()=>a(o), o.onerror = ()=>a(null), o.autoplay = !1, o.crossOrigin = "anonymous", o.preload = "auto", o.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=", o.load();
            });
            if (!t) return "premultiply-alpha-on-upload";
            const n = e.createTexture();
            e.bindTexture(e.TEXTURE_2D, n);
            const s = e.createFramebuffer();
            e.bindFramebuffer(e.FRAMEBUFFER, s), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, n, 0), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, e.NONE), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, t);
            const r = new Uint8Array(4);
            return e.readPixels(0, 0, 1, 1, e.RGBA, e.UNSIGNED_BYTE, r), e.deleteFramebuffer(s), e.deleteTexture(n), e.getExtension("WEBGL_lose_context")?.loseContext(), r[0] <= r[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload";
        })()), dl;
    }
    const mo = class um extends kt {
        constructor(e){
            super(e), this.isReady = !1, this.uploadMethodId = "video", e = {
                ...um.defaultOptions,
                ...e
            }, this._autoUpdate = !0, this._isConnectedToTicker = !1, this._updateFPS = e.updateFPS || 0, this._msToNextUpdate = 0, this.autoPlay = e.autoPlay !== !1, this.alphaMode = e.alphaMode ?? "premultiply-alpha-on-upload", this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this), this._videoFrameRequestCallbackHandle = null, this._load = null, this._resolve = null, this._reject = null, this._onCanPlay = this._onCanPlay.bind(this), this._onCanPlayThrough = this._onCanPlayThrough.bind(this), this._onError = this._onError.bind(this), this._onPlayStart = this._onPlayStart.bind(this), this._onPlayStop = this._onPlayStop.bind(this), this._onSeeked = this._onSeeked.bind(this), e.autoLoad !== !1 && this.load();
        }
        updateFrame() {
            if (!this.destroyed) {
                if (this._updateFPS) {
                    const e = Ps.shared.elapsedMS * this.resource.playbackRate;
                    this._msToNextUpdate = Math.floor(this._msToNextUpdate - e);
                }
                (!this._updateFPS || this._msToNextUpdate <= 0) && (this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0), this.isValid && this.update();
            }
        }
        _videoFrameRequestCallback() {
            this.updateFrame(), this.destroyed ? this._videoFrameRequestCallbackHandle = null : this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback);
        }
        get isValid() {
            return !!this.resource.videoWidth && !!this.resource.videoHeight;
        }
        async load() {
            if (this._load) return this._load;
            const e = this.resource, t = this.options;
            return (e.readyState === e.HAVE_ENOUGH_DATA || e.readyState === e.HAVE_FUTURE_DATA) && e.width && e.height && (e.complete = !0), e.addEventListener("play", this._onPlayStart), e.addEventListener("pause", this._onPlayStop), e.addEventListener("seeked", this._onSeeked), this._isSourceReady() ? this._mediaReady() : (t.preload || e.addEventListener("canplay", this._onCanPlay), e.addEventListener("canplaythrough", this._onCanPlayThrough), e.addEventListener("error", this._onError, !0)), this.alphaMode = await hm(), this._load = new Promise((n, s)=>{
                this.isValid ? n(this) : (this._resolve = n, this._reject = s, t.preloadTimeoutMs !== void 0 && (this._preloadTimeout = setTimeout(()=>{
                    this._onError(new ErrorEvent(`Preload exceeded timeout of ${t.preloadTimeoutMs}ms`));
                })), e.load());
            }), this._load;
        }
        _onError(e) {
            this.resource.removeEventListener("error", this._onError, !0), this.emit("error", e), this._reject && (this._reject(e), this._reject = null, this._resolve = null);
        }
        _isSourcePlaying() {
            const e = this.resource;
            return !e.paused && !e.ended;
        }
        _isSourceReady() {
            return this.resource.readyState > 2;
        }
        _onPlayStart() {
            this.isValid || this._mediaReady(), this._configureAutoUpdate();
        }
        _onPlayStop() {
            this._configureAutoUpdate();
        }
        _onSeeked() {
            this._autoUpdate && !this._isSourcePlaying() && (this._msToNextUpdate = 0, this.updateFrame(), this._msToNextUpdate = 0);
        }
        _onCanPlay() {
            this.resource.removeEventListener("canplay", this._onCanPlay), this._mediaReady();
        }
        _onCanPlayThrough() {
            this.resource.removeEventListener("canplaythrough", this._onCanPlay), this._preloadTimeout && (clearTimeout(this._preloadTimeout), this._preloadTimeout = void 0), this._mediaReady();
        }
        _mediaReady() {
            const e = this.resource;
            this.isValid && (this.isReady = !0, this.resize(e.videoWidth, e.videoHeight)), this._msToNextUpdate = 0, this.updateFrame(), this._msToNextUpdate = 0, this._resolve && (this._resolve(this), this._resolve = null, this._reject = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && this.resource.play();
        }
        destroy() {
            this._configureAutoUpdate();
            const e = this.resource;
            e && (e.removeEventListener("play", this._onPlayStart), e.removeEventListener("pause", this._onPlayStop), e.removeEventListener("seeked", this._onSeeked), e.removeEventListener("canplay", this._onCanPlay), e.removeEventListener("canplaythrough", this._onCanPlayThrough), e.removeEventListener("error", this._onError, !0), e.pause(), e.src = "", e.load()), super.destroy();
        }
        get autoUpdate() {
            return this._autoUpdate;
        }
        set autoUpdate(e) {
            e !== this._autoUpdate && (this._autoUpdate = e, this._configureAutoUpdate());
        }
        get updateFPS() {
            return this._updateFPS;
        }
        set updateFPS(e) {
            e !== this._updateFPS && (this._updateFPS = e, this._configureAutoUpdate());
        }
        _configureAutoUpdate() {
            this._autoUpdate && this._isSourcePlaying() ? !this._updateFPS && this.resource.requestVideoFrameCallback ? (this._isConnectedToTicker && (Ps.shared.remove(this.updateFrame, this), this._isConnectedToTicker = !1, this._msToNextUpdate = 0), this._videoFrameRequestCallbackHandle === null && (this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback))) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker || (Ps.shared.add(this.updateFrame, this), this._isConnectedToTicker = !0, this._msToNextUpdate = 0)) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker && (Ps.shared.remove(this.updateFrame, this), this._isConnectedToTicker = !1, this._msToNextUpdate = 0));
        }
        static test(e) {
            return globalThis.HTMLVideoElement && e instanceof HTMLVideoElement;
        }
    };
    mo.extension = J.TextureSource;
    mo.defaultOptions = {
        ...kt.defaultOptions,
        autoLoad: !0,
        autoPlay: !0,
        updateFPS: 0,
        crossorigin: !0,
        loop: !1,
        muted: !0,
        playsinline: !0,
        preload: !1
    };
    mo.MIME_TYPES = {
        ogv: "video/ogg",
        mov: "video/quicktime",
        m4v: "video/mp4"
    };
    let qa = mo;
    const Cn = (i, e, t = !1)=>(Array.isArray(i) || (i = [
            i
        ]), e ? i.map((n)=>typeof n == "string" || t ? e(n) : n) : i);
    class yM {
        constructor(){
            this._parsers = [], this._cache = new Map, this._cacheMap = new Map;
        }
        reset() {
            this._cacheMap.clear(), this._cache.clear();
        }
        has(e) {
            return this._cache.has(e);
        }
        get(e) {
            const t = this._cache.get(e);
            return t || tt(`[Assets] Asset id ${e} was not found in the Cache`), t;
        }
        set(e, t) {
            const n = Cn(e);
            let s;
            for(let l = 0; l < this.parsers.length; l++){
                const h = this.parsers[l];
                if (h.test(t)) {
                    s = h.getCacheableAssets(n, t);
                    break;
                }
            }
            const r = new Map(Object.entries(s || {}));
            s || n.forEach((l)=>{
                r.set(l, t);
            });
            const a = [
                ...r.keys()
            ], o = {
                cacheKeys: a,
                keys: n
            };
            n.forEach((l)=>{
                this._cacheMap.set(l, o);
            }), a.forEach((l)=>{
                const h = s ? s[l] : t;
                this._cache.has(l) && this._cache.get(l) !== h && tt("[Cache] already has key:", l), this._cache.set(l, r.get(l));
            });
        }
        remove(e) {
            if (!this._cacheMap.has(e)) {
                tt(`[Assets] Asset id ${e} was not found in the Cache`);
                return;
            }
            const t = this._cacheMap.get(e);
            t.cacheKeys.forEach((s)=>{
                this._cache.delete(s);
            }), t.keys.forEach((s)=>{
                this._cacheMap.delete(s);
            });
        }
        get parsers() {
            return this._parsers;
        }
    }
    let Fc;
    Mt = new yM;
    Fc = [];
    At.handleByList(J.TextureSource, Fc);
    function dm(i = {}) {
        const e = i && i.resource, t = e ? i.resource : i, n = e ? i : {
            resource: i
        };
        for(let s = 0; s < Fc.length; s++){
            const r = Fc[s];
            if (r.test(t)) return new r(n);
        }
        throw new Error(`Could not find a source type for resource: ${n.resource}`);
    }
    function bM(i = {}, e = !1) {
        const t = i && i.resource, n = t ? i.resource : i, s = t ? i : {
            resource: i
        };
        if (!e && Mt.has(n)) return Mt.get(n);
        const r = new Ie({
            source: dm(s)
        });
        return r.on("destroy", ()=>{
            Mt.has(n) && Mt.remove(n);
        }), e || Mt.set(n, r), r;
    }
    function SM(i, e = !1) {
        return typeof i == "string" ? Mt.get(i) : i instanceof kt ? new Ie({
            source: i
        }) : bM(i, e);
    }
    Ie.from = SM;
    kt.from = dm;
    At.add(am, om, lm, qa, ts, Ai, Eh);
    var Ci = ((i)=>(i[i.Low = 0] = "Low", i[i.Normal = 1] = "Normal", i[i.High = 2] = "High", i))(Ci || {});
    function En(i) {
        if (typeof i != "string") throw new TypeError(`Path must be a string. Received ${JSON.stringify(i)}`);
    }
    function _r(i) {
        return i.split("?")[0].split("#")[0];
    }
    function TM(i) {
        return i.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function MM(i, e, t) {
        return i.replace(new RegExp(TM(e), "g"), t);
    }
    function AM(i, e) {
        let t = "", n = 0, s = -1, r = 0, a = -1;
        for(let o = 0; o <= i.length; ++o){
            if (o < i.length) a = i.charCodeAt(o);
            else {
                if (a === 47) break;
                a = 47;
            }
            if (a === 47) {
                if (!(s === o - 1 || r === 1)) if (s !== o - 1 && r === 2) {
                    if (t.length < 2 || n !== 2 || t.charCodeAt(t.length - 1) !== 46 || t.charCodeAt(t.length - 2) !== 46) {
                        if (t.length > 2) {
                            const l = t.lastIndexOf("/");
                            if (l !== t.length - 1) {
                                l === -1 ? (t = "", n = 0) : (t = t.slice(0, l), n = t.length - 1 - t.lastIndexOf("/")), s = o, r = 0;
                                continue;
                            }
                        } else if (t.length === 2 || t.length === 1) {
                            t = "", n = 0, s = o, r = 0;
                            continue;
                        }
                    }
                } else t.length > 0 ? t += `/${i.slice(s + 1, o)}` : t = i.slice(s + 1, o), n = o - s - 1;
                s = o, r = 0;
            } else a === 46 && r !== -1 ? ++r : r = -1;
        }
        return t;
    }
    const hn = {
        toPosix (i) {
            return MM(i, "\\", "/");
        },
        isUrl (i) {
            return /^https?:/.test(this.toPosix(i));
        },
        isDataUrl (i) {
            return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(i);
        },
        isBlobUrl (i) {
            return i.startsWith("blob:");
        },
        hasProtocol (i) {
            return /^[^/:]+:/.test(this.toPosix(i));
        },
        getProtocol (i) {
            En(i), i = this.toPosix(i);
            const e = /^file:\/\/\//.exec(i);
            if (e) return e[0];
            const t = /^[^/:]+:\/{0,2}/.exec(i);
            return t ? t[0] : "";
        },
        toAbsolute (i, e, t) {
            if (En(i), this.isDataUrl(i) || this.isBlobUrl(i)) return i;
            const n = _r(this.toPosix(e ?? _t.get().getBaseUrl())), s = _r(this.toPosix(t ?? this.rootname(n)));
            return i = this.toPosix(i), i.startsWith("/") ? hn.join(s, i.slice(1)) : this.isAbsolute(i) ? i : this.join(n, i);
        },
        normalize (i) {
            if (En(i), i.length === 0) return ".";
            if (this.isDataUrl(i) || this.isBlobUrl(i)) return i;
            i = this.toPosix(i);
            let e = "";
            const t = i.startsWith("/");
            this.hasProtocol(i) && (e = this.rootname(i), i = i.slice(e.length));
            const n = i.endsWith("/");
            return i = AM(i), i.length > 0 && n && (i += "/"), t ? `/${i}` : e + i;
        },
        isAbsolute (i) {
            return En(i), i = this.toPosix(i), this.hasProtocol(i) ? !0 : i.startsWith("/");
        },
        join (...i) {
            if (i.length === 0) return ".";
            let e;
            for(let t = 0; t < i.length; ++t){
                const n = i[t];
                if (En(n), n.length > 0) if (e === void 0) e = n;
                else {
                    const s = i[t - 1] ?? "";
                    this.joinExtensions.includes(this.extname(s).toLowerCase()) ? e += `/../${n}` : e += `/${n}`;
                }
            }
            return e === void 0 ? "." : this.normalize(e);
        },
        dirname (i) {
            if (En(i), i.length === 0) return ".";
            i = this.toPosix(i);
            let e = i.charCodeAt(0);
            const t = e === 47;
            let n = -1, s = !0;
            const r = this.getProtocol(i), a = i;
            i = i.slice(r.length);
            for(let o = i.length - 1; o >= 1; --o)if (e = i.charCodeAt(o), e === 47) {
                if (!s) {
                    n = o;
                    break;
                }
            } else s = !1;
            return n === -1 ? t ? "/" : this.isUrl(a) ? r + i : r : t && n === 1 ? "//" : r + i.slice(0, n);
        },
        rootname (i) {
            En(i), i = this.toPosix(i);
            let e = "";
            if (i.startsWith("/") ? e = "/" : e = this.getProtocol(i), this.isUrl(i)) {
                const t = i.indexOf("/", e.length);
                t !== -1 ? e = i.slice(0, t) : e = i, e.endsWith("/") || (e += "/");
            }
            return e;
        },
        basename (i, e) {
            En(i), e && En(e), i = _r(this.toPosix(i));
            let t = 0, n = -1, s = !0, r;
            if (e !== void 0 && e.length > 0 && e.length <= i.length) {
                if (e.length === i.length && e === i) return "";
                let a = e.length - 1, o = -1;
                for(r = i.length - 1; r >= 0; --r){
                    const l = i.charCodeAt(r);
                    if (l === 47) {
                        if (!s) {
                            t = r + 1;
                            break;
                        }
                    } else o === -1 && (s = !1, o = r + 1), a >= 0 && (l === e.charCodeAt(a) ? --a === -1 && (n = r) : (a = -1, n = o));
                }
                return t === n ? n = o : n === -1 && (n = i.length), i.slice(t, n);
            }
            for(r = i.length - 1; r >= 0; --r)if (i.charCodeAt(r) === 47) {
                if (!s) {
                    t = r + 1;
                    break;
                }
            } else n === -1 && (s = !1, n = r + 1);
            return n === -1 ? "" : i.slice(t, n);
        },
        extname (i) {
            En(i), i = _r(this.toPosix(i));
            let e = -1, t = 0, n = -1, s = !0, r = 0;
            for(let a = i.length - 1; a >= 0; --a){
                const o = i.charCodeAt(a);
                if (o === 47) {
                    if (!s) {
                        t = a + 1;
                        break;
                    }
                    continue;
                }
                n === -1 && (s = !1, n = a + 1), o === 46 ? e === -1 ? e = a : r !== 1 && (r = 1) : e !== -1 && (r = -1);
            }
            return e === -1 || n === -1 || r === 0 || r === 1 && e === n - 1 && e === t + 1 ? "" : i.slice(e, n);
        },
        parse (i) {
            En(i);
            const e = {
                root: "",
                dir: "",
                base: "",
                ext: "",
                name: ""
            };
            if (i.length === 0) return e;
            i = _r(this.toPosix(i));
            let t = i.charCodeAt(0);
            const n = this.isAbsolute(i);
            let s;
            e.root = this.rootname(i), n || this.hasProtocol(i) ? s = 1 : s = 0;
            let r = -1, a = 0, o = -1, l = !0, h = i.length - 1, d = 0;
            for(; h >= s; --h){
                if (t = i.charCodeAt(h), t === 47) {
                    if (!l) {
                        a = h + 1;
                        break;
                    }
                    continue;
                }
                o === -1 && (l = !1, o = h + 1), t === 46 ? r === -1 ? r = h : d !== 1 && (d = 1) : r !== -1 && (d = -1);
            }
            return r === -1 || o === -1 || d === 0 || d === 1 && r === o - 1 && r === a + 1 ? o !== -1 && (a === 0 && n ? e.base = e.name = i.slice(1, o) : e.base = e.name = i.slice(a, o)) : (a === 0 && n ? (e.name = i.slice(1, r), e.base = i.slice(1, o)) : (e.name = i.slice(a, r), e.base = i.slice(a, o)), e.ext = i.slice(r, o)), e.dir = this.dirname(i), e;
        },
        sep: "/",
        delimiter: ":",
        joinExtensions: [
            ".html"
        ]
    };
    function fm(i, e, t, n, s) {
        const r = e[t];
        for(let a = 0; a < r.length; a++){
            const o = r[a];
            t < e.length - 1 ? fm(i.replace(n[t], o), e, t + 1, n, s) : s.push(i.replace(n[t], o));
        }
    }
    function EM(i) {
        const e = /\{(.*?)\}/g, t = i.match(e), n = [];
        if (t) {
            const s = [];
            t.forEach((r)=>{
                const a = r.substring(1, r.length - 1).split(",");
                s.push(a);
            }), fm(i, s, 0, t, n);
        } else n.push(i);
        return n;
    }
    const lo = (i)=>!Array.isArray(i);
    class nr {
        constructor(){
            this._defaultBundleIdentifierOptions = {
                connector: "-",
                createBundleAssetId: (e, t)=>`${e}${this._bundleIdConnector}${t}`,
                extractAssetIdFromBundle: (e, t)=>t.replace(`${e}${this._bundleIdConnector}`, "")
            }, this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector, this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId, this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle, this._assetMap = {}, this._preferredOrder = [], this._parsers = [], this._resolverHash = {}, this._bundles = {};
        }
        setBundleIdentifier(e) {
            if (this._bundleIdConnector = e.connector ?? this._bundleIdConnector, this._createBundleAssetId = e.createBundleAssetId ?? this._createBundleAssetId, this._extractAssetIdFromBundle = e.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle, this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
        }
        prefer(...e) {
            e.forEach((t)=>{
                this._preferredOrder.push(t), t.priority || (t.priority = Object.keys(t.params));
            }), this._resolverHash = {};
        }
        set basePath(e) {
            this._basePath = e;
        }
        get basePath() {
            return this._basePath;
        }
        set rootPath(e) {
            this._rootPath = e;
        }
        get rootPath() {
            return this._rootPath;
        }
        get parsers() {
            return this._parsers;
        }
        reset() {
            this.setBundleIdentifier(this._defaultBundleIdentifierOptions), this._assetMap = {}, this._preferredOrder = [], this._resolverHash = {}, this._rootPath = null, this._basePath = null, this._manifest = null, this._bundles = {}, this._defaultSearchParams = null;
        }
        setDefaultSearchParams(e) {
            if (typeof e == "string") this._defaultSearchParams = e;
            else {
                const t = e;
                this._defaultSearchParams = Object.keys(t).map((n)=>`${encodeURIComponent(n)}=${encodeURIComponent(t[n])}`).join("&");
            }
        }
        getAlias(e) {
            const { alias: t, src: n } = e;
            return Cn(t || n, (r)=>typeof r == "string" ? r : Array.isArray(r) ? r.map((a)=>a?.src ?? a) : r?.src ? r.src : r, !0);
        }
        addManifest(e) {
            this._manifest && tt("[Resolver] Manifest already exists, this will be overwritten"), this._manifest = e, e.bundles.forEach((t)=>{
                this.addBundle(t.name, t.assets);
            });
        }
        addBundle(e, t) {
            const n = [];
            let s = t;
            Array.isArray(t) || (s = Object.entries(t).map(([r, a])=>typeof a == "string" || Array.isArray(a) ? {
                    alias: r,
                    src: a
                } : {
                    alias: r,
                    ...a
                })), s.forEach((r)=>{
                const a = r.src, o = r.alias;
                let l;
                if (typeof o == "string") {
                    const h = this._createBundleAssetId(e, o);
                    n.push(h), l = [
                        o,
                        h
                    ];
                } else {
                    const h = o.map((d)=>this._createBundleAssetId(e, d));
                    n.push(...h), l = [
                        ...o,
                        ...h
                    ];
                }
                this.add({
                    ...r,
                    alias: l,
                    src: a
                });
            }), this._bundles[e] = n;
        }
        add(e) {
            const t = [];
            Array.isArray(e) ? t.push(...e) : t.push(e);
            let n;
            n = (r)=>{
                this.hasKey(r) && tt(`[Resolver] already has key: ${r} overwriting`);
            }, Cn(t).forEach((r)=>{
                const { src: a } = r;
                let { data: o, format: l, loadParser: h } = r;
                const d = Cn(a).map((f)=>typeof f == "string" ? EM(f) : Array.isArray(f) ? f : [
                        f
                    ]), c = this.getAlias(r);
                Array.isArray(c) ? c.forEach(n) : n(c);
                const u = [];
                d.forEach((f)=>{
                    f.forEach((_)=>{
                        let g = {};
                        if (typeof _ != "object") {
                            g.src = _;
                            for(let m = 0; m < this._parsers.length; m++){
                                const p = this._parsers[m];
                                if (p.test(_)) {
                                    g = p.parse(_);
                                    break;
                                }
                            }
                        } else o = _.data ?? o, l = _.format ?? l, h = _.loadParser ?? h, g = {
                            ...g,
                            ..._
                        };
                        if (!c) throw new Error(`[Resolver] alias is undefined for this asset: ${g.src}`);
                        g = this._buildResolvedAsset(g, {
                            aliases: c,
                            data: o,
                            format: l,
                            loadParser: h
                        }), u.push(g);
                    });
                }), c.forEach((f)=>{
                    this._assetMap[f] = u;
                });
            });
        }
        resolveBundle(e) {
            const t = lo(e);
            e = Cn(e);
            const n = {};
            return e.forEach((s)=>{
                const r = this._bundles[s];
                if (r) {
                    const a = this.resolve(r), o = {};
                    for(const l in a){
                        const h = a[l];
                        o[this._extractAssetIdFromBundle(s, l)] = h;
                    }
                    n[s] = o;
                }
            }), t ? n[e[0]] : n;
        }
        resolveUrl(e) {
            const t = this.resolve(e);
            if (typeof e != "string") {
                const n = {};
                for(const s in t)n[s] = t[s].src;
                return n;
            }
            return t.src;
        }
        resolve(e) {
            const t = lo(e);
            e = Cn(e);
            const n = {};
            return e.forEach((s)=>{
                if (!this._resolverHash[s]) if (this._assetMap[s]) {
                    let r = this._assetMap[s];
                    const a = this._getPreferredOrder(r);
                    a?.priority.forEach((o)=>{
                        a.params[o].forEach((l)=>{
                            const h = r.filter((d)=>d[o] ? d[o] === l : !1);
                            h.length && (r = h);
                        });
                    }), this._resolverHash[s] = r[0];
                } else this._resolverHash[s] = this._buildResolvedAsset({
                    alias: [
                        s
                    ],
                    src: s
                }, {});
                n[s] = this._resolverHash[s];
            }), t ? n[e[0]] : n;
        }
        hasKey(e) {
            return !!this._assetMap[e];
        }
        hasBundle(e) {
            return !!this._bundles[e];
        }
        _getPreferredOrder(e) {
            for(let t = 0; t < e.length; t++){
                const n = e[t], s = this._preferredOrder.find((r)=>r.params.format.includes(n.format));
                if (s) return s;
            }
            return this._preferredOrder[0];
        }
        _appendDefaultSearchParams(e) {
            if (!this._defaultSearchParams) return e;
            const t = /\?/.test(e) ? "&" : "?";
            return `${e}${t}${this._defaultSearchParams}`;
        }
        _buildResolvedAsset(e, t) {
            const { aliases: n, data: s, loadParser: r, format: a } = t;
            return (this._basePath || this._rootPath) && (e.src = hn.toAbsolute(e.src, this._basePath, this._rootPath)), e.alias = n ?? e.alias ?? [
                e.src
            ], e.src = this._appendDefaultSearchParams(e.src), e.data = {
                ...s || {},
                ...e.data
            }, e.loadParser = r ?? e.loadParser, e.format = a ?? e.format ?? wM(e.src), e;
        }
    }
    nr.RETINA_PREFIX = /@([0-9\.]+)x/;
    function wM(i) {
        return i.split(".").pop().split("?").shift().split("#").shift();
    }
    const Nc = (i, e)=>{
        const t = e.split("?")[1];
        return t && (i += `?${t}`), i;
    }, pm = class Er {
        constructor(e, t){
            this.linkedSheets = [], this._texture = e instanceof Ie ? e : null, this.textureSource = e.source, this.textures = {}, this.animations = {}, this.data = t;
            const n = parseFloat(t.meta.scale);
            n ? (this.resolution = n, e.source.resolution = this.resolution) : this.resolution = e.source._resolution, this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null;
        }
        parse() {
            return new Promise((e)=>{
                this._callback = e, this._batchIndex = 0, this._frameKeys.length <= Er.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch();
            });
        }
        _processFrames(e) {
            let t = e;
            const n = Er.BATCH_SIZE;
            for(; t - e < n && t < this._frameKeys.length;){
                const s = this._frameKeys[t], r = this._frames[s], a = r.frame;
                if (a) {
                    let o = null, l = null;
                    const h = r.trimmed !== !1 && r.sourceSize ? r.sourceSize : r.frame, d = new mt(0, 0, Math.floor(h.w) / this.resolution, Math.floor(h.h) / this.resolution);
                    r.rotated ? o = new mt(Math.floor(a.x) / this.resolution, Math.floor(a.y) / this.resolution, Math.floor(a.h) / this.resolution, Math.floor(a.w) / this.resolution) : o = new mt(Math.floor(a.x) / this.resolution, Math.floor(a.y) / this.resolution, Math.floor(a.w) / this.resolution, Math.floor(a.h) / this.resolution), r.trimmed !== !1 && r.spriteSourceSize && (l = new mt(Math.floor(r.spriteSourceSize.x) / this.resolution, Math.floor(r.spriteSourceSize.y) / this.resolution, Math.floor(a.w) / this.resolution, Math.floor(a.h) / this.resolution)), this.textures[s] = new Ie({
                        source: this.textureSource,
                        frame: o,
                        orig: d,
                        trim: l,
                        rotate: r.rotated ? 2 : 0,
                        defaultAnchor: r.anchor,
                        defaultBorders: r.borders,
                        label: s.toString()
                    });
                }
                t++;
            }
        }
        _processAnimations() {
            const e = this.data.animations || {};
            for(const t in e){
                this.animations[t] = [];
                for(let n = 0; n < e[t].length; n++){
                    const s = e[t][n];
                    this.animations[t].push(this.textures[s]);
                }
            }
        }
        _parseComplete() {
            const e = this._callback;
            this._callback = null, this._batchIndex = 0, e.call(this, this.textures);
        }
        _nextBatch() {
            this._processFrames(this._batchIndex * Er.BATCH_SIZE), this._batchIndex++, setTimeout(()=>{
                this._batchIndex * Er.BATCH_SIZE < this._frameKeys.length ? this._nextBatch() : (this._processAnimations(), this._parseComplete());
            }, 0);
        }
        destroy(e = !1) {
            for(const t in this.textures)this.textures[t].destroy();
            this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, e && (this._texture?.destroy(), this.textureSource.destroy()), this._texture = null, this.textureSource = null, this.linkedSheets = [];
        }
    };
    pm.BATCH_SIZE = 1e3;
    let Wd = pm;
    const RM = [
        "jpg",
        "png",
        "jpeg",
        "avif",
        "webp",
        "basis",
        "etc2",
        "bc7",
        "bc6h",
        "bc5",
        "bc4",
        "bc3",
        "bc2",
        "bc1",
        "eac",
        "astc"
    ];
    function mm(i, e, t) {
        const n = {};
        if (i.forEach((s)=>{
            n[s] = e;
        }), Object.keys(e.textures).forEach((s)=>{
            n[s] = e.textures[s];
        }), !t) {
            const s = hn.dirname(i[0]);
            e.linkedSheets.forEach((r, a)=>{
                const o = mm([
                    `${s}/${e.data.meta.related_multi_packs[a]}`
                ], r, !0);
                Object.assign(n, o);
            });
        }
        return n;
    }
    const CM = {
        extension: J.Asset,
        cache: {
            test: (i)=>i instanceof Wd,
            getCacheableAssets: (i, e)=>mm(i, e, !1)
        },
        resolver: {
            extension: {
                type: J.ResolveParser,
                name: "resolveSpritesheet"
            },
            test: (i)=>{
                const t = i.split("?")[0].split("."), n = t.pop(), s = t.pop();
                return n === "json" && RM.includes(s);
            },
            parse: (i)=>{
                const e = i.split(".");
                return {
                    resolution: parseFloat(nr.RETINA_PREFIX.exec(i)?.[1] ?? "1"),
                    format: e[e.length - 2],
                    src: i
                };
            }
        },
        loader: {
            name: "spritesheetLoader",
            extension: {
                type: J.LoadParser,
                priority: Ci.Normal,
                name: "spritesheetLoader"
            },
            async testParse (i, e) {
                return hn.extname(e.src).toLowerCase() === ".json" && !!i.frames;
            },
            async parse (i, e, t) {
                const { texture: n, imageFilename: s, textureOptions: r } = e?.data ?? {};
                let a = hn.dirname(e.src);
                a && a.lastIndexOf("/") !== a.length - 1 && (a += "/");
                let o;
                if (n instanceof Ie) o = n;
                else {
                    const d = Nc(a + (s ?? i.meta.image), e.src);
                    o = (await t.load([
                        {
                            src: d,
                            data: r
                        }
                    ]))[d];
                }
                const l = new Wd(o.source, i);
                await l.parse();
                const h = i?.meta?.related_multi_packs;
                if (Array.isArray(h)) {
                    const d = [];
                    for (const u of h){
                        if (typeof u != "string") continue;
                        let f = a + u;
                        e.data?.ignoreMultiPack || (f = Nc(f, e.src), d.push(t.load({
                            src: f,
                            data: {
                                textureOptions: r,
                                ignoreMultiPack: !0
                            }
                        })));
                    }
                    const c = await Promise.all(d);
                    l.linkedSheets = c, c.forEach((u)=>{
                        u.linkedSheets = [
                            l
                        ].concat(l.linkedSheets.filter((f)=>f !== u));
                    });
                }
                return l;
            },
            async unload (i, e, t) {
                await t.unload(i.textureSource._sourceOrigin), i.destroy(!1);
            }
        }
    };
    At.add(CM);
    const fl = Object.create(null), Xd = Object.create(null);
    function Lh(i, e) {
        let t = Xd[i];
        return t === void 0 && (fl[e] === void 0 && (fl[e] = 1), Xd[i] = t = fl[e]++), t;
    }
    let Pa;
    function _m() {
        return (!Pa || Pa?.isContextLost()) && (Pa = _t.get().createCanvas().getContext("webgl", {})), Pa;
    }
    let Ia;
    function PM() {
        if (!Ia) {
            Ia = "mediump";
            const i = _m();
            i && i.getShaderPrecisionFormat && (Ia = i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.HIGH_FLOAT).precision ? "highp" : "mediump");
        }
        return Ia;
    }
    function IM(i, e, t) {
        return e ? i : t ? (i = i.replace("out vec4 finalColor;", ""), `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${i}
        `) : `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${i}
        `;
    }
    function DM(i, e, t) {
        const n = t ? e.maxSupportedFragmentPrecision : e.maxSupportedVertexPrecision;
        if (i.substring(0, 9) !== "precision") {
            let s = t ? e.requestedFragmentPrecision : e.requestedVertexPrecision;
            return s === "highp" && n !== "highp" && (s = "mediump"), `precision ${s} float;
${i}`;
        } else if (n !== "highp" && i.substring(0, 15) === "precision highp") return i.replace("precision highp", "precision mediump");
        return i;
    }
    function LM(i, e) {
        return e ? `#version 300 es
${i}` : i;
    }
    const BM = {}, UM = {};
    function FM(i, { name: e = "pixi-program" }, t = !0) {
        e = e.replace(/\s+/g, "-"), e += t ? "-fragment" : "-vertex";
        const n = t ? BM : UM;
        return n[e] ? (n[e]++, e += `-${n[e]}`) : n[e] = 1, i.indexOf("#define SHADER_NAME") !== -1 ? i : `${`#define SHADER_NAME ${e}`}
${i}`;
    }
    function NM(i, e) {
        return e ? i.replace("#version 300 es", "") : i;
    }
    const pl = {
        stripVersion: NM,
        ensurePrecision: DM,
        addProgramDefines: IM,
        setProgramName: FM,
        insertVersion: LM
    }, ml = Object.create(null), gm = class Oc {
        constructor(e){
            e = {
                ...Oc.defaultOptions,
                ...e
            };
            const t = e.fragment.indexOf("#version 300 es") !== -1, n = {
                stripVersion: t,
                ensurePrecision: {
                    requestedFragmentPrecision: e.preferredFragmentPrecision,
                    requestedVertexPrecision: e.preferredVertexPrecision,
                    maxSupportedVertexPrecision: "highp",
                    maxSupportedFragmentPrecision: PM()
                },
                setProgramName: {
                    name: e.name
                },
                addProgramDefines: t,
                insertVersion: t
            };
            let s = e.fragment, r = e.vertex;
            Object.keys(pl).forEach((a)=>{
                const o = n[a];
                s = pl[a](s, o, !0), r = pl[a](r, o, !1);
            }), this.fragment = s, this.vertex = r, this.transformFeedbackVaryings = e.transformFeedbackVaryings, this._key = Lh(`${this.vertex}:${this.fragment}`, "gl-program");
        }
        destroy() {
            this.fragment = null, this.vertex = null, this._attributeData = null, this._uniformData = null, this._uniformBlockData = null, this.transformFeedbackVaryings = null;
        }
        static from(e) {
            const t = `${e.vertex}:${e.fragment}`;
            return ml[t] || (ml[t] = new Oc(e)), ml[t];
        }
    };
    gm.defaultOptions = {
        preferredVertexPrecision: "highp",
        preferredFragmentPrecision: "mediump"
    };
    $r = gm;
    const Yd = {
        uint8x2: {
            size: 2,
            stride: 2,
            normalised: !1
        },
        uint8x4: {
            size: 4,
            stride: 4,
            normalised: !1
        },
        sint8x2: {
            size: 2,
            stride: 2,
            normalised: !1
        },
        sint8x4: {
            size: 4,
            stride: 4,
            normalised: !1
        },
        unorm8x2: {
            size: 2,
            stride: 2,
            normalised: !0
        },
        unorm8x4: {
            size: 4,
            stride: 4,
            normalised: !0
        },
        snorm8x2: {
            size: 2,
            stride: 2,
            normalised: !0
        },
        snorm8x4: {
            size: 4,
            stride: 4,
            normalised: !0
        },
        uint16x2: {
            size: 2,
            stride: 4,
            normalised: !1
        },
        uint16x4: {
            size: 4,
            stride: 8,
            normalised: !1
        },
        sint16x2: {
            size: 2,
            stride: 4,
            normalised: !1
        },
        sint16x4: {
            size: 4,
            stride: 8,
            normalised: !1
        },
        unorm16x2: {
            size: 2,
            stride: 4,
            normalised: !0
        },
        unorm16x4: {
            size: 4,
            stride: 8,
            normalised: !0
        },
        snorm16x2: {
            size: 2,
            stride: 4,
            normalised: !0
        },
        snorm16x4: {
            size: 4,
            stride: 8,
            normalised: !0
        },
        float16x2: {
            size: 2,
            stride: 4,
            normalised: !1
        },
        float16x4: {
            size: 4,
            stride: 8,
            normalised: !1
        },
        float32: {
            size: 1,
            stride: 4,
            normalised: !1
        },
        float32x2: {
            size: 2,
            stride: 8,
            normalised: !1
        },
        float32x3: {
            size: 3,
            stride: 12,
            normalised: !1
        },
        float32x4: {
            size: 4,
            stride: 16,
            normalised: !1
        },
        uint32: {
            size: 1,
            stride: 4,
            normalised: !1
        },
        uint32x2: {
            size: 2,
            stride: 8,
            normalised: !1
        },
        uint32x3: {
            size: 3,
            stride: 12,
            normalised: !1
        },
        uint32x4: {
            size: 4,
            stride: 16,
            normalised: !1
        },
        sint32: {
            size: 1,
            stride: 4,
            normalised: !1
        },
        sint32x2: {
            size: 2,
            stride: 8,
            normalised: !1
        },
        sint32x3: {
            size: 3,
            stride: 12,
            normalised: !1
        },
        sint32x4: {
            size: 4,
            stride: 16,
            normalised: !1
        }
    };
    Xr = function(i) {
        return Yd[i] ?? Yd.float32;
    };
    const OM = {
        f32: "float32",
        "vec2<f32>": "float32x2",
        "vec3<f32>": "float32x3",
        "vec4<f32>": "float32x4",
        vec2f: "float32x2",
        vec3f: "float32x3",
        vec4f: "float32x4",
        i32: "sint32",
        "vec2<i32>": "sint32x2",
        "vec3<i32>": "sint32x3",
        "vec4<i32>": "sint32x4",
        u32: "uint32",
        "vec2<u32>": "uint32x2",
        "vec3<u32>": "uint32x3",
        "vec4<u32>": "uint32x4",
        bool: "uint32",
        "vec2<bool>": "uint32x2",
        "vec3<bool>": "uint32x3",
        "vec4<bool>": "uint32x4"
    };
    function kM({ source: i, entryPoint: e }) {
        const t = {}, n = i.indexOf(`fn ${e}`);
        if (n !== -1) {
            const s = i.indexOf("->", n);
            if (s !== -1) {
                const r = i.substring(n, s), a = /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;
                let o;
                for(; (o = a.exec(r)) !== null;){
                    const l = OM[o[3]] ?? "float32";
                    t[o[2]] = {
                        location: parseInt(o[1], 10),
                        format: l,
                        stride: Xr(l).stride,
                        offset: 0,
                        instance: !1,
                        start: 0
                    };
                }
            }
        }
        return t;
    }
    function _l(i) {
        const e = /(^|[^/])@(group|binding)\(\d+\)[^;]+;/g, t = /@group\((\d+)\)/, n = /@binding\((\d+)\)/, s = /var(<[^>]+>)? (\w+)/, r = /:\s*(\w+)/, a = /struct\s+(\w+)\s*{([^}]+)}/g, o = /(\w+)\s*:\s*([\w\<\>]+)/g, l = /struct\s+(\w+)/, h = i.match(e)?.map((c)=>({
                group: parseInt(c.match(t)[1], 10),
                binding: parseInt(c.match(n)[1], 10),
                name: c.match(s)[2],
                isUniform: c.match(s)[1] === "<uniform>",
                type: c.match(r)[1]
            }));
        if (!h) return {
            groups: [],
            structs: []
        };
        const d = i.match(a)?.map((c)=>{
            const u = c.match(l)[1], f = c.match(o).reduce((_, g)=>{
                const [m, p] = g.split(":");
                return _[m.trim()] = p.trim(), _;
            }, {});
            return f ? {
                name: u,
                members: f
            } : null;
        }).filter(({ name: c })=>h.some((u)=>u.type === c)) ?? [];
        return {
            groups: h,
            structs: d
        };
    }
    var wr = ((i)=>(i[i.VERTEX = 1] = "VERTEX", i[i.FRAGMENT = 2] = "FRAGMENT", i[i.COMPUTE = 4] = "COMPUTE", i))(wr || {});
    function GM({ groups: i }) {
        const e = [];
        for(let t = 0; t < i.length; t++){
            const n = i[t];
            e[n.group] || (e[n.group] = []), n.isUniform ? e[n.group].push({
                binding: n.binding,
                visibility: wr.VERTEX | wr.FRAGMENT,
                buffer: {
                    type: "uniform"
                }
            }) : n.type === "sampler" ? e[n.group].push({
                binding: n.binding,
                visibility: wr.FRAGMENT,
                sampler: {
                    type: "filtering"
                }
            }) : n.type === "texture_2d" && e[n.group].push({
                binding: n.binding,
                visibility: wr.FRAGMENT,
                texture: {
                    sampleType: "float",
                    viewDimension: "2d",
                    multisampled: !1
                }
            });
        }
        return e;
    }
    function HM({ groups: i }) {
        const e = [];
        for(let t = 0; t < i.length; t++){
            const n = i[t];
            e[n.group] || (e[n.group] = {}), e[n.group][n.name] = n.binding;
        }
        return e;
    }
    function zM(i, e) {
        const t = new Set, n = new Set, s = [
            ...i.structs,
            ...e.structs
        ].filter((a)=>t.has(a.name) ? !1 : (t.add(a.name), !0)), r = [
            ...i.groups,
            ...e.groups
        ].filter((a)=>{
            const o = `${a.name}-${a.binding}`;
            return n.has(o) ? !1 : (n.add(o), !0);
        });
        return {
            structs: s,
            groups: r
        };
    }
    const gl = Object.create(null);
    ir = class {
        constructor(e){
            this._layoutKey = 0, this._attributeLocationsKey = 0;
            const { fragment: t, vertex: n, layout: s, gpuLayout: r, name: a } = e;
            if (this.name = a, this.fragment = t, this.vertex = n, t.source === n.source) {
                const o = _l(t.source);
                this.structsAndGroups = o;
            } else {
                const o = _l(n.source), l = _l(t.source);
                this.structsAndGroups = zM(o, l);
            }
            this.layout = s ?? HM(this.structsAndGroups), this.gpuLayout = r ?? GM(this.structsAndGroups), this.autoAssignGlobalUniforms = this.layout[0]?.globalUniforms !== void 0, this.autoAssignLocalUniforms = this.layout[1]?.localUniforms !== void 0, this._generateProgramKey();
        }
        _generateProgramKey() {
            const { vertex: e, fragment: t } = this, n = e.source + t.source + e.entryPoint + t.entryPoint;
            this._layoutKey = Lh(n, "program");
        }
        get attributeData() {
            return this._attributeData ?? (this._attributeData = kM(this.vertex)), this._attributeData;
        }
        destroy() {
            this.gpuLayout = null, this.layout = null, this.structsAndGroups = null, this.fragment = null, this.vertex = null;
        }
        static from(e) {
            const t = `${e.vertex.source}:${e.fragment.source}:${e.fragment.entryPoint}:${e.vertex.entryPoint}`;
            return gl[t] || (gl[t] = new ir(e)), gl[t];
        }
    };
    const xm = [
        "f32",
        "i32",
        "vec2<f32>",
        "vec3<f32>",
        "vec4<f32>",
        "mat2x2<f32>",
        "mat3x3<f32>",
        "mat4x4<f32>",
        "mat3x2<f32>",
        "mat4x2<f32>",
        "mat2x3<f32>",
        "mat4x3<f32>",
        "mat2x4<f32>",
        "mat3x4<f32>",
        "vec2<i32>",
        "vec3<i32>",
        "vec4<i32>"
    ], VM = xm.reduce((i, e)=>(i[e] = !0, i), {});
    function WM(i, e) {
        switch(i){
            case "f32":
                return 0;
            case "vec2<f32>":
                return new Float32Array(2 * e);
            case "vec3<f32>":
                return new Float32Array(3 * e);
            case "vec4<f32>":
                return new Float32Array(4 * e);
            case "mat2x2<f32>":
                return new Float32Array([
                    1,
                    0,
                    0,
                    1
                ]);
            case "mat3x3<f32>":
                return new Float32Array([
                    1,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    1
                ]);
            case "mat4x4<f32>":
                return new Float32Array([
                    1,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    1
                ]);
        }
        return null;
    }
    const vm = class ym {
        constructor(e, t){
            this._touched = 0, this.uid = xt("uniform"), this._resourceType = "uniformGroup", this._resourceId = xt("resource"), this.isUniformGroup = !0, this._dirtyId = 0, this.destroyed = !1, t = {
                ...ym.defaultOptions,
                ...t
            }, this.uniformStructures = e;
            const n = {};
            for(const s in e){
                const r = e[s];
                if (r.name = s, r.size = r.size ?? 1, !VM[r.type]) throw new Error(`Uniform type ${r.type} is not supported. Supported uniform types are: ${xm.join(", ")}`);
                r.value ?? (r.value = WM(r.type, r.size)), n[s] = r.value;
            }
            this.uniforms = n, this._dirtyId = 1, this.ubo = t.ubo, this.isStatic = t.isStatic, this._signature = Lh(Object.keys(n).map((s)=>`${s}-${e[s].type}`).join("-"), "uniform-group");
        }
        update() {
            this._dirtyId++;
        }
    };
    vm.defaultOptions = {
        ubo: !1,
        isStatic: !1
    };
    rs = vm;
    Br = class {
        constructor(e){
            this.resources = Object.create(null), this._dirty = !0;
            let t = 0;
            for(const n in e){
                const s = e[n];
                this.setResource(s, t++);
            }
            this._updateKey();
        }
        _updateKey() {
            if (!this._dirty) return;
            this._dirty = !1;
            const e = [];
            let t = 0;
            for(const n in this.resources)e[t++] = this.resources[n]._resourceId;
            this._key = e.join("|");
        }
        setResource(e, t) {
            const n = this.resources[t];
            e !== n && (n && e.off?.("change", this.onResourceChange, this), e.on?.("change", this.onResourceChange, this), this.resources[t] = e, this._dirty = !0);
        }
        getResource(e) {
            return this.resources[e];
        }
        _touch(e) {
            const t = this.resources;
            for(const n in t)t[n]._touched = e;
        }
        destroy() {
            const e = this.resources;
            for(const t in e)e[t].off?.("change", this.onResourceChange, this);
            this.resources = null;
        }
        onResourceChange(e) {
            if (this._dirty = !0, e.destroyed) {
                const t = this.resources;
                for(const n in t)t[n] === e && (t[n] = null);
            } else this._updateKey();
        }
    };
    ns = ((i)=>(i[i.WEBGL = 1] = "WEBGL", i[i.WEBGPU = 2] = "WEBGPU", i[i.BOTH = 3] = "BOTH", i))(ns || {});
    as = class extends yn {
        constructor(e){
            super(), this.uid = xt("shader"), this._uniformBindMap = Object.create(null), this._ownedBindGroups = [];
            let { gpuProgram: t, glProgram: n, groups: s, resources: r, compatibleRenderers: a, groupMap: o } = e;
            this.gpuProgram = t, this.glProgram = n, a === void 0 && (a = 0, t && (a |= ns.WEBGPU), n && (a |= ns.WEBGL)), this.compatibleRenderers = a;
            const l = {};
            if (!r && !s && (r = {}), r && s) throw new Error("[Shader] Cannot have both resources and groups");
            if (!t && s && !o) throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");
            if (!t && s && o) for(const h in o)for(const d in o[h]){
                const c = o[h][d];
                l[c] = {
                    group: h,
                    binding: d,
                    name: c
                };
            }
            else if (t && s && !o) {
                const h = t.structsAndGroups.groups;
                o = {}, h.forEach((d)=>{
                    o[d.group] = o[d.group] || {}, o[d.group][d.binding] = d.name, l[d.name] = d;
                });
            } else if (r) {
                s = {}, o = {}, t && t.structsAndGroups.groups.forEach((c)=>{
                    o[c.group] = o[c.group] || {}, o[c.group][c.binding] = c.name, l[c.name] = c;
                });
                let h = 0;
                for(const d in r)l[d] || (s[99] || (s[99] = new Br, this._ownedBindGroups.push(s[99])), l[d] = {
                    group: 99,
                    binding: h,
                    name: d
                }, o[99] = o[99] || {}, o[99][h] = d, h++);
                for(const d in r){
                    const c = d;
                    let u = r[d];
                    !u.source && !u._resourceType && (u = new rs(u));
                    const f = l[c];
                    f && (s[f.group] || (s[f.group] = new Br, this._ownedBindGroups.push(s[f.group])), s[f.group].setResource(u, f.binding));
                }
            }
            this.groups = s, this._uniformBindMap = o, this.resources = this._buildResourceAccessor(s, l);
        }
        addResource(e, t, n) {
            var s, r;
            (s = this._uniformBindMap)[t] || (s[t] = {}), (r = this._uniformBindMap[t])[n] || (r[n] = e), this.groups[t] || (this.groups[t] = new Br, this._ownedBindGroups.push(this.groups[t]));
        }
        _buildResourceAccessor(e, t) {
            const n = {};
            for(const s in t){
                const r = t[s];
                Object.defineProperty(n, r.name, {
                    get () {
                        return e[r.group].getResource(r.binding);
                    },
                    set (a) {
                        e[r.group].setResource(a, r.binding);
                    }
                });
            }
            return n;
        }
        destroy(e = !1) {
            this.emit("destroy", this), e && (this.gpuProgram?.destroy(), this.glProgram?.destroy()), this.gpuProgram = null, this.glProgram = null, this.removeAllListeners(), this._uniformBindMap = null, this._ownedBindGroups.forEach((t)=>{
                t.destroy();
            }), this._ownedBindGroups = null, this.resources = null, this.groups = null;
        }
        static from(e) {
            const { gpu: t, gl: n, ...s } = e;
            let r, a;
            return t && (r = ir.from(t)), n && (a = $r.from(n)), new as({
                gpuProgram: r,
                glProgram: a,
                ...s
            });
        }
    };
    const XM = {
        normal: 0,
        add: 1,
        multiply: 2,
        screen: 3,
        overlay: 4,
        erase: 5,
        "normal-npm": 6,
        "add-npm": 7,
        "screen-npm": 8,
        min: 9,
        max: 10
    }, xl = 0, vl = 1, yl = 2, bl = 3, Sl = 4, Tl = 5, kc = class bm {
        constructor(){
            this.data = 0, this.blendMode = "normal", this.polygonOffset = 0, this.blend = !0, this.depthMask = !0;
        }
        get blend() {
            return !!(this.data & 1 << xl);
        }
        set blend(e) {
            !!(this.data & 1 << xl) !== e && (this.data ^= 1 << xl);
        }
        get offsets() {
            return !!(this.data & 1 << vl);
        }
        set offsets(e) {
            !!(this.data & 1 << vl) !== e && (this.data ^= 1 << vl);
        }
        set cullMode(e) {
            if (e === "none") {
                this.culling = !1;
                return;
            }
            this.culling = !0, this.clockwiseFrontFace = e === "front";
        }
        get cullMode() {
            return this.culling ? this.clockwiseFrontFace ? "front" : "back" : "none";
        }
        get culling() {
            return !!(this.data & 1 << yl);
        }
        set culling(e) {
            !!(this.data & 1 << yl) !== e && (this.data ^= 1 << yl);
        }
        get depthTest() {
            return !!(this.data & 1 << bl);
        }
        set depthTest(e) {
            !!(this.data & 1 << bl) !== e && (this.data ^= 1 << bl);
        }
        get depthMask() {
            return !!(this.data & 1 << Tl);
        }
        set depthMask(e) {
            !!(this.data & 1 << Tl) !== e && (this.data ^= 1 << Tl);
        }
        get clockwiseFrontFace() {
            return !!(this.data & 1 << Sl);
        }
        set clockwiseFrontFace(e) {
            !!(this.data & 1 << Sl) !== e && (this.data ^= 1 << Sl);
        }
        get blendMode() {
            return this._blendMode;
        }
        set blendMode(e) {
            this.blend = e !== "none", this._blendMode = e, this._blendModeId = XM[e] || 0;
        }
        get polygonOffset() {
            return this._polygonOffset;
        }
        set polygonOffset(e) {
            this.offsets = !!e, this._polygonOffset = e;
        }
        toString() {
            return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
        }
        static for2d() {
            const e = new bm;
            return e.depthTest = !1, e.blend = !0, e;
        }
    };
    kc.default2d = kc.for2d();
    Kr = kc;
    const Sm = class Gc extends as {
        constructor(e){
            e = {
                ...Gc.defaultOptions,
                ...e
            }, super(e), this.enabled = !0, this._state = Kr.for2d(), this.blendMode = e.blendMode, this.padding = e.padding, typeof e.antialias == "boolean" ? this.antialias = e.antialias ? "on" : "off" : this.antialias = e.antialias, this.resolution = e.resolution, this.blendRequired = e.blendRequired, this.clipToViewport = e.clipToViewport, this.addResource("uTexture", 0, 1);
        }
        apply(e, t, n, s) {
            e.applyFilter(this, t, n, s);
        }
        get blendMode() {
            return this._state.blendMode;
        }
        set blendMode(e) {
            this._state.blendMode = e;
        }
        static from(e) {
            const { gpu: t, gl: n, ...s } = e;
            let r, a;
            return t && (r = ir.from(t)), n && (a = $r.from(n)), new Gc({
                gpuProgram: r,
                glProgram: a,
                ...s
            });
        }
    };
    Sm.defaultOptions = {
        blendMode: "normal",
        resolution: 1,
        padding: 0,
        antialias: "off",
        blendRequired: !1,
        clipToViewport: !0
    };
    let YM = Sm;
    const Hc = [];
    At.handleByNamedList(J.Environment, Hc);
    async function jM(i) {
        if (!i) for(let e = 0; e < Hc.length; e++){
            const t = Hc[e];
            if (t.value.test()) {
                await t.value.load();
                return;
            }
        }
    }
    let gr;
    function Tm() {
        if (typeof gr == "boolean") return gr;
        try {
            gr = new Function("param1", "param2", "param3", "return param1[param2] === param3;")({
                a: "b"
            }, "a", "b") === !0;
        } catch  {
            gr = !1;
        }
        return gr;
    }
    var Da = {
        exports: {}
    }, jd;
    function qM() {
        if (jd) return Da.exports;
        jd = 1, Da.exports = i, Da.exports.default = i;
        function i(b, C, E) {
            E = E || 2;
            var U = C && C.length, F = U ? C[0] * E : b.length, V = e(b, 0, F, E, !0), j = [];
            if (!V || V.next === V.prev) return j;
            var ie, z, K, oe, se, ce, we;
            if (U && (V = l(b, C, V, E)), b.length > 80 * E) {
                ie = K = b[0], z = oe = b[1];
                for(var he = E; he < F; he += E)se = b[he], ce = b[he + 1], se < ie && (ie = se), ce < z && (z = ce), se > K && (K = se), ce > oe && (oe = ce);
                we = Math.max(K - ie, oe - z), we = we !== 0 ? 32767 / we : 0;
            }
            return n(V, j, E, ie, z, we, 0), j;
        }
        function e(b, C, E, U, F) {
            var V, j;
            if (F === ne(b, C, E, U) > 0) for(V = C; V < E; V += U)j = q(V, b[V], b[V + 1], j);
            else for(V = E - U; V >= C; V -= U)j = q(V, b[V], b[V + 1], j);
            return j && y(j, j.next) && (H(j), j = j.next), j;
        }
        function t(b, C) {
            if (!b) return b;
            C || (C = b);
            var E = b, U;
            do if (U = !1, !E.steiner && (y(E, E.next) || v(E.prev, E, E.next) === 0)) {
                if (H(E), E = C = E.prev, E === E.next) break;
                U = !0;
            } else E = E.next;
            while (U || E !== C);
            return C;
        }
        function n(b, C, E, U, F, V, j) {
            if (b) {
                !j && V && f(b, U, F, V);
                for(var ie = b, z, K; b.prev !== b.next;){
                    if (z = b.prev, K = b.next, V ? r(b, U, F, V) : s(b)) {
                        C.push(z.i / E | 0), C.push(b.i / E | 0), C.push(K.i / E | 0), H(b), b = K.next, ie = K.next;
                        continue;
                    }
                    if (b = K, b === ie) {
                        j ? j === 1 ? (b = a(t(b), C, E), n(b, C, E, U, F, V, 2)) : j === 2 && o(b, C, E, U, F, V) : n(t(b), C, E, U, F, V, 1);
                        break;
                    }
                }
            }
        }
        function s(b) {
            var C = b.prev, E = b, U = b.next;
            if (v(C, E, U) >= 0) return !1;
            for(var F = C.x, V = E.x, j = U.x, ie = C.y, z = E.y, K = U.y, oe = F < V ? F < j ? F : j : V < j ? V : j, se = ie < z ? ie < K ? ie : K : z < K ? z : K, ce = F > V ? F > j ? F : j : V > j ? V : j, we = ie > z ? ie > K ? ie : K : z > K ? z : K, he = U.next; he !== C;){
                if (he.x >= oe && he.x <= ce && he.y >= se && he.y <= we && p(F, ie, V, z, j, K, he.x, he.y) && v(he.prev, he, he.next) >= 0) return !1;
                he = he.next;
            }
            return !0;
        }
        function r(b, C, E, U) {
            var F = b.prev, V = b, j = b.next;
            if (v(F, V, j) >= 0) return !1;
            for(var ie = F.x, z = V.x, K = j.x, oe = F.y, se = V.y, ce = j.y, we = ie < z ? ie < K ? ie : K : z < K ? z : K, he = oe < se ? oe < ce ? oe : ce : se < ce ? se : ce, st = ie > z ? ie > K ? ie : K : z > K ? z : K, We = oe > se ? oe > ce ? oe : ce : se > ce ? se : ce, Be = g(we, he, C, E, U), L = g(st, We, C, E, U), Ce = b.prevZ, ge = b.nextZ; Ce && Ce.z >= Be && ge && ge.z <= L;){
                if (Ce.x >= we && Ce.x <= st && Ce.y >= he && Ce.y <= We && Ce !== F && Ce !== j && p(ie, oe, z, se, K, ce, Ce.x, Ce.y) && v(Ce.prev, Ce, Ce.next) >= 0 || (Ce = Ce.prevZ, ge.x >= we && ge.x <= st && ge.y >= he && ge.y <= We && ge !== F && ge !== j && p(ie, oe, z, se, K, ce, ge.x, ge.y) && v(ge.prev, ge, ge.next) >= 0)) return !1;
                ge = ge.nextZ;
            }
            for(; Ce && Ce.z >= Be;){
                if (Ce.x >= we && Ce.x <= st && Ce.y >= he && Ce.y <= We && Ce !== F && Ce !== j && p(ie, oe, z, se, K, ce, Ce.x, Ce.y) && v(Ce.prev, Ce, Ce.next) >= 0) return !1;
                Ce = Ce.prevZ;
            }
            for(; ge && ge.z <= L;){
                if (ge.x >= we && ge.x <= st && ge.y >= he && ge.y <= We && ge !== F && ge !== j && p(ie, oe, z, se, K, ce, ge.x, ge.y) && v(ge.prev, ge, ge.next) >= 0) return !1;
                ge = ge.nextZ;
            }
            return !0;
        }
        function a(b, C, E) {
            var U = b;
            do {
                var F = U.prev, V = U.next.next;
                !y(F, V) && P(F, U, U.next, V) && T(F, V) && T(V, F) && (C.push(F.i / E | 0), C.push(U.i / E | 0), C.push(V.i / E | 0), H(U), H(U.next), U = b = V), U = U.next;
            }while (U !== b);
            return t(U);
        }
        function o(b, C, E, U, F, V) {
            var j = b;
            do {
                for(var ie = j.next.next; ie !== j.prev;){
                    if (j.i !== ie.i && x(j, ie)) {
                        var z = D(j, ie);
                        j = t(j, j.next), z = t(z, z.next), n(j, C, E, U, F, V, 0), n(z, C, E, U, F, V, 0);
                        return;
                    }
                    ie = ie.next;
                }
                j = j.next;
            }while (j !== b);
        }
        function l(b, C, E, U) {
            var F = [], V, j, ie, z, K;
            for(V = 0, j = C.length; V < j; V++)ie = C[V] * U, z = V < j - 1 ? C[V + 1] * U : b.length, K = e(b, ie, z, U, !1), K === K.next && (K.steiner = !0), F.push(m(K));
            for(F.sort(h), V = 0; V < F.length; V++)E = d(F[V], E);
            return E;
        }
        function h(b, C) {
            return b.x - C.x;
        }
        function d(b, C) {
            var E = c(b, C);
            if (!E) return C;
            var U = D(E, b);
            return t(U, U.next), t(E, E.next);
        }
        function c(b, C) {
            var E = C, U = b.x, F = b.y, V = -1 / 0, j;
            do {
                if (F <= E.y && F >= E.next.y && E.next.y !== E.y) {
                    var ie = E.x + (F - E.y) * (E.next.x - E.x) / (E.next.y - E.y);
                    if (ie <= U && ie > V && (V = ie, j = E.x < E.next.x ? E : E.next, ie === U)) return j;
                }
                E = E.next;
            }while (E !== C);
            if (!j) return null;
            var z = j, K = j.x, oe = j.y, se = 1 / 0, ce;
            E = j;
            do U >= E.x && E.x >= K && U !== E.x && p(F < oe ? U : V, F, K, oe, F < oe ? V : U, F, E.x, E.y) && (ce = Math.abs(F - E.y) / (U - E.x), T(E, b) && (ce < se || ce === se && (E.x > j.x || E.x === j.x && u(j, E))) && (j = E, se = ce)), E = E.next;
            while (E !== z);
            return j;
        }
        function u(b, C) {
            return v(b.prev, b, C.prev) < 0 && v(C.next, b, b.next) < 0;
        }
        function f(b, C, E, U) {
            var F = b;
            do F.z === 0 && (F.z = g(F.x, F.y, C, E, U)), F.prevZ = F.prev, F.nextZ = F.next, F = F.next;
            while (F !== b);
            F.prevZ.nextZ = null, F.prevZ = null, _(F);
        }
        function _(b) {
            var C, E, U, F, V, j, ie, z, K = 1;
            do {
                for(E = b, b = null, V = null, j = 0; E;){
                    for(j++, U = E, ie = 0, C = 0; C < K && (ie++, U = U.nextZ, !!U); C++);
                    for(z = K; ie > 0 || z > 0 && U;)ie !== 0 && (z === 0 || !U || E.z <= U.z) ? (F = E, E = E.nextZ, ie--) : (F = U, U = U.nextZ, z--), V ? V.nextZ = F : b = F, F.prevZ = V, V = F;
                    E = U;
                }
                V.nextZ = null, K *= 2;
            }while (j > 1);
            return b;
        }
        function g(b, C, E, U, F) {
            return b = (b - E) * F | 0, C = (C - U) * F | 0, b = (b | b << 8) & 16711935, b = (b | b << 4) & 252645135, b = (b | b << 2) & 858993459, b = (b | b << 1) & 1431655765, C = (C | C << 8) & 16711935, C = (C | C << 4) & 252645135, C = (C | C << 2) & 858993459, C = (C | C << 1) & 1431655765, b | C << 1;
        }
        function m(b) {
            var C = b, E = b;
            do (C.x < E.x || C.x === E.x && C.y < E.y) && (E = C), C = C.next;
            while (C !== b);
            return E;
        }
        function p(b, C, E, U, F, V, j, ie) {
            return (F - j) * (C - ie) >= (b - j) * (V - ie) && (b - j) * (U - ie) >= (E - j) * (C - ie) && (E - j) * (V - ie) >= (F - j) * (U - ie);
        }
        function x(b, C) {
            return b.next.i !== C.i && b.prev.i !== C.i && !B(b, C) && (T(b, C) && T(C, b) && S(b, C) && (v(b.prev, b, C.prev) || v(b, C.prev, C)) || y(b, C) && v(b.prev, b, b.next) > 0 && v(C.prev, C, C.next) > 0);
        }
        function v(b, C, E) {
            return (C.y - b.y) * (E.x - C.x) - (C.x - b.x) * (E.y - C.y);
        }
        function y(b, C) {
            return b.x === C.x && b.y === C.y;
        }
        function P(b, C, E, U) {
            var F = R(v(b, C, E)), V = R(v(b, C, U)), j = R(v(E, U, b)), ie = R(v(E, U, C));
            return !!(F !== V && j !== ie || F === 0 && w(b, E, C) || V === 0 && w(b, U, C) || j === 0 && w(E, b, U) || ie === 0 && w(E, C, U));
        }
        function w(b, C, E) {
            return C.x <= Math.max(b.x, E.x) && C.x >= Math.min(b.x, E.x) && C.y <= Math.max(b.y, E.y) && C.y >= Math.min(b.y, E.y);
        }
        function R(b) {
            return b > 0 ? 1 : b < 0 ? -1 : 0;
        }
        function B(b, C) {
            var E = b;
            do {
                if (E.i !== b.i && E.next.i !== b.i && E.i !== C.i && E.next.i !== C.i && P(E, E.next, b, C)) return !0;
                E = E.next;
            }while (E !== b);
            return !1;
        }
        function T(b, C) {
            return v(b.prev, b, b.next) < 0 ? v(b, C, b.next) >= 0 && v(b, b.prev, C) >= 0 : v(b, C, b.prev) < 0 || v(b, b.next, C) < 0;
        }
        function S(b, C) {
            var E = b, U = !1, F = (b.x + C.x) / 2, V = (b.y + C.y) / 2;
            do E.y > V != E.next.y > V && E.next.y !== E.y && F < (E.next.x - E.x) * (V - E.y) / (E.next.y - E.y) + E.x && (U = !U), E = E.next;
            while (E !== b);
            return U;
        }
        function D(b, C) {
            var E = new $(b.i, b.x, b.y), U = new $(C.i, C.x, C.y), F = b.next, V = C.prev;
            return b.next = C, C.prev = b, E.next = F, F.prev = E, U.next = E, E.prev = U, V.next = U, U.prev = V, U;
        }
        function q(b, C, E, U) {
            var F = new $(b, C, E);
            return U ? (F.next = U.next, F.prev = U, U.next.prev = F, U.next = F) : (F.prev = F, F.next = F), F;
        }
        function H(b) {
            b.next.prev = b.prev, b.prev.next = b.next, b.prevZ && (b.prevZ.nextZ = b.nextZ), b.nextZ && (b.nextZ.prevZ = b.prevZ);
        }
        function $(b, C, E) {
            this.i = b, this.x = C, this.y = E, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
        }
        i.deviation = function(b, C, E, U) {
            var F = C && C.length, V = F ? C[0] * E : b.length, j = Math.abs(ne(b, 0, V, E));
            if (F) for(var ie = 0, z = C.length; ie < z; ie++){
                var K = C[ie] * E, oe = ie < z - 1 ? C[ie + 1] * E : b.length;
                j -= Math.abs(ne(b, K, oe, E));
            }
            var se = 0;
            for(ie = 0; ie < U.length; ie += 3){
                var ce = U[ie] * E, we = U[ie + 1] * E, he = U[ie + 2] * E;
                se += Math.abs((b[ce] - b[he]) * (b[we + 1] - b[ce + 1]) - (b[ce] - b[we]) * (b[he + 1] - b[ce + 1]));
            }
            return j === 0 && se === 0 ? 0 : Math.abs((se - j) / j);
        };
        function ne(b, C, E, U) {
            for(var F = 0, V = C, j = E - U; V < E; V += U)F += (b[j] - b[V]) * (b[V + 1] + b[j + 1]), j = V;
            return F;
        }
        return i.flatten = function(b) {
            for(var C = b[0][0].length, E = {
                vertices: [],
                holes: [],
                dimensions: C
            }, U = 0, F = 0; F < b.length; F++){
                for(var V = 0; V < b[F].length; V++)for(var j = 0; j < C; j++)E.vertices.push(b[F][V][j]);
                F > 0 && (U += b[F - 1].length, E.holes.push(U));
            }
            return E;
        }, Da.exports;
    }
    var $M = qM();
    const KM = Ah($M);
    var Ei = ((i)=>(i[i.NONE = 0] = "NONE", i[i.COLOR = 16384] = "COLOR", i[i.STENCIL = 1024] = "STENCIL", i[i.DEPTH = 256] = "DEPTH", i[i.COLOR_DEPTH = 16640] = "COLOR_DEPTH", i[i.COLOR_STENCIL = 17408] = "COLOR_STENCIL", i[i.DEPTH_STENCIL = 1280] = "DEPTH_STENCIL", i[i.ALL = 17664] = "ALL", i))(Ei || {});
    class Mm {
        constructor(e){
            this.items = [], this._name = e;
        }
        emit(e, t, n, s, r, a, o, l) {
            const { name: h, items: d } = this;
            for(let c = 0, u = d.length; c < u; c++)d[c][h](e, t, n, s, r, a, o, l);
            return this;
        }
        add(e) {
            return e[this._name] && (this.remove(e), this.items.push(e)), this;
        }
        remove(e) {
            const t = this.items.indexOf(e);
            return t !== -1 && this.items.splice(t, 1), this;
        }
        contains(e) {
            return this.items.indexOf(e) !== -1;
        }
        removeAll() {
            return this.items.length = 0, this;
        }
        destroy() {
            this.removeAll(), this.items = null, this._name = null;
        }
        get empty() {
            return this.items.length === 0;
        }
        get name() {
            return this._name;
        }
    }
    const ZM = [
        "init",
        "destroy",
        "contextChange",
        "resolutionChange",
        "resetState",
        "renderEnd",
        "renderStart",
        "render",
        "update",
        "postrender",
        "prerender"
    ], Am = class Em extends yn {
        constructor(e){
            super(), this.runners = Object.create(null), this.renderPipes = Object.create(null), this._initOptions = {}, this._systemsHash = Object.create(null), this.type = e.type, this.name = e.name, this.config = e;
            const t = [
                ...ZM,
                ...this.config.runners ?? []
            ];
            this._addRunners(...t), this._unsafeEvalCheck();
        }
        async init(e = {}) {
            const t = e.skipExtensionImports === !0 ? !0 : e.manageImports === !1;
            await jM(t), this._addSystems(this.config.systems), this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);
            for(const n in this._systemsHash)e = {
                ...this._systemsHash[n].constructor.defaultOptions,
                ...e
            };
            e = {
                ...Em.defaultOptions,
                ...e
            }, this._roundPixels = e.roundPixels ? 1 : 0;
            for(let n = 0; n < this.runners.init.items.length; n++)await this.runners.init.items[n].init(e);
            this._initOptions = e;
        }
        render(e, t) {
            let n = e;
            if (n instanceof Jt && (n = {
                container: n
            }, t && (et(dt, "passing a second argument is deprecated, please use render options instead"), n.target = t.renderTexture)), n.target || (n.target = this.view.renderTarget), n.target === this.view.renderTarget && (this._lastObjectRendered = n.container, n.clearColor ?? (n.clearColor = this.background.colorRgba), n.clear ?? (n.clear = this.background.clearBeforeRender)), n.clearColor) {
                const s = Array.isArray(n.clearColor) && n.clearColor.length === 4;
                n.clearColor = s ? n.clearColor : Et.shared.setValue(n.clearColor).toArray();
            }
            n.transform || (n.container.updateLocalTransform(), n.transform = n.container.localTransform), n.container.enableRenderGroup(), this.runners.prerender.emit(n), this.runners.renderStart.emit(n), this.runners.render.emit(n), this.runners.renderEnd.emit(n), this.runners.postrender.emit(n);
        }
        resize(e, t, n) {
            const s = this.view.resolution;
            this.view.resize(e, t, n), this.emit("resize", this.view.screen.width, this.view.screen.height, this.view.resolution), n !== void 0 && n !== s && this.runners.resolutionChange.emit(n);
        }
        clear(e = {}) {
            const t = this;
            e.target || (e.target = t.renderTarget.renderTarget), e.clearColor || (e.clearColor = this.background.colorRgba), e.clear ?? (e.clear = Ei.ALL);
            const { clear: n, clearColor: s, target: r } = e;
            Et.shared.setValue(s ?? this.background.colorRgba), t.renderTarget.clear(r, n, Et.shared.toArray());
        }
        get resolution() {
            return this.view.resolution;
        }
        set resolution(e) {
            this.view.resolution = e, this.runners.resolutionChange.emit(e);
        }
        get width() {
            return this.view.texture.frame.width;
        }
        get height() {
            return this.view.texture.frame.height;
        }
        get canvas() {
            return this.view.canvas;
        }
        get lastObjectRendered() {
            return this._lastObjectRendered;
        }
        get renderingToScreen() {
            return this.renderTarget.renderingToScreen;
        }
        get screen() {
            return this.view.screen;
        }
        _addRunners(...e) {
            e.forEach((t)=>{
                this.runners[t] = new Mm(t);
            });
        }
        _addSystems(e) {
            let t;
            for(t in e){
                const n = e[t];
                this._addSystem(n.value, n.name);
            }
        }
        _addSystem(e, t) {
            const n = new e(this);
            if (this[t]) throw new Error(`Whoops! The name "${t}" is already in use`);
            this[t] = n, this._systemsHash[t] = n;
            for(const s in this.runners)this.runners[s].add(n);
            return this;
        }
        _addPipes(e, t) {
            const n = t.reduce((s, r)=>(s[r.name] = r.value, s), {});
            e.forEach((s)=>{
                const r = s.value, a = s.name, o = n[a];
                this.renderPipes[a] = new r(this, o ? new o : null);
            });
        }
        destroy(e = !1) {
            this.runners.destroy.items.reverse(), this.runners.destroy.emit(e), Object.values(this.runners).forEach((t)=>{
                t.destroy();
            }), this._systemsHash = null, this.renderPipes = null;
        }
        generateTexture(e) {
            return this.textureGenerator.generateTexture(e);
        }
        get roundPixels() {
            return !!this._roundPixels;
        }
        _unsafeEvalCheck() {
            if (!Tm()) throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
        }
        resetState() {
            this.runners.resetState.emit();
        }
    };
    Am.defaultOptions = {
        resolution: 1,
        failIfMajorPerformanceCaveat: !1,
        roundPixels: !1
    };
    let JM = Am;
    const zc = "8.9.1";
    J.Application;
    class wm {
        constructor(e){
            this._renderer = e;
        }
        init() {
            globalThis.__PIXI_RENDERER_INIT__?.(this._renderer, zc);
        }
        destroy() {
            this._renderer = null;
        }
    }
    wm.extension = {
        type: [
            J.WebGLSystem,
            J.WebGPUSystem
        ],
        name: "initHook",
        priority: -10
    };
    class Rm extends yn {
        constructor(){
            super(...arguments), this.chars = Object.create(null), this.lineHeight = 0, this.fontFamily = "", this.fontMetrics = {
                fontSize: 0,
                ascent: 0,
                descent: 0
            }, this.baseLineOffset = 0, this.distanceField = {
                type: "none",
                range: 0
            }, this.pages = [], this.applyFillAsTint = !0, this.baseMeasurementFontSize = 100, this.baseRenderedFontSize = 100;
        }
        get font() {
            return et(dt, "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead."), this.fontFamily;
        }
        get pageTextures() {
            return et(dt, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."), this.pages;
        }
        get size() {
            return et(dt, "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead."), this.fontMetrics.fontSize;
        }
        get distanceFieldRange() {
            return et(dt, "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead."), this.distanceField.range;
        }
        get distanceFieldType() {
            return et(dt, "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead."), this.distanceField.type;
        }
        destroy(e = !1) {
            this.emit("destroy", this), this.removeAllListeners();
            for(const t in this.chars)this.chars[t].texture?.destroy();
            this.chars = null, e && (this.pages.forEach((t)=>t.texture.destroy(!0)), this.pages = null);
        }
    }
    const qd = [
        {
            offset: 0,
            color: "white"
        },
        {
            offset: 1,
            color: "black"
        }
    ], Bh = class Vc {
        constructor(...e){
            this.uid = xt("fillGradient"), this.type = "linear", this.colorStops = [];
            let t = QM(e);
            t = {
                ...t.type === "radial" ? Vc.defaultRadialOptions : Vc.defaultLinearOptions,
                ...Vp(t)
            }, this._textureSize = t.textureSize, t.type === "radial" ? (this.center = t.center, this.outerCenter = t.outerCenter ?? this.center, this.innerRadius = t.innerRadius, this.outerRadius = t.outerRadius, this.scale = t.scale, this.rotation = t.rotation) : (this.start = t.start, this.end = t.end), this.textureSpace = t.textureSpace, this.type = t.type, t.colorStops.forEach((s)=>{
                this.addColorStop(s.offset, s.color);
            });
        }
        addColorStop(e, t) {
            return this.colorStops.push({
                offset: e,
                color: Et.shared.setValue(t).toHexa()
            }), this;
        }
        buildLinearGradient() {
            if (this.texture) return;
            const e = this.colorStops.length ? this.colorStops : qd, t = this._textureSize, { canvas: n, context: s } = Kd(t, 1), r = s.createLinearGradient(0, 0, this._textureSize, 0);
            $d(r, e), s.fillStyle = r, s.fillRect(0, 0, t, 1), this.texture = new Ie({
                source: new ts({
                    resource: n
                })
            });
            const { x: a, y: o } = this.start, { x: l, y: h } = this.end, d = new Ne, c = l - a, u = h - o, f = Math.sqrt(c * c + u * u), _ = Math.atan2(u, c);
            d.scale(f / t, 1), d.rotate(_), d.translate(a, o), this.textureSpace === "local" && d.scale(t, t), this.transform = d;
        }
        buildGradient() {
            this.type === "linear" ? this.buildLinearGradient() : this.buildRadialGradient();
        }
        buildRadialGradient() {
            if (this.texture) return;
            const e = this.colorStops.length ? this.colorStops : qd, t = this._textureSize, { canvas: n, context: s } = Kd(t, t), { x: r, y: a } = this.center, { x: o, y: l } = this.outerCenter, h = this.innerRadius, d = this.outerRadius, c = o - d, u = l - d, f = t / (d * 2), _ = (r - c) * f, g = (a - u) * f, m = s.createRadialGradient(_, g, h * f, (o - c) * f, (l - u) * f, d * f);
            $d(m, e), s.fillStyle = e[e.length - 1].color, s.fillRect(0, 0, t, t), s.fillStyle = m, s.translate(_, g), s.rotate(this.rotation), s.scale(1, this.scale), s.translate(-_, -g), s.fillRect(0, 0, t, t), this.texture = new Ie({
                source: new ts({
                    resource: n,
                    addressModeU: "clamp-to-edge",
                    addressModeV: "clamp-to-edge"
                })
            });
            const p = new Ne;
            p.scale(1 / f, 1 / f), p.translate(c, u), this.textureSpace === "local" && p.scale(t, t), this.transform = p;
        }
        get styleKey() {
            return this.uid;
        }
        destroy() {
            this.texture?.destroy(!0), this.texture = null;
        }
    };
    Bh.defaultLinearOptions = {
        start: {
            x: 0,
            y: 0
        },
        end: {
            x: 0,
            y: 1
        },
        colorStops: [],
        textureSpace: "local",
        type: "linear",
        textureSize: 256
    };
    Bh.defaultRadialOptions = {
        center: {
            x: .5,
            y: .5
        },
        innerRadius: 0,
        outerRadius: .5,
        colorStops: [],
        scale: 1,
        textureSpace: "local",
        type: "radial",
        textureSize: 256
    };
    let Ri = Bh;
    function $d(i, e) {
        for(let t = 0; t < e.length; t++){
            const n = e[t];
            i.addColorStop(n.offset, n.color);
        }
    }
    function Kd(i, e) {
        const t = _t.get().createCanvas(i, e), n = t.getContext("2d");
        return {
            canvas: t,
            context: n
        };
    }
    function QM(i) {
        let e = i[0] ?? {};
        return (typeof e == "number" || i[1]) && (et("8.5.2", "use options object instead"), e = {
            type: "linear",
            start: {
                x: i[0],
                y: i[1]
            },
            end: {
                x: i[2],
                y: i[3]
            },
            textureSpace: i[4],
            textureSize: i[5] ?? Ri.defaultLinearOptions.textureSize
        }), e;
    }
    const Zd = {
        repeat: {
            addressModeU: "repeat",
            addressModeV: "repeat"
        },
        "repeat-x": {
            addressModeU: "repeat",
            addressModeV: "clamp-to-edge"
        },
        "repeat-y": {
            addressModeU: "clamp-to-edge",
            addressModeV: "repeat"
        },
        "no-repeat": {
            addressModeU: "clamp-to-edge",
            addressModeV: "clamp-to-edge"
        }
    };
    class _o {
        constructor(e, t){
            this.uid = xt("fillPattern"), this.transform = new Ne, this._styleKey = null, this.texture = e, this.transform.scale(1 / e.frame.width, 1 / e.frame.height), t && (e.source.style.addressModeU = Zd[t].addressModeU, e.source.style.addressModeV = Zd[t].addressModeV);
        }
        setTransform(e) {
            const t = this.texture;
            this.transform.copyFrom(e), this.transform.invert(), this.transform.scale(1 / t.frame.width, 1 / t.frame.height), this._styleKey = null;
        }
        get styleKey() {
            return this._styleKey ? this._styleKey : (this._styleKey = `fill-pattern-${this.uid}-${this.texture.uid}-${this.transform.toArray().join("-")}`, this._styleKey);
        }
    }
    var Ml, Jd;
    function eA() {
        if (Jd) return Ml;
        Jd = 1, Ml = t;
        var i = {
            a: 7,
            c: 6,
            h: 1,
            l: 2,
            m: 2,
            q: 4,
            s: 4,
            t: 2,
            v: 1,
            z: 0
        }, e = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
        function t(r) {
            var a = [];
            return r.replace(e, function(o, l, h) {
                var d = l.toLowerCase();
                for(h = s(h), d == "m" && h.length > 2 && (a.push([
                    l
                ].concat(h.splice(0, 2))), d = "l", l = l == "m" ? "l" : "L");;){
                    if (h.length == i[d]) return h.unshift(l), a.push(h);
                    if (h.length < i[d]) throw new Error("malformed path data");
                    a.push([
                        l
                    ].concat(h.splice(0, i[d])));
                }
            }), a;
        }
        var n = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
        function s(r) {
            var a = r.match(n);
            return a ? a.map(Number) : [];
        }
        return Ml;
    }
    var tA = eA();
    const nA = Ah(tA);
    function iA(i, e) {
        const t = nA(i), n = [];
        let s = null, r = 0, a = 0;
        for(let o = 0; o < t.length; o++){
            const l = t[o], h = l[0], d = l;
            switch(h){
                case "M":
                    r = d[1], a = d[2], e.moveTo(r, a);
                    break;
                case "m":
                    r += d[1], a += d[2], e.moveTo(r, a);
                    break;
                case "H":
                    r = d[1], e.lineTo(r, a);
                    break;
                case "h":
                    r += d[1], e.lineTo(r, a);
                    break;
                case "V":
                    a = d[1], e.lineTo(r, a);
                    break;
                case "v":
                    a += d[1], e.lineTo(r, a);
                    break;
                case "L":
                    r = d[1], a = d[2], e.lineTo(r, a);
                    break;
                case "l":
                    r += d[1], a += d[2], e.lineTo(r, a);
                    break;
                case "C":
                    r = d[5], a = d[6], e.bezierCurveTo(d[1], d[2], d[3], d[4], r, a);
                    break;
                case "c":
                    e.bezierCurveTo(r + d[1], a + d[2], r + d[3], a + d[4], r + d[5], a + d[6]), r += d[5], a += d[6];
                    break;
                case "S":
                    r = d[3], a = d[4], e.bezierCurveToShort(d[1], d[2], r, a);
                    break;
                case "s":
                    e.bezierCurveToShort(r + d[1], a + d[2], r + d[3], a + d[4]), r += d[3], a += d[4];
                    break;
                case "Q":
                    r = d[3], a = d[4], e.quadraticCurveTo(d[1], d[2], r, a);
                    break;
                case "q":
                    e.quadraticCurveTo(r + d[1], a + d[2], r + d[3], a + d[4]), r += d[3], a += d[4];
                    break;
                case "T":
                    r = d[1], a = d[2], e.quadraticCurveToShort(r, a);
                    break;
                case "t":
                    r += d[1], a += d[2], e.quadraticCurveToShort(r, a);
                    break;
                case "A":
                    r = d[6], a = d[7], e.arcToSvg(d[1], d[2], d[3], d[4], d[5], r, a);
                    break;
                case "a":
                    r += d[6], a += d[7], e.arcToSvg(d[1], d[2], d[3], d[4], d[5], r, a);
                    break;
                case "Z":
                case "z":
                    e.closePath(), n.length > 0 && (s = n.pop(), s ? (r = s.startX, a = s.startY) : (r = 0, a = 0)), s = null;
                    break;
                default:
                    tt(`Unknown SVG path command: ${h}`);
            }
            h !== "Z" && h !== "z" && s === null && (s = {
                startX: r,
                startY: a
            }, n.push(s));
        }
        return e;
    }
    class Uh {
        constructor(e = 0, t = 0, n = 0){
            this.type = "circle", this.x = e, this.y = t, this.radius = n;
        }
        clone() {
            return new Uh(this.x, this.y, this.radius);
        }
        contains(e, t) {
            if (this.radius <= 0) return !1;
            const n = this.radius * this.radius;
            let s = this.x - e, r = this.y - t;
            return s *= s, r *= r, s + r <= n;
        }
        strokeContains(e, t, n, s = .5) {
            if (this.radius === 0) return !1;
            const r = this.x - e, a = this.y - t, o = this.radius, l = (1 - s) * n, h = Math.sqrt(r * r + a * a);
            return h <= o + l && h > o - (n - l);
        }
        getBounds(e) {
            return e || (e = new mt), e.x = this.x - this.radius, e.y = this.y - this.radius, e.width = this.radius * 2, e.height = this.radius * 2, e;
        }
        copyFrom(e) {
            return this.x = e.x, this.y = e.y, this.radius = e.radius, this;
        }
        copyTo(e) {
            return e.copyFrom(this), e;
        }
        toString() {
            return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
        }
    }
    class Fh {
        constructor(e = 0, t = 0, n = 0, s = 0){
            this.type = "ellipse", this.x = e, this.y = t, this.halfWidth = n, this.halfHeight = s;
        }
        clone() {
            return new Fh(this.x, this.y, this.halfWidth, this.halfHeight);
        }
        contains(e, t) {
            if (this.halfWidth <= 0 || this.halfHeight <= 0) return !1;
            let n = (e - this.x) / this.halfWidth, s = (t - this.y) / this.halfHeight;
            return n *= n, s *= s, n + s <= 1;
        }
        strokeContains(e, t, n, s = .5) {
            const { halfWidth: r, halfHeight: a } = this;
            if (r <= 0 || a <= 0) return !1;
            const o = n * (1 - s), l = n - o, h = r - l, d = a - l, c = r + o, u = a + o, f = e - this.x, _ = t - this.y, g = f * f / (h * h) + _ * _ / (d * d), m = f * f / (c * c) + _ * _ / (u * u);
            return g > 1 && m <= 1;
        }
        getBounds(e) {
            return e || (e = new mt), e.x = this.x - this.halfWidth, e.y = this.y - this.halfHeight, e.width = this.halfWidth * 2, e.height = this.halfHeight * 2, e;
        }
        copyFrom(e) {
            return this.x = e.x, this.y = e.y, this.halfWidth = e.halfWidth, this.halfHeight = e.halfHeight, this;
        }
        copyTo(e) {
            return e.copyFrom(this), e;
        }
        toString() {
            return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;
        }
    }
    function sA(i, e, t, n, s, r) {
        const a = i - t, o = e - n, l = s - t, h = r - n, d = a * l + o * h, c = l * l + h * h;
        let u = -1;
        c !== 0 && (u = d / c);
        let f, _;
        u < 0 ? (f = t, _ = n) : u > 1 ? (f = s, _ = r) : (f = t + u * l, _ = n + u * h);
        const g = i - f, m = e - _;
        return g * g + m * m;
    }
    let rA, aA;
    class Ur {
        constructor(...e){
            this.type = "polygon";
            let t = Array.isArray(e[0]) ? e[0] : e;
            if (typeof t[0] != "number") {
                const n = [];
                for(let s = 0, r = t.length; s < r; s++)n.push(t[s].x, t[s].y);
                t = n;
            }
            this.points = t, this.closePath = !0;
        }
        isClockwise() {
            let e = 0;
            const t = this.points, n = t.length;
            for(let s = 0; s < n; s += 2){
                const r = t[s], a = t[s + 1], o = t[(s + 2) % n], l = t[(s + 3) % n];
                e += (o - r) * (l + a);
            }
            return e < 0;
        }
        containsPolygon(e) {
            const t = this.getBounds(rA), n = e.getBounds(aA);
            if (!t.containsRect(n)) return !1;
            const s = e.points;
            for(let r = 0; r < s.length; r += 2){
                const a = s[r], o = s[r + 1];
                if (!this.contains(a, o)) return !1;
            }
            return !0;
        }
        clone() {
            const e = this.points.slice(), t = new Ur(e);
            return t.closePath = this.closePath, t;
        }
        contains(e, t) {
            let n = !1;
            const s = this.points.length / 2;
            for(let r = 0, a = s - 1; r < s; a = r++){
                const o = this.points[r * 2], l = this.points[r * 2 + 1], h = this.points[a * 2], d = this.points[a * 2 + 1];
                l > t != d > t && e < (h - o) * ((t - l) / (d - l)) + o && (n = !n);
            }
            return n;
        }
        strokeContains(e, t, n, s = .5) {
            const r = n * n, a = r * (1 - s), o = r - a, { points: l } = this, h = l.length - (this.closePath ? 0 : 2);
            for(let d = 0; d < h; d += 2){
                const c = l[d], u = l[d + 1], f = l[(d + 2) % l.length], _ = l[(d + 3) % l.length], g = sA(e, t, c, u, f, _), m = Math.sign((f - c) * (t - u) - (_ - u) * (e - c));
                if (g <= (m < 0 ? o : a)) return !0;
            }
            return !1;
        }
        getBounds(e) {
            e || (e = new mt);
            const t = this.points;
            let n = 1 / 0, s = -1 / 0, r = 1 / 0, a = -1 / 0;
            for(let o = 0, l = t.length; o < l; o += 2){
                const h = t[o], d = t[o + 1];
                n = h < n ? h : n, s = h > s ? h : s, r = d < r ? d : r, a = d > a ? d : a;
            }
            return e.x = n, e.width = s - n, e.y = r, e.height = a - r, e;
        }
        copyFrom(e) {
            return this.points = e.points.slice(), this.closePath = e.closePath, this;
        }
        copyTo(e) {
            return e.copyFrom(this), e;
        }
        toString() {
            return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((e, t)=>`${e}, ${t}`, "")}]`;
        }
        get lastX() {
            return this.points[this.points.length - 2];
        }
        get lastY() {
            return this.points[this.points.length - 1];
        }
        get x() {
            return this.points[this.points.length - 2];
        }
        get y() {
            return this.points[this.points.length - 1];
        }
    }
    const La = (i, e, t, n, s, r, a)=>{
        const o = i - t, l = e - n, h = Math.sqrt(o * o + l * l);
        return h >= s - r && h <= s + a;
    };
    class Nh {
        constructor(e = 0, t = 0, n = 0, s = 0, r = 20){
            this.type = "roundedRectangle", this.x = e, this.y = t, this.width = n, this.height = s, this.radius = r;
        }
        getBounds(e) {
            return e || (e = new mt), e.x = this.x, e.y = this.y, e.width = this.width, e.height = this.height, e;
        }
        clone() {
            return new Nh(this.x, this.y, this.width, this.height, this.radius);
        }
        copyFrom(e) {
            return this.x = e.x, this.y = e.y, this.width = e.width, this.height = e.height, this;
        }
        copyTo(e) {
            return e.copyFrom(this), e;
        }
        contains(e, t) {
            if (this.width <= 0 || this.height <= 0) return !1;
            if (e >= this.x && e <= this.x + this.width && t >= this.y && t <= this.y + this.height) {
                const n = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
                if (t >= this.y + n && t <= this.y + this.height - n || e >= this.x + n && e <= this.x + this.width - n) return !0;
                let s = e - (this.x + n), r = t - (this.y + n);
                const a = n * n;
                if (s * s + r * r <= a || (s = e - (this.x + this.width - n), s * s + r * r <= a) || (r = t - (this.y + this.height - n), s * s + r * r <= a) || (s = e - (this.x + n), s * s + r * r <= a)) return !0;
            }
            return !1;
        }
        strokeContains(e, t, n, s = .5) {
            const { x: r, y: a, width: o, height: l, radius: h } = this, d = n * (1 - s), c = n - d, u = r + h, f = a + h, _ = o - h * 2, g = l - h * 2, m = r + o, p = a + l;
            return (e >= r - d && e <= r + c || e >= m - c && e <= m + d) && t >= f && t <= f + g || (t >= a - d && t <= a + c || t >= p - c && t <= p + d) && e >= u && e <= u + _ ? !0 : e < u && t < f && La(e, t, u, f, h, c, d) || e > m - h && t < f && La(e, t, m - h, f, h, c, d) || e > m - h && t > p - h && La(e, t, m - h, p - h, h, c, d) || e < u && t > p - h && La(e, t, u, p - h, h, c, d);
        }
        toString() {
            return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
        }
    }
    const oA = [
        "precision mediump float;",
        "void main(void){",
        "float test = 0.1;",
        "%forloop%",
        "gl_FragColor = vec4(0.0);",
        "}"
    ].join(`
`);
    function lA(i) {
        let e = "";
        for(let t = 0; t < i; ++t)t > 0 && (e += `
else `), t < i - 1 && (e += `if(test == ${t}.0){}`);
        return e;
    }
    function cA(i, e) {
        if (i === 0) throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
        const t = e.createShader(e.FRAGMENT_SHADER);
        try {
            for(;;){
                const n = oA.replace(/%forloop%/gi, lA(i));
                if (e.shaderSource(t, n), e.compileShader(t), !e.getShaderParameter(t, e.COMPILE_STATUS)) i = i / 2 | 0;
                else break;
            }
        } finally{
            e.deleteShader(t);
        }
        return i;
    }
    let Ms = null;
    go = function() {
        if (Ms) return Ms;
        const i = _m();
        return Ms = i.getParameter(i.MAX_TEXTURE_IMAGE_UNITS), Ms = cA(Ms, i), i.getExtension("WEBGL_lose_context")?.loseContext(), Ms;
    };
    const Cm = {};
    function hA(i, e) {
        let t = 2166136261;
        for(let n = 0; n < e; n++)t ^= i[n].uid, t = Math.imul(t, 16777619), t >>>= 0;
        return Cm[t] || uA(i, e, t);
    }
    let Al = 0;
    function uA(i, e, t) {
        const n = {};
        let s = 0;
        Al || (Al = go());
        for(let a = 0; a < Al; a++){
            const o = a < e ? i[a] : Ie.EMPTY.source;
            n[s++] = o.source, n[s++] = o.style;
        }
        const r = new Br(n);
        return Cm[t] = r, r;
    }
    Qd = class {
        constructor(e){
            typeof e == "number" ? this.rawBinaryData = new ArrayBuffer(e) : e instanceof Uint8Array ? this.rawBinaryData = e.buffer : this.rawBinaryData = e, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData), this.size = this.rawBinaryData.byteLength;
        }
        get int8View() {
            return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;
        }
        get uint8View() {
            return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;
        }
        get int16View() {
            return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;
        }
        get int32View() {
            return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;
        }
        get float64View() {
            return this._float64Array || (this._float64Array = new Float64Array(this.rawBinaryData)), this._float64Array;
        }
        get bigUint64View() {
            return this._bigUint64Array || (this._bigUint64Array = new BigUint64Array(this.rawBinaryData)), this._bigUint64Array;
        }
        view(e) {
            return this[`${e}View`];
        }
        destroy() {
            this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this.uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null;
        }
        static sizeOf(e) {
            switch(e){
                case "int8":
                case "uint8":
                    return 1;
                case "int16":
                case "uint16":
                    return 2;
                case "int32":
                case "uint32":
                case "float32":
                    return 4;
                default:
                    throw new Error(`${e} isn't a valid view type`);
            }
        }
    };
    function ef(i, e) {
        const t = i.byteLength / 8 | 0, n = new Float64Array(i, 0, t);
        new Float64Array(e, 0, t).set(n);
        const r = i.byteLength - t * 8;
        if (r > 0) {
            const a = new Uint8Array(i, t * 8, r);
            new Uint8Array(e, t * 8, r).set(a);
        }
    }
    const dA = {
        normal: "normal-npm",
        add: "add-npm",
        screen: "screen-npm"
    };
    var Bt = ((i)=>(i[i.DISABLED = 0] = "DISABLED", i[i.RENDERING_MASK_ADD = 1] = "RENDERING_MASK_ADD", i[i.MASK_ACTIVE = 2] = "MASK_ACTIVE", i[i.INVERSE_MASK_ACTIVE = 3] = "INVERSE_MASK_ACTIVE", i[i.RENDERING_MASK_REMOVE = 4] = "RENDERING_MASK_REMOVE", i[i.NONE = 5] = "NONE", i))(Bt || {});
    tf = function(i, e) {
        return e.alphaMode === "no-premultiply-alpha" && dA[i] || i;
    };
    class fA {
        constructor(){
            this.ids = Object.create(null), this.textures = [], this.count = 0;
        }
        clear() {
            for(let e = 0; e < this.count; e++){
                const t = this.textures[e];
                this.textures[e] = null, this.ids[t.uid] = null;
            }
            this.count = 0;
        }
    }
    class pA {
        constructor(){
            this.renderPipeId = "batch", this.action = "startBatch", this.start = 0, this.size = 0, this.textures = new fA, this.blendMode = "normal", this.topology = "triangle-strip", this.canBundle = !0;
        }
        destroy() {
            this.textures = null, this.gpuBindGroup = null, this.bindGroup = null, this.batcher = null;
        }
    }
    const Pm = [];
    let Wc = 0;
    function nf() {
        return Wc > 0 ? Pm[--Wc] : new pA;
    }
    function sf(i) {
        Pm[Wc++] = i;
    }
    let xr = 0;
    const Im = class $a {
        constructor(e = {}){
            this.uid = xt("batcher"), this.dirty = !0, this.batchIndex = 0, this.batches = [], this._elements = [], $a.defaultOptions.maxTextures = $a.defaultOptions.maxTextures ?? go(), e = {
                ...$a.defaultOptions,
                ...e
            };
            const { maxTextures: t, attributesInitialSize: n, indicesInitialSize: s } = e;
            this.attributeBuffer = new Qd(n * 4), this.indexBuffer = new Uint16Array(s), this.maxTextures = t;
        }
        begin() {
            this.elementSize = 0, this.elementStart = 0, this.indexSize = 0, this.attributeSize = 0;
            for(let e = 0; e < this.batchIndex; e++)sf(this.batches[e]);
            this.batchIndex = 0, this._batchIndexStart = 0, this._batchIndexSize = 0, this.dirty = !0;
        }
        add(e) {
            this._elements[this.elementSize++] = e, e._indexStart = this.indexSize, e._attributeStart = this.attributeSize, e._batcher = this, this.indexSize += e.indexSize, this.attributeSize += e.attributeSize * this.vertexSize;
        }
        checkAndUpdateTexture(e, t) {
            const n = e._batch.textures.ids[t._source.uid];
            return !n && n !== 0 ? !1 : (e._textureId = n, e.texture = t, !0);
        }
        updateElement(e) {
            this.dirty = !0;
            const t = this.attributeBuffer;
            e.packAsQuad ? this.packQuadAttributes(e, t.float32View, t.uint32View, e._attributeStart, e._textureId) : this.packAttributes(e, t.float32View, t.uint32View, e._attributeStart, e._textureId);
        }
        break(e) {
            const t = this._elements;
            if (!t[this.elementStart]) return;
            let n = nf(), s = n.textures;
            s.clear();
            const r = t[this.elementStart];
            let a = tf(r.blendMode, r.texture._source), o = r.topology;
            this.attributeSize * 4 > this.attributeBuffer.size && this._resizeAttributeBuffer(this.attributeSize * 4), this.indexSize > this.indexBuffer.length && this._resizeIndexBuffer(this.indexSize);
            const l = this.attributeBuffer.float32View, h = this.attributeBuffer.uint32View, d = this.indexBuffer;
            let c = this._batchIndexSize, u = this._batchIndexStart, f = "startBatch";
            const _ = this.maxTextures;
            for(let g = this.elementStart; g < this.elementSize; ++g){
                const m = t[g];
                t[g] = null;
                const x = m.texture._source, v = tf(m.blendMode, x), y = a !== v || o !== m.topology;
                if (x._batchTick === xr && !y) {
                    m._textureId = x._textureBindLocation, c += m.indexSize, m.packAsQuad ? (this.packQuadAttributes(m, l, h, m._attributeStart, m._textureId), this.packQuadIndex(d, m._indexStart, m._attributeStart / this.vertexSize)) : (this.packAttributes(m, l, h, m._attributeStart, m._textureId), this.packIndex(m, d, m._indexStart, m._attributeStart / this.vertexSize)), m._batch = n;
                    continue;
                }
                x._batchTick = xr, (s.count >= _ || y) && (this._finishBatch(n, u, c - u, s, a, o, e, f), f = "renderBatch", u = c, a = v, o = m.topology, n = nf(), s = n.textures, s.clear(), ++xr), m._textureId = x._textureBindLocation = s.count, s.ids[x.uid] = s.count, s.textures[s.count++] = x, m._batch = n, c += m.indexSize, m.packAsQuad ? (this.packQuadAttributes(m, l, h, m._attributeStart, m._textureId), this.packQuadIndex(d, m._indexStart, m._attributeStart / this.vertexSize)) : (this.packAttributes(m, l, h, m._attributeStart, m._textureId), this.packIndex(m, d, m._indexStart, m._attributeStart / this.vertexSize));
            }
            s.count > 0 && (this._finishBatch(n, u, c - u, s, a, o, e, f), u = c, ++xr), this.elementStart = this.elementSize, this._batchIndexStart = u, this._batchIndexSize = c;
        }
        _finishBatch(e, t, n, s, r, a, o, l) {
            e.gpuBindGroup = null, e.bindGroup = null, e.action = l, e.batcher = this, e.textures = s, e.blendMode = r, e.topology = a, e.start = t, e.size = n, ++xr, this.batches[this.batchIndex++] = e, o.add(e);
        }
        finish(e) {
            this.break(e);
        }
        ensureAttributeBuffer(e) {
            e * 4 <= this.attributeBuffer.size || this._resizeAttributeBuffer(e * 4);
        }
        ensureIndexBuffer(e) {
            e <= this.indexBuffer.length || this._resizeIndexBuffer(e);
        }
        _resizeAttributeBuffer(e) {
            const t = Math.max(e, this.attributeBuffer.size * 2), n = new Qd(t);
            ef(this.attributeBuffer.rawBinaryData, n.rawBinaryData), this.attributeBuffer = n;
        }
        _resizeIndexBuffer(e) {
            const t = this.indexBuffer;
            let n = Math.max(e, t.length * 1.5);
            n += n % 2;
            const s = n > 65535 ? new Uint32Array(n) : new Uint16Array(n);
            if (s.BYTES_PER_ELEMENT !== t.BYTES_PER_ELEMENT) for(let r = 0; r < t.length; r++)s[r] = t[r];
            else ef(t.buffer, s.buffer);
            this.indexBuffer = s;
        }
        packQuadIndex(e, t, n) {
            e[t] = n + 0, e[t + 1] = n + 1, e[t + 2] = n + 2, e[t + 3] = n + 0, e[t + 4] = n + 2, e[t + 5] = n + 3;
        }
        packIndex(e, t, n, s) {
            const r = e.indices, a = e.indexSize, o = e.indexOffset, l = e.attributeOffset;
            for(let h = 0; h < a; h++)t[n++] = s + r[h + o] - l;
        }
        destroy() {
            for(let e = 0; e < this.batches.length; e++)sf(this.batches[e]);
            this.batches = null;
            for(let e = 0; e < this._elements.length; e++)this._elements[e]._batch = null;
            this._elements = null, this.indexBuffer = null, this.attributeBuffer.destroy(), this.attributeBuffer = null;
        }
    };
    Im.defaultOptions = {
        maxTextures: null,
        attributesInitialSize: 4,
        indicesInitialSize: 6
    };
    let mA = Im;
    wt = ((i)=>(i[i.MAP_READ = 1] = "MAP_READ", i[i.MAP_WRITE = 2] = "MAP_WRITE", i[i.COPY_SRC = 4] = "COPY_SRC", i[i.COPY_DST = 8] = "COPY_DST", i[i.INDEX = 16] = "INDEX", i[i.VERTEX = 32] = "VERTEX", i[i.UNIFORM = 64] = "UNIFORM", i[i.STORAGE = 128] = "STORAGE", i[i.INDIRECT = 256] = "INDIRECT", i[i.QUERY_RESOLVE = 512] = "QUERY_RESOLVE", i[i.STATIC = 1024] = "STATIC", i))(wt || {});
    is = class extends yn {
        constructor(e){
            let { data: t, size: n } = e;
            const { usage: s, label: r, shrinkToFit: a } = e;
            super(), this.uid = xt("buffer"), this._resourceType = "buffer", this._resourceId = xt("resource"), this._touched = 0, this._updateID = 1, this._dataInt32 = null, this.shrinkToFit = !0, this.destroyed = !1, t instanceof Array && (t = new Float32Array(t)), this._data = t, n ?? (n = t?.byteLength);
            const o = !!t;
            this.descriptor = {
                size: n,
                usage: s,
                mappedAtCreation: o,
                label: r
            }, this.shrinkToFit = a ?? !0;
        }
        get data() {
            return this._data;
        }
        set data(e) {
            this.setDataWithSize(e, e.length, !0);
        }
        get dataInt32() {
            return this._dataInt32 || (this._dataInt32 = new Int32Array(this.data.buffer)), this._dataInt32;
        }
        get static() {
            return !!(this.descriptor.usage & wt.STATIC);
        }
        set static(e) {
            e ? this.descriptor.usage |= wt.STATIC : this.descriptor.usage &= ~wt.STATIC;
        }
        setDataWithSize(e, t, n) {
            if (this._updateID++, this._updateSize = t * e.BYTES_PER_ELEMENT, this._data === e) {
                n && this.emit("update", this);
                return;
            }
            const s = this._data;
            if (this._data = e, this._dataInt32 = null, !s || s.length !== e.length) {
                !this.shrinkToFit && s && e.byteLength < s.byteLength ? n && this.emit("update", this) : (this.descriptor.size = e.byteLength, this._resourceId = xt("resource"), this.emit("change", this));
                return;
            }
            n && this.emit("update", this);
        }
        update(e) {
            this._updateSize = e ?? this._updateSize, this._updateID++, this.emit("update", this);
        }
        destroy() {
            this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this._data = null, this.descriptor = null, this.removeAllListeners();
        }
    };
    function Dm(i, e) {
        if (!(i instanceof is)) {
            let t = e ? wt.INDEX : wt.VERTEX;
            i instanceof Array && (e ? (i = new Uint32Array(i), t = wt.INDEX | wt.COPY_DST) : (i = new Float32Array(i), t = wt.VERTEX | wt.COPY_DST)), i = new is({
                data: i,
                label: e ? "index-mesh-buffer" : "vertex-mesh-buffer",
                usage: t
            });
        }
        return i;
    }
    function _A(i, e, t) {
        const n = i.getAttribute(e);
        if (!n) return t.minX = 0, t.minY = 0, t.maxX = 0, t.maxY = 0, t;
        const s = n.buffer.data;
        let r = 1 / 0, a = 1 / 0, o = -1 / 0, l = -1 / 0;
        const h = s.BYTES_PER_ELEMENT, d = (n.offset || 0) / h, c = (n.stride || 2 * 4) / h;
        for(let u = d; u < s.length; u += c){
            const f = s[u], _ = s[u + 1];
            f > o && (o = f), _ > l && (l = _), f < r && (r = f), _ < a && (a = _);
        }
        return t.minX = r, t.minY = a, t.maxX = o, t.maxY = l, t;
    }
    function gA(i) {
        return (i instanceof is || Array.isArray(i) || i.BYTES_PER_ELEMENT) && (i = {
            buffer: i
        }), i.buffer = Dm(i.buffer, !1), i;
    }
    Lm = class extends yn {
        constructor(e = {}){
            super(), this.uid = xt("geometry"), this._layoutKey = 0, this.instanceCount = 1, this._bounds = new sn, this._boundsDirty = !0;
            const { attributes: t, indexBuffer: n, topology: s } = e;
            if (this.buffers = [], this.attributes = {}, t) for(const r in t)this.addAttribute(r, t[r]);
            this.instanceCount = e.instanceCount ?? 1, n && this.addIndex(n), this.topology = s || "triangle-list";
        }
        onBufferUpdate() {
            this._boundsDirty = !0, this.emit("update", this);
        }
        getAttribute(e) {
            return this.attributes[e];
        }
        getIndex() {
            return this.indexBuffer;
        }
        getBuffer(e) {
            return this.getAttribute(e).buffer;
        }
        getSize() {
            for(const e in this.attributes){
                const t = this.attributes[e];
                return t.buffer.data.length / (t.stride / 4 || t.size);
            }
            return 0;
        }
        addAttribute(e, t) {
            const n = gA(t);
            this.buffers.indexOf(n.buffer) === -1 && (this.buffers.push(n.buffer), n.buffer.on("update", this.onBufferUpdate, this), n.buffer.on("change", this.onBufferUpdate, this)), this.attributes[e] = n;
        }
        addIndex(e) {
            this.indexBuffer = Dm(e, !0), this.buffers.push(this.indexBuffer);
        }
        get bounds() {
            return this._boundsDirty ? (this._boundsDirty = !1, _A(this, "aPosition", this._bounds)) : this._bounds;
        }
        destroy(e = !1) {
            this.emit("destroy", this), this.removeAllListeners(), e && this.buffers.forEach((t)=>t.destroy()), this.attributes = null, this.buffers = null, this.indexBuffer = null, this._bounds = null;
        }
    };
    const xA = new Float32Array(1), vA = new Uint32Array(1);
    class yA extends Lm {
        constructor(){
            const t = new is({
                data: xA,
                label: "attribute-batch-buffer",
                usage: wt.VERTEX | wt.COPY_DST,
                shrinkToFit: !1
            }), n = new is({
                data: vA,
                label: "index-batch-buffer",
                usage: wt.INDEX | wt.COPY_DST,
                shrinkToFit: !1
            }), s = 6 * 4;
            super({
                attributes: {
                    aPosition: {
                        buffer: t,
                        format: "float32x2",
                        stride: s,
                        offset: 0
                    },
                    aUV: {
                        buffer: t,
                        format: "float32x2",
                        stride: s,
                        offset: 2 * 4
                    },
                    aColor: {
                        buffer: t,
                        format: "unorm8x4",
                        stride: s,
                        offset: 4 * 4
                    },
                    aTextureIdAndRound: {
                        buffer: t,
                        format: "uint16x2",
                        stride: s,
                        offset: 5 * 4
                    }
                },
                indexBuffer: n
            });
        }
    }
    function rf(i, e, t) {
        if (i) for(const n in i){
            const s = n.toLocaleLowerCase(), r = e[s];
            if (r) {
                let a = i[n];
                n === "header" && (a = a.replace(/@in\s+[^;]+;\s*/g, "").replace(/@out\s+[^;]+;\s*/g, "")), t && r.push(`//----${t}----//`), r.push(a);
            } else tt(`${n} placement hook does not exist in shader`);
        }
    }
    const bA = /\{\{(.*?)\}\}/g;
    function af(i) {
        const e = {};
        return (i.match(bA)?.map((n)=>n.replace(/[{()}]/g, "")) ?? []).forEach((n)=>{
            e[n] = [];
        }), e;
    }
    function of(i, e) {
        let t;
        const n = /@in\s+([^;]+);/g;
        for(; (t = n.exec(i)) !== null;)e.push(t[1]);
    }
    function lf(i, e, t = !1) {
        const n = [];
        of(e, n), i.forEach((o)=>{
            o.header && of(o.header, n);
        });
        const s = n;
        t && s.sort();
        const r = s.map((o, l)=>`       @location(${l}) ${o},`).join(`
`);
        let a = e.replace(/@in\s+[^;]+;\s*/g, "");
        return a = a.replace("{{in}}", `
${r}
`), a;
    }
    function cf(i, e) {
        let t;
        const n = /@out\s+([^;]+);/g;
        for(; (t = n.exec(i)) !== null;)e.push(t[1]);
    }
    function SA(i) {
        const t = /\b(\w+)\s*:/g.exec(i);
        return t ? t[1] : "";
    }
    function TA(i) {
        const e = /@.*?\s+/g;
        return i.replace(e, "");
    }
    function MA(i, e) {
        const t = [];
        cf(e, t), i.forEach((l)=>{
            l.header && cf(l.header, t);
        });
        let n = 0;
        const s = t.sort().map((l)=>l.indexOf("builtin") > -1 ? l : `@location(${n++}) ${l}`).join(`,
`), r = t.sort().map((l)=>`       var ${TA(l)};`).join(`
`), a = `return VSOutput(
            ${t.sort().map((l)=>` ${SA(l)}`).join(`,
`)});`;
        let o = e.replace(/@out\s+[^;]+;\s*/g, "");
        return o = o.replace("{{struct}}", `
${s}
`), o = o.replace("{{start}}", `
${r}
`), o = o.replace("{{return}}", `
${a}
`), o;
    }
    function hf(i, e) {
        let t = i;
        for(const n in e){
            const s = e[n];
            s.join(`
`).length ? t = t.replace(`{{${n}}}`, `//-----${n} START-----//
${s.join(`
`)}
//----${n} FINISH----//`) : t = t.replace(`{{${n}}}`, "");
        }
        return t;
    }
    const Si = Object.create(null), El = new Map;
    let AA = 0;
    function EA({ template: i, bits: e }) {
        const t = Bm(i, e);
        if (Si[t]) return Si[t];
        const { vertex: n, fragment: s } = RA(i, e);
        return Si[t] = Um(n, s, e), Si[t];
    }
    function wA({ template: i, bits: e }) {
        const t = Bm(i, e);
        return Si[t] || (Si[t] = Um(i.vertex, i.fragment, e)), Si[t];
    }
    function RA(i, e) {
        const t = e.map((a)=>a.vertex).filter((a)=>!!a), n = e.map((a)=>a.fragment).filter((a)=>!!a);
        let s = lf(t, i.vertex, !0);
        s = MA(t, s);
        const r = lf(n, i.fragment, !0);
        return {
            vertex: s,
            fragment: r
        };
    }
    function Bm(i, e) {
        return e.map((t)=>(El.has(t) || El.set(t, AA++), El.get(t))).sort((t, n)=>t - n).join("-") + i.vertex + i.fragment;
    }
    function Um(i, e, t) {
        const n = af(i), s = af(e);
        return t.forEach((r)=>{
            rf(r.vertex, n, r.name), rf(r.fragment, s, r.name);
        }), {
            vertex: hf(i, n),
            fragment: hf(e, s)
        };
    }
    const CA = `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}
        
        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);
       
        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`, PA = `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;
   
    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {
        
        {{start}}

        var outColor:vec4<f32>;
      
        {{main}}
        
        var finalColor:vec4<f32> = outColor * vColor;

        {{end}}

        return finalColor;
      };
`, IA = `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;
        
        {{start}}
        
        vColor = vec4(1.);
        
        {{main}}
        
        vUV = uv;
        
        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`, DA = `
   
    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {
        
        {{start}}

        vec4 outColor;
      
        {{main}}
        
        finalColor = outColor * vColor;
        
        {{end}}
    }
`, LA = {
        name: "global-uniforms-bit",
        vertex: {
            header: `
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `
        }
    }, BA = {
        name: "global-uniforms-bit",
        vertex: {
            header: `
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `
        }
    };
    UA = function({ bits: i, name: e }) {
        const t = EA({
            template: {
                fragment: PA,
                vertex: CA
            },
            bits: [
                LA,
                ...i
            ]
        });
        return ir.from({
            name: e,
            vertex: {
                source: t.vertex,
                entryPoint: "main"
            },
            fragment: {
                source: t.fragment,
                entryPoint: "main"
            }
        });
    };
    Oh = function({ bits: i, name: e }) {
        return new $r({
            name: e,
            ...wA({
                template: {
                    vertex: IA,
                    fragment: DA
                },
                bits: [
                    BA,
                    ...i
                ]
            })
        });
    };
    let wl;
    FA = {
        name: "color-bit",
        vertex: {
            header: `
            @in aColor: vec4<f32>;
        `,
            main: `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `
        }
    };
    Fm = {
        name: "color-bit",
        vertex: {
            header: `
            in vec4 aColor;
        `,
            main: `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `
        }
    };
    wl = {};
    function NA(i) {
        const e = [];
        if (i === 1) e.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"), e.push("@group(1) @binding(1) var textureSampler1: sampler;");
        else {
            let t = 0;
            for(let n = 0; n < i; n++)e.push(`@group(1) @binding(${t++}) var textureSource${n + 1}: texture_2d<f32>;`), e.push(`@group(1) @binding(${t++}) var textureSampler${n + 1}: sampler;`);
        }
        return e.join(`
`);
    }
    function OA(i) {
        const e = [];
        if (i === 1) e.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");
        else {
            e.push("switch vTextureId {");
            for(let t = 0; t < i; t++)t === i - 1 ? e.push("  default:{") : e.push(`  case ${t}:{`), e.push(`      outColor = textureSampleGrad(textureSource${t + 1}, textureSampler${t + 1}, vUV, uvDx, uvDy);`), e.push("      break;}");
            e.push("}");
        }
        return e.join(`
`);
    }
    kA = function(i) {
        return wl[i] || (wl[i] = {
            name: "texture-batch-bit",
            vertex: {
                header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,
                main: `
                vTextureId = aTextureIdAndRound.y;
            `,
                end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `
            },
            fragment: {
                header: `
                @in @interpolate(flat) vTextureId: u32;

                ${NA(i)}
            `,
                main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${OA(i)}
            `
            }
        }), wl[i];
    };
    const Rl = {};
    function GA(i) {
        const e = [];
        for(let t = 0; t < i; t++)t > 0 && e.push("else"), t < i - 1 && e.push(`if(vTextureId < ${t}.5)`), e.push("{"), e.push(`	outColor = texture(uTextures[${t}], vUV);`), e.push("}");
        return e.join(`
`);
    }
    Nm = function(i) {
        return Rl[i] || (Rl[i] = {
            name: "texture-batch-bit",
            vertex: {
                header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `,
                main: `
                vTextureId = aTextureIdAndRound.y;
            `,
                end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `
            },
            fragment: {
                header: `
                in float vTextureId;

                uniform sampler2D uTextures[${i}];

            `,
                main: `

                ${GA(i)}
            `
            }
        }), Rl[i];
    };
    let uf;
    HA = {
        name: "round-pixels-bit",
        vertex: {
            header: `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> 
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
        }
    };
    kh = {
        name: "round-pixels-bit",
        vertex: {
            header: `   
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {       
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
        }
    };
    uf = {};
    Om = function(i) {
        let e = uf[i];
        if (e) return e;
        const t = new Int32Array(i);
        for(let n = 0; n < i; n++)t[n] = n;
        return e = uf[i] = new rs({
            uTextures: {
                value: t,
                type: "i32",
                size: i
            }
        }, {
            isStatic: !0
        }), e;
    };
    class zA extends as {
        constructor(e){
            const t = Oh({
                name: "batch",
                bits: [
                    Fm,
                    Nm(e),
                    kh
                ]
            }), n = UA({
                name: "batch",
                bits: [
                    FA,
                    kA(e),
                    HA
                ]
            });
            super({
                glProgram: t,
                gpuProgram: n,
                resources: {
                    batchSamplers: Om(e)
                }
            });
        }
    }
    let df = null;
    const km = class Gm extends mA {
        constructor(){
            super(...arguments), this.geometry = new yA, this.shader = df || (df = new zA(this.maxTextures)), this.name = Gm.extension.name, this.vertexSize = 6;
        }
        packAttributes(e, t, n, s, r) {
            const a = r << 16 | e.roundPixels & 65535, o = e.transform, l = o.a, h = o.b, d = o.c, c = o.d, u = o.tx, f = o.ty, { positions: _, uvs: g } = e, m = e.color, p = e.attributeOffset, x = p + e.attributeSize;
            for(let v = p; v < x; v++){
                const y = v * 2, P = _[y], w = _[y + 1];
                t[s++] = l * P + d * w + u, t[s++] = c * w + h * P + f, t[s++] = g[y], t[s++] = g[y + 1], n[s++] = m, n[s++] = a;
            }
        }
        packQuadAttributes(e, t, n, s, r) {
            const a = e.texture, o = e.transform, l = o.a, h = o.b, d = o.c, c = o.d, u = o.tx, f = o.ty, _ = e.bounds, g = _.maxX, m = _.minX, p = _.maxY, x = _.minY, v = a.uvs, y = e.color, P = r << 16 | e.roundPixels & 65535;
            t[s + 0] = l * m + d * x + u, t[s + 1] = c * x + h * m + f, t[s + 2] = v.x0, t[s + 3] = v.y0, n[s + 4] = y, n[s + 5] = P, t[s + 6] = l * g + d * x + u, t[s + 7] = c * x + h * g + f, t[s + 8] = v.x1, t[s + 9] = v.y1, n[s + 10] = y, n[s + 11] = P, t[s + 12] = l * g + d * p + u, t[s + 13] = c * p + h * g + f, t[s + 14] = v.x2, t[s + 15] = v.y2, n[s + 16] = y, n[s + 17] = P, t[s + 18] = l * m + d * p + u, t[s + 19] = c * p + h * m + f, t[s + 20] = v.x3, t[s + 21] = v.y3, n[s + 22] = y, n[s + 23] = P;
        }
    };
    km.extension = {
        type: [
            J.Batcher
        ],
        name: "default"
    };
    let Gh = km;
    function VA(i, e, t, n, s, r, a, o = null) {
        let l = 0;
        t *= e, s *= r;
        const h = o.a, d = o.b, c = o.c, u = o.d, f = o.tx, _ = o.ty;
        for(; l < a;){
            const g = i[t], m = i[t + 1];
            n[s] = h * g + c * m + f, n[s + 1] = d * g + u * m + _, s += r, t += e, l++;
        }
    }
    function WA(i, e, t, n) {
        let s = 0;
        for(e *= t; s < n;)i[e] = 0, i[e + 1] = 0, e += t, s++;
    }
    function Hm(i, e, t, n, s) {
        const r = e.a, a = e.b, o = e.c, l = e.d, h = e.tx, d = e.ty;
        t || (t = 0), n || (n = 2), s || (s = i.length / n - t);
        let c = t * n;
        for(let u = 0; u < s; u++){
            const f = i[c], _ = i[c + 1];
            i[c] = r * f + o * _ + h, i[c + 1] = a * f + l * _ + d, c += n;
        }
    }
    const XA = new Ne;
    zm = class {
        constructor(){
            this.packAsQuad = !1, this.batcherName = "default", this.topology = "triangle-list", this.applyTransform = !0, this.roundPixels = 0, this._batcher = null, this._batch = null;
        }
        get uvs() {
            return this.geometryData.uvs;
        }
        get positions() {
            return this.geometryData.vertices;
        }
        get indices() {
            return this.geometryData.indices;
        }
        get blendMode() {
            return this.applyTransform ? this.renderable.groupBlendMode : "normal";
        }
        get color() {
            const e = this.baseColor, t = e >> 16 | e & 65280 | (e & 255) << 16, n = this.renderable;
            return n ? Qp(t, n.groupColor) + (this.alpha * n.groupAlpha * 255 << 24) : t + (this.alpha * 255 << 24);
        }
        get transform() {
            return this.renderable?.groupTransform || XA;
        }
        copyTo(e) {
            e.indexOffset = this.indexOffset, e.indexSize = this.indexSize, e.attributeOffset = this.attributeOffset, e.attributeSize = this.attributeSize, e.baseColor = this.baseColor, e.alpha = this.alpha, e.texture = this.texture, e.geometryData = this.geometryData, e.topology = this.topology;
        }
        reset() {
            this.applyTransform = !0, this.renderable = null, this.topology = "triangle-list";
        }
    };
    const Yr = {
        extension: {
            type: J.ShapeBuilder,
            name: "circle"
        },
        build (i, e) {
            let t, n, s, r, a, o;
            if (i.type === "circle") {
                const y = i;
                t = y.x, n = y.y, a = o = y.radius, s = r = 0;
            } else if (i.type === "ellipse") {
                const y = i;
                t = y.x, n = y.y, a = y.halfWidth, o = y.halfHeight, s = r = 0;
            } else {
                const y = i, P = y.width / 2, w = y.height / 2;
                t = y.x + P, n = y.y + w, a = o = Math.max(0, Math.min(y.radius, Math.min(P, w))), s = P - a, r = w - o;
            }
            if (!(a >= 0 && o >= 0 && s >= 0 && r >= 0)) return e;
            const l = Math.ceil(2.3 * Math.sqrt(a + o)), h = l * 8 + (s ? 4 : 0) + (r ? 4 : 0);
            if (h === 0) return e;
            if (l === 0) return e[0] = e[6] = t + s, e[1] = e[3] = n + r, e[2] = e[4] = t - s, e[5] = e[7] = n - r, e;
            let d = 0, c = l * 4 + (s ? 2 : 0) + 2, u = c, f = h, _ = s + a, g = r, m = t + _, p = t - _, x = n + g;
            if (e[d++] = m, e[d++] = x, e[--c] = x, e[--c] = p, r) {
                const y = n - g;
                e[u++] = p, e[u++] = y, e[--f] = y, e[--f] = m;
            }
            for(let y = 1; y < l; y++){
                const P = Math.PI / 2 * (y / l), w = s + Math.cos(P) * a, R = r + Math.sin(P) * o, B = t + w, T = t - w, S = n + R, D = n - R;
                e[d++] = B, e[d++] = S, e[--c] = S, e[--c] = T, e[u++] = T, e[u++] = D, e[--f] = D, e[--f] = B;
            }
            _ = s, g = r + o, m = t + _, p = t - _, x = n + g;
            const v = n - g;
            return e[d++] = m, e[d++] = x, e[--f] = v, e[--f] = m, s && (e[d++] = p, e[d++] = x, e[--f] = v, e[--f] = p), e;
        },
        triangulate (i, e, t, n, s, r) {
            if (i.length === 0) return;
            let a = 0, o = 0;
            for(let d = 0; d < i.length; d += 2)a += i[d], o += i[d + 1];
            a /= i.length / 2, o /= i.length / 2;
            let l = n;
            e[l * t] = a, e[l * t + 1] = o;
            const h = l++;
            for(let d = 0; d < i.length; d += 2)e[l * t] = i[d], e[l * t + 1] = i[d + 1], d > 0 && (s[r++] = l, s[r++] = h, s[r++] = l - 1), l++;
            s[r++] = h + 1, s[r++] = h, s[r++] = l - 1;
        }
    }, YA = {
        ...Yr,
        extension: {
            ...Yr.extension,
            name: "ellipse"
        }
    }, jA = {
        ...Yr,
        extension: {
            ...Yr.extension,
            name: "roundedRectangle"
        }
    }, Vm = 1e-4, ff = 1e-4;
    function qA(i) {
        const e = i.length;
        if (e < 6) return 1;
        let t = 0;
        for(let n = 0, s = i[e - 2], r = i[e - 1]; n < e; n += 2){
            const a = i[n], o = i[n + 1];
            t += (a - s) * (o + r), s = a, r = o;
        }
        return t < 0 ? -1 : 1;
    }
    function pf(i, e, t, n, s, r, a, o) {
        const l = i - t * s, h = e - n * s, d = i + t * r, c = e + n * r;
        let u, f;
        a ? (u = n, f = -t) : (u = -n, f = t);
        const _ = l + u, g = h + f, m = d + u, p = c + f;
        return o.push(_, g), o.push(m, p), 2;
    }
    function Oi(i, e, t, n, s, r, a, o) {
        const l = t - i, h = n - e;
        let d = Math.atan2(l, h), c = Math.atan2(s - i, r - e);
        o && d < c ? d += Math.PI * 2 : !o && d > c && (c += Math.PI * 2);
        let u = d;
        const f = c - d, _ = Math.abs(f), g = Math.sqrt(l * l + h * h), m = (15 * _ * Math.sqrt(g) / Math.PI >> 0) + 1, p = f / m;
        if (u += p, o) {
            a.push(i, e), a.push(t, n);
            for(let x = 1, v = u; x < m; x++, v += p)a.push(i, e), a.push(i + Math.sin(v) * g, e + Math.cos(v) * g);
            a.push(i, e), a.push(s, r);
        } else {
            a.push(t, n), a.push(i, e);
            for(let x = 1, v = u; x < m; x++, v += p)a.push(i + Math.sin(v) * g, e + Math.cos(v) * g), a.push(i, e);
            a.push(s, r), a.push(i, e);
        }
        return m * 2;
    }
    function $A(i, e, t, n, s, r) {
        const a = Vm;
        if (i.length === 0) return;
        const o = e;
        let l = o.alignment;
        if (e.alignment !== .5) {
            let U = qA(i);
            l = (l - .5) * U + .5;
        }
        const h = new Ot(i[0], i[1]), d = new Ot(i[i.length - 2], i[i.length - 1]), c = n, u = Math.abs(h.x - d.x) < a && Math.abs(h.y - d.y) < a;
        if (c) {
            i = i.slice(), u && (i.pop(), i.pop(), d.set(i[i.length - 2], i[i.length - 1]));
            const U = (h.x + d.x) * .5, F = (d.y + h.y) * .5;
            i.unshift(U, F), i.push(U, F);
        }
        const f = s, _ = i.length / 2;
        let g = i.length;
        const m = f.length / 2, p = o.width / 2, x = p * p, v = o.miterLimit * o.miterLimit;
        let y = i[0], P = i[1], w = i[2], R = i[3], B = 0, T = 0, S = -(P - R), D = y - w, q = 0, H = 0, $ = Math.sqrt(S * S + D * D);
        S /= $, D /= $, S *= p, D *= p;
        const ne = l, b = (1 - ne) * 2, C = ne * 2;
        c || (o.cap === "round" ? g += Oi(y - S * (b - C) * .5, P - D * (b - C) * .5, y - S * b, P - D * b, y + S * C, P + D * C, f, !0) + 2 : o.cap === "square" && (g += pf(y, P, S, D, b, C, !0, f))), f.push(y - S * b, P - D * b), f.push(y + S * C, P + D * C);
        for(let U = 1; U < _ - 1; ++U){
            y = i[(U - 1) * 2], P = i[(U - 1) * 2 + 1], w = i[U * 2], R = i[U * 2 + 1], B = i[(U + 1) * 2], T = i[(U + 1) * 2 + 1], S = -(P - R), D = y - w, $ = Math.sqrt(S * S + D * D), S /= $, D /= $, S *= p, D *= p, q = -(R - T), H = w - B, $ = Math.sqrt(q * q + H * H), q /= $, H /= $, q *= p, H *= p;
            const F = w - y, V = P - R, j = w - B, ie = T - R, z = F * j + V * ie, K = V * j - ie * F, oe = K < 0;
            if (Math.abs(K) < .001 * Math.abs(z)) {
                f.push(w - S * b, R - D * b), f.push(w + S * C, R + D * C), z >= 0 && (o.join === "round" ? g += Oi(w, R, w - S * b, R - D * b, w - q * b, R - H * b, f, !1) + 4 : g += 2, f.push(w - q * C, R - H * C), f.push(w + q * b, R + H * b));
                continue;
            }
            const se = (-S + y) * (-D + R) - (-S + w) * (-D + P), ce = (-q + B) * (-H + R) - (-q + w) * (-H + T), we = (F * ce - j * se) / K, he = (ie * se - V * ce) / K, st = (we - w) * (we - w) + (he - R) * (he - R), We = w + (we - w) * b, Be = R + (he - R) * b, L = w - (we - w) * C, Ce = R - (he - R) * C, ge = Math.min(F * F + V * V, j * j + ie * ie), Xe = oe ? b : C, Ae = ge + Xe * Xe * x;
            st <= Ae ? o.join === "bevel" || st / x > v ? (oe ? (f.push(We, Be), f.push(w + S * C, R + D * C), f.push(We, Be), f.push(w + q * C, R + H * C)) : (f.push(w - S * b, R - D * b), f.push(L, Ce), f.push(w - q * b, R - H * b), f.push(L, Ce)), g += 2) : o.join === "round" ? oe ? (f.push(We, Be), f.push(w + S * C, R + D * C), g += Oi(w, R, w + S * C, R + D * C, w + q * C, R + H * C, f, !0) + 4, f.push(We, Be), f.push(w + q * C, R + H * C)) : (f.push(w - S * b, R - D * b), f.push(L, Ce), g += Oi(w, R, w - S * b, R - D * b, w - q * b, R - H * b, f, !1) + 4, f.push(w - q * b, R - H * b), f.push(L, Ce)) : (f.push(We, Be), f.push(L, Ce)) : (f.push(w - S * b, R - D * b), f.push(w + S * C, R + D * C), o.join === "round" ? oe ? g += Oi(w, R, w + S * C, R + D * C, w + q * C, R + H * C, f, !0) + 2 : g += Oi(w, R, w - S * b, R - D * b, w - q * b, R - H * b, f, !1) + 2 : o.join === "miter" && st / x <= v && (oe ? (f.push(L, Ce), f.push(L, Ce)) : (f.push(We, Be), f.push(We, Be)), g += 2), f.push(w - q * b, R - H * b), f.push(w + q * C, R + H * C), g += 2);
        }
        y = i[(_ - 2) * 2], P = i[(_ - 2) * 2 + 1], w = i[(_ - 1) * 2], R = i[(_ - 1) * 2 + 1], S = -(P - R), D = y - w, $ = Math.sqrt(S * S + D * D), S /= $, D /= $, S *= p, D *= p, f.push(w - S * b, R - D * b), f.push(w + S * C, R + D * C), c || (o.cap === "round" ? g += Oi(w - S * (b - C) * .5, R - D * (b - C) * .5, w - S * b, R - D * b, w + S * C, R + D * C, f, !1) + 2 : o.cap === "square" && (g += pf(w, R, S, D, b, C, !1, f)));
        const E = ff * ff;
        for(let U = m; U < g + m - 2; ++U)y = f[U * 2], P = f[U * 2 + 1], w = f[(U + 1) * 2], R = f[(U + 1) * 2 + 1], B = f[(U + 2) * 2], T = f[(U + 2) * 2 + 1], !(Math.abs(y * (R - T) + w * (T - P) + B * (P - R)) < E) && r.push(U, U + 1, U + 2);
    }
    function KA(i, e, t, n) {
        const s = Vm;
        if (i.length === 0) return;
        const r = i[0], a = i[1], o = i[i.length - 2], l = i[i.length - 1], h = e || Math.abs(r - o) < s && Math.abs(a - l) < s, d = t, c = i.length / 2, u = d.length / 2;
        for(let f = 0; f < c; f++)d.push(i[f * 2]), d.push(i[f * 2 + 1]);
        for(let f = 0; f < c - 1; f++)n.push(u + f, u + f + 1);
        h && n.push(u + c - 1, u);
    }
    function Wm(i, e, t, n, s, r, a) {
        const o = KM(i, e, 2);
        if (!o) return;
        for(let h = 0; h < o.length; h += 3)r[a++] = o[h] + s, r[a++] = o[h + 1] + s, r[a++] = o[h + 2] + s;
        let l = s * n;
        for(let h = 0; h < i.length; h += 2)t[l] = i[h], t[l + 1] = i[h + 1], l += n;
    }
    const ZA = [], JA = {
        extension: {
            type: J.ShapeBuilder,
            name: "polygon"
        },
        build (i, e) {
            for(let t = 0; t < i.points.length; t++)e[t] = i.points[t];
            return e;
        },
        triangulate (i, e, t, n, s, r) {
            Wm(i, ZA, e, t, n, s, r);
        }
    }, QA = {
        extension: {
            type: J.ShapeBuilder,
            name: "rectangle"
        },
        build (i, e) {
            const t = i, n = t.x, s = t.y, r = t.width, a = t.height;
            return r >= 0 && a >= 0 && (e[0] = n, e[1] = s, e[2] = n + r, e[3] = s, e[4] = n + r, e[5] = s + a, e[6] = n, e[7] = s + a), e;
        },
        triangulate (i, e, t, n, s, r) {
            let a = 0;
            n *= t, e[n + a] = i[0], e[n + a + 1] = i[1], a += t, e[n + a] = i[2], e[n + a + 1] = i[3], a += t, e[n + a] = i[6], e[n + a + 1] = i[7], a += t, e[n + a] = i[4], e[n + a + 1] = i[5], a += t;
            const o = n / t;
            s[r++] = o, s[r++] = o + 1, s[r++] = o + 2, s[r++] = o + 1, s[r++] = o + 3, s[r++] = o + 2;
        }
    }, eE = {
        extension: {
            type: J.ShapeBuilder,
            name: "triangle"
        },
        build (i, e) {
            return e[0] = i.x, e[1] = i.y, e[2] = i.x2, e[3] = i.y2, e[4] = i.x3, e[5] = i.y3, e;
        },
        triangulate (i, e, t, n, s, r) {
            let a = 0;
            n *= t, e[n + a] = i[0], e[n + a + 1] = i[1], a += t, e[n + a] = i[2], e[n + a + 1] = i[3], a += t, e[n + a] = i[4], e[n + a + 1] = i[5];
            const o = n / t;
            s[r++] = o, s[r++] = o + 1, s[r++] = o + 2;
        }
    }, tE = new Ne, nE = new mt;
    function iE(i, e, t, n) {
        const s = e.matrix ? i.copyFrom(e.matrix).invert() : i.identity();
        if (e.textureSpace === "local") {
            const r = t.getBounds(nE);
            s.translate(-r.x, -r.y), s.scale(1 / r.width, 1 / r.height);
        } else {
            s.translate(e.texture.frame.x, e.texture.frame.y), s.scale(1 / e.texture.source.width, 1 / e.texture.source.height);
            const r = e.texture.source.style;
            r.addressMode === "clamp-to-edge" && (r.addressMode = "repeat", r.update());
        }
        return n && s.append(tE.copyFrom(n).invert()), s;
    }
    const xo = {};
    At.handleByMap(J.ShapeBuilder, xo);
    At.add(QA, JA, eE, Yr, YA, jA);
    const sE = new mt, rE = new Ne;
    function aE(i, e) {
        const { geometryData: t, batches: n } = e;
        n.length = 0, t.indices.length = 0, t.vertices.length = 0, t.uvs.length = 0;
        for(let s = 0; s < i.instructions.length; s++){
            const r = i.instructions[s];
            if (r.action === "texture") oE(r.data, n, t);
            else if (r.action === "fill" || r.action === "stroke") {
                const a = r.action === "stroke", o = r.data.path.shapePath, l = r.data.style, h = r.data.hole;
                a && h && mf(h.shapePath, l, !0, n, t), h && (o.shapePrimitives[o.shapePrimitives.length - 1].holes = h.shapePath.shapePrimitives), mf(o, l, a, n, t);
            }
        }
    }
    function oE(i, e, t) {
        const { vertices: n, uvs: s, indices: r } = t, a = r.length, o = n.length / 2, l = [], h = xo.rectangle, d = sE, c = i.image;
        d.x = i.dx, d.y = i.dy, d.width = i.dw, d.height = i.dh;
        const u = i.transform;
        h.build(d, l), u && Hm(l, u), h.triangulate(l, n, 2, o, r, a);
        const f = c.uvs;
        s.push(f.x0, f.y0, f.x1, f.y1, f.x3, f.y3, f.x2, f.y2);
        const _ = Vt.get(zm);
        _.indexOffset = a, _.indexSize = r.length - a, _.attributeOffset = o, _.attributeSize = n.length / 2 - o, _.baseColor = i.style, _.alpha = i.alpha, _.texture = c, _.geometryData = t, e.push(_);
    }
    function mf(i, e, t, n, s) {
        const { vertices: r, uvs: a, indices: o } = s;
        i.shapePrimitives.forEach(({ shape: l, transform: h, holes: d })=>{
            const c = o.length, u = r.length / 2, f = [], _ = xo[l.type];
            let g = "triangle-list";
            if (_.build(l, f), h && Hm(f, h), t) {
                const v = l.closePath ?? !0, y = e;
                y.pixelLine ? (KA(f, v, r, o), g = "line-list") : $A(f, y, !1, v, r, o);
            } else if (d) {
                const v = [], y = f.slice();
                lE(d).forEach((w)=>{
                    v.push(y.length / 2), y.push(...w);
                }), Wm(y, v, r, 2, u, o, c);
            } else _.triangulate(f, r, 2, u, o, c);
            const m = a.length / 2, p = e.texture;
            if (p !== Ie.WHITE) {
                const v = iE(rE, e, l, h);
                VA(r, 2, u, a, m, 2, r.length / 2 - u, v);
            } else WA(a, m, 2, r.length / 2 - u);
            const x = Vt.get(zm);
            x.indexOffset = c, x.indexSize = o.length - c, x.attributeOffset = u, x.attributeSize = r.length / 2 - u, x.baseColor = e.color, x.alpha = e.alpha, x.texture = p, x.geometryData = s, x.topology = g, n.push(x);
        });
    }
    function lE(i) {
        const e = [];
        for(let t = 0; t < i.length; t++){
            const n = i[t].shape, s = [];
            xo[n.type].build(n, s), e.push(s);
        }
        return e;
    }
    class cE {
        constructor(){
            this.batches = [], this.geometryData = {
                vertices: [],
                uvs: [],
                indices: []
            };
        }
    }
    class hE {
        constructor(){
            this.batcher = new Gh, this.instructions = new nm;
        }
        init() {
            this.instructions.reset();
        }
        get geometry() {
            return et(NT, "GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead."), this.batcher.geometry;
        }
    }
    const Hh = class Xc {
        constructor(e){
            this._gpuContextHash = {}, this._graphicsDataContextHash = Object.create(null), e.renderableGC.addManagedHash(this, "_gpuContextHash"), e.renderableGC.addManagedHash(this, "_graphicsDataContextHash");
        }
        init(e) {
            Xc.defaultOptions.bezierSmoothness = e?.bezierSmoothness ?? Xc.defaultOptions.bezierSmoothness;
        }
        getContextRenderData(e) {
            return this._graphicsDataContextHash[e.uid] || this._initContextRenderData(e);
        }
        updateGpuContext(e) {
            let t = this._gpuContextHash[e.uid] || this._initContext(e);
            if (e.dirty) {
                t ? this._cleanGraphicsContextData(e) : t = this._initContext(e), aE(e, t);
                const n = e.batchMode;
                e.customShader || n === "no-batch" ? t.isBatchable = !1 : n === "auto" && (t.isBatchable = t.geometryData.vertices.length < 400), e.dirty = !1;
            }
            return t;
        }
        getGpuContext(e) {
            return this._gpuContextHash[e.uid] || this._initContext(e);
        }
        _initContextRenderData(e) {
            const t = Vt.get(hE), { batches: n, geometryData: s } = this._gpuContextHash[e.uid], r = s.vertices.length, a = s.indices.length;
            for(let d = 0; d < n.length; d++)n[d].applyTransform = !1;
            const o = t.batcher;
            o.ensureAttributeBuffer(r), o.ensureIndexBuffer(a), o.begin();
            for(let d = 0; d < n.length; d++){
                const c = n[d];
                o.add(c);
            }
            o.finish(t.instructions);
            const l = o.geometry;
            l.indexBuffer.setDataWithSize(o.indexBuffer, o.indexSize, !0), l.buffers[0].setDataWithSize(o.attributeBuffer.float32View, o.attributeSize, !0);
            const h = o.batches;
            for(let d = 0; d < h.length; d++){
                const c = h[d];
                c.bindGroup = hA(c.textures.textures, c.textures.count);
            }
            return this._graphicsDataContextHash[e.uid] = t, t;
        }
        _initContext(e) {
            const t = new cE;
            return t.context = e, this._gpuContextHash[e.uid] = t, e.on("destroy", this.onGraphicsContextDestroy, this), this._gpuContextHash[e.uid];
        }
        onGraphicsContextDestroy(e) {
            this._cleanGraphicsContextData(e), e.off("destroy", this.onGraphicsContextDestroy, this), this._gpuContextHash[e.uid] = null;
        }
        _cleanGraphicsContextData(e) {
            const t = this._gpuContextHash[e.uid];
            t.isBatchable || this._graphicsDataContextHash[e.uid] && (Vt.return(this.getContextRenderData(e)), this._graphicsDataContextHash[e.uid] = null), t.batches && t.batches.forEach((n)=>{
                Vt.return(n);
            });
        }
        destroy() {
            for(const e in this._gpuContextHash)this._gpuContextHash[e] && this.onGraphicsContextDestroy(this._gpuContextHash[e].context);
        }
    };
    Hh.extension = {
        type: [
            J.WebGLSystem,
            J.WebGPUSystem,
            J.CanvasSystem
        ],
        name: "graphicsContext"
    };
    Hh.defaultOptions = {
        bezierSmoothness: .5
    };
    Xm = Hh;
    const uE = 8, Ba = 11920929e-14, dE = 1;
    function Ym(i, e, t, n, s, r, a, o, l, h) {
        const c = Math.min(.99, Math.max(0, h ?? Xm.defaultOptions.bezierSmoothness));
        let u = (dE - c) / 1;
        return u *= u, fE(e, t, n, s, r, a, o, l, i, u), i;
    }
    function fE(i, e, t, n, s, r, a, o, l, h) {
        Yc(i, e, t, n, s, r, a, o, l, h, 0), l.push(a, o);
    }
    function Yc(i, e, t, n, s, r, a, o, l, h, d) {
        if (d > uE) return;
        const c = (i + t) / 2, u = (e + n) / 2, f = (t + s) / 2, _ = (n + r) / 2, g = (s + a) / 2, m = (r + o) / 2, p = (c + f) / 2, x = (u + _) / 2, v = (f + g) / 2, y = (_ + m) / 2, P = (p + v) / 2, w = (x + y) / 2;
        if (d > 0) {
            let R = a - i, B = o - e;
            const T = Math.abs((t - a) * B - (n - o) * R), S = Math.abs((s - a) * B - (r - o) * R);
            if (T > Ba && S > Ba) {
                if ((T + S) * (T + S) <= h * (R * R + B * B)) {
                    l.push(P, w);
                    return;
                }
            } else if (T > Ba) {
                if (T * T <= h * (R * R + B * B)) {
                    l.push(P, w);
                    return;
                }
            } else if (S > Ba) {
                if (S * S <= h * (R * R + B * B)) {
                    l.push(P, w);
                    return;
                }
            } else if (R = P - (i + a) / 2, B = w - (e + o) / 2, R * R + B * B <= h) {
                l.push(P, w);
                return;
            }
        }
        Yc(i, e, c, u, p, x, P, w, l, h, d + 1), Yc(P, w, v, y, g, m, a, o, l, h, d + 1);
    }
    const pE = 8, mE = 11920929e-14, _E = 1;
    function gE(i, e, t, n, s, r, a, o) {
        const h = Math.min(.99, Math.max(0, o ?? Xm.defaultOptions.bezierSmoothness));
        let d = (_E - h) / 1;
        return d *= d, xE(e, t, n, s, r, a, i, d), i;
    }
    function xE(i, e, t, n, s, r, a, o) {
        jc(a, i, e, t, n, s, r, o, 0), a.push(s, r);
    }
    function jc(i, e, t, n, s, r, a, o, l) {
        if (l > pE) return;
        const h = (e + n) / 2, d = (t + s) / 2, c = (n + r) / 2, u = (s + a) / 2, f = (h + c) / 2, _ = (d + u) / 2;
        let g = r - e, m = a - t;
        const p = Math.abs((n - r) * m - (s - a) * g);
        if (p > mE) {
            if (p * p <= o * (g * g + m * m)) {
                i.push(f, _);
                return;
            }
        } else if (g = f - (e + r) / 2, m = _ - (t + a) / 2, g * g + m * m <= o) {
            i.push(f, _);
            return;
        }
        jc(i, e, t, h, d, f, _, o, l + 1), jc(i, f, _, c, u, r, a, o, l + 1);
    }
    function jm(i, e, t, n, s, r, a, o) {
        let l = Math.abs(s - r);
        (!a && s > r || a && r > s) && (l = 2 * Math.PI - l), o || (o = Math.max(6, Math.floor(6 * Math.pow(n, 1 / 3) * (l / Math.PI)))), o = Math.max(o, 3);
        let h = l / o, d = s;
        h *= a ? -1 : 1;
        for(let c = 0; c < o + 1; c++){
            const u = Math.cos(d), f = Math.sin(d), _ = e + u * n, g = t + f * n;
            i.push(_, g), d += h;
        }
    }
    function vE(i, e, t, n, s, r) {
        const a = i[i.length - 2], l = i[i.length - 1] - t, h = a - e, d = s - t, c = n - e, u = Math.abs(l * c - h * d);
        if (u < 1e-8 || r === 0) {
            (i[i.length - 2] !== e || i[i.length - 1] !== t) && i.push(e, t);
            return;
        }
        const f = l * l + h * h, _ = d * d + c * c, g = l * d + h * c, m = r * Math.sqrt(f) / u, p = r * Math.sqrt(_) / u, x = m * g / f, v = p * g / _, y = m * c + p * h, P = m * d + p * l, w = h * (p + x), R = l * (p + x), B = c * (m + v), T = d * (m + v), S = Math.atan2(R - P, w - y), D = Math.atan2(T - P, B - y);
        jm(i, y + e, P + t, r, S, D, h * d > c * l);
    }
    const Fr = Math.PI * 2, Cl = {
        centerX: 0,
        centerY: 0,
        ang1: 0,
        ang2: 0
    }, Pl = ({ x: i, y: e }, t, n, s, r, a, o, l)=>{
        i *= t, e *= n;
        const h = s * i - r * e, d = r * i + s * e;
        return l.x = h + a, l.y = d + o, l;
    };
    function yE(i, e) {
        const t = e === -1.5707963267948966 ? -.551915024494 : 1.3333333333333333 * Math.tan(e / 4), n = e === 1.5707963267948966 ? .551915024494 : t, s = Math.cos(i), r = Math.sin(i), a = Math.cos(i + e), o = Math.sin(i + e);
        return [
            {
                x: s - r * n,
                y: r + s * n
            },
            {
                x: a + o * n,
                y: o - a * n
            },
            {
                x: a,
                y: o
            }
        ];
    }
    const _f = (i, e, t, n)=>{
        const s = i * n - e * t < 0 ? -1 : 1;
        let r = i * t + e * n;
        return r > 1 && (r = 1), r < -1 && (r = -1), s * Math.acos(r);
    }, bE = (i, e, t, n, s, r, a, o, l, h, d, c, u)=>{
        const f = Math.pow(s, 2), _ = Math.pow(r, 2), g = Math.pow(d, 2), m = Math.pow(c, 2);
        let p = f * _ - f * m - _ * g;
        p < 0 && (p = 0), p /= f * m + _ * g, p = Math.sqrt(p) * (a === o ? -1 : 1);
        const x = p * s / r * c, v = p * -r / s * d, y = h * x - l * v + (i + t) / 2, P = l * x + h * v + (e + n) / 2, w = (d - x) / s, R = (c - v) / r, B = (-d - x) / s, T = (-c - v) / r, S = _f(1, 0, w, R);
        let D = _f(w, R, B, T);
        o === 0 && D > 0 && (D -= Fr), o === 1 && D < 0 && (D += Fr), u.centerX = y, u.centerY = P, u.ang1 = S, u.ang2 = D;
    };
    function SE(i, e, t, n, s, r, a, o = 0, l = 0, h = 0) {
        if (r === 0 || a === 0) return;
        const d = Math.sin(o * Fr / 360), c = Math.cos(o * Fr / 360), u = c * (e - n) / 2 + d * (t - s) / 2, f = -d * (e - n) / 2 + c * (t - s) / 2;
        if (u === 0 && f === 0) return;
        r = Math.abs(r), a = Math.abs(a);
        const _ = Math.pow(u, 2) / Math.pow(r, 2) + Math.pow(f, 2) / Math.pow(a, 2);
        _ > 1 && (r *= Math.sqrt(_), a *= Math.sqrt(_)), bE(e, t, n, s, r, a, l, h, d, c, u, f, Cl);
        let { ang1: g, ang2: m } = Cl;
        const { centerX: p, centerY: x } = Cl;
        let v = Math.abs(m) / (Fr / 4);
        Math.abs(1 - v) < 1e-7 && (v = 1);
        const y = Math.max(Math.ceil(v), 1);
        m /= y;
        let P = i[i.length - 2], w = i[i.length - 1];
        const R = {
            x: 0,
            y: 0
        };
        for(let B = 0; B < y; B++){
            const T = yE(g, m), { x: S, y: D } = Pl(T[0], r, a, c, d, p, x, R), { x: q, y: H } = Pl(T[1], r, a, c, d, p, x, R), { x: $, y: ne } = Pl(T[2], r, a, c, d, p, x, R);
            Ym(i, P, w, S, D, q, H, $, ne), P = $, w = ne, g += m;
        }
    }
    function TE(i, e, t) {
        const n = (a, o)=>{
            const l = o.x - a.x, h = o.y - a.y, d = Math.sqrt(l * l + h * h), c = l / d, u = h / d;
            return {
                len: d,
                nx: c,
                ny: u
            };
        }, s = (a, o)=>{
            a === 0 ? i.moveTo(o.x, o.y) : i.lineTo(o.x, o.y);
        };
        let r = e[e.length - 1];
        for(let a = 0; a < e.length; a++){
            const o = e[a % e.length], l = o.radius ?? t;
            if (l <= 0) {
                s(a, o), r = o;
                continue;
            }
            const h = e[(a + 1) % e.length], d = n(o, r), c = n(o, h);
            if (d.len < 1e-4 || c.len < 1e-4) {
                s(a, o), r = o;
                continue;
            }
            let u = Math.asin(d.nx * c.ny - d.ny * c.nx), f = 1, _ = !1;
            d.nx * c.nx - d.ny * -c.ny < 0 ? u < 0 ? u = Math.PI + u : (u = Math.PI - u, f = -1, _ = !0) : u > 0 && (f = -1, _ = !0);
            const g = u / 2;
            let m, p = Math.abs(Math.cos(g) * l / Math.sin(g));
            p > Math.min(d.len / 2, c.len / 2) ? (p = Math.min(d.len / 2, c.len / 2), m = Math.abs(p * Math.sin(g) / Math.cos(g))) : m = l;
            const x = o.x + c.nx * p + -c.ny * m * f, v = o.y + c.ny * p + c.nx * m * f, y = Math.atan2(d.ny, d.nx) + Math.PI / 2 * f, P = Math.atan2(c.ny, c.nx) - Math.PI / 2 * f;
            a === 0 && i.moveTo(x + Math.cos(y) * m, v + Math.sin(y) * m), i.arc(x, v, m, y, P, _), r = o;
        }
    }
    function ME(i, e, t, n) {
        const s = (o, l)=>Math.sqrt((o.x - l.x) ** 2 + (o.y - l.y) ** 2), r = (o, l, h)=>({
                x: o.x + (l.x - o.x) * h,
                y: o.y + (l.y - o.y) * h
            }), a = e.length;
        for(let o = 0; o < a; o++){
            const l = e[(o + 1) % a], h = l.radius ?? t;
            if (h <= 0) {
                o === 0 ? i.moveTo(l.x, l.y) : i.lineTo(l.x, l.y);
                continue;
            }
            const d = e[o], c = e[(o + 2) % a], u = s(d, l);
            let f;
            if (u < 1e-4) f = l;
            else {
                const m = Math.min(u / 2, h);
                f = r(l, d, m / u);
            }
            const _ = s(c, l);
            let g;
            if (_ < 1e-4) g = l;
            else {
                const m = Math.min(_ / 2, h);
                g = r(l, c, m / _);
            }
            o === 0 ? i.moveTo(f.x, f.y) : i.lineTo(f.x, f.y), i.quadraticCurveTo(l.x, l.y, g.x, g.y, n);
        }
    }
    const AE = new mt;
    class EE {
        constructor(e){
            this.shapePrimitives = [], this._currentPoly = null, this._bounds = new sn, this._graphicsPath2D = e, this.signed = e.checkForHoles;
        }
        moveTo(e, t) {
            return this.startPoly(e, t), this;
        }
        lineTo(e, t) {
            this._ensurePoly();
            const n = this._currentPoly.points, s = n[n.length - 2], r = n[n.length - 1];
            return (s !== e || r !== t) && n.push(e, t), this;
        }
        arc(e, t, n, s, r, a) {
            this._ensurePoly(!1);
            const o = this._currentPoly.points;
            return jm(o, e, t, n, s, r, a), this;
        }
        arcTo(e, t, n, s, r) {
            this._ensurePoly();
            const a = this._currentPoly.points;
            return vE(a, e, t, n, s, r), this;
        }
        arcToSvg(e, t, n, s, r, a, o) {
            const l = this._currentPoly.points;
            return SE(l, this._currentPoly.lastX, this._currentPoly.lastY, a, o, e, t, n, s, r), this;
        }
        bezierCurveTo(e, t, n, s, r, a, o) {
            this._ensurePoly();
            const l = this._currentPoly;
            return Ym(this._currentPoly.points, l.lastX, l.lastY, e, t, n, s, r, a, o), this;
        }
        quadraticCurveTo(e, t, n, s, r) {
            this._ensurePoly();
            const a = this._currentPoly;
            return gE(this._currentPoly.points, a.lastX, a.lastY, e, t, n, s, r), this;
        }
        closePath() {
            return this.endPoly(!0), this;
        }
        addPath(e, t) {
            this.endPoly(), t && !t.isIdentity() && (e = e.clone(!0), e.transform(t));
            const n = this.shapePrimitives, s = n.length;
            for(let r = 0; r < e.instructions.length; r++){
                const a = e.instructions[r];
                this[a.action](...a.data);
            }
            if (e.checkForHoles && n.length - s > 1) {
                let r = null;
                for(let a = s; a < n.length; a++){
                    const o = n[a];
                    if (o.shape.type === "polygon") {
                        const l = o.shape, h = r?.shape;
                        h && h.containsPolygon(l) ? (r.holes || (r.holes = []), r.holes.push(o), n.copyWithin(a, a + 1), n.length--, a--) : r = o;
                    }
                }
            }
            return this;
        }
        finish(e = !1) {
            this.endPoly(e);
        }
        rect(e, t, n, s, r) {
            return this.drawShape(new mt(e, t, n, s), r), this;
        }
        circle(e, t, n, s) {
            return this.drawShape(new Uh(e, t, n), s), this;
        }
        poly(e, t, n) {
            const s = new Ur(e);
            return s.closePath = t, this.drawShape(s, n), this;
        }
        regularPoly(e, t, n, s, r = 0, a) {
            s = Math.max(s | 0, 3);
            const o = -1 * Math.PI / 2 + r, l = Math.PI * 2 / s, h = [];
            for(let d = 0; d < s; d++){
                const c = o - d * l;
                h.push(e + n * Math.cos(c), t + n * Math.sin(c));
            }
            return this.poly(h, !0, a), this;
        }
        roundPoly(e, t, n, s, r, a = 0, o) {
            if (s = Math.max(s | 0, 3), r <= 0) return this.regularPoly(e, t, n, s, a);
            const l = n * Math.sin(Math.PI / s) - .001;
            r = Math.min(r, l);
            const h = -1 * Math.PI / 2 + a, d = Math.PI * 2 / s, c = (s - 2) * Math.PI / s / 2;
            for(let u = 0; u < s; u++){
                const f = u * d + h, _ = e + n * Math.cos(f), g = t + n * Math.sin(f), m = f + Math.PI + c, p = f - Math.PI - c, x = _ + r * Math.cos(m), v = g + r * Math.sin(m), y = _ + r * Math.cos(p), P = g + r * Math.sin(p);
                u === 0 ? this.moveTo(x, v) : this.lineTo(x, v), this.quadraticCurveTo(_, g, y, P, o);
            }
            return this.closePath();
        }
        roundShape(e, t, n = !1, s) {
            return e.length < 3 ? this : (n ? ME(this, e, t, s) : TE(this, e, t), this.closePath());
        }
        filletRect(e, t, n, s, r) {
            if (r === 0) return this.rect(e, t, n, s);
            const a = Math.min(n, s) / 2, o = Math.min(a, Math.max(-a, r)), l = e + n, h = t + s, d = o < 0 ? -o : 0, c = Math.abs(o);
            return this.moveTo(e, t + c).arcTo(e + d, t + d, e + c, t, c).lineTo(l - c, t).arcTo(l - d, t + d, l, t + c, c).lineTo(l, h - c).arcTo(l - d, h - d, e + n - c, h, c).lineTo(e + c, h).arcTo(e + d, h - d, e, h - c, c).closePath();
        }
        chamferRect(e, t, n, s, r, a) {
            if (r <= 0) return this.rect(e, t, n, s);
            const o = Math.min(r, Math.min(n, s) / 2), l = e + n, h = t + s, d = [
                e + o,
                t,
                l - o,
                t,
                l,
                t + o,
                l,
                h - o,
                l - o,
                h,
                e + o,
                h,
                e,
                h - o,
                e,
                t + o
            ];
            for(let c = d.length - 1; c >= 2; c -= 2)d[c] === d[c - 2] && d[c - 1] === d[c - 3] && d.splice(c - 1, 2);
            return this.poly(d, !0, a);
        }
        ellipse(e, t, n, s, r) {
            return this.drawShape(new Fh(e, t, n, s), r), this;
        }
        roundRect(e, t, n, s, r, a) {
            return this.drawShape(new Nh(e, t, n, s, r), a), this;
        }
        drawShape(e, t) {
            return this.endPoly(), this.shapePrimitives.push({
                shape: e,
                transform: t
            }), this;
        }
        startPoly(e, t) {
            let n = this._currentPoly;
            return n && this.endPoly(), n = new Ur, n.points.push(e, t), this._currentPoly = n, this;
        }
        endPoly(e = !1) {
            const t = this._currentPoly;
            return t && t.points.length > 2 && (t.closePath = e, this.shapePrimitives.push({
                shape: t
            })), this._currentPoly = null, this;
        }
        _ensurePoly(e = !0) {
            if (!this._currentPoly && (this._currentPoly = new Ur, e)) {
                const t = this.shapePrimitives[this.shapePrimitives.length - 1];
                if (t) {
                    let n = t.shape.x, s = t.shape.y;
                    if (t.transform && !t.transform.isIdentity()) {
                        const r = t.transform, a = n;
                        n = r.a * n + r.c * s + r.tx, s = r.b * a + r.d * s + r.ty;
                    }
                    this._currentPoly.points.push(n, s);
                } else this._currentPoly.points.push(0, 0);
            }
        }
        buildPath() {
            const e = this._graphicsPath2D;
            this.shapePrimitives.length = 0, this._currentPoly = null;
            for(let t = 0; t < e.instructions.length; t++){
                const n = e.instructions[t];
                this[n.action](...n.data);
            }
            this.finish();
        }
        get bounds() {
            const e = this._bounds;
            e.clear();
            const t = this.shapePrimitives;
            for(let n = 0; n < t.length; n++){
                const s = t[n], r = s.shape.getBounds(AE);
                s.transform ? e.addRect(r, s.transform) : e.addRect(r);
            }
            return e;
        }
    }
    class qs {
        constructor(e, t = !1){
            this.instructions = [], this.uid = xt("graphicsPath"), this._dirty = !0, this.checkForHoles = t, typeof e == "string" ? iA(e, this) : this.instructions = e?.slice() ?? [];
        }
        get shapePath() {
            return this._shapePath || (this._shapePath = new EE(this)), this._dirty && (this._dirty = !1, this._shapePath.buildPath()), this._shapePath;
        }
        addPath(e, t) {
            return e = e.clone(), this.instructions.push({
                action: "addPath",
                data: [
                    e,
                    t
                ]
            }), this._dirty = !0, this;
        }
        arc(...e) {
            return this.instructions.push({
                action: "arc",
                data: e
            }), this._dirty = !0, this;
        }
        arcTo(...e) {
            return this.instructions.push({
                action: "arcTo",
                data: e
            }), this._dirty = !0, this;
        }
        arcToSvg(...e) {
            return this.instructions.push({
                action: "arcToSvg",
                data: e
            }), this._dirty = !0, this;
        }
        bezierCurveTo(...e) {
            return this.instructions.push({
                action: "bezierCurveTo",
                data: e
            }), this._dirty = !0, this;
        }
        bezierCurveToShort(e, t, n, s, r) {
            const a = this.instructions[this.instructions.length - 1], o = this.getLastPoint(Ot.shared);
            let l = 0, h = 0;
            if (!a || a.action !== "bezierCurveTo") l = o.x, h = o.y;
            else {
                l = a.data[2], h = a.data[3];
                const d = o.x, c = o.y;
                l = d + (d - l), h = c + (c - h);
            }
            return this.instructions.push({
                action: "bezierCurveTo",
                data: [
                    l,
                    h,
                    e,
                    t,
                    n,
                    s,
                    r
                ]
            }), this._dirty = !0, this;
        }
        closePath() {
            return this.instructions.push({
                action: "closePath",
                data: []
            }), this._dirty = !0, this;
        }
        ellipse(...e) {
            return this.instructions.push({
                action: "ellipse",
                data: e
            }), this._dirty = !0, this;
        }
        lineTo(...e) {
            return this.instructions.push({
                action: "lineTo",
                data: e
            }), this._dirty = !0, this;
        }
        moveTo(...e) {
            return this.instructions.push({
                action: "moveTo",
                data: e
            }), this;
        }
        quadraticCurveTo(...e) {
            return this.instructions.push({
                action: "quadraticCurveTo",
                data: e
            }), this._dirty = !0, this;
        }
        quadraticCurveToShort(e, t, n) {
            const s = this.instructions[this.instructions.length - 1], r = this.getLastPoint(Ot.shared);
            let a = 0, o = 0;
            if (!s || s.action !== "quadraticCurveTo") a = r.x, o = r.y;
            else {
                a = s.data[0], o = s.data[1];
                const l = r.x, h = r.y;
                a = l + (l - a), o = h + (h - o);
            }
            return this.instructions.push({
                action: "quadraticCurveTo",
                data: [
                    a,
                    o,
                    e,
                    t,
                    n
                ]
            }), this._dirty = !0, this;
        }
        rect(e, t, n, s, r) {
            return this.instructions.push({
                action: "rect",
                data: [
                    e,
                    t,
                    n,
                    s,
                    r
                ]
            }), this._dirty = !0, this;
        }
        circle(e, t, n, s) {
            return this.instructions.push({
                action: "circle",
                data: [
                    e,
                    t,
                    n,
                    s
                ]
            }), this._dirty = !0, this;
        }
        roundRect(...e) {
            return this.instructions.push({
                action: "roundRect",
                data: e
            }), this._dirty = !0, this;
        }
        poly(...e) {
            return this.instructions.push({
                action: "poly",
                data: e
            }), this._dirty = !0, this;
        }
        regularPoly(...e) {
            return this.instructions.push({
                action: "regularPoly",
                data: e
            }), this._dirty = !0, this;
        }
        roundPoly(...e) {
            return this.instructions.push({
                action: "roundPoly",
                data: e
            }), this._dirty = !0, this;
        }
        roundShape(...e) {
            return this.instructions.push({
                action: "roundShape",
                data: e
            }), this._dirty = !0, this;
        }
        filletRect(...e) {
            return this.instructions.push({
                action: "filletRect",
                data: e
            }), this._dirty = !0, this;
        }
        chamferRect(...e) {
            return this.instructions.push({
                action: "chamferRect",
                data: e
            }), this._dirty = !0, this;
        }
        star(e, t, n, s, r, a, o) {
            r || (r = s / 2);
            const l = -1 * Math.PI / 2 + a, h = n * 2, d = Math.PI * 2 / h, c = [];
            for(let u = 0; u < h; u++){
                const f = u % 2 ? r : s, _ = u * d + l;
                c.push(e + f * Math.cos(_), t + f * Math.sin(_));
            }
            return this.poly(c, !0, o), this;
        }
        clone(e = !1) {
            const t = new qs;
            if (t.checkForHoles = this.checkForHoles, !e) t.instructions = this.instructions.slice();
            else for(let n = 0; n < this.instructions.length; n++){
                const s = this.instructions[n];
                t.instructions.push({
                    action: s.action,
                    data: s.data.slice()
                });
            }
            return t;
        }
        clear() {
            return this.instructions.length = 0, this._dirty = !0, this;
        }
        transform(e) {
            if (e.isIdentity()) return this;
            const t = e.a, n = e.b, s = e.c, r = e.d, a = e.tx, o = e.ty;
            let l = 0, h = 0, d = 0, c = 0, u = 0, f = 0, _ = 0, g = 0;
            for(let m = 0; m < this.instructions.length; m++){
                const p = this.instructions[m], x = p.data;
                switch(p.action){
                    case "moveTo":
                    case "lineTo":
                        l = x[0], h = x[1], x[0] = t * l + s * h + a, x[1] = n * l + r * h + o;
                        break;
                    case "bezierCurveTo":
                        d = x[0], c = x[1], u = x[2], f = x[3], l = x[4], h = x[5], x[0] = t * d + s * c + a, x[1] = n * d + r * c + o, x[2] = t * u + s * f + a, x[3] = n * u + r * f + o, x[4] = t * l + s * h + a, x[5] = n * l + r * h + o;
                        break;
                    case "quadraticCurveTo":
                        d = x[0], c = x[1], l = x[2], h = x[3], x[0] = t * d + s * c + a, x[1] = n * d + r * c + o, x[2] = t * l + s * h + a, x[3] = n * l + r * h + o;
                        break;
                    case "arcToSvg":
                        l = x[5], h = x[6], _ = x[0], g = x[1], x[0] = t * _ + s * g, x[1] = n * _ + r * g, x[5] = t * l + s * h + a, x[6] = n * l + r * h + o;
                        break;
                    case "circle":
                        x[4] = vr(x[3], e);
                        break;
                    case "rect":
                        x[4] = vr(x[4], e);
                        break;
                    case "ellipse":
                        x[8] = vr(x[8], e);
                        break;
                    case "roundRect":
                        x[5] = vr(x[5], e);
                        break;
                    case "addPath":
                        x[0].transform(e);
                        break;
                    case "poly":
                        x[2] = vr(x[2], e);
                        break;
                    default:
                        tt("unknown transform action", p.action);
                        break;
                }
            }
            return this._dirty = !0, this;
        }
        get bounds() {
            return this.shapePath.bounds;
        }
        getLastPoint(e) {
            let t = this.instructions.length - 1, n = this.instructions[t];
            if (!n) return e.x = 0, e.y = 0, e;
            for(; n.action === "closePath";){
                if (t--, t < 0) return e.x = 0, e.y = 0, e;
                n = this.instructions[t];
            }
            switch(n.action){
                case "moveTo":
                case "lineTo":
                    e.x = n.data[0], e.y = n.data[1];
                    break;
                case "quadraticCurveTo":
                    e.x = n.data[2], e.y = n.data[3];
                    break;
                case "bezierCurveTo":
                    e.x = n.data[4], e.y = n.data[5];
                    break;
                case "arc":
                case "arcToSvg":
                    e.x = n.data[5], e.y = n.data[6];
                    break;
                case "addPath":
                    n.data[0].getLastPoint(e);
                    break;
            }
            return e;
        }
    }
    function vr(i, e) {
        return i ? i.prepend(e) : e.clone();
    }
    function Tt(i, e, t) {
        const n = i.getAttribute(e);
        return n ? Number(n) : t;
    }
    function wE(i, e) {
        const t = i.querySelectorAll("defs");
        for(let n = 0; n < t.length; n++){
            const s = t[n];
            for(let r = 0; r < s.children.length; r++){
                const a = s.children[r];
                switch(a.nodeName.toLowerCase()){
                    case "lineargradient":
                        e.defs[a.id] = RE(a);
                        break;
                    case "radialgradient":
                        e.defs[a.id] = CE();
                        break;
                }
            }
        }
    }
    function RE(i) {
        const e = Tt(i, "x1", 0), t = Tt(i, "y1", 0), n = Tt(i, "x2", 1), s = Tt(i, "y2", 0), r = i.getAttribute("gradientUnits") || "objectBoundingBox", a = new Ri(e, t, n, s, r === "objectBoundingBox" ? "local" : "global");
        for(let o = 0; o < i.children.length; o++){
            const l = i.children[o], h = Tt(l, "offset", 0), d = Et.shared.setValue(l.getAttribute("stop-color")).toNumber();
            a.addColorStop(h, d);
        }
        return a;
    }
    function CE(i) {
        return tt("[SVG Parser] Radial gradients are not yet supported"), new Ri(0, 0, 1, 0);
    }
    function gf(i) {
        const e = i.match(/url\s*\(\s*['"]?\s*#([^'"\s)]+)\s*['"]?\s*\)/i);
        return e ? e[1] : "";
    }
    const xf = {
        fill: {
            type: "paint",
            default: 0
        },
        "fill-opacity": {
            type: "number",
            default: 1
        },
        stroke: {
            type: "paint",
            default: 0
        },
        "stroke-width": {
            type: "number",
            default: 1
        },
        "stroke-opacity": {
            type: "number",
            default: 1
        },
        "stroke-linecap": {
            type: "string",
            default: "butt"
        },
        "stroke-linejoin": {
            type: "string",
            default: "miter"
        },
        "stroke-miterlimit": {
            type: "number",
            default: 10
        },
        "stroke-dasharray": {
            type: "string",
            default: "none"
        },
        "stroke-dashoffset": {
            type: "number",
            default: 0
        },
        opacity: {
            type: "number",
            default: 1
        }
    };
    function qm(i, e) {
        const t = i.getAttribute("style"), n = {}, s = {}, r = {
            strokeStyle: n,
            fillStyle: s,
            useFill: !1,
            useStroke: !1
        };
        for(const a in xf){
            const o = i.getAttribute(a);
            o && vf(e, r, a, o.trim());
        }
        if (t) {
            const a = t.split(";");
            for(let o = 0; o < a.length; o++){
                const l = a[o].trim(), [h, d] = l.split(":");
                xf[h] && vf(e, r, h, d.trim());
            }
        }
        return {
            strokeStyle: r.useStroke ? n : null,
            fillStyle: r.useFill ? s : null,
            useFill: r.useFill,
            useStroke: r.useStroke
        };
    }
    function vf(i, e, t, n) {
        switch(t){
            case "stroke":
                if (n !== "none") {
                    if (n.startsWith("url(")) {
                        const s = gf(n);
                        e.strokeStyle.fill = i.defs[s];
                    } else e.strokeStyle.color = Et.shared.setValue(n).toNumber();
                    e.useStroke = !0;
                }
                break;
            case "stroke-width":
                e.strokeStyle.width = Number(n);
                break;
            case "fill":
                if (n !== "none") {
                    if (n.startsWith("url(")) {
                        const s = gf(n);
                        e.fillStyle.fill = i.defs[s];
                    } else e.fillStyle.color = Et.shared.setValue(n).toNumber();
                    e.useFill = !0;
                }
                break;
            case "fill-opacity":
                e.fillStyle.alpha = Number(n);
                break;
            case "stroke-opacity":
                e.strokeStyle.alpha = Number(n);
                break;
            case "opacity":
                e.fillStyle.alpha = Number(n), e.strokeStyle.alpha = Number(n);
                break;
        }
    }
    function PE(i, e) {
        if (typeof i == "string") {
            const a = document.createElement("div");
            a.innerHTML = i.trim(), i = a.querySelector("svg");
        }
        const t = {
            context: e,
            defs: {},
            path: new qs
        };
        wE(i, t);
        const n = i.children, { fillStyle: s, strokeStyle: r } = qm(i, t);
        for(let a = 0; a < n.length; a++){
            const o = n[a];
            o.nodeName.toLowerCase() !== "defs" && $m(o, t, s, r);
        }
        return e;
    }
    function $m(i, e, t, n) {
        const s = i.children, { fillStyle: r, strokeStyle: a } = qm(i, e);
        r && t ? t = {
            ...t,
            ...r
        } : r && (t = r), a && n ? n = {
            ...n,
            ...a
        } : a && (n = a);
        const o = !t && !n;
        o && (t = {
            color: 0
        });
        let l, h, d, c, u, f, _, g, m, p, x, v, y, P, w, R, B;
        switch(i.nodeName.toLowerCase()){
            case "path":
                P = i.getAttribute("d"), i.getAttribute("fill-rule") === "evenodd" && tt("SVG Evenodd fill rule not supported, your svg may render incorrectly"), w = new qs(P, !0), e.context.path(w), t && e.context.fill(t), n && e.context.stroke(n);
                break;
            case "circle":
                _ = Tt(i, "cx", 0), g = Tt(i, "cy", 0), m = Tt(i, "r", 0), e.context.ellipse(_, g, m, m), t && e.context.fill(t), n && e.context.stroke(n);
                break;
            case "rect":
                l = Tt(i, "x", 0), h = Tt(i, "y", 0), R = Tt(i, "width", 0), B = Tt(i, "height", 0), p = Tt(i, "rx", 0), x = Tt(i, "ry", 0), p || x ? e.context.roundRect(l, h, R, B, p || x) : e.context.rect(l, h, R, B), t && e.context.fill(t), n && e.context.stroke(n);
                break;
            case "ellipse":
                _ = Tt(i, "cx", 0), g = Tt(i, "cy", 0), p = Tt(i, "rx", 0), x = Tt(i, "ry", 0), e.context.beginPath(), e.context.ellipse(_, g, p, x), t && e.context.fill(t), n && e.context.stroke(n);
                break;
            case "line":
                d = Tt(i, "x1", 0), c = Tt(i, "y1", 0), u = Tt(i, "x2", 0), f = Tt(i, "y2", 0), e.context.beginPath(), e.context.moveTo(d, c), e.context.lineTo(u, f), n && e.context.stroke(n);
                break;
            case "polygon":
                y = i.getAttribute("points"), v = y.match(/\d+/g).map((T)=>parseInt(T, 10)), e.context.poly(v, !0), t && e.context.fill(t), n && e.context.stroke(n);
                break;
            case "polyline":
                y = i.getAttribute("points"), v = y.match(/\d+/g).map((T)=>parseInt(T, 10)), e.context.poly(v, !1), n && e.context.stroke(n);
                break;
            case "g":
            case "svg":
                break;
            default:
                {
                    tt(`[SVG parser] <${i.nodeName}> elements unsupported`);
                    break;
                }
        }
        o && (t = null);
        for(let T = 0; T < s.length; T++)$m(s[T], e, t, n);
    }
    function IE(i) {
        return Et.isColorLike(i);
    }
    function yf(i) {
        return i instanceof _o;
    }
    function bf(i) {
        return i instanceof Ri;
    }
    function DE(i) {
        return i instanceof Ie;
    }
    function LE(i, e, t) {
        const n = Et.shared.setValue(e ?? 0);
        return i.color = n.toNumber(), i.alpha = n.alpha === 1 ? t.alpha : n.alpha, i.texture = Ie.WHITE, {
            ...t,
            ...i
        };
    }
    function BE(i, e, t) {
        return i.texture = e, {
            ...t,
            ...i
        };
    }
    function Sf(i, e, t) {
        return i.fill = e, i.color = 16777215, i.texture = e.texture, i.matrix = e.transform, {
            ...t,
            ...i
        };
    }
    function Tf(i, e, t) {
        return e.buildGradient(), i.fill = e, i.color = 16777215, i.texture = e.texture, i.matrix = e.transform, i.textureSpace = e.textureSpace, {
            ...t,
            ...i
        };
    }
    function UE(i, e) {
        const t = {
            ...e,
            ...i
        }, n = Et.shared.setValue(t.color);
        return t.alpha *= n.alpha, t.color = n.toNumber(), t;
    }
    function Ki(i, e) {
        if (i == null) return null;
        const t = {}, n = i;
        return IE(i) ? LE(t, i, e) : DE(i) ? BE(t, i, e) : yf(i) ? Sf(t, i, e) : bf(i) ? Tf(t, i, e) : n.fill && yf(n.fill) ? Sf(n, n.fill, e) : n.fill && bf(n.fill) ? Tf(n, n.fill, e) : UE(n, e);
    }
    function co(i, e) {
        const { width: t, alignment: n, miterLimit: s, cap: r, join: a, pixelLine: o, ...l } = e, h = Ki(i, l);
        return h ? {
            width: t,
            alignment: n,
            miterLimit: s,
            cap: r,
            join: a,
            pixelLine: o,
            ...h
        } : null;
    }
    const FE = new Ot, Mf = new Ne, zh = class Nn extends yn {
        constructor(){
            super(...arguments), this.uid = xt("graphicsContext"), this.dirty = !0, this.batchMode = "auto", this.instructions = [], this._activePath = new qs, this._transform = new Ne, this._fillStyle = {
                ...Nn.defaultFillStyle
            }, this._strokeStyle = {
                ...Nn.defaultStrokeStyle
            }, this._stateStack = [], this._tick = 0, this._bounds = new sn, this._boundsDirty = !0;
        }
        clone() {
            const e = new Nn;
            return e.batchMode = this.batchMode, e.instructions = this.instructions.slice(), e._activePath = this._activePath.clone(), e._transform = this._transform.clone(), e._fillStyle = {
                ...this._fillStyle
            }, e._strokeStyle = {
                ...this._strokeStyle
            }, e._stateStack = this._stateStack.slice(), e._bounds = this._bounds.clone(), e._boundsDirty = !0, e;
        }
        get fillStyle() {
            return this._fillStyle;
        }
        set fillStyle(e) {
            this._fillStyle = Ki(e, Nn.defaultFillStyle);
        }
        get strokeStyle() {
            return this._strokeStyle;
        }
        set strokeStyle(e) {
            this._strokeStyle = co(e, Nn.defaultStrokeStyle);
        }
        setFillStyle(e) {
            return this._fillStyle = Ki(e, Nn.defaultFillStyle), this;
        }
        setStrokeStyle(e) {
            return this._strokeStyle = Ki(e, Nn.defaultStrokeStyle), this;
        }
        texture(e, t, n, s, r, a) {
            return this.instructions.push({
                action: "texture",
                data: {
                    image: e,
                    dx: n || 0,
                    dy: s || 0,
                    dw: r || e.frame.width,
                    dh: a || e.frame.height,
                    transform: this._transform.clone(),
                    alpha: this._fillStyle.alpha,
                    style: t ? Et.shared.setValue(t).toNumber() : 16777215
                }
            }), this.onUpdate(), this;
        }
        beginPath() {
            return this._activePath = new qs, this;
        }
        fill(e, t) {
            let n;
            const s = this.instructions[this.instructions.length - 1];
            return this._tick === 0 && s && s.action === "stroke" ? n = s.data.path : n = this._activePath.clone(), n ? (e != null && (t !== void 0 && typeof e == "number" && (et(dt, "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead"), e = {
                color: e,
                alpha: t
            }), this._fillStyle = Ki(e, Nn.defaultFillStyle)), this.instructions.push({
                action: "fill",
                data: {
                    style: this.fillStyle,
                    path: n
                }
            }), this.onUpdate(), this._initNextPathLocation(), this._tick = 0, this) : this;
        }
        _initNextPathLocation() {
            const { x: e, y: t } = this._activePath.getLastPoint(Ot.shared);
            this._activePath.clear(), this._activePath.moveTo(e, t);
        }
        stroke(e) {
            let t;
            const n = this.instructions[this.instructions.length - 1];
            return this._tick === 0 && n && n.action === "fill" ? t = n.data.path : t = this._activePath.clone(), t ? (e != null && (this._strokeStyle = co(e, Nn.defaultStrokeStyle)), this.instructions.push({
                action: "stroke",
                data: {
                    style: this.strokeStyle,
                    path: t
                }
            }), this.onUpdate(), this._initNextPathLocation(), this._tick = 0, this) : this;
        }
        cut() {
            for(let e = 0; e < 2; e++){
                const t = this.instructions[this.instructions.length - 1 - e], n = this._activePath.clone();
                if (t && (t.action === "stroke" || t.action === "fill")) if (t.data.hole) t.data.hole.addPath(n);
                else {
                    t.data.hole = n;
                    break;
                }
            }
            return this._initNextPathLocation(), this;
        }
        arc(e, t, n, s, r, a) {
            this._tick++;
            const o = this._transform;
            return this._activePath.arc(o.a * e + o.c * t + o.tx, o.b * e + o.d * t + o.ty, n, s, r, a), this;
        }
        arcTo(e, t, n, s, r) {
            this._tick++;
            const a = this._transform;
            return this._activePath.arcTo(a.a * e + a.c * t + a.tx, a.b * e + a.d * t + a.ty, a.a * n + a.c * s + a.tx, a.b * n + a.d * s + a.ty, r), this;
        }
        arcToSvg(e, t, n, s, r, a, o) {
            this._tick++;
            const l = this._transform;
            return this._activePath.arcToSvg(e, t, n, s, r, l.a * a + l.c * o + l.tx, l.b * a + l.d * o + l.ty), this;
        }
        bezierCurveTo(e, t, n, s, r, a, o) {
            this._tick++;
            const l = this._transform;
            return this._activePath.bezierCurveTo(l.a * e + l.c * t + l.tx, l.b * e + l.d * t + l.ty, l.a * n + l.c * s + l.tx, l.b * n + l.d * s + l.ty, l.a * r + l.c * a + l.tx, l.b * r + l.d * a + l.ty, o), this;
        }
        closePath() {
            return this._tick++, this._activePath?.closePath(), this;
        }
        ellipse(e, t, n, s) {
            return this._tick++, this._activePath.ellipse(e, t, n, s, this._transform.clone()), this;
        }
        circle(e, t, n) {
            return this._tick++, this._activePath.circle(e, t, n, this._transform.clone()), this;
        }
        path(e) {
            return this._tick++, this._activePath.addPath(e, this._transform.clone()), this;
        }
        lineTo(e, t) {
            this._tick++;
            const n = this._transform;
            return this._activePath.lineTo(n.a * e + n.c * t + n.tx, n.b * e + n.d * t + n.ty), this;
        }
        moveTo(e, t) {
            this._tick++;
            const n = this._transform, s = this._activePath.instructions, r = n.a * e + n.c * t + n.tx, a = n.b * e + n.d * t + n.ty;
            return s.length === 1 && s[0].action === "moveTo" ? (s[0].data[0] = r, s[0].data[1] = a, this) : (this._activePath.moveTo(r, a), this);
        }
        quadraticCurveTo(e, t, n, s, r) {
            this._tick++;
            const a = this._transform;
            return this._activePath.quadraticCurveTo(a.a * e + a.c * t + a.tx, a.b * e + a.d * t + a.ty, a.a * n + a.c * s + a.tx, a.b * n + a.d * s + a.ty, r), this;
        }
        rect(e, t, n, s) {
            return this._tick++, this._activePath.rect(e, t, n, s, this._transform.clone()), this;
        }
        roundRect(e, t, n, s, r) {
            return this._tick++, this._activePath.roundRect(e, t, n, s, r, this._transform.clone()), this;
        }
        poly(e, t) {
            return this._tick++, this._activePath.poly(e, t, this._transform.clone()), this;
        }
        regularPoly(e, t, n, s, r = 0, a) {
            return this._tick++, this._activePath.regularPoly(e, t, n, s, r, a), this;
        }
        roundPoly(e, t, n, s, r, a) {
            return this._tick++, this._activePath.roundPoly(e, t, n, s, r, a), this;
        }
        roundShape(e, t, n, s) {
            return this._tick++, this._activePath.roundShape(e, t, n, s), this;
        }
        filletRect(e, t, n, s, r) {
            return this._tick++, this._activePath.filletRect(e, t, n, s, r), this;
        }
        chamferRect(e, t, n, s, r, a) {
            return this._tick++, this._activePath.chamferRect(e, t, n, s, r, a), this;
        }
        star(e, t, n, s, r = 0, a = 0) {
            return this._tick++, this._activePath.star(e, t, n, s, r, a, this._transform.clone()), this;
        }
        svg(e) {
            return this._tick++, PE(e, this), this;
        }
        restore() {
            const e = this._stateStack.pop();
            return e && (this._transform = e.transform, this._fillStyle = e.fillStyle, this._strokeStyle = e.strokeStyle), this;
        }
        save() {
            return this._stateStack.push({
                transform: this._transform.clone(),
                fillStyle: {
                    ...this._fillStyle
                },
                strokeStyle: {
                    ...this._strokeStyle
                }
            }), this;
        }
        getTransform() {
            return this._transform;
        }
        resetTransform() {
            return this._transform.identity(), this;
        }
        rotate(e) {
            return this._transform.rotate(e), this;
        }
        scale(e, t = e) {
            return this._transform.scale(e, t), this;
        }
        setTransform(e, t, n, s, r, a) {
            return e instanceof Ne ? (this._transform.set(e.a, e.b, e.c, e.d, e.tx, e.ty), this) : (this._transform.set(e, t, n, s, r, a), this);
        }
        transform(e, t, n, s, r, a) {
            return e instanceof Ne ? (this._transform.append(e), this) : (Mf.set(e, t, n, s, r, a), this._transform.append(Mf), this);
        }
        translate(e, t = e) {
            return this._transform.translate(e, t), this;
        }
        clear() {
            return this._activePath.clear(), this.instructions.length = 0, this.resetTransform(), this.onUpdate(), this;
        }
        onUpdate() {
            this.dirty || (this.emit("update", this, 16), this.dirty = !0, this._boundsDirty = !0);
        }
        get bounds() {
            if (!this._boundsDirty) return this._bounds;
            const e = this._bounds;
            e.clear();
            for(let t = 0; t < this.instructions.length; t++){
                const n = this.instructions[t], s = n.action;
                if (s === "fill") {
                    const r = n.data;
                    e.addBounds(r.path.bounds);
                } else if (s === "texture") {
                    const r = n.data;
                    e.addFrame(r.dx, r.dy, r.dx + r.dw, r.dy + r.dh, r.transform);
                }
                if (s === "stroke") {
                    const r = n.data, a = r.style.alignment, o = r.style.width * (1 - a), l = r.path.bounds;
                    e.addFrame(l.minX - o, l.minY - o, l.maxX + o, l.maxY + o);
                }
            }
            return e;
        }
        containsPoint(e) {
            if (!this.bounds.containsPoint(e.x, e.y)) return !1;
            const t = this.instructions;
            let n = !1;
            for(let s = 0; s < t.length; s++){
                const r = t[s], a = r.data, o = a.path;
                if (!r.action || !o) continue;
                const l = a.style, h = o.shapePath.shapePrimitives;
                for(let d = 0; d < h.length; d++){
                    const c = h[d].shape;
                    if (!l || !c) continue;
                    const u = h[d].transform, f = u ? u.applyInverse(e, FE) : e;
                    if (r.action === "fill") n = c.contains(f.x, f.y);
                    else {
                        const g = l;
                        n = c.strokeContains(f.x, f.y, g.width, g.alignment);
                    }
                    const _ = a.hole;
                    if (_) {
                        const g = _.shapePath?.shapePrimitives;
                        if (g) for(let m = 0; m < g.length; m++)g[m].shape.contains(f.x, f.y) && (n = !1);
                    }
                    if (n) return !0;
                }
            }
            return n;
        }
        destroy(e = !1) {
            if (this._stateStack.length = 0, this._transform = null, this.emit("destroy", this), this.removeAllListeners(), typeof e == "boolean" ? e : e?.texture) {
                const n = typeof e == "boolean" ? e : e?.textureSource;
                this._fillStyle.texture && this._fillStyle.texture.destroy(n), this._strokeStyle.texture && this._strokeStyle.texture.destroy(n);
            }
            this._fillStyle = null, this._strokeStyle = null, this.instructions = null, this._activePath = null, this._bounds = null, this._stateStack = null, this.customShader = null, this._transform = null;
        }
    };
    zh.defaultFillStyle = {
        color: 16777215,
        alpha: 1,
        texture: Ie.WHITE,
        matrix: null,
        fill: null,
        textureSpace: "local"
    };
    zh.defaultStrokeStyle = {
        width: 1,
        color: 16777215,
        alpha: 1,
        alignment: .5,
        miterLimit: 10,
        cap: "butt",
        join: "miter",
        texture: Ie.WHITE,
        matrix: null,
        fill: null,
        textureSpace: "local",
        pixelLine: !1
    };
    let _n = zh;
    const Af = [
        "align",
        "breakWords",
        "cssOverrides",
        "fontVariant",
        "fontWeight",
        "leading",
        "letterSpacing",
        "lineHeight",
        "padding",
        "textBaseline",
        "trim",
        "whiteSpace",
        "wordWrap",
        "wordWrapWidth",
        "fontFamily",
        "fontStyle",
        "fontSize"
    ];
    NE = function(i) {
        const e = [];
        let t = 0;
        for(let n = 0; n < Af.length; n++){
            const s = `_${Af[n]}`;
            e[t++] = i[s];
        }
        return t = Km(i._fill, e, t), t = OE(i._stroke, e, t), t = kE(i.dropShadow, e, t), e.join("-");
    };
    function Km(i, e, t) {
        return i && (e[t++] = i.color, e[t++] = i.alpha, e[t++] = i.fill?.styleKey), t;
    }
    function OE(i, e, t) {
        return i && (t = Km(i, e, t), e[t++] = i.width, e[t++] = i.alignment, e[t++] = i.cap, e[t++] = i.join, e[t++] = i.miterLimit), t;
    }
    function kE(i, e, t) {
        return i && (e[t++] = i.alpha, e[t++] = i.angle, e[t++] = i.blur, e[t++] = i.distance, e[t++] = Et.shared.setValue(i.color).toNumber()), t;
    }
    const Vh = class Es extends yn {
        constructor(e = {}){
            super(), GE(e);
            const t = {
                ...Es.defaultTextStyle,
                ...e
            };
            for(const n in t){
                const s = n;
                this[s] = t[n];
            }
            this.update();
        }
        get align() {
            return this._align;
        }
        set align(e) {
            this._align = e, this.update();
        }
        get breakWords() {
            return this._breakWords;
        }
        set breakWords(e) {
            this._breakWords = e, this.update();
        }
        get dropShadow() {
            return this._dropShadow;
        }
        set dropShadow(e) {
            e !== null && typeof e == "object" ? this._dropShadow = this._createProxy({
                ...Es.defaultDropShadow,
                ...e
            }) : this._dropShadow = e ? this._createProxy({
                ...Es.defaultDropShadow
            }) : null, this.update();
        }
        get fontFamily() {
            return this._fontFamily;
        }
        set fontFamily(e) {
            this._fontFamily = e, this.update();
        }
        get fontSize() {
            return this._fontSize;
        }
        set fontSize(e) {
            typeof e == "string" ? this._fontSize = parseInt(e, 10) : this._fontSize = e, this.update();
        }
        get fontStyle() {
            return this._fontStyle;
        }
        set fontStyle(e) {
            this._fontStyle = e.toLowerCase(), this.update();
        }
        get fontVariant() {
            return this._fontVariant;
        }
        set fontVariant(e) {
            this._fontVariant = e, this.update();
        }
        get fontWeight() {
            return this._fontWeight;
        }
        set fontWeight(e) {
            this._fontWeight = e, this.update();
        }
        get leading() {
            return this._leading;
        }
        set leading(e) {
            this._leading = e, this.update();
        }
        get letterSpacing() {
            return this._letterSpacing;
        }
        set letterSpacing(e) {
            this._letterSpacing = e, this.update();
        }
        get lineHeight() {
            return this._lineHeight;
        }
        set lineHeight(e) {
            this._lineHeight = e, this.update();
        }
        get padding() {
            return this._padding;
        }
        set padding(e) {
            this._padding = e, this.update();
        }
        get trim() {
            return this._trim;
        }
        set trim(e) {
            this._trim = e, this.update();
        }
        get textBaseline() {
            return this._textBaseline;
        }
        set textBaseline(e) {
            this._textBaseline = e, this.update();
        }
        get whiteSpace() {
            return this._whiteSpace;
        }
        set whiteSpace(e) {
            this._whiteSpace = e, this.update();
        }
        get wordWrap() {
            return this._wordWrap;
        }
        set wordWrap(e) {
            this._wordWrap = e, this.update();
        }
        get wordWrapWidth() {
            return this._wordWrapWidth;
        }
        set wordWrapWidth(e) {
            this._wordWrapWidth = e, this.update();
        }
        get fill() {
            return this._originalFill;
        }
        set fill(e) {
            e !== this._originalFill && (this._originalFill = e, this._isFillStyle(e) && (this._originalFill = this._createProxy({
                ..._n.defaultFillStyle,
                ...e
            }, ()=>{
                this._fill = Ki({
                    ...this._originalFill
                }, _n.defaultFillStyle);
            })), this._fill = Ki(e === 0 ? "black" : e, _n.defaultFillStyle), this.update());
        }
        get stroke() {
            return this._originalStroke;
        }
        set stroke(e) {
            e !== this._originalStroke && (this._originalStroke = e, this._isFillStyle(e) && (this._originalStroke = this._createProxy({
                ..._n.defaultStrokeStyle,
                ...e
            }, ()=>{
                this._stroke = co({
                    ...this._originalStroke
                }, _n.defaultStrokeStyle);
            })), this._stroke = co(e, _n.defaultStrokeStyle), this.update());
        }
        _generateKey() {
            return this._styleKey = NE(this), this._styleKey;
        }
        update() {
            this._styleKey = null, this.emit("update", this);
        }
        reset() {
            const e = Es.defaultTextStyle;
            for(const t in e)this[t] = e[t];
        }
        get styleKey() {
            return this._styleKey || this._generateKey();
        }
        clone() {
            return new Es({
                align: this.align,
                breakWords: this.breakWords,
                dropShadow: this._dropShadow ? {
                    ...this._dropShadow
                } : null,
                fill: this._fill,
                fontFamily: this.fontFamily,
                fontSize: this.fontSize,
                fontStyle: this.fontStyle,
                fontVariant: this.fontVariant,
                fontWeight: this.fontWeight,
                leading: this.leading,
                letterSpacing: this.letterSpacing,
                lineHeight: this.lineHeight,
                padding: this.padding,
                stroke: this._stroke,
                textBaseline: this.textBaseline,
                whiteSpace: this.whiteSpace,
                wordWrap: this.wordWrap,
                wordWrapWidth: this.wordWrapWidth
            });
        }
        destroy(e = !1) {
            if (this.removeAllListeners(), typeof e == "boolean" ? e : e?.texture) {
                const n = typeof e == "boolean" ? e : e?.textureSource;
                this._fill?.texture && this._fill.texture.destroy(n), this._originalFill?.texture && this._originalFill.texture.destroy(n), this._stroke?.texture && this._stroke.texture.destroy(n), this._originalStroke?.texture && this._originalStroke.texture.destroy(n);
            }
            this._fill = null, this._stroke = null, this.dropShadow = null, this._originalStroke = null, this._originalFill = null;
        }
        _createProxy(e, t) {
            return new Proxy(e, {
                set: (n, s, r)=>(n[s] = r, t?.(s, r), this.update(), !0)
            });
        }
        _isFillStyle(e) {
            return (e ?? null) !== null && !(Et.isColorLike(e) || e instanceof Ri || e instanceof _o);
        }
    };
    Vh.defaultDropShadow = {
        alpha: 1,
        angle: Math.PI / 6,
        blur: 0,
        color: "black",
        distance: 5
    };
    Vh.defaultTextStyle = {
        align: "left",
        breakWords: !1,
        dropShadow: null,
        fill: "black",
        fontFamily: "Arial",
        fontSize: 26,
        fontStyle: "normal",
        fontVariant: "normal",
        fontWeight: "normal",
        leading: 0,
        letterSpacing: 0,
        lineHeight: 0,
        padding: 0,
        stroke: null,
        textBaseline: "alphabetic",
        trim: !1,
        whiteSpace: "pre",
        wordWrap: !1,
        wordWrapWidth: 100
    };
    $s = Vh;
    function GE(i) {
        const e = i;
        if (typeof e.dropShadow == "boolean" && e.dropShadow) {
            const t = $s.defaultDropShadow;
            i.dropShadow = {
                alpha: e.dropShadowAlpha ?? t.alpha,
                angle: e.dropShadowAngle ?? t.angle,
                blur: e.dropShadowBlur ?? t.blur,
                color: e.dropShadowColor ?? t.color,
                distance: e.dropShadowDistance ?? t.distance
            };
        }
        if (e.strokeThickness !== void 0) {
            et(dt, "strokeThickness is now a part of stroke");
            const t = e.stroke;
            let n = {};
            if (Et.isColorLike(t)) n.color = t;
            else if (t instanceof Ri || t instanceof _o) n.fill = t;
            else if (Object.hasOwnProperty.call(t, "color") || Object.hasOwnProperty.call(t, "fill")) n = t;
            else throw new Error("Invalid stroke value.");
            i.stroke = {
                ...n,
                width: e.strokeThickness
            };
        }
        if (Array.isArray(e.fillGradientStops)) {
            et(dt, "gradient fill is now a fill pattern: `new FillGradient(...)`");
            let t;
            i.fontSize == null ? i.fontSize = $s.defaultTextStyle.fontSize : typeof i.fontSize == "string" ? t = parseInt(i.fontSize, 10) : t = i.fontSize;
            const n = new Ri({
                start: {
                    x: 0,
                    y: 0
                },
                end: {
                    x: 0,
                    y: (t || 0) * 1.7
                }
            }), s = e.fillGradientStops.map((r)=>Et.shared.setValue(r).toNumber());
            s.forEach((r, a)=>{
                const o = a / (s.length - 1);
                n.addColorStop(o, r);
            }), i.fill = {
                fill: n
            };
        }
    }
    class HE {
        constructor(e){
            this._canvasPool = Object.create(null), this.canvasOptions = e || {}, this.enableFullScreen = !1;
        }
        _createCanvasAndContext(e, t) {
            const n = _t.get().createCanvas();
            n.width = e, n.height = t;
            const s = n.getContext("2d");
            return {
                canvas: n,
                context: s
            };
        }
        getOptimalCanvasAndContext(e, t, n = 1) {
            e = Math.ceil(e * n - 1e-6), t = Math.ceil(t * n - 1e-6), e = so(e), t = so(t);
            const s = (e << 17) + (t << 1);
            this._canvasPool[s] || (this._canvasPool[s] = []);
            let r = this._canvasPool[s].pop();
            return r || (r = this._createCanvasAndContext(e, t)), r;
        }
        returnCanvasAndContext(e) {
            const t = e.canvas, { width: n, height: s } = t, r = (n << 17) + (s << 1);
            e.context.clearRect(0, 0, n, s), this._canvasPool[r].push(e);
        }
        clear() {
            this._canvasPool = {};
        }
    }
    let zE;
    Ef = new HE;
    zE = [
        "serif",
        "sans-serif",
        "monospace",
        "cursive",
        "fantasy",
        "system-ui"
    ];
    qc = function(i) {
        const e = typeof i.fontSize == "number" ? `${i.fontSize}px` : i.fontSize;
        let t = i.fontFamily;
        Array.isArray(i.fontFamily) || (t = i.fontFamily.split(","));
        for(let n = t.length - 1; n >= 0; n--){
            let s = t[n].trim();
            !/([\"\'])[^\'\"]+\1/.test(s) && !zE.includes(s) && (s = `"${s}"`), t[n] = s;
        }
        return `${i.fontStyle} ${i.fontVariant} ${i.fontWeight} ${e} ${t.join(",")}`;
    };
    const Il = {
        willReadFrequently: !0
    }, Un = class Te {
        static get experimentalLetterSpacingSupported() {
            let e = Te._experimentalLetterSpacingSupported;
            if (e !== void 0) {
                const t = _t.get().getCanvasRenderingContext2D().prototype;
                e = Te._experimentalLetterSpacingSupported = "letterSpacing" in t || "textLetterSpacing" in t;
            }
            return e;
        }
        constructor(e, t, n, s, r, a, o, l, h){
            this.text = e, this.style = t, this.width = n, this.height = s, this.lines = r, this.lineWidths = a, this.lineHeight = o, this.maxLineWidth = l, this.fontProperties = h;
        }
        static measureText(e = " ", t, n = Te._canvas, s = t.wordWrap) {
            const r = `${e}:${t.styleKey}`;
            if (Te._measurementCache[r]) return Te._measurementCache[r];
            const a = qc(t), o = Te.measureFont(a);
            o.fontSize === 0 && (o.fontSize = t.fontSize, o.ascent = t.fontSize);
            const l = Te.__context;
            l.font = a;
            const d = (s ? Te._wordWrap(e, t, n) : e).split(/(?:\r\n|\r|\n)/), c = new Array(d.length);
            let u = 0;
            for(let x = 0; x < d.length; x++){
                const v = Te._measureText(d[x], t.letterSpacing, l);
                c[x] = v, u = Math.max(u, v);
            }
            const f = t._stroke?.width || 0;
            let _ = u + f;
            t.dropShadow && (_ += t.dropShadow.distance);
            const g = t.lineHeight || o.fontSize;
            let m = Math.max(g, o.fontSize + f) + (d.length - 1) * (g + t.leading);
            return t.dropShadow && (m += t.dropShadow.distance), new Te(e, t, _, m, d, c, g + t.leading, u, o);
        }
        static _measureText(e, t, n) {
            let s = !1;
            Te.experimentalLetterSpacingSupported && (Te.experimentalLetterSpacing ? (n.letterSpacing = `${t}px`, n.textLetterSpacing = `${t}px`, s = !0) : (n.letterSpacing = "0px", n.textLetterSpacing = "0px"));
            const r = n.measureText(e);
            let a = r.width;
            const o = -r.actualBoundingBoxLeft;
            let h = r.actualBoundingBoxRight - o;
            if (a > 0) if (s) a -= t, h -= t;
            else {
                const d = (Te.graphemeSegmenter(e).length - 1) * t;
                a += d, h += d;
            }
            return Math.max(a, h);
        }
        static _wordWrap(e, t, n = Te._canvas) {
            const s = n.getContext("2d", Il);
            let r = 0, a = "", o = "";
            const l = Object.create(null), { letterSpacing: h, whiteSpace: d } = t, c = Te._collapseSpaces(d), u = Te._collapseNewlines(d);
            let f = !c;
            const _ = t.wordWrapWidth + h, g = Te._tokenize(e);
            for(let m = 0; m < g.length; m++){
                let p = g[m];
                if (Te._isNewline(p)) {
                    if (!u) {
                        o += Te._addLine(a), f = !c, a = "", r = 0;
                        continue;
                    }
                    p = " ";
                }
                if (c) {
                    const v = Te.isBreakingSpace(p), y = Te.isBreakingSpace(a[a.length - 1]);
                    if (v && y) continue;
                }
                const x = Te._getFromCache(p, h, l, s);
                if (x > _) if (a !== "" && (o += Te._addLine(a), a = "", r = 0), Te.canBreakWords(p, t.breakWords)) {
                    const v = Te.wordWrapSplit(p);
                    for(let y = 0; y < v.length; y++){
                        let P = v[y], w = P, R = 1;
                        for(; v[y + R];){
                            const T = v[y + R];
                            if (!Te.canBreakChars(w, T, p, y, t.breakWords)) P += T;
                            else break;
                            w = T, R++;
                        }
                        y += R - 1;
                        const B = Te._getFromCache(P, h, l, s);
                        B + r > _ && (o += Te._addLine(a), f = !1, a = "", r = 0), a += P, r += B;
                    }
                } else {
                    a.length > 0 && (o += Te._addLine(a), a = "", r = 0);
                    const v = m === g.length - 1;
                    o += Te._addLine(p, !v), f = !1, a = "", r = 0;
                }
                else x + r > _ && (f = !1, o += Te._addLine(a), a = "", r = 0), (a.length > 0 || !Te.isBreakingSpace(p) || f) && (a += p, r += x);
            }
            return o += Te._addLine(a, !1), o;
        }
        static _addLine(e, t = !0) {
            return e = Te._trimRight(e), e = t ? `${e}
` : e, e;
        }
        static _getFromCache(e, t, n, s) {
            let r = n[e];
            return typeof r != "number" && (r = Te._measureText(e, t, s) + t, n[e] = r), r;
        }
        static _collapseSpaces(e) {
            return e === "normal" || e === "pre-line";
        }
        static _collapseNewlines(e) {
            return e === "normal";
        }
        static _trimRight(e) {
            if (typeof e != "string") return "";
            for(let t = e.length - 1; t >= 0; t--){
                const n = e[t];
                if (!Te.isBreakingSpace(n)) break;
                e = e.slice(0, -1);
            }
            return e;
        }
        static _isNewline(e) {
            return typeof e != "string" ? !1 : Te._newlines.includes(e.charCodeAt(0));
        }
        static isBreakingSpace(e, t) {
            return typeof e != "string" ? !1 : Te._breakingSpaces.includes(e.charCodeAt(0));
        }
        static _tokenize(e) {
            const t = [];
            let n = "";
            if (typeof e != "string") return t;
            for(let s = 0; s < e.length; s++){
                const r = e[s], a = e[s + 1];
                if (Te.isBreakingSpace(r, a) || Te._isNewline(r)) {
                    n !== "" && (t.push(n), n = ""), t.push(r);
                    continue;
                }
                n += r;
            }
            return n !== "" && t.push(n), t;
        }
        static canBreakWords(e, t) {
            return t;
        }
        static canBreakChars(e, t, n, s, r) {
            return !0;
        }
        static wordWrapSplit(e) {
            return Te.graphemeSegmenter(e);
        }
        static measureFont(e) {
            if (Te._fonts[e]) return Te._fonts[e];
            const t = Te._context;
            t.font = e;
            const n = t.measureText(Te.METRICS_STRING + Te.BASELINE_SYMBOL), s = {
                ascent: n.actualBoundingBoxAscent,
                descent: n.actualBoundingBoxDescent,
                fontSize: n.actualBoundingBoxAscent + n.actualBoundingBoxDescent
            };
            return Te._fonts[e] = s, s;
        }
        static clearMetrics(e = "") {
            e ? delete Te._fonts[e] : Te._fonts = {};
        }
        static get _canvas() {
            if (!Te.__canvas) {
                let e;
                try {
                    const t = new OffscreenCanvas(0, 0);
                    if (t.getContext("2d", Il)?.measureText) return Te.__canvas = t, t;
                    e = _t.get().createCanvas();
                } catch  {
                    e = _t.get().createCanvas();
                }
                e.width = e.height = 10, Te.__canvas = e;
            }
            return Te.__canvas;
        }
        static get _context() {
            return Te.__context || (Te.__context = Te._canvas.getContext("2d", Il)), Te.__context;
        }
    };
    Un.METRICS_STRING = "|q";
    Un.BASELINE_SYMBOL = "M";
    Un.BASELINE_MULTIPLIER = 1.4;
    Un.HEIGHT_MULTIPLIER = 2;
    Un.graphemeSegmenter = (()=>{
        if (typeof Intl?.Segmenter == "function") {
            const i = new Intl.Segmenter;
            return (e)=>[
                    ...i.segment(e)
                ].map((t)=>t.segment);
        }
        return (i)=>[
                ...i
            ];
    })();
    Un.experimentalLetterSpacing = !1;
    Un._fonts = {};
    Un._newlines = [
        10,
        13
    ];
    Un._breakingSpaces = [
        9,
        32,
        8192,
        8193,
        8194,
        8195,
        8196,
        8197,
        8198,
        8200,
        8201,
        8202,
        8287,
        12288
    ];
    Un._measurementCache = {};
    $c = Un;
    const wf = 1e5;
    Rf = function(i, e, t, n = 0) {
        if (i.texture === Ie.WHITE && !i.fill) return Et.shared.setValue(i.color).setAlpha(i.alpha ?? 1).toHexa();
        if (i.fill) {
            if (i.fill instanceof _o) {
                const s = i.fill, r = e.createPattern(s.texture.source.resource, "repeat"), a = s.transform.copyTo(Ne.shared);
                return a.scale(s.texture.frame.width, s.texture.frame.height), r.setTransform(a), r;
            } else if (i.fill instanceof Ri) {
                const s = i.fill, r = s.type === "linear", a = s.textureSpace === "local";
                let o = 1, l = 1;
                a && t && (o = t.width + n, l = t.height + n);
                let h, d = !1;
                if (r) {
                    const { start: c, end: u } = s;
                    h = e.createLinearGradient(c.x * o, c.y * l, u.x * o, u.y * l), d = Math.abs(u.x - c.x) < Math.abs((u.y - c.y) * .1);
                } else {
                    const { center: c, innerRadius: u, outerCenter: f, outerRadius: _ } = s;
                    h = e.createRadialGradient(c.x * o, c.y * l, u * o, f.x * o, f.y * l, _ * o);
                }
                if (d && a && t) {
                    const c = t.lineHeight / l;
                    for(let u = 0; u < t.lines.length; u++){
                        const f = (u * t.lineHeight + n / 2) / l;
                        s.colorStops.forEach((_)=>{
                            const g = f + _.offset * c;
                            h.addColorStop(Math.floor(g * wf) / wf, Et.shared.setValue(_.color).toHex());
                        });
                    }
                } else s.colorStops.forEach((c)=>{
                    h.addColorStop(c.offset, Et.shared.setValue(c.color).toHex());
                });
                return h;
            }
        } else {
            const s = e.createPattern(i.texture.source.resource, "repeat"), r = i.matrix.copyTo(Ne.shared);
            return r.scale(i.texture.frame.width, i.texture.frame.height), s.setTransform(r), s;
        }
        return tt("FillStyle not recognised", i), "red";
    };
    function Zm(i) {
        if (i === "") return [];
        typeof i == "string" && (i = [
            i
        ]);
        const e = [];
        for(let t = 0, n = i.length; t < n; t++){
            const s = i[t];
            if (Array.isArray(s)) {
                if (s.length !== 2) throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${s.length}.`);
                if (s[0].length === 0 || s[1].length === 0) throw new Error("[BitmapFont]: Invalid character delimiter.");
                const r = s[0].charCodeAt(0), a = s[1].charCodeAt(0);
                if (a < r) throw new Error("[BitmapFont]: Invalid character range.");
                for(let o = r, l = a; o <= l; o++)e.push(String.fromCharCode(o));
            } else e.push(...Array.from(s));
        }
        if (e.length === 0) throw new Error("[BitmapFont]: Empty set when resolving characters.");
        return e;
    }
    const Jm = class Qm extends Rm {
        constructor(e){
            super(), this.resolution = 1, this.pages = [], this._padding = 0, this._measureCache = Object.create(null), this._currentChars = [], this._currentX = 0, this._currentY = 0, this._currentPageIndex = -1, this._skipKerning = !1;
            const t = {
                ...Qm.defaultOptions,
                ...e
            };
            this._textureSize = t.textureSize, this._mipmap = t.mipmap;
            const n = t.style.clone();
            t.overrideFill && (n._fill.color = 16777215, n._fill.alpha = 1, n._fill.texture = Ie.WHITE, n._fill.fill = null), this.applyFillAsTint = t.overrideFill;
            const s = n.fontSize;
            n.fontSize = this.baseMeasurementFontSize;
            const r = qc(n);
            t.overrideSize ? n._stroke && (n._stroke.width *= this.baseRenderedFontSize / s) : n.fontSize = this.baseRenderedFontSize = s, this._style = n, this._skipKerning = t.skipKerning ?? !1, this.resolution = t.resolution ?? 1, this._padding = t.padding ?? 4, this.fontMetrics = $c.measureFont(r), this.lineHeight = n.lineHeight || this.fontMetrics.fontSize || n.fontSize;
        }
        ensureCharacters(e) {
            const t = Zm(e).filter((m)=>!this._currentChars.includes(m)).filter((m, p, x)=>x.indexOf(m) === p);
            if (!t.length) return;
            this._currentChars = [
                ...this._currentChars,
                ...t
            ];
            let n;
            this._currentPageIndex === -1 ? n = this._nextPage() : n = this.pages[this._currentPageIndex];
            let { canvas: s, context: r } = n.canvasAndContext, a = n.texture.source;
            const o = this._style;
            let l = this._currentX, h = this._currentY;
            const d = this.baseRenderedFontSize / this.baseMeasurementFontSize, c = this._padding * d;
            let u = 0, f = !1;
            const _ = s.width / this.resolution, g = s.height / this.resolution;
            for(let m = 0; m < t.length; m++){
                const p = t[m], x = $c.measureText(p, o, s, !1);
                x.lineHeight = x.height;
                const v = x.width * d, y = Math.ceil((o.fontStyle === "italic" ? 2 : 1) * v), P = x.height * d, w = y + c * 2, R = P + c * 2;
                if (f = !1, p !== `
` && p !== "\r" && p !== "	" && p !== " " && (f = !0, u = Math.ceil(Math.max(R, u))), l + w > _ && (h += u, u = R, l = 0, h + u > g)) {
                    a.update();
                    const T = this._nextPage();
                    s = T.canvasAndContext.canvas, r = T.canvasAndContext.context, a = T.texture.source, h = 0;
                }
                const B = v / d - (o.dropShadow?.distance ?? 0) - (o._stroke?.width ?? 0);
                if (this.chars[p] = {
                    id: p.codePointAt(0),
                    xOffset: -this._padding,
                    yOffset: -this._padding,
                    xAdvance: B,
                    kerning: {}
                }, f) {
                    this._drawGlyph(r, x, l + c, h + c, d, o);
                    const T = a.width * d, S = a.height * d, D = new mt(l / T * a.width, h / S * a.height, w / T * a.width, R / S * a.height);
                    this.chars[p].texture = new Ie({
                        source: a,
                        frame: D
                    }), l += Math.ceil(w);
                }
            }
            a.update(), this._currentX = l, this._currentY = h, this._skipKerning && this._applyKerning(t, r);
        }
        get pageTextures() {
            return et(dt, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."), this.pages;
        }
        _applyKerning(e, t) {
            const n = this._measureCache;
            for(let s = 0; s < e.length; s++){
                const r = e[s];
                for(let a = 0; a < this._currentChars.length; a++){
                    const o = this._currentChars[a];
                    let l = n[r];
                    l || (l = n[r] = t.measureText(r).width);
                    let h = n[o];
                    h || (h = n[o] = t.measureText(o).width);
                    let d = t.measureText(r + o).width, c = d - (l + h);
                    c && (this.chars[r].kerning[o] = c), d = t.measureText(r + o).width, c = d - (l + h), c && (this.chars[o].kerning[r] = c);
                }
            }
        }
        _nextPage() {
            this._currentPageIndex++;
            const e = this.resolution, t = Ef.getOptimalCanvasAndContext(this._textureSize, this._textureSize, e);
            this._setupContext(t.context, this._style, e);
            const n = e * (this.baseRenderedFontSize / this.baseMeasurementFontSize), s = new Ie({
                source: new ts({
                    resource: t.canvas,
                    resolution: n,
                    alphaMode: "premultiply-alpha-on-upload",
                    autoGenerateMipmaps: this._mipmap
                })
            }), r = {
                canvasAndContext: t,
                texture: s
            };
            return this.pages[this._currentPageIndex] = r, r;
        }
        _setupContext(e, t, n) {
            t.fontSize = this.baseRenderedFontSize, e.scale(n, n), e.font = qc(t), t.fontSize = this.baseMeasurementFontSize, e.textBaseline = t.textBaseline;
            const s = t._stroke, r = s?.width ?? 0;
            if (s && (e.lineWidth = r, e.lineJoin = s.join, e.miterLimit = s.miterLimit, e.strokeStyle = Rf(s, e)), t._fill && (e.fillStyle = Rf(t._fill, e)), t.dropShadow) {
                const a = t.dropShadow, o = Et.shared.setValue(a.color).toArray(), l = a.blur * n, h = a.distance * n;
                e.shadowColor = `rgba(${o[0] * 255},${o[1] * 255},${o[2] * 255},${a.alpha})`, e.shadowBlur = l, e.shadowOffsetX = Math.cos(a.angle) * h, e.shadowOffsetY = Math.sin(a.angle) * h;
            } else e.shadowColor = "black", e.shadowBlur = 0, e.shadowOffsetX = 0, e.shadowOffsetY = 0;
        }
        _drawGlyph(e, t, n, s, r, a) {
            const o = t.text, l = t.fontProperties, d = (a._stroke?.width ?? 0) * r, c = n + d / 2, u = s - d / 2, f = l.descent * r, _ = t.lineHeight * r;
            a.stroke && d && e.strokeText(o, c, u + _ - f), a._fill && e.fillText(o, c, u + _ - f);
        }
        destroy() {
            super.destroy();
            for(let e = 0; e < this.pages.length; e++){
                const { canvasAndContext: t, texture: n } = this.pages[e];
                Ef.returnCanvasAndContext(t), n.destroy(!0);
            }
            this.pages = null;
        }
    };
    Jm.defaultOptions = {
        textureSize: 512,
        style: new $s,
        mipmap: !0
    };
    let Cf = Jm;
    VE = function(i, e, t, n) {
        const s = {
            width: 0,
            height: 0,
            offsetY: 0,
            scale: e.fontSize / t.baseMeasurementFontSize,
            lines: [
                {
                    width: 0,
                    charPositions: [],
                    spaceWidth: 0,
                    spacesIndex: [],
                    chars: []
                }
            ]
        };
        s.offsetY = t.baseLineOffset;
        let r = s.lines[0], a = null, o = !0;
        const l = {
            width: 0,
            start: 0,
            index: 0,
            positions: [],
            chars: []
        }, h = (_)=>{
            const g = r.width;
            for(let m = 0; m < l.index; m++){
                const p = _.positions[m];
                r.chars.push(_.chars[m]), r.charPositions.push(p + g);
            }
            r.width += _.width, o = !1, l.width = 0, l.index = 0, l.chars.length = 0;
        }, d = ()=>{
            let _ = r.chars.length - 1;
            if (n) {
                let g = r.chars[_];
                for(; g === " ";)r.width -= t.chars[g].xAdvance, g = r.chars[--_];
            }
            s.width = Math.max(s.width, r.width), r = {
                width: 0,
                charPositions: [],
                chars: [],
                spaceWidth: 0,
                spacesIndex: []
            }, o = !0, s.lines.push(r), s.height += t.lineHeight;
        }, c = t.baseMeasurementFontSize / e.fontSize, u = e.letterSpacing * c, f = e.wordWrapWidth * c;
        for(let _ = 0; _ < i.length + 1; _++){
            let g;
            const m = _ === i.length;
            m || (g = i[_]);
            const p = t.chars[g] || t.chars[" "];
            if (/(?:\s)/.test(g) || g === "\r" || g === `
` || m) {
                if (!o && e.wordWrap && r.width + l.width - u > f ? (d(), h(l), m || r.charPositions.push(0)) : (l.start = r.width, h(l), m || r.charPositions.push(0)), g === "\r" || g === `
`) r.width !== 0 && d();
                else if (!m) {
                    const P = p.xAdvance + (p.kerning[a] || 0) + u;
                    r.width += P, r.spaceWidth = P, r.spacesIndex.push(r.charPositions.length), r.chars.push(g);
                }
            } else {
                const y = p.kerning[a] || 0, P = p.xAdvance + y + u;
                l.positions[l.index++] = l.width + y, l.chars.push(g), l.width += P;
            }
            a = g;
        }
        return d(), e.align === "center" ? WE(s) : e.align === "right" ? XE(s) : e.align === "justify" && YE(s), s;
    };
    function WE(i) {
        for(let e = 0; e < i.lines.length; e++){
            const t = i.lines[e], n = i.width / 2 - t.width / 2;
            for(let s = 0; s < t.charPositions.length; s++)t.charPositions[s] += n;
        }
    }
    function XE(i) {
        for(let e = 0; e < i.lines.length; e++){
            const t = i.lines[e], n = i.width - t.width;
            for(let s = 0; s < t.charPositions.length; s++)t.charPositions[s] += n;
        }
    }
    function YE(i) {
        const e = i.width;
        for(let t = 0; t < i.lines.length; t++){
            const n = i.lines[t];
            let s = 0, r = n.spacesIndex[s++], a = 0;
            const o = n.spacesIndex.length, h = (e - n.width) / o;
            for(let d = 0; d < n.charPositions.length; d++)d === r && (r = n.spacesIndex[s++], a += h), n.charPositions[d] += a;
        }
    }
    let Ua = 0;
    class jE {
        constructor(){
            this.ALPHA = [
                [
                    "a",
                    "z"
                ],
                [
                    "A",
                    "Z"
                ],
                " "
            ], this.NUMERIC = [
                [
                    "0",
                    "9"
                ]
            ], this.ALPHANUMERIC = [
                [
                    "a",
                    "z"
                ],
                [
                    "A",
                    "Z"
                ],
                [
                    "0",
                    "9"
                ],
                " "
            ], this.ASCII = [
                [
                    " ",
                    "~"
                ]
            ], this.defaultOptions = {
                chars: this.ALPHANUMERIC,
                resolution: 1,
                padding: 4,
                skipKerning: !1
            };
        }
        getFont(e, t) {
            let n = `${t.fontFamily}-bitmap`, s = !0;
            if (t._fill.fill && !t._stroke) n += t._fill.fill.styleKey, s = !1;
            else if (t._stroke || t.dropShadow) {
                let a = t.styleKey;
                a = a.substring(0, a.lastIndexOf("-")), n = `${a}-bitmap`, s = !1;
            }
            if (!Mt.has(n)) {
                const a = new Cf({
                    style: t,
                    overrideFill: s,
                    overrideSize: !0,
                    ...this.defaultOptions
                });
                Ua++, Ua > 50 && tt("BitmapText", `You have dynamically created ${Ua} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``), a.once("destroy", ()=>{
                    Ua--, Mt.remove(n);
                }), Mt.set(n, a);
            }
            const r = Mt.get(n);
            return r.ensureCharacters?.(e), r;
        }
        getLayout(e, t, n = !0) {
            const s = this.getFont(e, t);
            return VE([
                ...e
            ], t, s, n);
        }
        measureText(e, t, n = !0) {
            return this.getLayout(e, t, n);
        }
        install(...e) {
            let t = e[0];
            typeof t == "string" && (t = {
                name: t,
                style: e[1],
                chars: e[2]?.chars,
                resolution: e[2]?.resolution,
                padding: e[2]?.padding,
                skipKerning: e[2]?.skipKerning
            }, et(dt, "BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})"));
            const n = t?.name;
            if (!n) throw new Error("[BitmapFontManager] Property `name` is required.");
            t = {
                ...this.defaultOptions,
                ...t
            };
            const s = t.style, r = s instanceof $s ? s : new $s(s), a = r._fill.fill !== null && r._fill.fill !== void 0, o = new Cf({
                style: r,
                overrideFill: a,
                skipKerning: t.skipKerning,
                padding: t.padding,
                resolution: t.resolution,
                overrideSize: !1
            }), l = Zm(t.chars);
            return o.ensureCharacters(l.join("")), Mt.set(`${n}-bitmap`, o), o.once("destroy", ()=>Mt.remove(`${n}-bitmap`)), o;
        }
        uninstall(e) {
            const t = `${e}-bitmap`, n = Mt.get(t);
            n && n.destroy();
        }
    }
    Pf = new jE;
    class e_ extends Rm {
        constructor(e, t){
            super();
            const { textures: n, data: s } = e;
            Object.keys(s.pages).forEach((r)=>{
                const a = s.pages[parseInt(r, 10)], o = n[a.id];
                this.pages.push({
                    texture: o
                });
            }), Object.keys(s.chars).forEach((r)=>{
                const a = s.chars[r], { frame: o, source: l } = n[a.page], h = new mt(a.x + o.x, a.y + o.y, a.width, a.height), d = new Ie({
                    source: l,
                    frame: h
                });
                this.chars[r] = {
                    id: r.codePointAt(0),
                    xOffset: a.xOffset,
                    yOffset: a.yOffset,
                    xAdvance: a.xAdvance,
                    kerning: a.kerning ?? {},
                    texture: d
                };
            }), this.baseRenderedFontSize = s.fontSize, this.baseMeasurementFontSize = s.fontSize, this.fontMetrics = {
                ascent: 0,
                descent: 0,
                fontSize: s.fontSize
            }, this.baseLineOffset = s.baseLineOffset, this.lineHeight = s.lineHeight, this.fontFamily = s.fontFamily, this.distanceField = s.distanceField ?? {
                type: "none",
                range: 0
            }, this.url = t;
        }
        destroy() {
            super.destroy();
            for(let e = 0; e < this.pages.length; e++){
                const { texture: t } = this.pages[e];
                t.destroy(!0);
            }
            this.pages = null;
        }
        static install(e) {
            Pf.install(e);
        }
        static uninstall(e) {
            Pf.uninstall(e);
        }
    }
    const Dl = {
        test (i) {
            return typeof i == "string" && i.startsWith("info face=");
        },
        parse (i) {
            const e = i.match(/^[a-z]+\s+.+$/gm), t = {
                info: [],
                common: [],
                page: [],
                char: [],
                chars: [],
                kerning: [],
                kernings: [],
                distanceField: []
            };
            for(const c in e){
                const u = e[c].match(/^[a-z]+/gm)[0], f = e[c].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm), _ = {};
                for(const g in f){
                    const m = f[g].split("="), p = m[0], x = m[1].replace(/"/gm, ""), v = parseFloat(x), y = isNaN(v) ? x : v;
                    _[p] = y;
                }
                t[u].push(_);
            }
            const n = {
                chars: {},
                pages: [],
                lineHeight: 0,
                fontSize: 0,
                fontFamily: "",
                distanceField: null,
                baseLineOffset: 0
            }, [s] = t.info, [r] = t.common, [a] = t.distanceField ?? [];
            a && (n.distanceField = {
                range: parseInt(a.distanceRange, 10),
                type: a.fieldType
            }), n.fontSize = parseInt(s.size, 10), n.fontFamily = s.face, n.lineHeight = parseInt(r.lineHeight, 10);
            const o = t.page;
            for(let c = 0; c < o.length; c++)n.pages.push({
                id: parseInt(o[c].id, 10) || 0,
                file: o[c].file
            });
            const l = {};
            n.baseLineOffset = n.lineHeight - parseInt(r.base, 10);
            const h = t.char;
            for(let c = 0; c < h.length; c++){
                const u = h[c], f = parseInt(u.id, 10);
                let _ = u.letter ?? u.char ?? String.fromCharCode(f);
                _ === "space" && (_ = " "), l[f] = _, n.chars[_] = {
                    id: f,
                    page: parseInt(u.page, 10) || 0,
                    x: parseInt(u.x, 10),
                    y: parseInt(u.y, 10),
                    width: parseInt(u.width, 10),
                    height: parseInt(u.height, 10),
                    xOffset: parseInt(u.xoffset, 10),
                    yOffset: parseInt(u.yoffset, 10),
                    xAdvance: parseInt(u.xadvance, 10),
                    kerning: {}
                };
            }
            const d = t.kerning || [];
            for(let c = 0; c < d.length; c++){
                const u = parseInt(d[c].first, 10), f = parseInt(d[c].second, 10), _ = parseInt(d[c].amount, 10);
                n.chars[l[f]].kerning[l[u]] = _;
            }
            return n;
        }
    }, If = {
        test (i) {
            const e = i;
            return typeof e != "string" && "getElementsByTagName" in e && e.getElementsByTagName("page").length && e.getElementsByTagName("info")[0].getAttribute("face") !== null;
        },
        parse (i) {
            const e = {
                chars: {},
                pages: [],
                lineHeight: 0,
                fontSize: 0,
                fontFamily: "",
                distanceField: null,
                baseLineOffset: 0
            }, t = i.getElementsByTagName("info")[0], n = i.getElementsByTagName("common")[0], s = i.getElementsByTagName("distanceField")[0];
            s && (e.distanceField = {
                type: s.getAttribute("fieldType"),
                range: parseInt(s.getAttribute("distanceRange"), 10)
            });
            const r = i.getElementsByTagName("page"), a = i.getElementsByTagName("char"), o = i.getElementsByTagName("kerning");
            e.fontSize = parseInt(t.getAttribute("size"), 10), e.fontFamily = t.getAttribute("face"), e.lineHeight = parseInt(n.getAttribute("lineHeight"), 10);
            for(let h = 0; h < r.length; h++)e.pages.push({
                id: parseInt(r[h].getAttribute("id"), 10) || 0,
                file: r[h].getAttribute("file")
            });
            const l = {};
            e.baseLineOffset = e.lineHeight - parseInt(n.getAttribute("base"), 10);
            for(let h = 0; h < a.length; h++){
                const d = a[h], c = parseInt(d.getAttribute("id"), 10);
                let u = d.getAttribute("letter") ?? d.getAttribute("char") ?? String.fromCharCode(c);
                u === "space" && (u = " "), l[c] = u, e.chars[u] = {
                    id: c,
                    page: parseInt(d.getAttribute("page"), 10) || 0,
                    x: parseInt(d.getAttribute("x"), 10),
                    y: parseInt(d.getAttribute("y"), 10),
                    width: parseInt(d.getAttribute("width"), 10),
                    height: parseInt(d.getAttribute("height"), 10),
                    xOffset: parseInt(d.getAttribute("xoffset"), 10),
                    yOffset: parseInt(d.getAttribute("yoffset"), 10),
                    xAdvance: parseInt(d.getAttribute("xadvance"), 10),
                    kerning: {}
                };
            }
            for(let h = 0; h < o.length; h++){
                const d = parseInt(o[h].getAttribute("first"), 10), c = parseInt(o[h].getAttribute("second"), 10), u = parseInt(o[h].getAttribute("amount"), 10);
                e.chars[l[c]].kerning[l[d]] = u;
            }
            return e;
        }
    }, Df = {
        test (i) {
            return typeof i == "string" && i.includes("<font>") ? If.test(_t.get().parseXML(i)) : !1;
        },
        parse (i) {
            return If.parse(_t.get().parseXML(i));
        }
    }, qE = [
        ".xml",
        ".fnt"
    ], $E = {
        extension: {
            type: J.CacheParser,
            name: "cacheBitmapFont"
        },
        test: (i)=>i instanceof e_,
        getCacheableAssets (i, e) {
            const t = {};
            return i.forEach((n)=>{
                t[n] = e, t[`${n}-bitmap`] = e;
            }), t[`${e.fontFamily}-bitmap`] = e, t;
        }
    }, KE = {
        extension: {
            type: J.LoadParser,
            priority: Ci.Normal
        },
        name: "loadBitmapFont",
        test (i) {
            return qE.includes(hn.extname(i).toLowerCase());
        },
        async testParse (i) {
            return Dl.test(i) || Df.test(i);
        },
        async parse (i, e, t) {
            const n = Dl.test(i) ? Dl.parse(i) : Df.parse(i), { src: s } = e, { pages: r } = n, a = [], o = n.distanceField ? {
                scaleMode: "linear",
                alphaMode: "premultiply-alpha-on-upload",
                autoGenerateMipmaps: !1,
                resolution: 1
            } : {};
            for(let c = 0; c < r.length; ++c){
                const u = r[c].file;
                let f = hn.join(hn.dirname(s), u);
                f = Nc(f, s), a.push({
                    src: f,
                    data: o
                });
            }
            const l = await t.load(a), h = a.map((c)=>l[c.src]);
            return new e_({
                data: n,
                textures: h
            }, s);
        },
        async load (i, e) {
            return await (await _t.get().fetch(i)).text();
        },
        async unload (i, e, t) {
            await Promise.all(i.pages.map((n)=>t.unload(n.texture.source._sourceOrigin))), i.destroy();
        }
    };
    class ZE {
        constructor(e, t = !1){
            this._loader = e, this._assetList = [], this._isLoading = !1, this._maxConcurrent = 1, this.verbose = t;
        }
        add(e) {
            e.forEach((t)=>{
                this._assetList.push(t);
            }), this.verbose && console.log("[BackgroundLoader] assets: ", this._assetList), this._isActive && !this._isLoading && this._next();
        }
        async _next() {
            if (this._assetList.length && this._isActive) {
                this._isLoading = !0;
                const e = [], t = Math.min(this._assetList.length, this._maxConcurrent);
                for(let n = 0; n < t; n++)e.push(this._assetList.pop());
                await this._loader.load(e), this._isLoading = !1, this._next();
            }
        }
        get active() {
            return this._isActive;
        }
        set active(e) {
            this._isActive !== e && (this._isActive = e, e && !this._isLoading && this._next());
        }
    }
    const JE = {
        extension: {
            type: J.CacheParser,
            name: "cacheTextureArray"
        },
        test: (i)=>Array.isArray(i) && i.every((e)=>e instanceof Ie),
        getCacheableAssets: (i, e)=>{
            const t = {};
            return i.forEach((n)=>{
                e.forEach((s, r)=>{
                    t[n + (r === 0 ? "" : r + 1)] = s;
                });
            }), t;
        }
    };
    async function t_(i) {
        if ("Image" in globalThis) return new Promise((e)=>{
            const t = new Image;
            t.onload = ()=>{
                e(!0);
            }, t.onerror = ()=>{
                e(!1);
            }, t.src = i;
        });
        if ("createImageBitmap" in globalThis && "fetch" in globalThis) {
            try {
                const e = await (await fetch(i)).blob();
                await createImageBitmap(e);
            } catch  {
                return !1;
            }
            return !0;
        }
        return !1;
    }
    const QE = {
        extension: {
            type: J.DetectionParser,
            priority: 1
        },
        test: async ()=>t_("data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="),
        add: async (i)=>[
                ...i,
                "avif"
            ],
        remove: async (i)=>i.filter((e)=>e !== "avif")
    }, Lf = [
        "png",
        "jpg",
        "jpeg"
    ], ew = {
        extension: {
            type: J.DetectionParser,
            priority: -1
        },
        test: ()=>Promise.resolve(!0),
        add: async (i)=>[
                ...i,
                ...Lf
            ],
        remove: async (i)=>i.filter((e)=>!Lf.includes(e))
    }, tw = "WorkerGlobalScope" in globalThis && globalThis instanceof globalThis.WorkerGlobalScope;
    function Wh(i) {
        return tw ? !1 : document.createElement("video").canPlayType(i) !== "";
    }
    const nw = {
        extension: {
            type: J.DetectionParser,
            priority: 0
        },
        test: async ()=>Wh("video/mp4"),
        add: async (i)=>[
                ...i,
                "mp4",
                "m4v"
            ],
        remove: async (i)=>i.filter((e)=>e !== "mp4" && e !== "m4v")
    }, iw = {
        extension: {
            type: J.DetectionParser,
            priority: 0
        },
        test: async ()=>Wh("video/ogg"),
        add: async (i)=>[
                ...i,
                "ogv"
            ],
        remove: async (i)=>i.filter((e)=>e !== "ogv")
    }, sw = {
        extension: {
            type: J.DetectionParser,
            priority: 0
        },
        test: async ()=>Wh("video/webm"),
        add: async (i)=>[
                ...i,
                "webm"
            ],
        remove: async (i)=>i.filter((e)=>e !== "webm")
    }, rw = {
        extension: {
            type: J.DetectionParser,
            priority: 0
        },
        test: async ()=>t_("data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="),
        add: async (i)=>[
                ...i,
                "webp"
            ],
        remove: async (i)=>i.filter((e)=>e !== "webp")
    };
    class aw {
        constructor(){
            this._parsers = [], this._parsersValidated = !1, this.parsers = new Proxy(this._parsers, {
                set: (e, t, n)=>(this._parsersValidated = !1, e[t] = n, !0)
            }), this.promiseCache = {};
        }
        reset() {
            this._parsersValidated = !1, this.promiseCache = {};
        }
        _getLoadPromiseAndParser(e, t) {
            const n = {
                promise: null,
                parser: null
            };
            return n.promise = (async ()=>{
                let s = null, r = null;
                if (t.loadParser && (r = this._parserHash[t.loadParser], r || tt(`[Assets] specified load parser "${t.loadParser}" not found while loading ${e}`)), !r) {
                    for(let a = 0; a < this.parsers.length; a++){
                        const o = this.parsers[a];
                        if (o.load && o.test?.(e, t, this)) {
                            r = o;
                            break;
                        }
                    }
                    if (!r) return tt(`[Assets] ${e} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`), null;
                }
                s = await r.load(e, t, this), n.parser = r;
                for(let a = 0; a < this.parsers.length; a++){
                    const o = this.parsers[a];
                    o.parse && o.parse && await o.testParse?.(s, t, this) && (s = await o.parse(s, t, this) || s, n.parser = o);
                }
                return s;
            })(), n;
        }
        async load(e, t) {
            this._parsersValidated || this._validateParsers();
            let n = 0;
            const s = {}, r = lo(e), a = Cn(e, (h)=>({
                    alias: [
                        h
                    ],
                    src: h,
                    data: {}
                })), o = a.length, l = a.map(async (h)=>{
                const d = hn.toAbsolute(h.src);
                if (!s[h.src]) try {
                    this.promiseCache[d] || (this.promiseCache[d] = this._getLoadPromiseAndParser(d, h)), s[h.src] = await this.promiseCache[d].promise, t && t(++n / o);
                } catch (c) {
                    throw delete this.promiseCache[d], delete s[h.src], new Error(`[Loader.load] Failed to load ${d}.
${c}`);
                }
            });
            return await Promise.all(l), r ? s[a[0].src] : s;
        }
        async unload(e) {
            const n = Cn(e, (s)=>({
                    alias: [
                        s
                    ],
                    src: s
                })).map(async (s)=>{
                const r = hn.toAbsolute(s.src), a = this.promiseCache[r];
                if (a) {
                    const o = await a.promise;
                    delete this.promiseCache[r], await a.parser?.unload?.(o, s, this);
                }
            });
            await Promise.all(n);
        }
        _validateParsers() {
            this._parsersValidated = !0, this._parserHash = this._parsers.filter((e)=>e.name).reduce((e, t)=>(t.name ? e[t.name] && tt(`[Assets] loadParser name conflict "${t.name}"`) : tt("[Assets] loadParser should have a name"), {
                    ...e,
                    [t.name]: t
                }), {});
        }
    }
    function sr(i, e) {
        if (Array.isArray(e)) {
            for (const t of e)if (i.startsWith(`data:${t}`)) return !0;
            return !1;
        }
        return i.startsWith(`data:${e}`);
    }
    function rr(i, e) {
        const t = i.split("?")[0], n = hn.extname(t).toLowerCase();
        return Array.isArray(e) ? e.includes(n) : n === e;
    }
    const ow = ".json", lw = "application/json", cw = {
        extension: {
            type: J.LoadParser,
            priority: Ci.Low
        },
        name: "loadJson",
        test (i) {
            return sr(i, lw) || rr(i, ow);
        },
        async load (i) {
            return await (await _t.get().fetch(i)).json();
        }
    }, hw = ".txt", uw = "text/plain", dw = {
        name: "loadTxt",
        extension: {
            type: J.LoadParser,
            priority: Ci.Low,
            name: "loadTxt"
        },
        test (i) {
            return sr(i, uw) || rr(i, hw);
        },
        async load (i) {
            return await (await _t.get().fetch(i)).text();
        }
    }, fw = [
        "normal",
        "bold",
        "100",
        "200",
        "300",
        "400",
        "500",
        "600",
        "700",
        "800",
        "900"
    ], pw = [
        ".ttf",
        ".otf",
        ".woff",
        ".woff2"
    ], mw = [
        "font/ttf",
        "font/otf",
        "font/woff",
        "font/woff2"
    ], _w = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
    function gw(i) {
        const e = hn.extname(i), s = hn.basename(i, e).replace(/(-|_)/g, " ").toLowerCase().split(" ").map((o)=>o.charAt(0).toUpperCase() + o.slice(1));
        let r = s.length > 0;
        for (const o of s)if (!o.match(_w)) {
            r = !1;
            break;
        }
        let a = s.join(" ");
        return r || (a = `"${a.replace(/[\\"]/g, "\\$&")}"`), a;
    }
    const xw = /^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;
    function vw(i) {
        return xw.test(i) ? i : encodeURI(i);
    }
    const yw = {
        extension: {
            type: J.LoadParser,
            priority: Ci.Low
        },
        name: "loadWebFont",
        test (i) {
            return sr(i, mw) || rr(i, pw);
        },
        async load (i, e) {
            const t = _t.get().getFontFaceSet();
            if (t) {
                const n = [], s = e.data?.family ?? gw(i), r = e.data?.weights?.filter((o)=>fw.includes(o)) ?? [
                    "normal"
                ], a = e.data ?? {};
                for(let o = 0; o < r.length; o++){
                    const l = r[o], h = new FontFace(s, `url(${vw(i)})`, {
                        ...a,
                        weight: l
                    });
                    await h.load(), t.add(h), n.push(h);
                }
                return Mt.set(`${s}-and-url`, {
                    url: i,
                    fontFaces: n
                }), n.length === 1 ? n[0] : n;
            }
            return tt("[loadWebFont] FontFace API is not supported. Skipping loading font"), null;
        },
        unload (i) {
            (Array.isArray(i) ? i : [
                i
            ]).forEach((e)=>{
                Mt.remove(`${e.family}-and-url`), _t.get().getFontFaceSet().delete(e);
            });
        }
    };
    function Xh(i, e = 1) {
        const t = nr.RETINA_PREFIX?.exec(i);
        return t ? parseFloat(t[1]) : e;
    }
    function Yh(i, e, t) {
        i.label = t, i._sourceOrigin = t;
        const n = new Ie({
            source: i,
            label: t
        }), s = ()=>{
            delete e.promiseCache[t], Mt.has(t) && Mt.remove(t);
        };
        return n.source.once("destroy", ()=>{
            e.promiseCache[t] && (tt("[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the TextureSource."), s());
        }), n.once("destroy", ()=>{
            i.destroyed || (tt("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture."), s());
        }), n;
    }
    const bw = ".svg", Sw = "image/svg+xml", Tw = {
        extension: {
            type: J.LoadParser,
            priority: Ci.Low,
            name: "loadSVG"
        },
        name: "loadSVG",
        config: {
            crossOrigin: "anonymous",
            parseAsGraphicsContext: !1
        },
        test (i) {
            return sr(i, Sw) || rr(i, bw);
        },
        async load (i, e, t) {
            return e.data?.parseAsGraphicsContext ?? this.config.parseAsGraphicsContext ? Aw(i) : Mw(i, e, t, this.config.crossOrigin);
        },
        unload (i) {
            i.destroy(!0);
        }
    };
    async function Mw(i, e, t, n) {
        const r = await (await _t.get().fetch(i)).blob(), a = URL.createObjectURL(r), o = new Image;
        o.src = a, o.crossOrigin = n, await o.decode(), URL.revokeObjectURL(a);
        const l = document.createElement("canvas"), h = l.getContext("2d"), d = e.data?.resolution || Xh(i), c = e.data?.width ?? o.width, u = e.data?.height ?? o.height;
        l.width = c * d, l.height = u * d, h.drawImage(o, 0, 0, c * d, u * d);
        const { parseAsGraphicsContext: f, ..._ } = e.data ?? {}, g = new ts({
            resource: l,
            alphaMode: "premultiply-alpha-on-upload",
            resolution: d,
            ..._
        });
        return Yh(g, t, i);
    }
    async function Aw(i) {
        const t = await (await _t.get().fetch(i)).text(), n = new _n;
        return n.svg(t), n;
    }
    const Ew = `(function () {
    'use strict';

    const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
    async function checkImageBitmap() {
      try {
        if (typeof createImageBitmap !== "function")
          return false;
        const response = await fetch(WHITE_PNG);
        const imageBlob = await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);
        return imageBitmap.width === 1 && imageBitmap.height === 1;
      } catch (_e) {
        return false;
      }
    }
    void checkImageBitmap().then((result) => {
      self.postMessage(result);
    });

})();
`;
    let Bs = null, Kc = class {
        constructor(){
            Bs || (Bs = URL.createObjectURL(new Blob([
                Ew
            ], {
                type: "application/javascript"
            }))), this.worker = new Worker(Bs);
        }
    };
    Kc.revokeObjectURL = function() {
        Bs && (URL.revokeObjectURL(Bs), Bs = null);
    };
    const ww = `(function () {
    'use strict';

    async function loadImageBitmap(url, alphaMode) {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \${response.status} \${response.statusText}\`);
      }
      const imageBlob = await response.blob();
      return alphaMode === "premultiplied-alpha" ? createImageBitmap(imageBlob, { premultiplyAlpha: "none" }) : createImageBitmap(imageBlob);
    }
    self.onmessage = async (event) => {
      try {
        const imageBitmap = await loadImageBitmap(event.data.data[0], event.data.data[1]);
        self.postMessage({
          data: imageBitmap,
          uuid: event.data.uuid,
          id: event.data.id
        }, [imageBitmap]);
      } catch (e) {
        self.postMessage({
          error: e,
          uuid: event.data.uuid,
          id: event.data.id
        });
      }
    };

})();
`;
    let Us = null;
    class n_ {
        constructor(){
            Us || (Us = URL.createObjectURL(new Blob([
                ww
            ], {
                type: "application/javascript"
            }))), this.worker = new Worker(Us);
        }
    }
    n_.revokeObjectURL = function() {
        Us && (URL.revokeObjectURL(Us), Us = null);
    };
    let Bf = 0, Ll;
    class Rw {
        constructor(){
            this._initialized = !1, this._createdWorkers = 0, this._workerPool = [], this._queue = [], this._resolveHash = {};
        }
        isImageBitmapSupported() {
            return this._isImageBitmapSupported !== void 0 ? this._isImageBitmapSupported : (this._isImageBitmapSupported = new Promise((e)=>{
                const { worker: t } = new Kc;
                t.addEventListener("message", (n)=>{
                    t.terminate(), Kc.revokeObjectURL(), e(n.data);
                });
            }), this._isImageBitmapSupported);
        }
        loadImageBitmap(e, t) {
            return this._run("loadImageBitmap", [
                e,
                t?.data?.alphaMode
            ]);
        }
        async _initWorkers() {
            this._initialized || (this._initialized = !0);
        }
        _getWorker() {
            Ll === void 0 && (Ll = navigator.hardwareConcurrency || 4);
            let e = this._workerPool.pop();
            return !e && this._createdWorkers < Ll && (this._createdWorkers++, e = new n_().worker, e.addEventListener("message", (t)=>{
                this._complete(t.data), this._returnWorker(t.target), this._next();
            })), e;
        }
        _returnWorker(e) {
            this._workerPool.push(e);
        }
        _complete(e) {
            e.error !== void 0 ? this._resolveHash[e.uuid].reject(e.error) : this._resolveHash[e.uuid].resolve(e.data), this._resolveHash[e.uuid] = null;
        }
        async _run(e, t) {
            await this._initWorkers();
            const n = new Promise((s, r)=>{
                this._queue.push({
                    id: e,
                    arguments: t,
                    resolve: s,
                    reject: r
                });
            });
            return this._next(), n;
        }
        _next() {
            if (!this._queue.length) return;
            const e = this._getWorker();
            if (!e) return;
            const t = this._queue.pop(), n = t.id;
            this._resolveHash[Bf] = {
                resolve: t.resolve,
                reject: t.reject
            }, e.postMessage({
                data: t.arguments,
                uuid: Bf++,
                id: n
            });
        }
    }
    const Uf = new Rw, Cw = [
        ".jpeg",
        ".jpg",
        ".png",
        ".webp",
        ".avif"
    ], Pw = [
        "image/jpeg",
        "image/png",
        "image/webp",
        "image/avif"
    ];
    async function Iw(i, e) {
        const t = await _t.get().fetch(i);
        if (!t.ok) throw new Error(`[loadImageBitmap] Failed to fetch ${i}: ${t.status} ${t.statusText}`);
        const n = await t.blob();
        return e?.data?.alphaMode === "premultiplied-alpha" ? createImageBitmap(n, {
            premultiplyAlpha: "none"
        }) : createImageBitmap(n);
    }
    const i_ = {
        name: "loadTextures",
        extension: {
            type: J.LoadParser,
            priority: Ci.High,
            name: "loadTextures"
        },
        config: {
            preferWorkers: !0,
            preferCreateImageBitmap: !0,
            crossOrigin: "anonymous"
        },
        test (i) {
            return sr(i, Pw) || rr(i, Cw);
        },
        async load (i, e, t) {
            let n = null;
            globalThis.createImageBitmap && this.config.preferCreateImageBitmap ? this.config.preferWorkers && await Uf.isImageBitmapSupported() ? n = await Uf.loadImageBitmap(i, e) : n = await Iw(i, e) : n = await new Promise((r, a)=>{
                n = new Image, n.crossOrigin = this.config.crossOrigin, n.src = i, n.complete ? r(n) : (n.onload = ()=>{
                    r(n);
                }, n.onerror = a);
            });
            const s = new ts({
                resource: n,
                alphaMode: "premultiply-alpha-on-upload",
                resolution: e.data?.resolution || Xh(i),
                ...e.data
            });
            return Yh(s, t, i);
        },
        unload (i) {
            i.destroy(!0);
        }
    }, s_ = [
        ".mp4",
        ".m4v",
        ".webm",
        ".ogg",
        ".ogv",
        ".h264",
        ".avi",
        ".mov"
    ], Dw = s_.map((i)=>`video/${i.substring(1)}`);
    function Lw(i, e, t) {
        t === void 0 && !e.startsWith("data:") ? i.crossOrigin = Uw(e) : t !== !1 && (i.crossOrigin = typeof t == "string" ? t : "anonymous");
    }
    function Bw(i) {
        return new Promise((e, t)=>{
            i.addEventListener("canplaythrough", n), i.addEventListener("error", s), i.load();
            function n() {
                r(), e();
            }
            function s(a) {
                r(), t(a);
            }
            function r() {
                i.removeEventListener("canplaythrough", n), i.removeEventListener("error", s);
            }
        });
    }
    function Uw(i, e = globalThis.location) {
        if (i.startsWith("data:")) return "";
        e || (e = globalThis.location);
        const t = new URL(i, document.baseURI);
        return t.hostname !== e.hostname || t.port !== e.port || t.protocol !== e.protocol ? "anonymous" : "";
    }
    const Fw = {
        name: "loadVideo",
        extension: {
            type: J.LoadParser,
            name: "loadVideo"
        },
        test (i) {
            const e = sr(i, Dw), t = rr(i, s_);
            return e || t;
        },
        async load (i, e, t) {
            const n = {
                ...qa.defaultOptions,
                resolution: e.data?.resolution || Xh(i),
                alphaMode: e.data?.alphaMode || await hm(),
                ...e.data
            }, s = document.createElement("video"), r = {
                preload: n.autoLoad !== !1 ? "auto" : void 0,
                "webkit-playsinline": n.playsinline !== !1 ? "" : void 0,
                playsinline: n.playsinline !== !1 ? "" : void 0,
                muted: n.muted === !0 ? "" : void 0,
                loop: n.loop === !0 ? "" : void 0,
                autoplay: n.autoPlay !== !1 ? "" : void 0
            };
            Object.keys(r).forEach((l)=>{
                const h = r[l];
                h !== void 0 && s.setAttribute(l, h);
            }), n.muted === !0 && (s.muted = !0), Lw(s, i, n.crossorigin);
            const a = document.createElement("source");
            let o;
            if (i.startsWith("data:")) o = i.slice(5, i.indexOf(";"));
            else if (!i.startsWith("blob:")) {
                const l = i.split("?")[0].slice(i.lastIndexOf(".") + 1).toLowerCase();
                o = qa.MIME_TYPES[l] || `video/${l}`;
            }
            return a.src = i, o && (a.type = o), new Promise((l)=>{
                const h = async ()=>{
                    const d = new qa({
                        ...n,
                        resource: s
                    });
                    s.removeEventListener("canplay", h), e.data.preload && await Bw(s), l(Yh(d, t, i));
                };
                s.addEventListener("canplay", h), s.appendChild(a);
            });
        },
        unload (i) {
            i.destroy(!0);
        }
    }, r_ = {
        extension: {
            type: J.ResolveParser,
            name: "resolveTexture"
        },
        test: i_.test,
        parse: (i)=>({
                resolution: parseFloat(nr.RETINA_PREFIX.exec(i)?.[1] ?? "1"),
                format: i.split(".").pop(),
                src: i
            })
    }, Nw = {
        extension: {
            type: J.ResolveParser,
            priority: -2,
            name: "resolveJson"
        },
        test: (i)=>nr.RETINA_PREFIX.test(i) && i.endsWith(".json"),
        parse: r_.parse
    };
    class Ow {
        constructor(){
            this._detections = [], this._initialized = !1, this.resolver = new nr, this.loader = new aw, this.cache = Mt, this._backgroundLoader = new ZE(this.loader), this._backgroundLoader.active = !0, this.reset();
        }
        async init(e = {}) {
            if (this._initialized) {
                tt("[Assets]AssetManager already initialized, did you load before calling this Assets.init()?");
                return;
            }
            if (this._initialized = !0, e.defaultSearchParams && this.resolver.setDefaultSearchParams(e.defaultSearchParams), e.basePath && (this.resolver.basePath = e.basePath), e.bundleIdentifier && this.resolver.setBundleIdentifier(e.bundleIdentifier), e.manifest) {
                let r = e.manifest;
                typeof r == "string" && (r = await this.load(r)), this.resolver.addManifest(r);
            }
            const t = e.texturePreference?.resolution ?? 1, n = typeof t == "number" ? [
                t
            ] : t, s = await this._detectFormats({
                preferredFormats: e.texturePreference?.format,
                skipDetections: e.skipDetections,
                detections: this._detections
            });
            this.resolver.prefer({
                params: {
                    format: s,
                    resolution: n
                }
            }), e.preferences && this.setPreferences(e.preferences);
        }
        add(e) {
            this.resolver.add(e);
        }
        async load(e, t) {
            this._initialized || await this.init();
            const n = lo(e), s = Cn(e).map((o)=>{
                if (typeof o != "string") {
                    const l = this.resolver.getAlias(o);
                    return l.some((h)=>!this.resolver.hasKey(h)) && this.add(o), Array.isArray(l) ? l[0] : l;
                }
                return this.resolver.hasKey(o) || this.add({
                    alias: o,
                    src: o
                }), o;
            }), r = this.resolver.resolve(s), a = await this._mapLoadToResolve(r, t);
            return n ? a[s[0]] : a;
        }
        addBundle(e, t) {
            this.resolver.addBundle(e, t);
        }
        async loadBundle(e, t) {
            this._initialized || await this.init();
            let n = !1;
            typeof e == "string" && (n = !0, e = [
                e
            ]);
            const s = this.resolver.resolveBundle(e), r = {}, a = Object.keys(s);
            let o = 0, l = 0;
            const h = ()=>{
                t?.(++o / l);
            }, d = a.map((c)=>{
                const u = s[c];
                return l += Object.keys(u).length, this._mapLoadToResolve(u, h).then((f)=>{
                    r[c] = f;
                });
            });
            return await Promise.all(d), n ? r[e[0]] : r;
        }
        async backgroundLoad(e) {
            this._initialized || await this.init(), typeof e == "string" && (e = [
                e
            ]);
            const t = this.resolver.resolve(e);
            this._backgroundLoader.add(Object.values(t));
        }
        async backgroundLoadBundle(e) {
            this._initialized || await this.init(), typeof e == "string" && (e = [
                e
            ]);
            const t = this.resolver.resolveBundle(e);
            Object.values(t).forEach((n)=>{
                this._backgroundLoader.add(Object.values(n));
            });
        }
        reset() {
            this.resolver.reset(), this.loader.reset(), this.cache.reset(), this._initialized = !1;
        }
        get(e) {
            if (typeof e == "string") return Mt.get(e);
            const t = {};
            for(let n = 0; n < e.length; n++)t[n] = Mt.get(e[n]);
            return t;
        }
        async _mapLoadToResolve(e, t) {
            const n = [
                ...new Set(Object.values(e))
            ];
            this._backgroundLoader.active = !1;
            const s = await this.loader.load(n, t);
            this._backgroundLoader.active = !0;
            const r = {};
            return n.forEach((a)=>{
                const o = s[a.src], l = [
                    a.src
                ];
                a.alias && l.push(...a.alias), l.forEach((h)=>{
                    r[h] = o;
                }), Mt.set(l, o);
            }), r;
        }
        async unload(e) {
            this._initialized || await this.init();
            const t = Cn(e).map((s)=>typeof s != "string" ? s.src : s), n = this.resolver.resolve(t);
            await this._unloadFromResolved(n);
        }
        async unloadBundle(e) {
            this._initialized || await this.init(), e = Cn(e);
            const t = this.resolver.resolveBundle(e), n = Object.keys(t).map((s)=>this._unloadFromResolved(t[s]));
            await Promise.all(n);
        }
        async _unloadFromResolved(e) {
            const t = Object.values(e);
            t.forEach((n)=>{
                Mt.remove(n.src);
            }), await this.loader.unload(t);
        }
        async _detectFormats(e) {
            let t = [];
            e.preferredFormats && (t = Array.isArray(e.preferredFormats) ? e.preferredFormats : [
                e.preferredFormats
            ]);
            for (const n of e.detections)e.skipDetections || await n.test() ? t = await n.add(t) : e.skipDetections || (t = await n.remove(t));
            return t = t.filter((n, s)=>t.indexOf(n) === s), t;
        }
        get detections() {
            return this._detections;
        }
        setPreferences(e) {
            this.loader.parsers.forEach((t)=>{
                t.config && Object.keys(t.config).filter((n)=>n in e).forEach((n)=>{
                    t.config[n] = e[n];
                });
            });
        }
    }
    const Rr = new Ow;
    At.handleByList(J.LoadParser, Rr.loader.parsers).handleByList(J.ResolveParser, Rr.resolver.parsers).handleByList(J.CacheParser, Rr.cache.parsers).handleByList(J.DetectionParser, Rr.detections);
    At.add(JE, ew, QE, rw, nw, iw, sw, cw, dw, yw, Tw, i_, Fw, KE, $E, r_, Nw);
    const Ff = {
        loader: J.LoadParser,
        resolver: J.ResolveParser,
        cache: J.CacheParser,
        detection: J.DetectionParser
    };
    At.handle(J.Asset, (i)=>{
        const e = i.ref;
        Object.entries(Ff).filter(([t])=>!!e[t]).forEach(([t, n])=>At.add(Object.assign(e[t], {
                extension: e[t].extension ?? n
            })));
    }, (i)=>{
        const e = i.ref;
        Object.keys(Ff).filter((t)=>!!e[t]).forEach((t)=>At.remove(e[t]));
    });
    var kw = `in vec2 vMaskCoord;
in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform sampler2D uMaskTexture;

uniform float uAlpha;
uniform vec4 uMaskClamp;
uniform float uInverse;

out vec4 finalColor;

void main(void)
{
    float clip = step(3.5,
        step(uMaskClamp.x, vMaskCoord.x) +
        step(uMaskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, uMaskClamp.z) +
        step(vMaskCoord.y, uMaskClamp.w));

    // TODO look into why this is needed
    float npmAlpha = uAlpha;
    vec4 original = texture(uTexture, vTextureCoord);
    vec4 masky = texture(uMaskTexture, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    float a = alphaMul * masky.r * npmAlpha * clip;

    if (uInverse == 1.0) {
        a = 1.0 - a;
    }

    finalColor = original * a;
}
`, Gw = `in vec2 aPosition;

out vec2 vTextureCoord;
out vec2 vMaskCoord;


uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;
uniform mat3 uFilterMatrix;

vec4 filterVertexPosition(  vec2 aPosition )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
       
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord(  vec2 aPosition )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

vec2 getFilterCoord( vec2 aPosition )
{
    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}   

void main(void)
{
    gl_Position = filterVertexPosition(aPosition);
    vTextureCoord = filterTextureCoord(aPosition);
    vMaskCoord = getFilterCoord(aPosition);
}
`, Nf = `struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct MaskUniforms {
  uFilterMatrix:mat3x3<f32>,
  uMaskClamp:vec4<f32>,
  uAlpha:f32,
  uInverse:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;
@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) filterUv : vec2<f32>,
};

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);
}

fn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>
{
  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}

@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>,
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition),
   getFilterCoord(aPosition)
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) filterUv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {

    var maskClamp = filterUniforms.uMaskClamp;
    var uAlpha = filterUniforms.uAlpha;

    var clip = step(3.5,
      step(maskClamp.x, filterUv.x) +
      step(maskClamp.y, filterUv.y) +
      step(filterUv.x, maskClamp.z) +
      step(filterUv.y, maskClamp.w));

    var mask = textureSample(uMaskTexture, uSampler, filterUv);
    var source = textureSample(uTexture, uSampler, uv);
    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);

    var a: f32 = alphaMul * mask.r * uAlpha * clip;

    if (filterUniforms.uInverse == 1.0) {
        a = 1.0 - a;
    }

    return source * a;
}
`;
    class Hw extends YM {
        constructor(e){
            const { sprite: t, ...n } = e, s = new qp(t.texture), r = new rs({
                uFilterMatrix: {
                    value: new Ne,
                    type: "mat3x3<f32>"
                },
                uMaskClamp: {
                    value: s.uClampFrame,
                    type: "vec4<f32>"
                },
                uAlpha: {
                    value: 1,
                    type: "f32"
                },
                uInverse: {
                    value: e.inverse ? 1 : 0,
                    type: "f32"
                }
            }), a = ir.from({
                vertex: {
                    source: Nf,
                    entryPoint: "mainVertex"
                },
                fragment: {
                    source: Nf,
                    entryPoint: "mainFragment"
                }
            }), o = $r.from({
                vertex: Gw,
                fragment: kw,
                name: "mask-filter"
            });
            super({
                ...n,
                gpuProgram: a,
                glProgram: o,
                resources: {
                    filterUniforms: r,
                    uMaskTexture: t.texture.source
                }
            }), this.sprite = t, this._textureMatrix = s;
        }
        set inverse(e) {
            this.resources.filterUniforms.uniforms.uInverse = e ? 1 : 0;
        }
        get inverse() {
            return this.resources.filterUniforms.uniforms.uInverse === 1;
        }
        apply(e, t, n, s) {
            this._textureMatrix.texture = this.sprite.texture, e.calculateSpriteMatrix(this.resources.filterUniforms.uniforms.uFilterMatrix, this.sprite).prepend(this._textureMatrix.mapCoord), this.resources.uMaskTexture = this.sprite.texture.source, e.applyFilter(this, t, n, s);
        }
    }
    oi = class extends Dh {
        constructor(e){
            e instanceof _n && (e = {
                context: e
            });
            const { context: t, roundPixels: n, ...s } = e || {};
            super({
                label: "Graphics",
                ...s
            }), this.renderPipeId = "graphics", t ? this._context = t : this._context = this._ownedContext = new _n, this._context.on("update", this.onViewUpdate, this), this.allowChildren = !1, this.roundPixels = n ?? !1;
        }
        set context(e) {
            e !== this._context && (this._context.off("update", this.onViewUpdate, this), this._context = e, this._context.on("update", this.onViewUpdate, this), this.onViewUpdate());
        }
        get context() {
            return this._context;
        }
        get bounds() {
            return this._context.bounds;
        }
        updateBounds() {}
        containsPoint(e) {
            return this._context.containsPoint(e);
        }
        destroy(e) {
            this._ownedContext && !e ? this._ownedContext.destroy(e) : (e === !0 || e?.context === !0) && this._context.destroy(e), this._ownedContext = null, this._context = null, super.destroy(e);
        }
        _callContextMethod(e, t) {
            return this.context[e](...t), this;
        }
        setFillStyle(...e) {
            return this._callContextMethod("setFillStyle", e);
        }
        setStrokeStyle(...e) {
            return this._callContextMethod("setStrokeStyle", e);
        }
        fill(...e) {
            return this._callContextMethod("fill", e);
        }
        stroke(...e) {
            return this._callContextMethod("stroke", e);
        }
        texture(...e) {
            return this._callContextMethod("texture", e);
        }
        beginPath() {
            return this._callContextMethod("beginPath", []);
        }
        cut() {
            return this._callContextMethod("cut", []);
        }
        arc(...e) {
            return this._callContextMethod("arc", e);
        }
        arcTo(...e) {
            return this._callContextMethod("arcTo", e);
        }
        arcToSvg(...e) {
            return this._callContextMethod("arcToSvg", e);
        }
        bezierCurveTo(...e) {
            return this._callContextMethod("bezierCurveTo", e);
        }
        closePath() {
            return this._callContextMethod("closePath", []);
        }
        ellipse(...e) {
            return this._callContextMethod("ellipse", e);
        }
        circle(...e) {
            return this._callContextMethod("circle", e);
        }
        path(...e) {
            return this._callContextMethod("path", e);
        }
        lineTo(...e) {
            return this._callContextMethod("lineTo", e);
        }
        moveTo(...e) {
            return this._callContextMethod("moveTo", e);
        }
        quadraticCurveTo(...e) {
            return this._callContextMethod("quadraticCurveTo", e);
        }
        rect(...e) {
            return this._callContextMethod("rect", e);
        }
        roundRect(...e) {
            return this._callContextMethod("roundRect", e);
        }
        poly(...e) {
            return this._callContextMethod("poly", e);
        }
        regularPoly(...e) {
            return this._callContextMethod("regularPoly", e);
        }
        roundPoly(...e) {
            return this._callContextMethod("roundPoly", e);
        }
        roundShape(...e) {
            return this._callContextMethod("roundShape", e);
        }
        filletRect(...e) {
            return this._callContextMethod("filletRect", e);
        }
        chamferRect(...e) {
            return this._callContextMethod("chamferRect", e);
        }
        star(...e) {
            return this._callContextMethod("star", e);
        }
        svg(...e) {
            return this._callContextMethod("svg", e);
        }
        restore(...e) {
            return this._callContextMethod("restore", e);
        }
        save() {
            return this._callContextMethod("save", []);
        }
        getTransform() {
            return this.context.getTransform();
        }
        resetTransform() {
            return this._callContextMethod("resetTransform", []);
        }
        rotateTransform(...e) {
            return this._callContextMethod("rotate", e);
        }
        scaleTransform(...e) {
            return this._callContextMethod("scale", e);
        }
        setTransform(...e) {
            return this._callContextMethod("setTransform", e);
        }
        transform(...e) {
            return this._callContextMethod("transform", e);
        }
        translateTransform(...e) {
            return this._callContextMethod("translate", e);
        }
        clear() {
            return this._callContextMethod("clear", []);
        }
        get fillStyle() {
            return this._context.fillStyle;
        }
        set fillStyle(e) {
            this._context.fillStyle = e;
        }
        get strokeStyle() {
            return this._context.strokeStyle;
        }
        set strokeStyle(e) {
            this._context.strokeStyle = e;
        }
        clone(e = !1) {
            return e ? new oi(this._context.clone()) : (this._ownedContext = null, new oi(this._context));
        }
        lineStyle(e, t, n) {
            et(dt, "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");
            const s = {};
            return e && (s.width = e), t && (s.color = t), n && (s.alpha = n), this.context.strokeStyle = s, this;
        }
        beginFill(e, t) {
            et(dt, "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
            const n = {};
            return e !== void 0 && (n.color = e), t !== void 0 && (n.alpha = t), this.context.fillStyle = n, this;
        }
        endFill() {
            et(dt, "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."), this.context.fill();
            const e = this.context.strokeStyle;
            return (e.width !== _n.defaultStrokeStyle.width || e.color !== _n.defaultStrokeStyle.color || e.alpha !== _n.defaultStrokeStyle.alpha) && this.context.stroke(), this;
        }
        drawCircle(...e) {
            return et(dt, "Graphics#drawCircle has been renamed to Graphics#circle"), this._callContextMethod("circle", e);
        }
        drawEllipse(...e) {
            return et(dt, "Graphics#drawEllipse has been renamed to Graphics#ellipse"), this._callContextMethod("ellipse", e);
        }
        drawPolygon(...e) {
            return et(dt, "Graphics#drawPolygon has been renamed to Graphics#poly"), this._callContextMethod("poly", e);
        }
        drawRect(...e) {
            return et(dt, "Graphics#drawRect has been renamed to Graphics#rect"), this._callContextMethod("rect", e);
        }
        drawRoundedRect(...e) {
            return et(dt, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect"), this._callContextMethod("roundRect", e);
        }
        drawStar(...e) {
            return et(dt, "Graphics#drawStar has been renamed to Graphics#star"), this._callContextMethod("star", e);
        }
    };
    class zw extends Dh {
        constructor(e, t){
            const { text: n, resolution: s, style: r, anchor: a, width: o, height: l, roundPixels: h, ...d } = e;
            super({
                ...d
            }), this.batched = !0, this._resolution = null, this._autoResolution = !0, this._didTextUpdate = !0, this._styleClass = t, this.text = n ?? "", this.style = r, this.resolution = s ?? null, this.allowChildren = !1, this._anchor = new en({
                _onUpdate: ()=>{
                    this.onViewUpdate();
                }
            }), a && (this.anchor = a), this.roundPixels = h ?? !1, o !== void 0 && (this.width = o), l !== void 0 && (this.height = l);
        }
        get anchor() {
            return this._anchor;
        }
        set anchor(e) {
            typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e);
        }
        set text(e) {
            e = e.toString(), this._text !== e && (this._text = e, this.onViewUpdate());
        }
        get text() {
            return this._text;
        }
        set resolution(e) {
            this._autoResolution = e === null, this._resolution = e, this.onViewUpdate();
        }
        get resolution() {
            return this._resolution;
        }
        get style() {
            return this._style;
        }
        set style(e) {
            e || (e = {}), this._style?.off("update", this.onViewUpdate, this), e instanceof this._styleClass ? this._style = e : this._style = new this._styleClass(e), this._style.on("update", this.onViewUpdate, this), this.onViewUpdate();
        }
        get width() {
            return Math.abs(this.scale.x) * this.bounds.width;
        }
        set width(e) {
            this._setWidth(e, this.bounds.width);
        }
        get height() {
            return Math.abs(this.scale.y) * this.bounds.height;
        }
        set height(e) {
            this._setHeight(e, this.bounds.height);
        }
        getSize(e) {
            return e || (e = {}), e.width = Math.abs(this.scale.x) * this.bounds.width, e.height = Math.abs(this.scale.y) * this.bounds.height, e;
        }
        setSize(e, t) {
            typeof e == "object" ? (t = e.height ?? e.width, e = e.width) : t ?? (t = e), e !== void 0 && this._setWidth(e, this.bounds.width), t !== void 0 && this._setHeight(t, this.bounds.height);
        }
        containsPoint(e) {
            const t = this.bounds.width, n = this.bounds.height, s = -t * this.anchor.x;
            let r = 0;
            return e.x >= s && e.x <= s + t && (r = -n * this.anchor.y, e.y >= r && e.y <= r + n);
        }
        onViewUpdate() {
            this.didViewUpdate || (this._didTextUpdate = !0), super.onViewUpdate();
        }
        _getKey() {
            return `${this.text}:${this._style.styleKey}:${this._resolution}`;
        }
        destroy(e = !1) {
            super.destroy(e), this.owner = null, this._bounds = null, this._anchor = null, (typeof e == "boolean" ? e : e?.style) && this._style.destroy(e), this._style = null, this._text = null;
        }
    }
    function Vw(i, e) {
        let t = i[0] ?? {};
        return (typeof t == "string" || i[1]) && (et(dt, `use new ${e}({ text: "hi!", style }) instead`), t = {
            text: t,
            style: i[1]
        }), t;
    }
    class xi extends zw {
        constructor(...e){
            const t = Vw(e, "Text");
            super(t, $s), this.renderPipeId = "text";
        }
        updateBounds() {
            const e = this._bounds, t = this._anchor, n = $c.measureText(this._text, this._style), { width: s, height: r } = n;
            e.minX = -t._x * s, e.maxX = e.minX + s, e.minY = -t._y * r, e.maxY = e.minY + r;
        }
    }
    class a_ {
        constructor(){
            this._tempState = Kr.for2d(), this._didUploadHash = {};
        }
        init(e) {
            e.renderer.runners.contextChange.add(this);
        }
        contextChange() {
            this._didUploadHash = {};
        }
        start(e, t, n) {
            const s = e.renderer, r = this._didUploadHash[n.uid];
            s.shader.bind(n, r), r || (this._didUploadHash[n.uid] = !0), s.shader.updateUniformGroup(s.globalUniforms.uniformGroup), s.geometry.bind(t, n.glProgram);
        }
        execute(e, t) {
            const n = e.renderer;
            this._tempState.blendMode = t.blendMode, n.state.set(this._tempState);
            const s = t.textures.textures;
            for(let r = 0; r < t.textures.count; r++)n.texture.bind(s[r], r);
            n.geometry.draw(t.topology, t.size, t.start);
        }
    }
    a_.extension = {
        type: [
            J.WebGLPipesAdaptor
        ],
        name: "batch"
    };
    const jh = class o_ {
        constructor(e, t){
            this.state = Kr.for2d(), this._batchersByInstructionSet = Object.create(null), this._activeBatches = Object.create(null), this.renderer = e, this._adaptor = t, this._adaptor.init?.(this);
        }
        static getBatcher(e) {
            return new this._availableBatchers[e];
        }
        buildStart(e) {
            let t = this._batchersByInstructionSet[e.uid];
            t || (t = this._batchersByInstructionSet[e.uid] = Object.create(null), t.default || (t.default = new Gh)), this._activeBatches = t, this._activeBatch = this._activeBatches.default;
            for(const n in this._activeBatches)this._activeBatches[n].begin();
        }
        addToBatch(e, t) {
            if (this._activeBatch.name !== e.batcherName) {
                this._activeBatch.break(t);
                let n = this._activeBatches[e.batcherName];
                n || (n = this._activeBatches[e.batcherName] = o_.getBatcher(e.batcherName), n.begin()), this._activeBatch = n;
            }
            this._activeBatch.add(e);
        }
        break(e) {
            this._activeBatch.break(e);
        }
        buildEnd(e) {
            this._activeBatch.break(e);
            const t = this._activeBatches;
            for(const n in t){
                const s = t[n], r = s.geometry;
                r.indexBuffer.setDataWithSize(s.indexBuffer, s.indexSize, !0), r.buffers[0].setDataWithSize(s.attributeBuffer.float32View, s.attributeSize, !1);
            }
        }
        upload(e) {
            const t = this._batchersByInstructionSet[e.uid];
            for(const n in t){
                const s = t[n], r = s.geometry;
                s.dirty && (s.dirty = !1, r.buffers[0].update(s.attributeSize * 4));
            }
        }
        execute(e) {
            if (e.action === "startBatch") {
                const t = e.batcher, n = t.geometry, s = t.shader;
                this._adaptor.start(this, n, s);
            }
            this._adaptor.execute(this, e);
        }
        destroy() {
            this.state = null, this.renderer = null, this._adaptor = null;
            for(const e in this._activeBatches)this._activeBatches[e].destroy();
            this._activeBatches = null;
        }
    };
    jh.extension = {
        type: [
            J.WebGLPipes,
            J.WebGPUPipes,
            J.CanvasPipes
        ],
        name: "batch"
    };
    jh._availableBatchers = Object.create(null);
    let l_ = jh;
    At.handleByMap(J.Batcher, l_._availableBatchers);
    At.add(Gh);
    Bl = {
        name: "local-uniform-bit",
        vertex: {
            header: `

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,
            main: `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,
            end: `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
        }
    };
    ({
        ...Bl,
        vertex: {
            ...Bl.vertex,
            header: Bl.vertex.header.replace("group(1)", "group(2)")
        }
    });
    let Ww, Xw;
    c_ = {
        name: "local-uniform-bit",
        vertex: {
            header: `

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,
            main: `
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `,
            end: `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
        }
    };
    Ww = {
        name: "texture-bit",
        vertex: {
            header: `
            uniform mat3 uTextureMatrix;
        `,
            main: `
            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;
        `
        },
        fragment: {
            header: `
        uniform sampler2D uTexture;

         
        `,
            main: `
            outColor = texture(uTexture, vUV);
        `
        }
    };
    Xw = new sn;
    class Yw extends ro {
        constructor(){
            super(), this.filters = [
                new Hw({
                    sprite: new es(Ie.EMPTY),
                    inverse: !1,
                    resolution: "inherit",
                    antialias: "inherit"
                })
            ];
        }
        get sprite() {
            return this.filters[0].sprite;
        }
        set sprite(e) {
            this.filters[0].sprite = e;
        }
        get inverse() {
            return this.filters[0].inverse;
        }
        set inverse(e) {
            this.filters[0].inverse = e;
        }
    }
    class h_ {
        constructor(e){
            this._activeMaskStage = [], this._renderer = e;
        }
        push(e, t, n) {
            const s = this._renderer;
            if (s.renderPipes.batch.break(n), n.add({
                renderPipeId: "alphaMask",
                action: "pushMaskBegin",
                mask: e,
                inverse: t._maskOptions.inverse,
                canBundle: !1,
                maskedContainer: t
            }), e.inverse = t._maskOptions.inverse, e.renderMaskToTexture) {
                const r = e.mask;
                r.includeInBuild = !0, r.collectRenderables(n, s, null), r.includeInBuild = !1;
            }
            s.renderPipes.batch.break(n), n.add({
                renderPipeId: "alphaMask",
                action: "pushMaskEnd",
                mask: e,
                maskedContainer: t,
                inverse: t._maskOptions.inverse,
                canBundle: !1
            });
        }
        pop(e, t, n) {
            this._renderer.renderPipes.batch.break(n), n.add({
                renderPipeId: "alphaMask",
                action: "popMaskEnd",
                mask: e,
                inverse: t._maskOptions.inverse,
                canBundle: !1
            });
        }
        execute(e) {
            const t = this._renderer, n = e.mask.renderMaskToTexture;
            if (e.action === "pushMaskBegin") {
                const s = Vt.get(Yw);
                if (s.inverse = e.inverse, n) {
                    e.mask.mask.measurable = !0;
                    const r = Rh(e.mask.mask, !0, Xw);
                    e.mask.mask.measurable = !1, r.ceil();
                    const a = t.renderTarget.renderTarget.colorTexture.source, o = Ls.getOptimalTexture(r.width, r.height, a._resolution, a.antialias);
                    t.renderTarget.push(o, !0), t.globalUniforms.push({
                        offset: r,
                        worldColor: 4294967295
                    });
                    const l = s.sprite;
                    l.texture = o, l.worldTransform.tx = r.minX, l.worldTransform.ty = r.minY, this._activeMaskStage.push({
                        filterEffect: s,
                        maskedContainer: e.maskedContainer,
                        filterTexture: o
                    });
                } else s.sprite = e.mask.mask, this._activeMaskStage.push({
                    filterEffect: s,
                    maskedContainer: e.maskedContainer
                });
            } else if (e.action === "pushMaskEnd") {
                const s = this._activeMaskStage[this._activeMaskStage.length - 1];
                n && (t.type === ns.WEBGL && t.renderTarget.finishRenderPass(), t.renderTarget.pop(), t.globalUniforms.pop()), t.filter.push({
                    renderPipeId: "filter",
                    action: "pushFilter",
                    container: s.maskedContainer,
                    filterEffect: s.filterEffect,
                    canBundle: !1
                });
            } else if (e.action === "popMaskEnd") {
                t.filter.pop();
                const s = this._activeMaskStage.pop();
                n && Ls.returnTexture(s.filterTexture), Vt.return(s.filterEffect);
            }
        }
        destroy() {
            this._renderer = null, this._activeMaskStage = null;
        }
    }
    h_.extension = {
        type: [
            J.WebGLPipes,
            J.WebGPUPipes,
            J.CanvasPipes
        ],
        name: "alphaMask"
    };
    class u_ {
        constructor(e){
            this._colorStack = [], this._colorStackIndex = 0, this._currentColor = 0, this._renderer = e;
        }
        buildStart() {
            this._colorStack[0] = 15, this._colorStackIndex = 1, this._currentColor = 15;
        }
        push(e, t, n) {
            this._renderer.renderPipes.batch.break(n);
            const r = this._colorStack;
            r[this._colorStackIndex] = r[this._colorStackIndex - 1] & e.mask;
            const a = this._colorStack[this._colorStackIndex];
            a !== this._currentColor && (this._currentColor = a, n.add({
                renderPipeId: "colorMask",
                colorMask: a,
                canBundle: !1
            })), this._colorStackIndex++;
        }
        pop(e, t, n) {
            this._renderer.renderPipes.batch.break(n);
            const r = this._colorStack;
            this._colorStackIndex--;
            const a = r[this._colorStackIndex - 1];
            a !== this._currentColor && (this._currentColor = a, n.add({
                renderPipeId: "colorMask",
                colorMask: a,
                canBundle: !1
            }));
        }
        execute(e) {
            this._renderer.colorMask.setMask(e.colorMask);
        }
        destroy() {
            this._colorStack = null;
        }
    }
    u_.extension = {
        type: [
            J.WebGLPipes,
            J.WebGPUPipes,
            J.CanvasPipes
        ],
        name: "colorMask"
    };
    class d_ {
        constructor(e){
            this._maskStackHash = {}, this._maskHash = new WeakMap, this._renderer = e;
        }
        push(e, t, n) {
            var s;
            const r = e, a = this._renderer;
            a.renderPipes.batch.break(n), a.renderPipes.blendMode.setBlendMode(r.mask, "none", n), n.add({
                renderPipeId: "stencilMask",
                action: "pushMaskBegin",
                mask: e,
                inverse: t._maskOptions.inverse,
                canBundle: !1
            });
            const o = r.mask;
            o.includeInBuild = !0, this._maskHash.has(r) || this._maskHash.set(r, {
                instructionsStart: 0,
                instructionsLength: 0
            });
            const l = this._maskHash.get(r);
            l.instructionsStart = n.instructionSize, o.collectRenderables(n, a, null), o.includeInBuild = !1, a.renderPipes.batch.break(n), n.add({
                renderPipeId: "stencilMask",
                action: "pushMaskEnd",
                mask: e,
                inverse: t._maskOptions.inverse,
                canBundle: !1
            });
            const h = n.instructionSize - l.instructionsStart - 1;
            l.instructionsLength = h;
            const d = a.renderTarget.renderTarget.uid;
            (s = this._maskStackHash)[d] ?? (s[d] = 0);
        }
        pop(e, t, n) {
            const s = e, r = this._renderer;
            r.renderPipes.batch.break(n), r.renderPipes.blendMode.setBlendMode(s.mask, "none", n), n.add({
                renderPipeId: "stencilMask",
                action: "popMaskBegin",
                inverse: t._maskOptions.inverse,
                canBundle: !1
            });
            const a = this._maskHash.get(e);
            for(let o = 0; o < a.instructionsLength; o++)n.instructions[n.instructionSize++] = n.instructions[a.instructionsStart++];
            n.add({
                renderPipeId: "stencilMask",
                action: "popMaskEnd",
                canBundle: !1
            });
        }
        execute(e) {
            var t;
            const n = this._renderer, s = n.renderTarget.renderTarget.uid;
            let r = (t = this._maskStackHash)[s] ?? (t[s] = 0);
            e.action === "pushMaskBegin" ? (n.renderTarget.ensureDepthStencil(), n.stencil.setStencilMode(Bt.RENDERING_MASK_ADD, r), r++, n.colorMask.setMask(0)) : e.action === "pushMaskEnd" ? (e.inverse ? n.stencil.setStencilMode(Bt.INVERSE_MASK_ACTIVE, r) : n.stencil.setStencilMode(Bt.MASK_ACTIVE, r), n.colorMask.setMask(15)) : e.action === "popMaskBegin" ? (n.colorMask.setMask(0), r !== 0 ? n.stencil.setStencilMode(Bt.RENDERING_MASK_REMOVE, r) : (n.renderTarget.clear(null, Ei.STENCIL), n.stencil.setStencilMode(Bt.DISABLED, r)), r--) : e.action === "popMaskEnd" && (e.inverse ? n.stencil.setStencilMode(Bt.INVERSE_MASK_ACTIVE, r) : n.stencil.setStencilMode(Bt.MASK_ACTIVE, r), n.colorMask.setMask(15)), this._maskStackHash[s] = r;
        }
        destroy() {
            this._renderer = null, this._maskStackHash = null, this._maskHash = null;
        }
    }
    d_.extension = {
        type: [
            J.WebGLPipes,
            J.WebGPUPipes,
            J.CanvasPipes
        ],
        name: "stencilMask"
    };
    var Ka = ((i)=>(i[i.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", i[i.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", i[i.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER", i))(Ka || {});
    class jw {
        constructor(e, t){
            this._lastBindBaseLocation = -1, this._lastBindCallId = -1, this.buffer = e || null, this.updateID = -1, this.byteLength = -1, this.type = t;
        }
    }
    class f_ {
        constructor(e){
            this._gpuBuffers = Object.create(null), this._boundBufferBases = Object.create(null), this._minBaseLocation = 0, this._nextBindBaseIndex = this._minBaseLocation, this._bindCallId = 0, this._renderer = e, this._renderer.renderableGC.addManagedHash(this, "_gpuBuffers");
        }
        destroy() {
            this._renderer = null, this._gl = null, this._gpuBuffers = null, this._boundBufferBases = null;
        }
        contextChange() {
            const e = this._gl = this._renderer.gl;
            this._gpuBuffers = Object.create(null), this._maxBindings = e.MAX_UNIFORM_BUFFER_BINDINGS ? e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
        }
        getGlBuffer(e) {
            return this._gpuBuffers[e.uid] || this.createGLBuffer(e);
        }
        bind(e) {
            const { _gl: t } = this, n = this.getGlBuffer(e);
            t.bindBuffer(n.type, n.buffer);
        }
        bindBufferBase(e, t) {
            const { _gl: n } = this;
            this._boundBufferBases[t] !== e && (this._boundBufferBases[t] = e, e._lastBindBaseLocation = t, n.bindBufferBase(n.UNIFORM_BUFFER, t, e.buffer));
        }
        nextBindBase(e) {
            this._bindCallId++, this._minBaseLocation = 0, e && (this._boundBufferBases[0] = null, this._minBaseLocation = 1, this._nextBindBaseIndex < 1 && (this._nextBindBaseIndex = 1));
        }
        freeLocationForBufferBase(e) {
            let t = this.getLastBindBaseLocation(e);
            if (t >= this._minBaseLocation) return e._lastBindCallId = this._bindCallId, t;
            let n = 0, s = this._nextBindBaseIndex;
            for(; n < 2;){
                s >= this._maxBindings && (s = this._minBaseLocation, n++);
                const r = this._boundBufferBases[s];
                if (r && r._lastBindCallId === this._bindCallId) {
                    s++;
                    continue;
                }
                break;
            }
            return t = s, this._nextBindBaseIndex = s + 1, n >= 2 ? -1 : (e._lastBindCallId = this._bindCallId, this._boundBufferBases[t] = null, t);
        }
        getLastBindBaseLocation(e) {
            const t = e._lastBindBaseLocation;
            return this._boundBufferBases[t] === e ? t : -1;
        }
        bindBufferRange(e, t, n, s) {
            const { _gl: r } = this;
            n || (n = 0), t || (t = 0), this._boundBufferBases[t] = null, r.bindBufferRange(r.UNIFORM_BUFFER, t || 0, e.buffer, n * 256, s || 256);
        }
        updateBuffer(e) {
            const { _gl: t } = this, n = this.getGlBuffer(e);
            if (e._updateID === n.updateID) return n;
            n.updateID = e._updateID, t.bindBuffer(n.type, n.buffer);
            const s = e.data, r = e.descriptor.usage & wt.STATIC ? t.STATIC_DRAW : t.DYNAMIC_DRAW;
            return s ? n.byteLength >= s.byteLength ? t.bufferSubData(n.type, 0, s, 0, e._updateSize / s.BYTES_PER_ELEMENT) : (n.byteLength = s.byteLength, t.bufferData(n.type, s, r)) : (n.byteLength = e.descriptor.size, t.bufferData(n.type, n.byteLength, r)), n;
        }
        destroyAll() {
            const e = this._gl;
            for(const t in this._gpuBuffers)e.deleteBuffer(this._gpuBuffers[t].buffer);
            this._gpuBuffers = Object.create(null);
        }
        onBufferDestroy(e, t) {
            const n = this._gpuBuffers[e.uid], s = this._gl;
            t || s.deleteBuffer(n.buffer), this._gpuBuffers[e.uid] = null;
        }
        createGLBuffer(e) {
            const { _gl: t } = this;
            let n = Ka.ARRAY_BUFFER;
            e.descriptor.usage & wt.INDEX ? n = Ka.ELEMENT_ARRAY_BUFFER : e.descriptor.usage & wt.UNIFORM && (n = Ka.UNIFORM_BUFFER);
            const s = new jw(t.createBuffer(), n);
            return this._gpuBuffers[e.uid] = s, e.on("destroy", this.onBufferDestroy, this), s;
        }
        resetState() {
            this._boundBufferBases = Object.create(null);
        }
    }
    f_.extension = {
        type: [
            J.WebGLSystem
        ],
        name: "buffer"
    };
    const qh = class p_ {
        constructor(e){
            this.supports = {
                uint32Indices: !0,
                uniformBufferObject: !0,
                vertexArrayObject: !0,
                srgbTextures: !0,
                nonPowOf2wrapping: !0,
                msaa: !0,
                nonPowOf2mipmaps: !0
            }, this._renderer = e, this.extensions = Object.create(null), this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this);
        }
        get isLost() {
            return !this.gl || this.gl.isContextLost();
        }
        contextChange(e) {
            this.gl = e, this._renderer.gl = e;
        }
        init(e) {
            e = {
                ...p_.defaultOptions,
                ...e
            };
            let t = this.multiView = e.multiView;
            if (e.context && t && (tt("Renderer created with both a context and multiview enabled. Disabling multiView as both cannot work together."), t = !1), t ? this.canvas = _t.get().createCanvas(this._renderer.canvas.width, this._renderer.canvas.height) : this.canvas = this._renderer.view.canvas, e.context) this.initFromContext(e.context);
            else {
                const n = this._renderer.background.alpha < 1, s = e.premultipliedAlpha ?? !0, r = e.antialias && !this._renderer.backBuffer.useBackBuffer;
                this.createContext(e.preferWebGLVersion, {
                    alpha: n,
                    premultipliedAlpha: s,
                    antialias: r,
                    stencil: !0,
                    preserveDrawingBuffer: e.preserveDrawingBuffer,
                    powerPreference: e.powerPreference ?? "default"
                });
            }
        }
        ensureCanvasSize(e) {
            if (!this.multiView) {
                e !== this.canvas && tt("multiView is disabled, but targetCanvas is not the main canvas");
                return;
            }
            const { canvas: t } = this;
            (t.width < e.width || t.height < e.height) && (t.width = Math.max(e.width, e.width), t.height = Math.max(e.height, e.height));
        }
        initFromContext(e) {
            this.gl = e, this.webGLVersion = e instanceof _t.get().getWebGLRenderingContext() ? 1 : 2, this.getExtensions(), this.validateContext(e), this._renderer.runners.contextChange.emit(e);
            const t = this._renderer.view.canvas;
            t.addEventListener("webglcontextlost", this.handleContextLost, !1), t.addEventListener("webglcontextrestored", this.handleContextRestored, !1);
        }
        createContext(e, t) {
            let n;
            const s = this.canvas;
            if (e === 2 && (n = s.getContext("webgl2", t)), !n && (n = s.getContext("webgl", t), !n)) throw new Error("This browser does not support WebGL. Try using the canvas renderer");
            this.gl = n, this.initFromContext(this.gl);
        }
        getExtensions() {
            const { gl: e } = this, t = {
                anisotropicFiltering: e.getExtension("EXT_texture_filter_anisotropic"),
                floatTextureLinear: e.getExtension("OES_texture_float_linear"),
                s3tc: e.getExtension("WEBGL_compressed_texture_s3tc"),
                s3tc_sRGB: e.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
                etc: e.getExtension("WEBGL_compressed_texture_etc"),
                etc1: e.getExtension("WEBGL_compressed_texture_etc1"),
                pvrtc: e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
                atc: e.getExtension("WEBGL_compressed_texture_atc"),
                astc: e.getExtension("WEBGL_compressed_texture_astc"),
                bptc: e.getExtension("EXT_texture_compression_bptc"),
                rgtc: e.getExtension("EXT_texture_compression_rgtc"),
                loseContext: e.getExtension("WEBGL_lose_context")
            };
            if (this.webGLVersion === 1) this.extensions = {
                ...t,
                drawBuffers: e.getExtension("WEBGL_draw_buffers"),
                depthTexture: e.getExtension("WEBGL_depth_texture"),
                vertexArrayObject: e.getExtension("OES_vertex_array_object") || e.getExtension("MOZ_OES_vertex_array_object") || e.getExtension("WEBKIT_OES_vertex_array_object"),
                uint32ElementIndex: e.getExtension("OES_element_index_uint"),
                floatTexture: e.getExtension("OES_texture_float"),
                floatTextureLinear: e.getExtension("OES_texture_float_linear"),
                textureHalfFloat: e.getExtension("OES_texture_half_float"),
                textureHalfFloatLinear: e.getExtension("OES_texture_half_float_linear"),
                vertexAttribDivisorANGLE: e.getExtension("ANGLE_instanced_arrays"),
                srgb: e.getExtension("EXT_sRGB")
            };
            else {
                this.extensions = {
                    ...t,
                    colorBufferFloat: e.getExtension("EXT_color_buffer_float")
                };
                const n = e.getExtension("WEBGL_provoking_vertex");
                n && n.provokingVertexWEBGL(n.FIRST_VERTEX_CONVENTION_WEBGL);
            }
        }
        handleContextLost(e) {
            e.preventDefault(), this._contextLossForced && (this._contextLossForced = !1, setTimeout(()=>{
                this.gl.isContextLost() && this.extensions.loseContext?.restoreContext();
            }, 0));
        }
        handleContextRestored() {
            this.getExtensions(), this._renderer.runners.contextChange.emit(this.gl);
        }
        destroy() {
            const e = this._renderer.view.canvas;
            this._renderer = null, e.removeEventListener("webglcontextlost", this.handleContextLost), e.removeEventListener("webglcontextrestored", this.handleContextRestored), this.gl.useProgram(null), this.extensions.loseContext?.loseContext();
        }
        forceContextLoss() {
            this.extensions.loseContext?.loseContext(), this._contextLossForced = !0;
        }
        validateContext(e) {
            const t = e.getContextAttributes();
            t && !t.stencil && tt("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
            const n = this.supports, s = this.webGLVersion === 2, r = this.extensions;
            n.uint32Indices = s || !!r.uint32ElementIndex, n.uniformBufferObject = s, n.vertexArrayObject = s || !!r.vertexArrayObject, n.srgbTextures = s || !!r.srgb, n.nonPowOf2wrapping = s, n.nonPowOf2mipmaps = s, n.msaa = s, n.uint32Indices || tt("Provided WebGL context does not support 32 index buffer, large scenes may not render correctly");
        }
    };
    qh.extension = {
        type: [
            J.WebGLSystem
        ],
        name: "context"
    };
    qh.defaultOptions = {
        context: null,
        premultipliedAlpha: !0,
        preserveDrawingBuffer: !1,
        powerPreference: void 0,
        preferWebGLVersion: 2,
        multiView: !1
    };
    let qw = qh;
    function $w(i, e) {
        for(const t in i.attributes){
            const n = i.attributes[t], s = e[t];
            s ? (n.format ?? (n.format = s.format), n.offset ?? (n.offset = s.offset), n.instance ?? (n.instance = s.instance)) : tt(`Attribute ${t} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);
        }
        Kw(i);
    }
    function Kw(i) {
        const { buffers: e, attributes: t } = i, n = {}, s = {};
        for(const r in e){
            const a = e[r];
            n[a.uid] = 0, s[a.uid] = 0;
        }
        for(const r in t){
            const a = t[r];
            n[a.buffer.uid] += Xr(a.format).stride;
        }
        for(const r in t){
            const a = t[r];
            a.stride ?? (a.stride = n[a.buffer.uid]), a.start ?? (a.start = s[a.buffer.uid]), s[a.buffer.uid] += Xr(a.format).stride;
        }
    }
    var Zc = ((i)=>(i[i.RGBA = 6408] = "RGBA", i[i.RGB = 6407] = "RGB", i[i.RG = 33319] = "RG", i[i.RED = 6403] = "RED", i[i.RGBA_INTEGER = 36249] = "RGBA_INTEGER", i[i.RGB_INTEGER = 36248] = "RGB_INTEGER", i[i.RG_INTEGER = 33320] = "RG_INTEGER", i[i.RED_INTEGER = 36244] = "RED_INTEGER", i[i.ALPHA = 6406] = "ALPHA", i[i.LUMINANCE = 6409] = "LUMINANCE", i[i.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", i[i.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", i[i.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL", i))(Zc || {}), m_ = ((i)=>(i[i.TEXTURE_2D = 3553] = "TEXTURE_2D", i[i.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", i[i.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", i[i.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", i[i.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", i[i.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", i[i.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", i[i.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", i[i.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z", i))(m_ || {}), it = ((i)=>(i[i.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", i[i.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", i[i.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", i[i.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", i[i.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", i[i.UNSIGNED_INT = 5125] = "UNSIGNED_INT", i[i.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", i[i.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", i[i.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", i[i.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", i[i.BYTE = 5120] = "BYTE", i[i.SHORT = 5122] = "SHORT", i[i.INT = 5124] = "INT", i[i.FLOAT = 5126] = "FLOAT", i[i.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", i[i.HALF_FLOAT = 36193] = "HALF_FLOAT", i))(it || {});
    const Of = {
        uint8x2: it.UNSIGNED_BYTE,
        uint8x4: it.UNSIGNED_BYTE,
        sint8x2: it.BYTE,
        sint8x4: it.BYTE,
        unorm8x2: it.UNSIGNED_BYTE,
        unorm8x4: it.UNSIGNED_BYTE,
        snorm8x2: it.BYTE,
        snorm8x4: it.BYTE,
        uint16x2: it.UNSIGNED_SHORT,
        uint16x4: it.UNSIGNED_SHORT,
        sint16x2: it.SHORT,
        sint16x4: it.SHORT,
        unorm16x2: it.UNSIGNED_SHORT,
        unorm16x4: it.UNSIGNED_SHORT,
        snorm16x2: it.SHORT,
        snorm16x4: it.SHORT,
        float16x2: it.HALF_FLOAT,
        float16x4: it.HALF_FLOAT,
        float32: it.FLOAT,
        float32x2: it.FLOAT,
        float32x3: it.FLOAT,
        float32x4: it.FLOAT,
        uint32: it.UNSIGNED_INT,
        uint32x2: it.UNSIGNED_INT,
        uint32x3: it.UNSIGNED_INT,
        uint32x4: it.UNSIGNED_INT,
        sint32: it.INT,
        sint32x2: it.INT,
        sint32x3: it.INT,
        sint32x4: it.INT
    };
    function Zw(i) {
        return Of[i] ?? Of.float32;
    }
    const Jw = {
        "point-list": 0,
        "line-list": 1,
        "line-strip": 3,
        "triangle-list": 4,
        "triangle-strip": 5
    };
    class __ {
        constructor(e){
            this._geometryVaoHash = Object.create(null), this._renderer = e, this._activeGeometry = null, this._activeVao = null, this.hasVao = !0, this.hasInstance = !0, this._renderer.renderableGC.addManagedHash(this, "_geometryVaoHash");
        }
        contextChange() {
            const e = this.gl = this._renderer.gl;
            if (!this._renderer.context.supports.vertexArrayObject) throw new Error("[PixiJS] Vertex Array Objects are not supported on this device");
            const t = this._renderer.context.extensions.vertexArrayObject;
            t && (e.createVertexArray = ()=>t.createVertexArrayOES(), e.bindVertexArray = (s)=>t.bindVertexArrayOES(s), e.deleteVertexArray = (s)=>t.deleteVertexArrayOES(s));
            const n = this._renderer.context.extensions.vertexAttribDivisorANGLE;
            n && (e.drawArraysInstanced = (s, r, a, o)=>{
                n.drawArraysInstancedANGLE(s, r, a, o);
            }, e.drawElementsInstanced = (s, r, a, o, l)=>{
                n.drawElementsInstancedANGLE(s, r, a, o, l);
            }, e.vertexAttribDivisor = (s, r)=>n.vertexAttribDivisorANGLE(s, r)), this._activeGeometry = null, this._activeVao = null, this._geometryVaoHash = Object.create(null);
        }
        bind(e, t) {
            const n = this.gl;
            this._activeGeometry = e;
            const s = this.getVao(e, t);
            this._activeVao !== s && (this._activeVao = s, n.bindVertexArray(s)), this.updateBuffers();
        }
        resetState() {
            this.unbind();
        }
        updateBuffers() {
            const e = this._activeGeometry, t = this._renderer.buffer;
            for(let n = 0; n < e.buffers.length; n++){
                const s = e.buffers[n];
                t.updateBuffer(s);
            }
        }
        checkCompatibility(e, t) {
            const n = e.attributes, s = t._attributeData;
            for(const r in s)if (!n[r]) throw new Error(`shader and geometry incompatible, geometry missing the "${r}" attribute`);
        }
        getSignature(e, t) {
            const n = e.attributes, s = t._attributeData, r = [
                "g",
                e.uid
            ];
            for(const a in n)s[a] && r.push(a, s[a].location);
            return r.join("-");
        }
        getVao(e, t) {
            return this._geometryVaoHash[e.uid]?.[t._key] || this.initGeometryVao(e, t);
        }
        initGeometryVao(e, t, n = !0) {
            const s = this._renderer.gl, r = this._renderer.buffer;
            this._renderer.shader._getProgramData(t), this.checkCompatibility(e, t);
            const a = this.getSignature(e, t);
            this._geometryVaoHash[e.uid] || (this._geometryVaoHash[e.uid] = Object.create(null), e.on("destroy", this.onGeometryDestroy, this));
            const o = this._geometryVaoHash[e.uid];
            let l = o[a];
            if (l) return o[t._key] = l, l;
            $w(e, t._attributeData);
            const h = e.buffers;
            l = s.createVertexArray(), s.bindVertexArray(l);
            for(let d = 0; d < h.length; d++){
                const c = h[d];
                r.bind(c);
            }
            return this.activateVao(e, t), o[t._key] = l, o[a] = l, s.bindVertexArray(null), l;
        }
        onGeometryDestroy(e, t) {
            const n = this._geometryVaoHash[e.uid], s = this.gl;
            if (n) {
                if (t) for(const r in n)this._activeVao !== n[r] && this.unbind(), s.deleteVertexArray(n[r]);
                this._geometryVaoHash[e.uid] = null;
            }
        }
        destroyAll(e = !1) {
            const t = this.gl;
            for(const n in this._geometryVaoHash){
                if (e) for(const s in this._geometryVaoHash[n]){
                    const r = this._geometryVaoHash[n];
                    this._activeVao !== r && this.unbind(), t.deleteVertexArray(r[s]);
                }
                this._geometryVaoHash[n] = null;
            }
        }
        activateVao(e, t) {
            const n = this._renderer.gl, s = this._renderer.buffer, r = e.attributes;
            e.indexBuffer && s.bind(e.indexBuffer);
            let a = null;
            for(const o in r){
                const l = r[o], h = l.buffer, d = s.getGlBuffer(h), c = t._attributeData[o];
                if (c) {
                    a !== d && (s.bind(h), a = d);
                    const u = c.location;
                    n.enableVertexAttribArray(u);
                    const f = Xr(l.format), _ = Zw(l.format);
                    if (c.format?.substring(1, 4) === "int" ? n.vertexAttribIPointer(u, f.size, _, l.stride, l.offset) : n.vertexAttribPointer(u, f.size, _, f.normalised, l.stride, l.offset), l.instance) if (this.hasInstance) {
                        const g = l.divisor ?? 1;
                        n.vertexAttribDivisor(u, g);
                    } else throw new Error("geometry error, GPU Instancing is not supported on this device");
                }
            }
        }
        draw(e, t, n, s) {
            const { gl: r } = this._renderer, a = this._activeGeometry, o = Jw[e || a.topology];
            if (s ?? (s = a.instanceCount), a.indexBuffer) {
                const l = a.indexBuffer.data.BYTES_PER_ELEMENT, h = l === 2 ? r.UNSIGNED_SHORT : r.UNSIGNED_INT;
                s > 1 ? r.drawElementsInstanced(o, t || a.indexBuffer.data.length, h, (n || 0) * l, s) : r.drawElements(o, t || a.indexBuffer.data.length, h, (n || 0) * l);
            } else s > 1 ? r.drawArraysInstanced(o, n || 0, t || a.getSize(), s) : r.drawArrays(o, n || 0, t || a.getSize());
            return this;
        }
        unbind() {
            this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null;
        }
        destroy() {
            this._renderer = null, this.gl = null, this._activeVao = null, this._activeGeometry = null;
        }
    }
    __.extension = {
        type: [
            J.WebGLSystem
        ],
        name: "geometry"
    };
    const Qw = new Lm({
        attributes: {
            aPosition: [
                -1,
                -1,
                3,
                -1,
                -1,
                3
            ]
        }
    }), $h = class g_ {
        constructor(e){
            this.useBackBuffer = !1, this._useBackBufferThisRender = !1, this._renderer = e;
        }
        init(e = {}) {
            const { useBackBuffer: t, antialias: n } = {
                ...g_.defaultOptions,
                ...e
            };
            this.useBackBuffer = t, this._antialias = n, this._renderer.context.supports.msaa || (tt("antialiasing, is not supported on when using the back buffer"), this._antialias = !1), this._state = Kr.for2d();
            const s = new $r({
                vertex: `
                attribute vec2 aPosition;
                out vec2 vUv;

                void main() {
                    gl_Position = vec4(aPosition, 0.0, 1.0);

                    vUv = (aPosition + 1.0) / 2.0;

                    // flip dem UVs
                    vUv.y = 1.0 - vUv.y;
                }`,
                fragment: `
                in vec2 vUv;
                out vec4 finalColor;

                uniform sampler2D uTexture;

                void main() {
                    finalColor = texture(uTexture, vUv);
                }`,
                name: "big-triangle"
            });
            this._bigTriangleShader = new as({
                glProgram: s,
                resources: {
                    uTexture: Ie.WHITE.source
                }
            });
        }
        renderStart(e) {
            const t = this._renderer.renderTarget.getRenderTarget(e.target);
            if (this._useBackBufferThisRender = this.useBackBuffer && !!t.isRoot, this._useBackBufferThisRender) {
                const n = this._renderer.renderTarget.getRenderTarget(e.target);
                this._targetTexture = n.colorTexture, e.target = this._getBackBufferTexture(n.colorTexture);
            }
        }
        renderEnd() {
            this._presentBackBuffer();
        }
        _presentBackBuffer() {
            const e = this._renderer;
            e.renderTarget.finishRenderPass(), this._useBackBufferThisRender && (e.renderTarget.bind(this._targetTexture, !1), this._bigTriangleShader.resources.uTexture = this._backBufferTexture.source, e.encoder.draw({
                geometry: Qw,
                shader: this._bigTriangleShader,
                state: this._state
            }));
        }
        _getBackBufferTexture(e) {
            return this._backBufferTexture = this._backBufferTexture || new Ie({
                source: new kt({
                    width: e.width,
                    height: e.height,
                    resolution: e._resolution,
                    antialias: this._antialias
                })
            }), this._backBufferTexture.source.resize(e.width, e.height, e._resolution), this._backBufferTexture;
        }
        destroy() {
            this._backBufferTexture && (this._backBufferTexture.destroy(), this._backBufferTexture = null);
        }
    };
    $h.extension = {
        type: [
            J.WebGLSystem
        ],
        name: "backBuffer",
        priority: 1
    };
    $h.defaultOptions = {
        useBackBuffer: !1
    };
    let e1 = $h;
    class x_ {
        constructor(e){
            this._colorMaskCache = 15, this._renderer = e;
        }
        setMask(e) {
            this._colorMaskCache !== e && (this._colorMaskCache = e, this._renderer.gl.colorMask(!!(e & 8), !!(e & 4), !!(e & 2), !!(e & 1)));
        }
    }
    x_.extension = {
        type: [
            J.WebGLSystem
        ],
        name: "colorMask"
    };
    class v_ {
        constructor(e){
            this.commandFinished = Promise.resolve(), this._renderer = e;
        }
        setGeometry(e, t) {
            this._renderer.geometry.bind(e, t.glProgram);
        }
        finishRenderPass() {}
        draw(e) {
            const t = this._renderer, { geometry: n, shader: s, state: r, skipSync: a, topology: o, size: l, start: h, instanceCount: d } = e;
            t.shader.bind(s, a), t.geometry.bind(n, t.shader._activeProgram), r && t.state.set(r), t.geometry.draw(o, l, h, d ?? n.instanceCount);
        }
        destroy() {
            this._renderer = null;
        }
    }
    v_.extension = {
        type: [
            J.WebGLSystem
        ],
        name: "encoder"
    };
    class t1 {
        constructor(){
            this.width = -1, this.height = -1, this.msaa = !1, this.msaaRenderBuffer = [];
        }
    }
    const os = [];
    os[Bt.NONE] = void 0;
    os[Bt.DISABLED] = {
        stencilWriteMask: 0,
        stencilReadMask: 0
    };
    os[Bt.RENDERING_MASK_ADD] = {
        stencilFront: {
            compare: "equal",
            passOp: "increment-clamp"
        },
        stencilBack: {
            compare: "equal",
            passOp: "increment-clamp"
        }
    };
    os[Bt.RENDERING_MASK_REMOVE] = {
        stencilFront: {
            compare: "equal",
            passOp: "decrement-clamp"
        },
        stencilBack: {
            compare: "equal",
            passOp: "decrement-clamp"
        }
    };
    os[Bt.MASK_ACTIVE] = {
        stencilWriteMask: 0,
        stencilFront: {
            compare: "equal",
            passOp: "keep"
        },
        stencilBack: {
            compare: "equal",
            passOp: "keep"
        }
    };
    os[Bt.INVERSE_MASK_ACTIVE] = {
        stencilWriteMask: 0,
        stencilFront: {
            compare: "not-equal",
            passOp: "replace"
        },
        stencilBack: {
            compare: "not-equal",
            passOp: "replace"
        }
    };
    class y_ {
        constructor(e){
            this._stencilCache = {
                enabled: !1,
                stencilReference: 0,
                stencilMode: Bt.NONE
            }, this._renderTargetStencilState = Object.create(null), e.renderTarget.onRenderTargetChange.add(this);
        }
        contextChange(e) {
            this._gl = e, this._comparisonFuncMapping = {
                always: e.ALWAYS,
                never: e.NEVER,
                equal: e.EQUAL,
                "not-equal": e.NOTEQUAL,
                less: e.LESS,
                "less-equal": e.LEQUAL,
                greater: e.GREATER,
                "greater-equal": e.GEQUAL
            }, this._stencilOpsMapping = {
                keep: e.KEEP,
                zero: e.ZERO,
                replace: e.REPLACE,
                invert: e.INVERT,
                "increment-clamp": e.INCR,
                "decrement-clamp": e.DECR,
                "increment-wrap": e.INCR_WRAP,
                "decrement-wrap": e.DECR_WRAP
            }, this.resetState();
        }
        onRenderTargetChange(e) {
            if (this._activeRenderTarget === e) return;
            this._activeRenderTarget = e;
            let t = this._renderTargetStencilState[e.uid];
            t || (t = this._renderTargetStencilState[e.uid] = {
                stencilMode: Bt.DISABLED,
                stencilReference: 0
            }), this.setStencilMode(t.stencilMode, t.stencilReference);
        }
        resetState() {
            this._stencilCache.enabled = !1, this._stencilCache.stencilMode = Bt.NONE, this._stencilCache.stencilReference = 0;
        }
        setStencilMode(e, t) {
            const n = this._renderTargetStencilState[this._activeRenderTarget.uid], s = this._gl, r = os[e], a = this._stencilCache;
            if (n.stencilMode = e, n.stencilReference = t, e === Bt.DISABLED) {
                this._stencilCache.enabled && (this._stencilCache.enabled = !1, s.disable(s.STENCIL_TEST));
                return;
            }
            this._stencilCache.enabled || (this._stencilCache.enabled = !0, s.enable(s.STENCIL_TEST)), (e !== a.stencilMode || a.stencilReference !== t) && (a.stencilMode = e, a.stencilReference = t, s.stencilFunc(this._comparisonFuncMapping[r.stencilBack.compare], t, 255), s.stencilOp(s.KEEP, s.KEEP, this._stencilOpsMapping[r.stencilBack.passOp]));
        }
    }
    y_.extension = {
        type: [
            J.WebGLSystem
        ],
        name: "stencil"
    };
    class n1 {
        constructor(e){
            this._syncFunctionHash = Object.create(null), this._adaptor = e, this._systemCheck();
        }
        _systemCheck() {
            if (!Tm()) throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
        }
        ensureUniformGroup(e) {
            const t = this.getUniformGroupData(e);
            e.buffer || (e.buffer = new is({
                data: new Float32Array(t.layout.size / 4),
                usage: wt.UNIFORM | wt.COPY_DST
            }));
        }
        getUniformGroupData(e) {
            return this._syncFunctionHash[e._signature] || this._initUniformGroup(e);
        }
        _initUniformGroup(e) {
            const t = e._signature;
            let n = this._syncFunctionHash[t];
            if (!n) {
                const s = Object.keys(e.uniformStructures).map((o)=>e.uniformStructures[o]), r = this._adaptor.createUboElements(s), a = this._generateUboSync(r.uboElements);
                n = this._syncFunctionHash[t] = {
                    layout: r,
                    syncFunction: a
                };
            }
            return this._syncFunctionHash[t];
        }
        _generateUboSync(e) {
            return this._adaptor.generateUboSync(e);
        }
        syncUniformGroup(e, t, n) {
            const s = this.getUniformGroupData(e);
            e.buffer || (e.buffer = new is({
                data: new Float32Array(s.layout.size / 4),
                usage: wt.UNIFORM | wt.COPY_DST
            }));
            let r = null;
            return t || (t = e.buffer.data, r = e.buffer.dataInt32), n || (n = 0), s.syncFunction(e.uniforms, t, r, n), !0;
        }
        updateUniformGroup(e) {
            if (e.isStatic && !e._dirtyId) return !1;
            e._dirtyId = 0;
            const t = this.syncUniformGroup(e);
            return e.buffer.update(), t;
        }
        destroy() {
            this._syncFunctionHash = null;
        }
    }
    const b_ = {
        f32: 4,
        i32: 4,
        "vec2<f32>": 8,
        "vec3<f32>": 12,
        "vec4<f32>": 16,
        "vec2<i32>": 8,
        "vec3<i32>": 12,
        "vec4<i32>": 16,
        "mat2x2<f32>": 16 * 2,
        "mat3x3<f32>": 16 * 3,
        "mat4x4<f32>": 16 * 4
    };
    function i1(i) {
        const e = i.map((r)=>({
                data: r,
                offset: 0,
                size: 0
            })), t = 16;
        let n = 0, s = 0;
        for(let r = 0; r < e.length; r++){
            const a = e[r];
            if (n = b_[a.data.type], !n) throw new Error(`Unknown type ${a.data.type}`);
            a.data.size > 1 && (n = Math.max(n, t) * a.data.size);
            const o = n === 12 ? 16 : n;
            a.size = n;
            const l = s % t;
            l > 0 && t - l < o ? s += (t - l) % 16 : s += (n - l % n) % n, a.offset = s, s += n;
        }
        return s = Math.ceil(s / 16) * 16, {
            uboElements: e,
            size: s
        };
    }
    const Zi = [
        {
            type: "mat3x3<f32>",
            test: (i)=>i.value.a !== void 0,
            ubo: `
            var matrix = uv[name].toArray(true);
            data[offset] = matrix[0];
            data[offset + 1] = matrix[1];
            data[offset + 2] = matrix[2];
            data[offset + 4] = matrix[3];
            data[offset + 5] = matrix[4];
            data[offset + 6] = matrix[5];
            data[offset + 8] = matrix[6];
            data[offset + 9] = matrix[7];
            data[offset + 10] = matrix[8];
        `,
            uniform: `
            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));
        `
        },
        {
            type: "vec4<f32>",
            test: (i)=>i.type === "vec4<f32>" && i.size === 1 && i.value.width !== void 0,
            ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
            data[offset + 2] = v.width;
            data[offset + 3] = v.height;
        `,
            uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {
                cv[0] = v.x;
                cv[1] = v.y;
                cv[2] = v.width;
                cv[3] = v.height;
                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);
            }
        `
        },
        {
            type: "vec2<f32>",
            test: (i)=>i.type === "vec2<f32>" && i.size === 1 && i.value.x !== void 0,
            ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
        `,
            uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y) {
                cv[0] = v.x;
                cv[1] = v.y;
                gl.uniform2f(ud[name].location, v.x, v.y);
            }
        `
        },
        {
            type: "vec4<f32>",
            test: (i)=>i.type === "vec4<f32>" && i.size === 1 && i.value.red !== void 0,
            ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
            data[offset + 3] = v.alpha;
        `,
            uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                cv[3] = v.alpha;
                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);
            }
        `
        },
        {
            type: "vec3<f32>",
            test: (i)=>i.type === "vec3<f32>" && i.size === 1 && i.value.red !== void 0,
            ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
        `,
            uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);
            }
        `
        }
    ];
    function s1(i, e, t, n) {
        const s = [
            `
        var v = null;
        var v2 = null;
        var t = 0;
        var index = 0;
        var name = null;
        var arrayOffset = null;
    `
        ];
        let r = 0;
        for(let o = 0; o < i.length; o++){
            const l = i[o], h = l.data.name;
            let d = !1, c = 0;
            for(let u = 0; u < Zi.length; u++)if (Zi[u].test(l.data)) {
                c = l.offset / 4, s.push(`name = "${h}";`, `offset += ${c - r};`, Zi[u][e] || Zi[u].ubo), d = !0;
                break;
            }
            if (!d) if (l.data.size > 1) c = l.offset / 4, s.push(t(l, c - r));
            else {
                const u = n[l.data.type];
                c = l.offset / 4, s.push(`
                    v = uv.${h};
                    offset += ${c - r};
                    ${u};
                `);
            }
            r = c;
        }
        const a = s.join(`
`);
        return new Function("uv", "data", "dataInt32", "offset", a);
    }
    function As(i, e) {
        return `
        for (let i = 0; i < ${i * e}; i++) {
            data[offset + (((i / ${i})|0) * 4) + (i % ${i})] = v[i];
        }
    `;
    }
    const S_ = {
        f32: `
        data[offset] = v;`,
        i32: `
        dataInt32[offset] = v;`,
        "vec2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];`,
        "vec3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];`,
        "vec4<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];`,
        "vec2<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];`,
        "vec3<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];`,
        "vec4<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];
        dataInt32[offset + 3] = v[3];`,
        "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 4] = v[2];
        data[offset + 5] = v[3];`,
        "mat3x3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];
        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];`,
        "mat4x4<f32>": `
        for (let i = 0; i < 16; i++) {
            data[offset + i] = v[i];
        }`,
        "mat3x2<f32>": As(3, 2),
        "mat4x2<f32>": As(4, 2),
        "mat2x3<f32>": As(2, 3),
        "mat4x3<f32>": As(4, 3),
        "mat2x4<f32>": As(2, 4),
        "mat3x4<f32>": As(3, 4)
    };
    ({
        ...S_
    });
    function r1(i, e) {
        const t = Math.max(b_[i.data.type] / 16, 1), n = i.data.value.length / i.data.size, s = (4 - n % 4) % 4, r = i.data.type.indexOf("i32") >= 0 ? "dataInt32" : "data";
        return `
        v = uv.${i.data.name};
        offset += ${e};

        arrayOffset = offset;

        t = 0;

        for(var i=0; i < ${i.data.size * t}; i++)
        {
            for(var j = 0; j < ${n}; j++)
            {
                ${r}[arrayOffset++] = v[t++];
            }
            ${s !== 0 ? `arrayOffset += ${s};` : ""}
        }
    `;
    }
    function a1(i) {
        return s1(i, "uboStd40", r1, S_);
    }
    class T_ extends n1 {
        constructor(){
            super({
                createUboElements: i1,
                generateUboSync: a1
            });
        }
    }
    T_.extension = {
        type: [
            J.WebGLSystem
        ],
        name: "ubo"
    };
    class o1 {
        constructor(){
            this._clearColorCache = [
                0,
                0,
                0,
                0
            ], this._viewPortCache = new mt;
        }
        init(e, t) {
            this._renderer = e, this._renderTargetSystem = t, e.runners.contextChange.add(this);
        }
        contextChange() {
            this._clearColorCache = [
                0,
                0,
                0,
                0
            ], this._viewPortCache = new mt;
        }
        copyToTexture(e, t, n, s, r) {
            const a = this._renderTargetSystem, o = this._renderer, l = a.getGpuRenderTarget(e), h = o.gl;
            return this.finishRenderPass(e), h.bindFramebuffer(h.FRAMEBUFFER, l.resolveTargetFramebuffer), o.texture.bind(t, 0), h.copyTexSubImage2D(h.TEXTURE_2D, 0, r.x, r.y, n.x, n.y, s.width, s.height), t;
        }
        startRenderPass(e, t = !0, n, s) {
            const r = this._renderTargetSystem, a = e.colorTexture, o = r.getGpuRenderTarget(e);
            let l = s.y;
            e.isRoot && (l = a.pixelHeight - s.height), e.colorTextures.forEach((c)=>{
                this._renderer.texture.unbind(c);
            });
            const h = this._renderer.gl;
            h.bindFramebuffer(h.FRAMEBUFFER, o.framebuffer);
            const d = this._viewPortCache;
            (d.x !== s.x || d.y !== l || d.width !== s.width || d.height !== s.height) && (d.x = s.x, d.y = l, d.width = s.width, d.height = s.height, h.viewport(s.x, l, s.width, s.height)), !o.depthStencilRenderBuffer && (e.stencil || e.depth) && this._initStencil(o), this.clear(e, t, n);
        }
        finishRenderPass(e) {
            const n = this._renderTargetSystem.getGpuRenderTarget(e);
            if (!n.msaa) return;
            const s = this._renderer.gl;
            s.bindFramebuffer(s.FRAMEBUFFER, n.resolveTargetFramebuffer), s.bindFramebuffer(s.READ_FRAMEBUFFER, n.framebuffer), s.blitFramebuffer(0, 0, n.width, n.height, 0, 0, n.width, n.height, s.COLOR_BUFFER_BIT, s.NEAREST), s.bindFramebuffer(s.FRAMEBUFFER, n.framebuffer);
        }
        initGpuRenderTarget(e) {
            const n = this._renderer.gl, s = new t1, r = e.colorTexture;
            return Ai.test(r.resource) ? (this._renderer.context.ensureCanvasSize(e.colorTexture.resource), s.framebuffer = null, s) : (this._initColor(e, s), n.bindFramebuffer(n.FRAMEBUFFER, null), s);
        }
        destroyGpuRenderTarget(e) {
            const t = this._renderer.gl;
            e.framebuffer && (t.deleteFramebuffer(e.framebuffer), e.framebuffer = null), e.resolveTargetFramebuffer && (t.deleteFramebuffer(e.resolveTargetFramebuffer), e.resolveTargetFramebuffer = null), e.depthStencilRenderBuffer && (t.deleteRenderbuffer(e.depthStencilRenderBuffer), e.depthStencilRenderBuffer = null), e.msaaRenderBuffer.forEach((n)=>{
                t.deleteRenderbuffer(n);
            }), e.msaaRenderBuffer = null;
        }
        clear(e, t, n) {
            if (!t) return;
            const s = this._renderTargetSystem;
            typeof t == "boolean" && (t = t ? Ei.ALL : Ei.NONE);
            const r = this._renderer.gl;
            if (t & Ei.COLOR) {
                n ?? (n = s.defaultClearColor);
                const a = this._clearColorCache, o = n;
                (a[0] !== o[0] || a[1] !== o[1] || a[2] !== o[2] || a[3] !== o[3]) && (a[0] = o[0], a[1] = o[1], a[2] = o[2], a[3] = o[3], r.clearColor(o[0], o[1], o[2], o[3]));
            }
            r.clear(t);
        }
        resizeGpuRenderTarget(e) {
            if (e.isRoot) return;
            const n = this._renderTargetSystem.getGpuRenderTarget(e);
            this._resizeColor(e, n), (e.stencil || e.depth) && this._resizeStencil(n);
        }
        _initColor(e, t) {
            const n = this._renderer, s = n.gl, r = s.createFramebuffer();
            if (t.resolveTargetFramebuffer = r, s.bindFramebuffer(s.FRAMEBUFFER, r), t.width = e.colorTexture.source.pixelWidth, t.height = e.colorTexture.source.pixelHeight, e.colorTextures.forEach((a, o)=>{
                const l = a.source;
                l.antialias && (n.context.supports.msaa ? t.msaa = !0 : tt("[RenderTexture] Antialiasing on textures is not supported in WebGL1")), n.texture.bindSource(l, 0);
                const d = n.texture.getGlSource(l).texture;
                s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + o, 3553, d, 0);
            }), t.msaa) {
                const a = s.createFramebuffer();
                t.framebuffer = a, s.bindFramebuffer(s.FRAMEBUFFER, a), e.colorTextures.forEach((o, l)=>{
                    const h = s.createRenderbuffer();
                    t.msaaRenderBuffer[l] = h;
                });
            } else t.framebuffer = r;
            this._resizeColor(e, t);
        }
        _resizeColor(e, t) {
            const n = e.colorTexture.source;
            if (t.width = n.pixelWidth, t.height = n.pixelHeight, e.colorTextures.forEach((s, r)=>{
                r !== 0 && s.source.resize(n.width, n.height, n._resolution);
            }), t.msaa) {
                const s = this._renderer, r = s.gl, a = t.framebuffer;
                r.bindFramebuffer(r.FRAMEBUFFER, a), e.colorTextures.forEach((o, l)=>{
                    const h = o.source;
                    s.texture.bindSource(h, 0);
                    const c = s.texture.getGlSource(h).internalFormat, u = t.msaaRenderBuffer[l];
                    r.bindRenderbuffer(r.RENDERBUFFER, u), r.renderbufferStorageMultisample(r.RENDERBUFFER, 4, c, h.pixelWidth, h.pixelHeight), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + l, r.RENDERBUFFER, u);
                });
            }
        }
        _initStencil(e) {
            if (e.framebuffer === null) return;
            const t = this._renderer.gl, n = t.createRenderbuffer();
            e.depthStencilRenderBuffer = n, t.bindRenderbuffer(t.RENDERBUFFER, n), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, n), this._resizeStencil(e);
        }
        _resizeStencil(e) {
            const t = this._renderer.gl;
            t.bindRenderbuffer(t.RENDERBUFFER, e.depthStencilRenderBuffer), e.msaa ? t.renderbufferStorageMultisample(t.RENDERBUFFER, 4, t.DEPTH24_STENCIL8, e.width, e.height) : t.renderbufferStorage(t.RENDERBUFFER, this._renderer.context.webGLVersion === 2 ? t.DEPTH24_STENCIL8 : t.DEPTH_STENCIL, e.width, e.height);
        }
        prerender(e) {
            const t = e.colorTexture.resource;
            this._renderer.context.multiView && Ai.test(t) && this._renderer.context.ensureCanvasSize(t);
        }
        postrender(e) {
            if (this._renderer.context.multiView && Ai.test(e.colorTexture.resource)) {
                const t = this._renderer.context.canvas, n = e.colorTexture;
                n.context2D.drawImage(t, 0, n.pixelHeight - t.height);
            }
        }
    }
    function l1(i, e, t, n, s, r) {
        const a = r ? 1 : -1;
        return i.identity(), i.a = 1 / n * 2, i.d = a * (1 / s * 2), i.tx = -1 - e * i.a, i.ty = -a - t * i.d, i;
    }
    const yr = new Map;
    function M_(i, e) {
        if (!yr.has(i)) {
            const t = new Ie({
                source: new Ai({
                    resource: i,
                    ...e
                })
            }), n = ()=>{
                yr.get(i) === t && yr.delete(i);
            };
            t.once("destroy", n), t.source.once("destroy", n), yr.set(i, t);
        }
        return yr.get(i);
    }
    function c1(i) {
        const e = i.colorTexture.source.resource;
        return globalThis.HTMLCanvasElement && e instanceof HTMLCanvasElement && document.body.contains(e);
    }
    const A_ = class E_ {
        constructor(e = {}){
            if (this.uid = xt("renderTarget"), this.colorTextures = [], this.dirtyId = 0, this.isRoot = !1, this._size = new Float32Array(2), this._managedColorTextures = !1, e = {
                ...E_.defaultOptions,
                ...e
            }, this.stencil = e.stencil, this.depth = e.depth, this.isRoot = e.isRoot, typeof e.colorTextures == "number") {
                this._managedColorTextures = !0;
                for(let t = 0; t < e.colorTextures; t++)this.colorTextures.push(new kt({
                    width: e.width,
                    height: e.height,
                    resolution: e.resolution,
                    antialias: e.antialias
                }));
            } else {
                this.colorTextures = [
                    ...e.colorTextures.map((n)=>n.source)
                ];
                const t = this.colorTexture.source;
                this.resize(t.width, t.height, t._resolution);
            }
            this.colorTexture.source.on("resize", this.onSourceResize, this), (e.depthStencilTexture || this.stencil) && (e.depthStencilTexture instanceof Ie || e.depthStencilTexture instanceof kt ? this.depthStencilTexture = e.depthStencilTexture.source : this.ensureDepthStencilTexture());
        }
        get size() {
            const e = this._size;
            return e[0] = this.pixelWidth, e[1] = this.pixelHeight, e;
        }
        get width() {
            return this.colorTexture.source.width;
        }
        get height() {
            return this.colorTexture.source.height;
        }
        get pixelWidth() {
            return this.colorTexture.source.pixelWidth;
        }
        get pixelHeight() {
            return this.colorTexture.source.pixelHeight;
        }
        get resolution() {
            return this.colorTexture.source._resolution;
        }
        get colorTexture() {
            return this.colorTextures[0];
        }
        onSourceResize(e) {
            this.resize(e.width, e.height, e._resolution, !0);
        }
        ensureDepthStencilTexture() {
            this.depthStencilTexture || (this.depthStencilTexture = new kt({
                width: this.width,
                height: this.height,
                resolution: this.resolution,
                format: "depth24plus-stencil8",
                autoGenerateMipmaps: !1,
                antialias: !1,
                mipLevelCount: 1
            }));
        }
        resize(e, t, n = this.resolution, s = !1) {
            this.dirtyId++, this.colorTextures.forEach((r, a)=>{
                s && a === 0 || r.source.resize(e, t, n);
            }), this.depthStencilTexture && this.depthStencilTexture.source.resize(e, t, n);
        }
        destroy() {
            this.colorTexture.source.off("resize", this.onSourceResize, this), this._managedColorTextures && this.colorTextures.forEach((e)=>{
                e.destroy();
            }), this.depthStencilTexture && (this.depthStencilTexture.destroy(), delete this.depthStencilTexture);
        }
    };
    A_.defaultOptions = {
        width: 0,
        height: 0,
        resolution: 1,
        colorTextures: 1,
        stencil: !1,
        depth: !1,
        antialias: !1,
        isRoot: !1
    };
    let Jc = A_;
    class h1 {
        constructor(e){
            this.rootViewPort = new mt, this.viewport = new mt, this.onRenderTargetChange = new Mm("onRenderTargetChange"), this.projectionMatrix = new Ne, this.defaultClearColor = [
                0,
                0,
                0,
                0
            ], this._renderSurfaceToRenderTargetHash = new Map, this._gpuRenderTargetHash = Object.create(null), this._renderTargetStack = [], this._renderer = e, e.renderableGC.addManagedHash(this, "_gpuRenderTargetHash");
        }
        finishRenderPass() {
            this.adaptor.finishRenderPass(this.renderTarget);
        }
        renderStart({ target: e, clear: t, clearColor: n, frame: s }) {
            this._renderTargetStack.length = 0, this.push(e, t, n, s), this.rootViewPort.copyFrom(this.viewport), this.rootRenderTarget = this.renderTarget, this.renderingToScreen = c1(this.rootRenderTarget), this.adaptor.prerender?.(this.rootRenderTarget);
        }
        postrender() {
            this.adaptor.postrender?.(this.rootRenderTarget);
        }
        bind(e, t = !0, n, s) {
            const r = this.getRenderTarget(e), a = this.renderTarget !== r;
            this.renderTarget = r, this.renderSurface = e;
            const o = this.getGpuRenderTarget(r);
            (r.pixelWidth !== o.width || r.pixelHeight !== o.height) && (this.adaptor.resizeGpuRenderTarget(r), o.width = r.pixelWidth, o.height = r.pixelHeight);
            const l = r.colorTexture, h = this.viewport, d = l.pixelWidth, c = l.pixelHeight;
            if (!s && e instanceof Ie && (s = e.frame), s) {
                const u = l._resolution;
                h.x = s.x * u + .5 | 0, h.y = s.y * u + .5 | 0, h.width = s.width * u + .5 | 0, h.height = s.height * u + .5 | 0;
            } else h.x = 0, h.y = 0, h.width = d, h.height = c;
            return l1(this.projectionMatrix, 0, 0, h.width / l.resolution, h.height / l.resolution, !r.isRoot), this.adaptor.startRenderPass(r, t, n, h), a && this.onRenderTargetChange.emit(r), r;
        }
        clear(e, t = Ei.ALL, n) {
            t && (e && (e = this.getRenderTarget(e)), this.adaptor.clear(e || this.renderTarget, t, n, this.viewport));
        }
        contextChange() {
            this._gpuRenderTargetHash = Object.create(null);
        }
        push(e, t = Ei.ALL, n, s) {
            const r = this.bind(e, t, n, s);
            return this._renderTargetStack.push({
                renderTarget: r,
                frame: s
            }), r;
        }
        pop() {
            this._renderTargetStack.pop();
            const e = this._renderTargetStack[this._renderTargetStack.length - 1];
            this.bind(e.renderTarget, !1, null, e.frame);
        }
        getRenderTarget(e) {
            return e.isTexture && (e = e.source), this._renderSurfaceToRenderTargetHash.get(e) ?? this._initRenderTarget(e);
        }
        copyToTexture(e, t, n, s, r) {
            n.x < 0 && (s.width += n.x, r.x -= n.x, n.x = 0), n.y < 0 && (s.height += n.y, r.y -= n.y, n.y = 0);
            const { pixelWidth: a, pixelHeight: o } = e;
            return s.width = Math.min(s.width, a - n.x), s.height = Math.min(s.height, o - n.y), this.adaptor.copyToTexture(e, t, n, s, r);
        }
        ensureDepthStencil() {
            this.renderTarget.stencil || (this.renderTarget.stencil = !0, this.adaptor.startRenderPass(this.renderTarget, !1, null, this.viewport));
        }
        destroy() {
            this._renderer = null, this._renderSurfaceToRenderTargetHash.forEach((e, t)=>{
                e !== t && e.destroy();
            }), this._renderSurfaceToRenderTargetHash.clear(), this._gpuRenderTargetHash = Object.create(null);
        }
        _initRenderTarget(e) {
            let t = null;
            return Ai.test(e) && (e = M_(e).source), e instanceof Jc ? t = e : e instanceof kt && (t = new Jc({
                colorTextures: [
                    e
                ]
            }), Ai.test(e.source.resource) && (t.isRoot = !0), e.once("destroy", ()=>{
                t.destroy(), this._renderSurfaceToRenderTargetHash.delete(e);
                const n = this._gpuRenderTargetHash[t.uid];
                n && (this._gpuRenderTargetHash[t.uid] = null, this.adaptor.destroyGpuRenderTarget(n));
            })), this._renderSurfaceToRenderTargetHash.set(e, t), t;
        }
        getGpuRenderTarget(e) {
            return this._gpuRenderTargetHash[e.uid] || (this._gpuRenderTargetHash[e.uid] = this.adaptor.initGpuRenderTarget(e));
        }
        resetState() {
            this.renderTarget = null, this.renderSurface = null;
        }
    }
    class w_ extends h1 {
        constructor(e){
            super(e), this.adaptor = new o1, this.adaptor.init(e, this);
        }
    }
    w_.extension = {
        type: [
            J.WebGLSystem
        ],
        name: "renderTarget"
    };
    class R_ extends yn {
        constructor({ buffer: e, offset: t, size: n }){
            super(), this.uid = xt("buffer"), this._resourceType = "bufferResource", this._touched = 0, this._resourceId = xt("resource"), this._bufferResource = !0, this.destroyed = !1, this.buffer = e, this.offset = t | 0, this.size = n, this.buffer.on("change", this.onBufferChange, this);
        }
        onBufferChange() {
            this._resourceId = xt("resource"), this.emit("change", this);
        }
        destroy(e = !1) {
            this.destroyed = !0, e && this.buffer.destroy(), this.emit("change", this), this.buffer = null;
        }
    }
    function u1(i, e) {
        const t = [], n = [
            `
        var g = s.groups;
        var sS = r.shader;
        var p = s.glProgram;
        var ugS = r.uniformGroup;
        var resources;
    `
        ];
        let s = !1, r = 0;
        const a = e._getProgramData(i.glProgram);
        for(const l in i.groups){
            const h = i.groups[l];
            t.push(`
            resources = g[${l}].resources;
        `);
            for(const d in h.resources){
                const c = h.resources[d];
                if (c instanceof rs) if (c.ubo) {
                    const u = i._uniformBindMap[l][Number(d)];
                    t.push(`
                        sS.bindUniformBlock(
                            resources[${d}],
                            '${u}',
                            ${i.glProgram._uniformBlockData[u].index}
                        );
                    `);
                } else t.push(`
                        ugS.updateUniformGroup(resources[${d}], p, sD);
                    `);
                else if (c instanceof R_) {
                    const u = i._uniformBindMap[l][Number(d)];
                    t.push(`
                    sS.bindUniformBlock(
                        resources[${d}],
                        '${u}',
                        ${i.glProgram._uniformBlockData[u].index}
                    );
                `);
                } else if (c instanceof kt) {
                    const u = i._uniformBindMap[l][d], f = a.uniformData[u];
                    f && (s || (s = !0, n.push(`
                        var tS = r.texture;
                        `)), e._gl.uniform1i(f.location, r), t.push(`
                        tS.bind(resources[${d}], ${r});
                    `), r++);
                }
            }
        }
        const o = [
            ...n,
            ...t
        ].join(`
`);
        return new Function("r", "s", "sD", o);
    }
    class d1 {
        constructor(e, t){
            this.program = e, this.uniformData = t, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBlockBindings = {};
        }
        destroy() {
            this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBlockBindings = null, this.program = null;
        }
    }
    function kf(i, e, t) {
        const n = i.createShader(e);
        return i.shaderSource(n, t), i.compileShader(n), n;
    }
    function Ul(i) {
        const e = new Array(i);
        for(let t = 0; t < e.length; t++)e[t] = !1;
        return e;
    }
    function C_(i, e) {
        switch(i){
            case "float":
                return 0;
            case "vec2":
                return new Float32Array(2 * e);
            case "vec3":
                return new Float32Array(3 * e);
            case "vec4":
                return new Float32Array(4 * e);
            case "int":
            case "uint":
            case "sampler2D":
            case "sampler2DArray":
                return 0;
            case "ivec2":
                return new Int32Array(2 * e);
            case "ivec3":
                return new Int32Array(3 * e);
            case "ivec4":
                return new Int32Array(4 * e);
            case "uvec2":
                return new Uint32Array(2 * e);
            case "uvec3":
                return new Uint32Array(3 * e);
            case "uvec4":
                return new Uint32Array(4 * e);
            case "bool":
                return !1;
            case "bvec2":
                return Ul(2 * e);
            case "bvec3":
                return Ul(3 * e);
            case "bvec4":
                return Ul(4 * e);
            case "mat2":
                return new Float32Array([
                    1,
                    0,
                    0,
                    1
                ]);
            case "mat3":
                return new Float32Array([
                    1,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    1
                ]);
            case "mat4":
                return new Float32Array([
                    1,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    1
                ]);
        }
        return null;
    }
    let Fa = null;
    const Gf = {
        FLOAT: "float",
        FLOAT_VEC2: "vec2",
        FLOAT_VEC3: "vec3",
        FLOAT_VEC4: "vec4",
        INT: "int",
        INT_VEC2: "ivec2",
        INT_VEC3: "ivec3",
        INT_VEC4: "ivec4",
        UNSIGNED_INT: "uint",
        UNSIGNED_INT_VEC2: "uvec2",
        UNSIGNED_INT_VEC3: "uvec3",
        UNSIGNED_INT_VEC4: "uvec4",
        BOOL: "bool",
        BOOL_VEC2: "bvec2",
        BOOL_VEC3: "bvec3",
        BOOL_VEC4: "bvec4",
        FLOAT_MAT2: "mat2",
        FLOAT_MAT3: "mat3",
        FLOAT_MAT4: "mat4",
        SAMPLER_2D: "sampler2D",
        INT_SAMPLER_2D: "sampler2D",
        UNSIGNED_INT_SAMPLER_2D: "sampler2D",
        SAMPLER_CUBE: "samplerCube",
        INT_SAMPLER_CUBE: "samplerCube",
        UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
        SAMPLER_2D_ARRAY: "sampler2DArray",
        INT_SAMPLER_2D_ARRAY: "sampler2DArray",
        UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
    }, f1 = {
        float: "float32",
        vec2: "float32x2",
        vec3: "float32x3",
        vec4: "float32x4",
        int: "sint32",
        ivec2: "sint32x2",
        ivec3: "sint32x3",
        ivec4: "sint32x4",
        uint: "uint32",
        uvec2: "uint32x2",
        uvec3: "uint32x3",
        uvec4: "uint32x4",
        bool: "uint32",
        bvec2: "uint32x2",
        bvec3: "uint32x3",
        bvec4: "uint32x4"
    };
    function P_(i, e) {
        if (!Fa) {
            const t = Object.keys(Gf);
            Fa = {};
            for(let n = 0; n < t.length; ++n){
                const s = t[n];
                Fa[i[s]] = Gf[s];
            }
        }
        return Fa[e];
    }
    function p1(i, e) {
        const t = P_(i, e);
        return f1[t] || "float32";
    }
    function m1(i, e, t = !1) {
        const n = {}, s = e.getProgramParameter(i, e.ACTIVE_ATTRIBUTES);
        for(let a = 0; a < s; a++){
            const o = e.getActiveAttrib(i, a);
            if (o.name.startsWith("gl_")) continue;
            const l = p1(e, o.type);
            n[o.name] = {
                location: 0,
                format: l,
                stride: Xr(l).stride,
                offset: 0,
                instance: !1,
                start: 0
            };
        }
        const r = Object.keys(n);
        if (t) {
            r.sort((a, o)=>a > o ? 1 : -1);
            for(let a = 0; a < r.length; a++)n[r[a]].location = a, e.bindAttribLocation(i, a, r[a]);
            e.linkProgram(i);
        } else for(let a = 0; a < r.length; a++)n[r[a]].location = e.getAttribLocation(i, r[a]);
        return n;
    }
    function _1(i, e) {
        if (!e.ACTIVE_UNIFORM_BLOCKS) return {};
        const t = {}, n = e.getProgramParameter(i, e.ACTIVE_UNIFORM_BLOCKS);
        for(let s = 0; s < n; s++){
            const r = e.getActiveUniformBlockName(i, s), a = e.getUniformBlockIndex(i, r), o = e.getActiveUniformBlockParameter(i, s, e.UNIFORM_BLOCK_DATA_SIZE);
            t[r] = {
                name: r,
                index: a,
                size: o
            };
        }
        return t;
    }
    function g1(i, e) {
        const t = {}, n = e.getProgramParameter(i, e.ACTIVE_UNIFORMS);
        for(let s = 0; s < n; s++){
            const r = e.getActiveUniform(i, s), a = r.name.replace(/\[.*?\]$/, ""), o = !!r.name.match(/\[.*?\]$/), l = P_(e, r.type);
            t[a] = {
                name: a,
                index: s,
                type: l,
                size: r.size,
                isArray: o,
                value: C_(l, r.size)
            };
        }
        return t;
    }
    function Hf(i, e) {
        const t = i.getShaderSource(e).split(`
`).map((h, d)=>`${d}: ${h}`), n = i.getShaderInfoLog(e), s = n.split(`
`), r = {}, a = s.map((h)=>parseFloat(h.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter((h)=>h && !r[h] ? (r[h] = !0, !0) : !1), o = [
            ""
        ];
        a.forEach((h)=>{
            t[h - 1] = `%c${t[h - 1]}%c`, o.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
        });
        const l = t.join(`
`);
        o[0] = l, console.error(n), console.groupCollapsed("click to view full shader code"), console.warn(...o), console.groupEnd();
    }
    function x1(i, e, t, n) {
        i.getProgramParameter(e, i.LINK_STATUS) || (i.getShaderParameter(t, i.COMPILE_STATUS) || Hf(i, t), i.getShaderParameter(n, i.COMPILE_STATUS) || Hf(i, n), console.error("PixiJS Error: Could not initialize shader."), i.getProgramInfoLog(e) !== "" && console.warn("PixiJS Warning: gl.getProgramInfoLog()", i.getProgramInfoLog(e)));
    }
    function v1(i, e) {
        const t = kf(i, i.VERTEX_SHADER, e.vertex), n = kf(i, i.FRAGMENT_SHADER, e.fragment), s = i.createProgram();
        i.attachShader(s, t), i.attachShader(s, n);
        const r = e.transformFeedbackVaryings;
        r && (typeof i.transformFeedbackVaryings != "function" ? tt("TransformFeedback is not supported but TransformFeedbackVaryings are given.") : i.transformFeedbackVaryings(s, r.names, r.bufferMode === "separate" ? i.SEPARATE_ATTRIBS : i.INTERLEAVED_ATTRIBS)), i.linkProgram(s), i.getProgramParameter(s, i.LINK_STATUS) || x1(i, s, t, n), e._attributeData = m1(s, i, !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(e.vertex)), e._uniformData = g1(s, i), e._uniformBlockData = _1(s, i), i.deleteShader(t), i.deleteShader(n);
        const a = {};
        for(const l in e._uniformData){
            const h = e._uniformData[l];
            a[l] = {
                location: i.getUniformLocation(s, l),
                value: C_(h.type, h.size)
            };
        }
        return new d1(s, a);
    }
    const Na = {
        textureCount: 0,
        blockIndex: 0
    };
    class I_ {
        constructor(e){
            this._activeProgram = null, this._programDataHash = Object.create(null), this._shaderSyncFunctions = Object.create(null), this._renderer = e, this._renderer.renderableGC.addManagedHash(this, "_programDataHash");
        }
        contextChange(e) {
            this._gl = e, this._programDataHash = Object.create(null), this._shaderSyncFunctions = Object.create(null), this._activeProgram = null, this.maxTextures = go();
        }
        bind(e, t) {
            if (this._setProgram(e.glProgram), t) return;
            Na.textureCount = 0, Na.blockIndex = 0;
            let n = this._shaderSyncFunctions[e.glProgram._key];
            n || (n = this._shaderSyncFunctions[e.glProgram._key] = this._generateShaderSync(e, this)), this._renderer.buffer.nextBindBase(!!e.glProgram.transformFeedbackVaryings), n(this._renderer, e, Na);
        }
        updateUniformGroup(e) {
            this._renderer.uniformGroup.updateUniformGroup(e, this._activeProgram, Na);
        }
        bindUniformBlock(e, t, n = 0) {
            const s = this._renderer.buffer, r = this._getProgramData(this._activeProgram), a = e._bufferResource;
            a || this._renderer.ubo.updateUniformGroup(e);
            const o = e.buffer, l = s.updateBuffer(o), h = s.freeLocationForBufferBase(l);
            if (a) {
                const { offset: c, size: u } = e;
                c === 0 && u === o.data.byteLength ? s.bindBufferBase(l, h) : s.bindBufferRange(l, h, c);
            } else s.getLastBindBaseLocation(l) !== h && s.bindBufferBase(l, h);
            const d = this._activeProgram._uniformBlockData[t].index;
            r.uniformBlockBindings[n] !== h && (r.uniformBlockBindings[n] = h, this._renderer.gl.uniformBlockBinding(r.program, d, h));
        }
        _setProgram(e) {
            if (this._activeProgram === e) return;
            this._activeProgram = e;
            const t = this._getProgramData(e);
            this._gl.useProgram(t.program);
        }
        _getProgramData(e) {
            return this._programDataHash[e._key] || this._createProgramData(e);
        }
        _createProgramData(e) {
            const t = e._key;
            return this._programDataHash[t] = v1(this._gl, e), this._programDataHash[t];
        }
        destroy() {
            for (const e of Object.keys(this._programDataHash))this._programDataHash[e].destroy(), this._programDataHash[e] = null;
            this._programDataHash = null;
        }
        _generateShaderSync(e, t) {
            return u1(e, t);
        }
        resetState() {
            this._activeProgram = null;
        }
    }
    I_.extension = {
        type: [
            J.WebGLSystem
        ],
        name: "shader"
    };
    const y1 = {
        f32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1f(location, v);
        }`,
        "vec2<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2f(location, v[0], v[1]);
        }`,
        "vec3<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3f(location, v[0], v[1], v[2]);
        }`,
        "vec4<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4f(location, v[0], v[1], v[2], v[3]);
        }`,
        i32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
        "vec2<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
        "vec3<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
        "vec4<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
        u32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1ui(location, v);
        }`,
        "vec2<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2ui(location, v[0], v[1]);
        }`,
        "vec3<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3ui(location, v[0], v[1], v[2]);
        }`,
        "vec4<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
        }`,
        bool: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
        "vec2<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
        "vec3<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
        "vec4<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
        "mat2x2<f32>": "gl.uniformMatrix2fv(location, false, v);",
        "mat3x3<f32>": "gl.uniformMatrix3fv(location, false, v);",
        "mat4x4<f32>": "gl.uniformMatrix4fv(location, false, v);"
    }, b1 = {
        f32: "gl.uniform1fv(location, v);",
        "vec2<f32>": "gl.uniform2fv(location, v);",
        "vec3<f32>": "gl.uniform3fv(location, v);",
        "vec4<f32>": "gl.uniform4fv(location, v);",
        "mat2x2<f32>": "gl.uniformMatrix2fv(location, false, v);",
        "mat3x3<f32>": "gl.uniformMatrix3fv(location, false, v);",
        "mat4x4<f32>": "gl.uniformMatrix4fv(location, false, v);",
        i32: "gl.uniform1iv(location, v);",
        "vec2<i32>": "gl.uniform2iv(location, v);",
        "vec3<i32>": "gl.uniform3iv(location, v);",
        "vec4<i32>": "gl.uniform4iv(location, v);",
        u32: "gl.uniform1iv(location, v);",
        "vec2<u32>": "gl.uniform2iv(location, v);",
        "vec3<u32>": "gl.uniform3iv(location, v);",
        "vec4<u32>": "gl.uniform4iv(location, v);",
        bool: "gl.uniform1iv(location, v);",
        "vec2<bool>": "gl.uniform2iv(location, v);",
        "vec3<bool>": "gl.uniform3iv(location, v);",
        "vec4<bool>": "gl.uniform4iv(location, v);"
    };
    function S1(i, e) {
        const t = [
            `
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
        var name = null;
    `
        ];
        for(const n in i.uniforms){
            if (!e[n]) {
                i.uniforms[n] instanceof rs ? i.uniforms[n].ubo ? t.push(`
                        renderer.shader.bindUniformBlock(uv.${n}, "${n}");
                    `) : t.push(`
                        renderer.shader.updateUniformGroup(uv.${n});
                    `) : i.uniforms[n] instanceof R_ && t.push(`
                        renderer.shader.bindBufferResource(uv.${n}, "${n}");
                    `);
                continue;
            }
            const s = i.uniformStructures[n];
            let r = !1;
            for(let a = 0; a < Zi.length; a++){
                const o = Zi[a];
                if (s.type === o.type && o.test(s)) {
                    t.push(`name = "${n}";`, Zi[a].uniform), r = !0;
                    break;
                }
            }
            if (!r) {
                const o = (s.size === 1 ? y1 : b1)[s.type].replace("location", `ud["${n}"].location`);
                t.push(`
            cu = ud["${n}"];
            cv = cu.value;
            v = uv["${n}"];
            ${o};`);
            }
        }
        return new Function("ud", "uv", "renderer", "syncData", t.join(`
`));
    }
    class D_ {
        constructor(e){
            this._cache = {}, this._uniformGroupSyncHash = {}, this._renderer = e, this.gl = null, this._cache = {};
        }
        contextChange(e) {
            this.gl = e;
        }
        updateUniformGroup(e, t, n) {
            const s = this._renderer.shader._getProgramData(t);
            (!e.isStatic || e._dirtyId !== s.uniformDirtyGroups[e.uid]) && (s.uniformDirtyGroups[e.uid] = e._dirtyId, this._getUniformSyncFunction(e, t)(s.uniformData, e.uniforms, this._renderer, n));
        }
        _getUniformSyncFunction(e, t) {
            return this._uniformGroupSyncHash[e._signature]?.[t._key] || this._createUniformSyncFunction(e, t);
        }
        _createUniformSyncFunction(e, t) {
            const n = this._uniformGroupSyncHash[e._signature] || (this._uniformGroupSyncHash[e._signature] = {}), s = this._getSignature(e, t._uniformData, "u");
            return this._cache[s] || (this._cache[s] = this._generateUniformsSync(e, t._uniformData)), n[t._key] = this._cache[s], n[t._key];
        }
        _generateUniformsSync(e, t) {
            return S1(e, t);
        }
        _getSignature(e, t, n) {
            const s = e.uniforms, r = [
                `${n}-`
            ];
            for(const a in s)r.push(a), t[a] && r.push(t[a].type);
            return r.join("-");
        }
        destroy() {
            this._renderer = null, this._cache = null;
        }
    }
    D_.extension = {
        type: [
            J.WebGLSystem
        ],
        name: "uniformGroup"
    };
    function T1(i) {
        const e = {};
        if (e.normal = [
            i.ONE,
            i.ONE_MINUS_SRC_ALPHA
        ], e.add = [
            i.ONE,
            i.ONE
        ], e.multiply = [
            i.DST_COLOR,
            i.ONE_MINUS_SRC_ALPHA,
            i.ONE,
            i.ONE_MINUS_SRC_ALPHA
        ], e.screen = [
            i.ONE,
            i.ONE_MINUS_SRC_COLOR,
            i.ONE,
            i.ONE_MINUS_SRC_ALPHA
        ], e.none = [
            0,
            0
        ], e["normal-npm"] = [
            i.SRC_ALPHA,
            i.ONE_MINUS_SRC_ALPHA,
            i.ONE,
            i.ONE_MINUS_SRC_ALPHA
        ], e["add-npm"] = [
            i.SRC_ALPHA,
            i.ONE,
            i.ONE,
            i.ONE
        ], e["screen-npm"] = [
            i.SRC_ALPHA,
            i.ONE_MINUS_SRC_COLOR,
            i.ONE,
            i.ONE_MINUS_SRC_ALPHA
        ], e.erase = [
            i.ZERO,
            i.ONE_MINUS_SRC_ALPHA
        ], !(i instanceof _t.get().getWebGLRenderingContext())) e.min = [
            i.ONE,
            i.ONE,
            i.ONE,
            i.ONE,
            i.MIN,
            i.MIN
        ], e.max = [
            i.ONE,
            i.ONE,
            i.ONE,
            i.ONE,
            i.MAX,
            i.MAX
        ];
        else {
            const n = i.getExtension("EXT_blend_minmax");
            n && (e.min = [
                i.ONE,
                i.ONE,
                i.ONE,
                i.ONE,
                n.MIN_EXT,
                n.MIN_EXT
            ], e.max = [
                i.ONE,
                i.ONE,
                i.ONE,
                i.ONE,
                n.MAX_EXT,
                n.MAX_EXT
            ]);
        }
        return e;
    }
    const M1 = 0, A1 = 1, E1 = 2, w1 = 3, R1 = 4, C1 = 5, L_ = class Qc {
        constructor(e){
            this._invertFrontFace = !1, this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = "none", this._blendEq = !1, this.map = [], this.map[M1] = this.setBlend, this.map[A1] = this.setOffset, this.map[E1] = this.setCullFace, this.map[w1] = this.setDepthTest, this.map[R1] = this.setFrontFace, this.map[C1] = this.setDepthMask, this.checks = [], this.defaultState = Kr.for2d(), e.renderTarget.onRenderTargetChange.add(this);
        }
        onRenderTargetChange(e) {
            this._invertFrontFace = !e.isRoot, this._cullFace ? this.setFrontFace(this._frontFace) : this._frontFaceDirty = !0;
        }
        contextChange(e) {
            this.gl = e, this.blendModesMap = T1(e), this.resetState();
        }
        set(e) {
            if (e || (e = this.defaultState), this.stateId !== e.data) {
                let t = this.stateId ^ e.data, n = 0;
                for(; t;)t & 1 && this.map[n].call(this, !!(e.data & 1 << n)), t >>= 1, n++;
                this.stateId = e.data;
            }
            for(let t = 0; t < this.checks.length; t++)this.checks[t](this, e);
        }
        forceState(e) {
            e || (e = this.defaultState);
            for(let t = 0; t < this.map.length; t++)this.map[t].call(this, !!(e.data & 1 << t));
            for(let t = 0; t < this.checks.length; t++)this.checks[t](this, e);
            this.stateId = e.data;
        }
        setBlend(e) {
            this._updateCheck(Qc._checkBlendMode, e), this.gl[e ? "enable" : "disable"](this.gl.BLEND);
        }
        setOffset(e) {
            this._updateCheck(Qc._checkPolygonOffset, e), this.gl[e ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
        }
        setDepthTest(e) {
            this.gl[e ? "enable" : "disable"](this.gl.DEPTH_TEST);
        }
        setDepthMask(e) {
            this.gl.depthMask(e);
        }
        setCullFace(e) {
            this._cullFace = e, this.gl[e ? "enable" : "disable"](this.gl.CULL_FACE), this._cullFace && this._frontFaceDirty && this.setFrontFace(this._frontFace);
        }
        setFrontFace(e) {
            this._frontFace = e, this._frontFaceDirty = !1;
            const t = this._invertFrontFace ? !e : e;
            this._glFrontFace !== t && (this._glFrontFace = t, this.gl.frontFace(this.gl[t ? "CW" : "CCW"]));
        }
        setBlendMode(e) {
            if (this.blendModesMap[e] || (e = "normal"), e === this.blendMode) return;
            this.blendMode = e;
            const t = this.blendModesMap[e], n = this.gl;
            t.length === 2 ? n.blendFunc(t[0], t[1]) : n.blendFuncSeparate(t[0], t[1], t[2], t[3]), t.length === 6 ? (this._blendEq = !0, n.blendEquationSeparate(t[4], t[5])) : this._blendEq && (this._blendEq = !1, n.blendEquationSeparate(n.FUNC_ADD, n.FUNC_ADD));
        }
        setPolygonOffset(e, t) {
            this.gl.polygonOffset(e, t);
        }
        resetState() {
            this._glFrontFace = !1, this._frontFace = !1, this._cullFace = !1, this._frontFaceDirty = !1, this._invertFrontFace = !1, this.gl.frontFace(this.gl.CCW), this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1), this.forceState(this.defaultState), this._blendEq = !0, this.blendMode = "", this.setBlendMode("normal");
        }
        _updateCheck(e, t) {
            const n = this.checks.indexOf(e);
            t && n === -1 ? this.checks.push(e) : !t && n !== -1 && this.checks.splice(n, 1);
        }
        static _checkBlendMode(e, t) {
            e.setBlendMode(t.blendMode);
        }
        static _checkPolygonOffset(e, t) {
            e.setPolygonOffset(1, t.polygonOffset);
        }
        destroy() {
            this.gl = null, this.checks.length = 0;
        }
    };
    L_.extension = {
        type: [
            J.WebGLSystem
        ],
        name: "state"
    };
    let P1 = L_;
    class I1 {
        constructor(e){
            this.target = m_.TEXTURE_2D, this.texture = e, this.width = -1, this.height = -1, this.type = it.UNSIGNED_BYTE, this.internalFormat = Zc.RGBA, this.format = Zc.RGBA, this.samplerType = 0;
        }
    }
    const D1 = {
        id: "buffer",
        upload (i, e, t) {
            e.width === i.width || e.height === i.height ? t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, i.width, i.height, e.format, e.type, i.resource) : t.texImage2D(e.target, 0, e.internalFormat, i.width, i.height, 0, e.format, e.type, i.resource), e.width = i.width, e.height = i.height;
        }
    }, L1 = {
        "bc1-rgba-unorm": !0,
        "bc1-rgba-unorm-srgb": !0,
        "bc2-rgba-unorm": !0,
        "bc2-rgba-unorm-srgb": !0,
        "bc3-rgba-unorm": !0,
        "bc3-rgba-unorm-srgb": !0,
        "bc4-r-unorm": !0,
        "bc4-r-snorm": !0,
        "bc5-rg-unorm": !0,
        "bc5-rg-snorm": !0,
        "bc6h-rgb-ufloat": !0,
        "bc6h-rgb-float": !0,
        "bc7-rgba-unorm": !0,
        "bc7-rgba-unorm-srgb": !0,
        "etc2-rgb8unorm": !0,
        "etc2-rgb8unorm-srgb": !0,
        "etc2-rgb8a1unorm": !0,
        "etc2-rgb8a1unorm-srgb": !0,
        "etc2-rgba8unorm": !0,
        "etc2-rgba8unorm-srgb": !0,
        "eac-r11unorm": !0,
        "eac-r11snorm": !0,
        "eac-rg11unorm": !0,
        "eac-rg11snorm": !0,
        "astc-4x4-unorm": !0,
        "astc-4x4-unorm-srgb": !0,
        "astc-5x4-unorm": !0,
        "astc-5x4-unorm-srgb": !0,
        "astc-5x5-unorm": !0,
        "astc-5x5-unorm-srgb": !0,
        "astc-6x5-unorm": !0,
        "astc-6x5-unorm-srgb": !0,
        "astc-6x6-unorm": !0,
        "astc-6x6-unorm-srgb": !0,
        "astc-8x5-unorm": !0,
        "astc-8x5-unorm-srgb": !0,
        "astc-8x6-unorm": !0,
        "astc-8x6-unorm-srgb": !0,
        "astc-8x8-unorm": !0,
        "astc-8x8-unorm-srgb": !0,
        "astc-10x5-unorm": !0,
        "astc-10x5-unorm-srgb": !0,
        "astc-10x6-unorm": !0,
        "astc-10x6-unorm-srgb": !0,
        "astc-10x8-unorm": !0,
        "astc-10x8-unorm-srgb": !0,
        "astc-10x10-unorm": !0,
        "astc-10x10-unorm-srgb": !0,
        "astc-12x10-unorm": !0,
        "astc-12x10-unorm-srgb": !0,
        "astc-12x12-unorm": !0,
        "astc-12x12-unorm-srgb": !0
    }, B1 = {
        id: "compressed",
        upload (i, e, t) {
            t.pixelStorei(t.UNPACK_ALIGNMENT, 4);
            let n = i.pixelWidth, s = i.pixelHeight;
            const r = !!L1[i.format];
            for(let a = 0; a < i.resource.length; a++){
                const o = i.resource[a];
                r ? t.compressedTexImage2D(t.TEXTURE_2D, a, e.internalFormat, n, s, 0, o) : t.texImage2D(t.TEXTURE_2D, a, e.internalFormat, n, s, 0, e.format, e.type, o), n = Math.max(n >> 1, 1), s = Math.max(s >> 1, 1);
            }
        }
    }, B_ = {
        id: "image",
        upload (i, e, t, n) {
            const s = e.width, r = e.height, a = i.pixelWidth, o = i.pixelHeight, l = i.resourceWidth, h = i.resourceHeight;
            l < a || h < o ? ((s !== a || r !== o) && t.texImage2D(e.target, 0, e.internalFormat, a, o, 0, e.format, e.type, null), n === 2 ? t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, l, h, e.format, e.type, i.resource) : t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, e.format, e.type, i.resource)) : s === a && r === o ? t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, e.format, e.type, i.resource) : n === 2 ? t.texImage2D(e.target, 0, e.internalFormat, a, o, 0, e.format, e.type, i.resource) : t.texImage2D(e.target, 0, e.internalFormat, e.format, e.type, i.resource), e.width = a, e.height = o;
        }
    }, U1 = {
        id: "video",
        upload (i, e, t, n) {
            if (!i.isValid) {
                t.texImage2D(e.target, 0, e.internalFormat, 1, 1, 0, e.format, e.type, null);
                return;
            }
            B_.upload(i, e, t, n);
        }
    }, zf = {
        linear: 9729,
        nearest: 9728
    }, F1 = {
        linear: {
            linear: 9987,
            nearest: 9985
        },
        nearest: {
            linear: 9986,
            nearest: 9984
        }
    }, Fl = {
        "clamp-to-edge": 33071,
        repeat: 10497,
        "mirror-repeat": 33648
    }, N1 = {
        never: 512,
        less: 513,
        equal: 514,
        "less-equal": 515,
        greater: 516,
        "not-equal": 517,
        "greater-equal": 518,
        always: 519
    };
    function Vf(i, e, t, n, s, r, a, o) {
        const l = r;
        if (!o || i.addressModeU !== "repeat" || i.addressModeV !== "repeat" || i.addressModeW !== "repeat") {
            const h = Fl[a ? "clamp-to-edge" : i.addressModeU], d = Fl[a ? "clamp-to-edge" : i.addressModeV], c = Fl[a ? "clamp-to-edge" : i.addressModeW];
            e[s](l, e.TEXTURE_WRAP_S, h), e[s](l, e.TEXTURE_WRAP_T, d), e.TEXTURE_WRAP_R && e[s](l, e.TEXTURE_WRAP_R, c);
        }
        if ((!o || i.magFilter !== "linear") && e[s](l, e.TEXTURE_MAG_FILTER, zf[i.magFilter]), t) {
            if (!o || i.mipmapFilter !== "linear") {
                const h = F1[i.minFilter][i.mipmapFilter];
                e[s](l, e.TEXTURE_MIN_FILTER, h);
            }
        } else e[s](l, e.TEXTURE_MIN_FILTER, zf[i.minFilter]);
        if (n && i.maxAnisotropy > 1) {
            const h = Math.min(i.maxAnisotropy, e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
            e[s](l, n.TEXTURE_MAX_ANISOTROPY_EXT, h);
        }
        i.compare && e[s](l, e.TEXTURE_COMPARE_FUNC, N1[i.compare]);
    }
    function O1(i) {
        return {
            r8unorm: i.RED,
            r8snorm: i.RED,
            r8uint: i.RED,
            r8sint: i.RED,
            r16uint: i.RED,
            r16sint: i.RED,
            r16float: i.RED,
            rg8unorm: i.RG,
            rg8snorm: i.RG,
            rg8uint: i.RG,
            rg8sint: i.RG,
            r32uint: i.RED,
            r32sint: i.RED,
            r32float: i.RED,
            rg16uint: i.RG,
            rg16sint: i.RG,
            rg16float: i.RG,
            rgba8unorm: i.RGBA,
            "rgba8unorm-srgb": i.RGBA,
            rgba8snorm: i.RGBA,
            rgba8uint: i.RGBA,
            rgba8sint: i.RGBA,
            bgra8unorm: i.RGBA,
            "bgra8unorm-srgb": i.RGBA,
            rgb9e5ufloat: i.RGB,
            rgb10a2unorm: i.RGBA,
            rg11b10ufloat: i.RGB,
            rg32uint: i.RG,
            rg32sint: i.RG,
            rg32float: i.RG,
            rgba16uint: i.RGBA,
            rgba16sint: i.RGBA,
            rgba16float: i.RGBA,
            rgba32uint: i.RGBA,
            rgba32sint: i.RGBA,
            rgba32float: i.RGBA,
            stencil8: i.STENCIL_INDEX8,
            depth16unorm: i.DEPTH_COMPONENT,
            depth24plus: i.DEPTH_COMPONENT,
            "depth24plus-stencil8": i.DEPTH_STENCIL,
            depth32float: i.DEPTH_COMPONENT,
            "depth32float-stencil8": i.DEPTH_STENCIL
        };
    }
    function k1(i, e) {
        let t = {}, n = i.RGBA;
        return i instanceof _t.get().getWebGLRenderingContext() ? e.srgb && (t = {
            "rgba8unorm-srgb": e.srgb.SRGB8_ALPHA8_EXT,
            "bgra8unorm-srgb": e.srgb.SRGB8_ALPHA8_EXT
        }) : (t = {
            "rgba8unorm-srgb": i.SRGB8_ALPHA8,
            "bgra8unorm-srgb": i.SRGB8_ALPHA8
        }, n = i.RGBA8), {
            r8unorm: i.R8,
            r8snorm: i.R8_SNORM,
            r8uint: i.R8UI,
            r8sint: i.R8I,
            r16uint: i.R16UI,
            r16sint: i.R16I,
            r16float: i.R16F,
            rg8unorm: i.RG8,
            rg8snorm: i.RG8_SNORM,
            rg8uint: i.RG8UI,
            rg8sint: i.RG8I,
            r32uint: i.R32UI,
            r32sint: i.R32I,
            r32float: i.R32F,
            rg16uint: i.RG16UI,
            rg16sint: i.RG16I,
            rg16float: i.RG16F,
            rgba8unorm: i.RGBA,
            ...t,
            rgba8snorm: i.RGBA8_SNORM,
            rgba8uint: i.RGBA8UI,
            rgba8sint: i.RGBA8I,
            bgra8unorm: n,
            rgb9e5ufloat: i.RGB9_E5,
            rgb10a2unorm: i.RGB10_A2,
            rg11b10ufloat: i.R11F_G11F_B10F,
            rg32uint: i.RG32UI,
            rg32sint: i.RG32I,
            rg32float: i.RG32F,
            rgba16uint: i.RGBA16UI,
            rgba16sint: i.RGBA16I,
            rgba16float: i.RGBA16F,
            rgba32uint: i.RGBA32UI,
            rgba32sint: i.RGBA32I,
            rgba32float: i.RGBA32F,
            stencil8: i.STENCIL_INDEX8,
            depth16unorm: i.DEPTH_COMPONENT16,
            depth24plus: i.DEPTH_COMPONENT24,
            "depth24plus-stencil8": i.DEPTH24_STENCIL8,
            depth32float: i.DEPTH_COMPONENT32F,
            "depth32float-stencil8": i.DEPTH32F_STENCIL8,
            ...e.s3tc ? {
                "bc1-rgba-unorm": e.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,
                "bc2-rgba-unorm": e.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,
                "bc3-rgba-unorm": e.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT
            } : {},
            ...e.s3tc_sRGB ? {
                "bc1-rgba-unorm-srgb": e.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
                "bc2-rgba-unorm-srgb": e.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
                "bc3-rgba-unorm-srgb": e.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
            } : {},
            ...e.rgtc ? {
                "bc4-r-unorm": e.rgtc.COMPRESSED_RED_RGTC1_EXT,
                "bc4-r-snorm": e.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,
                "bc5-rg-unorm": e.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,
                "bc5-rg-snorm": e.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
            } : {},
            ...e.bptc ? {
                "bc6h-rgb-float": e.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,
                "bc6h-rgb-ufloat": e.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,
                "bc7-rgba-unorm": e.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,
                "bc7-rgba-unorm-srgb": e.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            } : {},
            ...e.etc ? {
                "etc2-rgb8unorm": e.etc.COMPRESSED_RGB8_ETC2,
                "etc2-rgb8unorm-srgb": e.etc.COMPRESSED_SRGB8_ETC2,
                "etc2-rgb8a1unorm": e.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
                "etc2-rgb8a1unorm-srgb": e.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,
                "etc2-rgba8unorm": e.etc.COMPRESSED_RGBA8_ETC2_EAC,
                "etc2-rgba8unorm-srgb": e.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,
                "eac-r11unorm": e.etc.COMPRESSED_R11_EAC,
                "eac-rg11unorm": e.etc.COMPRESSED_SIGNED_RG11_EAC
            } : {},
            ...e.astc ? {
                "astc-4x4-unorm": e.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,
                "astc-4x4-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,
                "astc-5x4-unorm": e.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,
                "astc-5x4-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,
                "astc-5x5-unorm": e.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,
                "astc-5x5-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,
                "astc-6x5-unorm": e.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,
                "astc-6x5-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,
                "astc-6x6-unorm": e.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,
                "astc-6x6-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,
                "astc-8x5-unorm": e.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,
                "astc-8x5-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,
                "astc-8x6-unorm": e.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,
                "astc-8x6-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,
                "astc-8x8-unorm": e.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,
                "astc-8x8-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,
                "astc-10x5-unorm": e.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,
                "astc-10x5-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,
                "astc-10x6-unorm": e.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,
                "astc-10x6-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,
                "astc-10x8-unorm": e.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,
                "astc-10x8-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,
                "astc-10x10-unorm": e.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,
                "astc-10x10-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,
                "astc-12x10-unorm": e.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,
                "astc-12x10-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,
                "astc-12x12-unorm": e.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,
                "astc-12x12-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            } : {}
        };
    }
    function G1(i) {
        return {
            r8unorm: i.UNSIGNED_BYTE,
            r8snorm: i.BYTE,
            r8uint: i.UNSIGNED_BYTE,
            r8sint: i.BYTE,
            r16uint: i.UNSIGNED_SHORT,
            r16sint: i.SHORT,
            r16float: i.HALF_FLOAT,
            rg8unorm: i.UNSIGNED_BYTE,
            rg8snorm: i.BYTE,
            rg8uint: i.UNSIGNED_BYTE,
            rg8sint: i.BYTE,
            r32uint: i.UNSIGNED_INT,
            r32sint: i.INT,
            r32float: i.FLOAT,
            rg16uint: i.UNSIGNED_SHORT,
            rg16sint: i.SHORT,
            rg16float: i.HALF_FLOAT,
            rgba8unorm: i.UNSIGNED_BYTE,
            "rgba8unorm-srgb": i.UNSIGNED_BYTE,
            rgba8snorm: i.BYTE,
            rgba8uint: i.UNSIGNED_BYTE,
            rgba8sint: i.BYTE,
            bgra8unorm: i.UNSIGNED_BYTE,
            "bgra8unorm-srgb": i.UNSIGNED_BYTE,
            rgb9e5ufloat: i.UNSIGNED_INT_5_9_9_9_REV,
            rgb10a2unorm: i.UNSIGNED_INT_2_10_10_10_REV,
            rg11b10ufloat: i.UNSIGNED_INT_10F_11F_11F_REV,
            rg32uint: i.UNSIGNED_INT,
            rg32sint: i.INT,
            rg32float: i.FLOAT,
            rgba16uint: i.UNSIGNED_SHORT,
            rgba16sint: i.SHORT,
            rgba16float: i.HALF_FLOAT,
            rgba32uint: i.UNSIGNED_INT,
            rgba32sint: i.INT,
            rgba32float: i.FLOAT,
            stencil8: i.UNSIGNED_BYTE,
            depth16unorm: i.UNSIGNED_SHORT,
            depth24plus: i.UNSIGNED_INT,
            "depth24plus-stencil8": i.UNSIGNED_INT_24_8,
            depth32float: i.FLOAT,
            "depth32float-stencil8": i.FLOAT_32_UNSIGNED_INT_24_8_REV
        };
    }
    const H1 = 4;
    class U_ {
        constructor(e){
            this.managedTextures = [], this._glTextures = Object.create(null), this._glSamplers = Object.create(null), this._boundTextures = [], this._activeTextureLocation = -1, this._boundSamplers = Object.create(null), this._uploads = {
                image: B_,
                buffer: D1,
                video: U1,
                compressed: B1
            }, this._premultiplyAlpha = !1, this._useSeparateSamplers = !1, this._renderer = e, this._renderer.renderableGC.addManagedHash(this, "_glTextures"), this._renderer.renderableGC.addManagedHash(this, "_glSamplers");
        }
        contextChange(e) {
            this._gl = e, this._mapFormatToInternalFormat || (this._mapFormatToInternalFormat = k1(e, this._renderer.context.extensions), this._mapFormatToType = G1(e), this._mapFormatToFormat = O1(e)), this._glTextures = Object.create(null), this._glSamplers = Object.create(null), this._boundSamplers = Object.create(null), this._premultiplyAlpha = !1;
            for(let t = 0; t < 16; t++)this.bind(Ie.EMPTY, t);
        }
        initSource(e) {
            this.bind(e);
        }
        bind(e, t = 0) {
            const n = e.source;
            e ? (this.bindSource(n, t), this._useSeparateSamplers && this._bindSampler(n.style, t)) : (this.bindSource(null, t), this._useSeparateSamplers && this._bindSampler(null, t));
        }
        bindSource(e, t = 0) {
            const n = this._gl;
            if (e._touched = this._renderer.textureGC.count, this._boundTextures[t] !== e) {
                this._boundTextures[t] = e, this._activateLocation(t), e || (e = Ie.EMPTY.source);
                const s = this.getGlSource(e);
                n.bindTexture(s.target, s.texture);
            }
        }
        _bindSampler(e, t = 0) {
            const n = this._gl;
            if (!e) {
                this._boundSamplers[t] = null, n.bindSampler(t, null);
                return;
            }
            const s = this._getGlSampler(e);
            this._boundSamplers[t] !== s && (this._boundSamplers[t] = s, n.bindSampler(t, s));
        }
        unbind(e) {
            const t = e.source, n = this._boundTextures, s = this._gl;
            for(let r = 0; r < n.length; r++)if (n[r] === t) {
                this._activateLocation(r);
                const a = this.getGlSource(t);
                s.bindTexture(a.target, null), n[r] = null;
            }
        }
        _activateLocation(e) {
            this._activeTextureLocation !== e && (this._activeTextureLocation = e, this._gl.activeTexture(this._gl.TEXTURE0 + e));
        }
        _initSource(e) {
            const t = this._gl, n = new I1(t.createTexture());
            if (n.type = this._mapFormatToType[e.format], n.internalFormat = this._mapFormatToInternalFormat[e.format], n.format = this._mapFormatToFormat[e.format], e.autoGenerateMipmaps && (this._renderer.context.supports.nonPowOf2mipmaps || e.isPowerOfTwo)) {
                const s = Math.max(e.width, e.height);
                e.mipLevelCount = Math.floor(Math.log2(s)) + 1;
            }
            return this._glTextures[e.uid] = n, this.managedTextures.includes(e) || (e.on("update", this.onSourceUpdate, this), e.on("resize", this.onSourceUpdate, this), e.on("styleChange", this.onStyleChange, this), e.on("destroy", this.onSourceDestroy, this), e.on("unload", this.onSourceUnload, this), e.on("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.push(e)), this.onSourceUpdate(e), this.updateStyle(e, !1), n;
        }
        onStyleChange(e) {
            this.updateStyle(e, !1);
        }
        updateStyle(e, t) {
            const n = this._gl, s = this.getGlSource(e);
            n.bindTexture(n.TEXTURE_2D, s.texture), this._boundTextures[this._activeTextureLocation] = e, Vf(e.style, n, e.mipLevelCount > 1, this._renderer.context.extensions.anisotropicFiltering, "texParameteri", n.TEXTURE_2D, !this._renderer.context.supports.nonPowOf2wrapping && !e.isPowerOfTwo, t);
        }
        onSourceUnload(e) {
            const t = this._glTextures[e.uid];
            t && (this.unbind(e), this._glTextures[e.uid] = null, this._gl.deleteTexture(t.texture));
        }
        onSourceUpdate(e) {
            const t = this._gl, n = this.getGlSource(e);
            t.bindTexture(t.TEXTURE_2D, n.texture), this._boundTextures[this._activeTextureLocation] = e;
            const s = e.alphaMode === "premultiply-alpha-on-upload";
            this._premultiplyAlpha !== s && (this._premultiplyAlpha = s, t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, s)), this._uploads[e.uploadMethodId] ? this._uploads[e.uploadMethodId].upload(e, n, t, this._renderer.context.webGLVersion) : t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, e.pixelWidth, e.pixelHeight, 0, t.RGBA, t.UNSIGNED_BYTE, null), e.autoGenerateMipmaps && e.mipLevelCount > 1 && this.onUpdateMipmaps(e, !1);
        }
        onUpdateMipmaps(e, t = !0) {
            t && this.bindSource(e, 0);
            const n = this.getGlSource(e);
            this._gl.generateMipmap(n.target);
        }
        onSourceDestroy(e) {
            e.off("destroy", this.onSourceDestroy, this), e.off("update", this.onSourceUpdate, this), e.off("resize", this.onSourceUpdate, this), e.off("unload", this.onSourceUnload, this), e.off("styleChange", this.onStyleChange, this), e.off("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.splice(this.managedTextures.indexOf(e), 1), this.onSourceUnload(e);
        }
        _initSampler(e) {
            const t = this._gl, n = this._gl.createSampler();
            return this._glSamplers[e._resourceId] = n, Vf(e, t, this._boundTextures[this._activeTextureLocation].mipLevelCount > 1, this._renderer.context.extensions.anisotropicFiltering, "samplerParameteri", n, !1, !0), this._glSamplers[e._resourceId];
        }
        _getGlSampler(e) {
            return this._glSamplers[e._resourceId] || this._initSampler(e);
        }
        getGlSource(e) {
            return this._glTextures[e.uid] || this._initSource(e);
        }
        generateCanvas(e) {
            const { pixels: t, width: n, height: s } = this.getPixels(e), r = _t.get().createCanvas();
            r.width = n, r.height = s;
            const a = r.getContext("2d");
            if (a) {
                const o = a.createImageData(n, s);
                o.data.set(t), a.putImageData(o, 0, 0);
            }
            return r;
        }
        getPixels(e) {
            const t = e.source.resolution, n = e.frame, s = Math.max(Math.round(n.width * t), 1), r = Math.max(Math.round(n.height * t), 1), a = new Uint8Array(H1 * s * r), o = this._renderer, l = o.renderTarget.getRenderTarget(e), h = o.renderTarget.getGpuRenderTarget(l), d = o.gl;
            return d.bindFramebuffer(d.FRAMEBUFFER, h.resolveTargetFramebuffer), d.readPixels(Math.round(n.x * t), Math.round(n.y * t), s, r, d.RGBA, d.UNSIGNED_BYTE, a), {
                pixels: new Uint8ClampedArray(a.buffer),
                width: s,
                height: r
            };
        }
        destroy() {
            this.managedTextures.slice().forEach((e)=>this.onSourceDestroy(e)), this.managedTextures = null, this._renderer = null;
        }
        resetState() {
            this._activeTextureLocation = -1, this._boundTextures.fill(Ie.EMPTY.source), this._boundSamplers = Object.create(null);
            const e = this._gl;
            this._premultiplyAlpha = !1, e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._premultiplyAlpha);
        }
    }
    U_.extension = {
        type: [
            J.WebGLSystem
        ],
        name: "texture"
    };
    class F_ {
        init() {
            const e = new rs({
                uColor: {
                    value: new Float32Array([
                        1,
                        1,
                        1,
                        1
                    ]),
                    type: "vec4<f32>"
                },
                uTransformMatrix: {
                    value: new Ne,
                    type: "mat3x3<f32>"
                },
                uRound: {
                    value: 0,
                    type: "f32"
                }
            }), t = go(), n = Oh({
                name: "graphics",
                bits: [
                    Fm,
                    Nm(t),
                    c_,
                    kh
                ]
            });
            this.shader = new as({
                glProgram: n,
                resources: {
                    localUniforms: e,
                    batchSamplers: Om(t)
                }
            });
        }
        execute(e, t) {
            const n = t.context, s = n.customShader || this.shader, r = e.renderer, a = r.graphicsContext, { batcher: o, instructions: l } = a.getContextRenderData(n);
            s.groups[0] = r.globalUniforms.bindGroup, r.state.set(e.state), r.shader.bind(s), r.geometry.bind(o.geometry, s.glProgram);
            const h = l.instructions;
            for(let d = 0; d < l.instructionSize; d++){
                const c = h[d];
                if (c.size) {
                    for(let u = 0; u < c.textures.count; u++)r.texture.bind(c.textures.textures[u], u);
                    r.geometry.draw(c.topology, c.size, c.start);
                }
            }
        }
        destroy() {
            this.shader.destroy(!0), this.shader = null;
        }
    }
    F_.extension = {
        type: [
            J.WebGLPipesAdaptor
        ],
        name: "graphics"
    };
    class N_ {
        init() {
            const e = Oh({
                name: "mesh",
                bits: [
                    c_,
                    Ww,
                    kh
                ]
            });
            this._shader = new as({
                glProgram: e,
                resources: {
                    uTexture: Ie.EMPTY.source,
                    textureUniforms: {
                        uTextureMatrix: {
                            type: "mat3x3<f32>",
                            value: new Ne
                        }
                    }
                }
            });
        }
        execute(e, t) {
            const n = e.renderer;
            let s = t._shader;
            if (s) {
                if (!s.glProgram) {
                    tt("Mesh shader has no glProgram", t.shader);
                    return;
                }
            } else {
                s = this._shader;
                const r = t.texture, a = r.source;
                s.resources.uTexture = a, s.resources.uSampler = a.style, s.resources.textureUniforms.uniforms.uTextureMatrix = r.textureMatrix.mapCoord;
            }
            s.groups[100] = n.globalUniforms.bindGroup, s.groups[101] = e.localUniformsBindGroup, n.encoder.draw({
                geometry: t._geometry,
                shader: s,
                state: t.state
            });
        }
        destroy() {
            this._shader.destroy(!0), this._shader = null;
        }
    }
    N_.extension = {
        type: [
            J.WebGLPipesAdaptor
        ],
        name: "mesh"
    };
    class O_ {
        constructor(e){
            this._renderer = e;
        }
        updateRenderable() {}
        destroyRenderable() {}
        validateRenderable() {
            return !1;
        }
        addRenderable(e, t) {
            this._renderer.renderPipes.batch.break(t), t.add(e);
        }
        execute(e) {
            e.isRenderable && e.render(this._renderer);
        }
        destroy() {
            this._renderer = null;
        }
    }
    O_.extension = {
        type: [
            J.WebGLPipes,
            J.WebGPUPipes,
            J.CanvasPipes
        ],
        name: "customRender"
    };
    k_ = class {
        constructor(){
            this.batcherName = "default", this.topology = "triangle-list", this.attributeSize = 4, this.indexSize = 6, this.packAsQuad = !0, this.roundPixels = 0, this._attributeStart = 0, this._batcher = null, this._batch = null;
        }
        get blendMode() {
            return this.renderable.groupBlendMode;
        }
        get color() {
            return this.renderable.groupColorAlpha;
        }
        reset() {
            this.renderable = null, this.texture = null, this._batcher = null, this._batch = null, this.bounds = null;
        }
    };
    function eh(i, e) {
        const t = i.instructionSet, n = t.instructions;
        for(let s = 0; s < t.instructionSize; s++){
            const r = n[s];
            e[r.renderPipeId].execute(r);
        }
    }
    const z1 = new Ne;
    class G_ {
        constructor(e){
            this._renderer = e;
        }
        addRenderGroup(e, t) {
            e.isCachedAsTexture ? this._addRenderableCacheAsTexture(e, t) : this._addRenderableDirect(e, t);
        }
        execute(e) {
            e.isRenderable && (e.isCachedAsTexture ? this._executeCacheAsTexture(e) : this._executeDirect(e));
        }
        destroy() {
            this._renderer = null;
        }
        _addRenderableDirect(e, t) {
            this._renderer.renderPipes.batch.break(t), e._batchableRenderGroup && (Vt.return(e._batchableRenderGroup), e._batchableRenderGroup = null), t.add(e);
        }
        _addRenderableCacheAsTexture(e, t) {
            const n = e._batchableRenderGroup ?? (e._batchableRenderGroup = Vt.get(k_));
            n.renderable = e.root, n.transform = e.root.relativeGroupTransform, n.texture = e.texture, n.bounds = e._textureBounds, t.add(e), this._renderer.renderPipes.batch.addToBatch(n, t);
        }
        _executeCacheAsTexture(e) {
            if (e.textureNeedsUpdate) {
                e.textureNeedsUpdate = !1;
                const t = z1.identity().translate(-e._textureBounds.x, -e._textureBounds.y);
                this._renderer.renderTarget.push(e.texture, !0, null, e.texture.frame), this._renderer.globalUniforms.push({
                    worldTransformMatrix: t,
                    worldColor: 4294967295
                }), eh(e, this._renderer.renderPipes), this._renderer.renderTarget.finishRenderPass(), this._renderer.renderTarget.pop(), this._renderer.globalUniforms.pop();
            }
            e._batchableRenderGroup._batcher.updateElement(e._batchableRenderGroup), e._batchableRenderGroup._batcher.geometry.buffers[0].update();
        }
        _executeDirect(e) {
            this._renderer.globalUniforms.push({
                worldTransformMatrix: e.inverseParentTextureTransform,
                worldColor: e.worldColorAlpha
            }), eh(e, this._renderer.renderPipes), this._renderer.globalUniforms.pop();
        }
    }
    G_.extension = {
        type: [
            J.WebGLPipes,
            J.WebGPUPipes,
            J.CanvasPipes
        ],
        name: "renderGroup"
    };
    function th(i, e) {
        e || (e = 0);
        for(let t = e; t < i.length && i[t]; t++)i[t] = null;
    }
    const V1 = new Jt, Wf = Lr | oo | Ih;
    function H_(i, e = !1) {
        W1(i);
        const t = i.childrenToUpdate, n = i.updateTick++;
        for(const s in t){
            const r = Number(s), a = t[s], o = a.list, l = a.index;
            for(let h = 0; h < l; h++){
                const d = o[h];
                d.parentRenderGroup === i && d.relativeRenderGroupDepth === r && z_(d, n, 0);
            }
            th(o, l), a.index = 0;
        }
        if (e) for(let s = 0; s < i.renderGroupChildren.length; s++)H_(i.renderGroupChildren[s], e);
    }
    function W1(i) {
        const e = i.root;
        let t;
        if (i.renderGroupParent) {
            const n = i.renderGroupParent;
            i.worldTransform.appendFrom(e.relativeGroupTransform, n.worldTransform), i.worldColor = ao(e.groupColor, n.worldColor), t = e.groupAlpha * n.worldAlpha;
        } else i.worldTransform.copyFrom(e.localTransform), i.worldColor = e.localColor, t = e.localAlpha;
        t = t < 0 ? 0 : t > 1 ? 1 : t, i.worldAlpha = t, i.worldColorAlpha = i.worldColor + ((t * 255 | 0) << 24);
    }
    function z_(i, e, t) {
        if (e === i.updateTick) return;
        i.updateTick = e, i.didChange = !1;
        const n = i.localTransform;
        i.updateLocalTransform();
        const s = i.parent;
        if (s && !s.renderGroup ? (t |= i._updateFlags, i.relativeGroupTransform.appendFrom(n, s.relativeGroupTransform), t & Wf && Xf(i, s, t)) : (t = i._updateFlags, i.relativeGroupTransform.copyFrom(n), t & Wf && Xf(i, V1, t)), !i.renderGroup) {
            const r = i.children, a = r.length;
            for(let h = 0; h < a; h++)z_(r[h], e, t);
            const o = i.parentRenderGroup, l = i;
            l.renderPipeId && !o.structureDidChange && o.updateRenderable(l);
        }
    }
    function Xf(i, e, t) {
        if (t & oo) {
            i.groupColor = ao(i.localColor, e.groupColor);
            let n = i.localAlpha * e.groupAlpha;
            n = n < 0 ? 0 : n > 1 ? 1 : n, i.groupAlpha = n, i.groupColorAlpha = i.groupColor + ((n * 255 | 0) << 24);
        }
        t & Ih && (i.groupBlendMode = i.localBlendMode === "inherit" ? e.groupBlendMode : i.localBlendMode), t & Lr && (i.globalDisplayStatus = i.localDisplayStatus & e.globalDisplayStatus), i._updateFlags = 0;
    }
    function X1(i, e) {
        const { list: t, index: n } = i.childrenRenderablesToUpdate;
        let s = !1;
        for(let r = 0; r < n; r++){
            const a = t[r];
            if (s = e[a.renderPipeId].validateRenderable(a), s) break;
        }
        return i.structureDidChange = s, s;
    }
    const Y1 = new Ne;
    class V_ {
        constructor(e){
            this._renderer = e;
        }
        render({ container: e, transform: t }) {
            const n = e.parent, s = e.renderGroup.renderGroupParent;
            e.parent = null, e.renderGroup.renderGroupParent = null;
            const r = this._renderer;
            let a = Y1;
            t && (a = a.copyFrom(e.renderGroup.localTransform), e.renderGroup.localTransform.copyFrom(t));
            const o = r.renderPipes;
            this._updateCachedRenderGroups(e.renderGroup, null), this._updateRenderGroups(e.renderGroup), r.globalUniforms.start({
                worldTransformMatrix: t ? e.renderGroup.localTransform : e.renderGroup.worldTransform,
                worldColor: e.renderGroup.worldColorAlpha
            }), eh(e.renderGroup, o), o.uniformBatch && o.uniformBatch.renderEnd(), t && e.renderGroup.localTransform.copyFrom(a), e.parent = n, e.renderGroup.renderGroupParent = s;
        }
        destroy() {
            this._renderer = null;
        }
        _updateCachedRenderGroups(e, t) {
            if (e.isCachedAsTexture) {
                if (!e.updateCacheTexture) return;
                t = e;
            }
            e._parentCacheAsTextureRenderGroup = t;
            for(let n = e.renderGroupChildren.length - 1; n >= 0; n--)this._updateCachedRenderGroups(e.renderGroupChildren[n], t);
            if (e.invalidateMatrices(), e.isCachedAsTexture) {
                if (e.textureNeedsUpdate) {
                    const n = e.root.getLocalBounds();
                    n.ceil();
                    const s = e.texture;
                    e.texture && Ls.returnTexture(e.texture);
                    const r = this._renderer, a = e.textureOptions.resolution || r.view.resolution, o = e.textureOptions.antialias ?? r.view.antialias;
                    e.texture = Ls.getOptimalTexture(n.width, n.height, a, o), e._textureBounds || (e._textureBounds = new sn), e._textureBounds.copyFrom(n), s !== e.texture && e.renderGroupParent && (e.renderGroupParent.structureDidChange = !0);
                }
            } else e.texture && (Ls.returnTexture(e.texture), e.texture = null);
        }
        _updateRenderGroups(e) {
            const t = this._renderer, n = t.renderPipes;
            if (e.runOnRender(t), e.instructionSet.renderPipes = n, e.structureDidChange ? th(e.childrenRenderablesToUpdate.list, 0) : X1(e, n), H_(e), e.structureDidChange ? (e.structureDidChange = !1, this._buildInstructions(e, t)) : this._updateRenderables(e), e.childrenRenderablesToUpdate.index = 0, t.renderPipes.batch.upload(e.instructionSet), !(e.isCachedAsTexture && !e.textureNeedsUpdate)) for(let s = 0; s < e.renderGroupChildren.length; s++)this._updateRenderGroups(e.renderGroupChildren[s]);
        }
        _updateRenderables(e) {
            const { list: t, index: n } = e.childrenRenderablesToUpdate;
            for(let s = 0; s < n; s++){
                const r = t[s];
                r.didViewUpdate && e.updateRenderable(r);
            }
            th(t, n);
        }
        _buildInstructions(e, t) {
            const n = e.root, s = e.instructionSet;
            s.reset();
            const r = t.renderPipes ? t : t.batch.renderer, a = r.renderPipes;
            a.batch.buildStart(s), a.blendMode.buildStart(), a.colorMask.buildStart(), n.sortableChildren && n.sortChildren(), n.collectRenderablesWithEffects(s, r, null), a.batch.buildEnd(s), a.blendMode.buildEnd(s);
        }
    }
    V_.extension = {
        type: [
            J.WebGLSystem,
            J.WebGPUSystem,
            J.CanvasSystem
        ],
        name: "renderGroup"
    };
    class W_ {
        constructor(e){
            this._gpuSpriteHash = Object.create(null), this._destroyRenderableBound = this.destroyRenderable.bind(this), this._renderer = e, this._renderer.renderableGC.addManagedHash(this, "_gpuSpriteHash");
        }
        addRenderable(e, t) {
            const n = this._getGpuSprite(e);
            e.didViewUpdate && this._updateBatchableSprite(e, n), this._renderer.renderPipes.batch.addToBatch(n, t);
        }
        updateRenderable(e) {
            const t = this._gpuSpriteHash[e.uid];
            e.didViewUpdate && this._updateBatchableSprite(e, t), t._batcher.updateElement(t);
        }
        validateRenderable(e) {
            const t = this._getGpuSprite(e);
            return !t._batcher.checkAndUpdateTexture(t, e._texture);
        }
        destroyRenderable(e) {
            const t = this._gpuSpriteHash[e.uid];
            Vt.return(t), this._gpuSpriteHash[e.uid] = null, e.off("destroyed", this._destroyRenderableBound);
        }
        _updateBatchableSprite(e, t) {
            t.bounds = e.visualBounds, t.texture = e._texture;
        }
        _getGpuSprite(e) {
            return this._gpuSpriteHash[e.uid] || this._initGPUSprite(e);
        }
        _initGPUSprite(e) {
            const t = Vt.get(k_);
            return t.renderable = e, t.transform = e.groupTransform, t.texture = e._texture, t.bounds = e.visualBounds, t.roundPixels = this._renderer._roundPixels | e._roundPixels, this._gpuSpriteHash[e.uid] = t, e.on("destroyed", this._destroyRenderableBound), t;
        }
        destroy() {
            for(const e in this._gpuSpriteHash)Vt.return(this._gpuSpriteHash[e]);
            this._gpuSpriteHash = null, this._renderer = null;
        }
    }
    W_.extension = {
        type: [
            J.WebGLPipes,
            J.WebGPUPipes,
            J.CanvasPipes
        ],
        name: "sprite"
    };
    const Kh = class X_ {
        constructor(){
            this.clearBeforeRender = !0, this._backgroundColor = new Et(0), this.color = this._backgroundColor, this.alpha = 1;
        }
        init(e) {
            e = {
                ...X_.defaultOptions,
                ...e
            }, this.clearBeforeRender = e.clearBeforeRender, this.color = e.background || e.backgroundColor || this._backgroundColor, this.alpha = e.backgroundAlpha, this._backgroundColor.setAlpha(e.backgroundAlpha);
        }
        get color() {
            return this._backgroundColor;
        }
        set color(e) {
            this._backgroundColor.setValue(e);
        }
        get alpha() {
            return this._backgroundColor.alpha;
        }
        set alpha(e) {
            this._backgroundColor.setAlpha(e);
        }
        get colorRgba() {
            return this._backgroundColor.toArray();
        }
        destroy() {}
    };
    Kh.extension = {
        type: [
            J.WebGLSystem,
            J.WebGPUSystem,
            J.CanvasSystem
        ],
        name: "background",
        priority: 0
    };
    Kh.defaultOptions = {
        backgroundAlpha: 1,
        backgroundColor: 0,
        clearBeforeRender: !0
    };
    let j1 = Kh;
    const Nr = {};
    At.handle(J.BlendMode, (i)=>{
        if (!i.name) throw new Error("BlendMode extension must have a name property");
        Nr[i.name] = i.ref;
    }, (i)=>{
        delete Nr[i.name];
    });
    class Y_ {
        constructor(e){
            this._isAdvanced = !1, this._filterHash = Object.create(null), this._renderer = e, this._renderer.runners.prerender.add(this);
        }
        prerender() {
            this._activeBlendMode = "normal", this._isAdvanced = !1;
        }
        setBlendMode(e, t, n) {
            if (this._activeBlendMode === t) {
                this._isAdvanced && this._renderableList.push(e);
                return;
            }
            this._activeBlendMode = t, this._isAdvanced && this._endAdvancedBlendMode(n), this._isAdvanced = !!Nr[t], this._isAdvanced && (this._beginAdvancedBlendMode(n), this._renderableList.push(e));
        }
        _beginAdvancedBlendMode(e) {
            this._renderer.renderPipes.batch.break(e);
            const t = this._activeBlendMode;
            if (!Nr[t]) {
                tt(`Unable to assign BlendMode: '${t}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);
                return;
            }
            let n = this._filterHash[t];
            n || (n = this._filterHash[t] = new ro, n.filters = [
                new Nr[t]
            ]);
            const s = {
                renderPipeId: "filter",
                action: "pushFilter",
                renderables: [],
                filterEffect: n,
                canBundle: !1
            };
            this._renderableList = s.renderables, e.add(s);
        }
        _endAdvancedBlendMode(e) {
            this._renderableList = null, this._renderer.renderPipes.batch.break(e), e.add({
                renderPipeId: "filter",
                action: "popFilter",
                canBundle: !1
            });
        }
        buildStart() {
            this._isAdvanced = !1;
        }
        buildEnd(e) {
            this._isAdvanced && this._endAdvancedBlendMode(e);
        }
        destroy() {
            this._renderer = null, this._renderableList = null;
            for(const e in this._filterHash)this._filterHash[e].destroy();
            this._filterHash = null;
        }
    }
    Y_.extension = {
        type: [
            J.WebGLPipes,
            J.WebGPUPipes,
            J.CanvasPipes
        ],
        name: "blendMode"
    };
    const Nl = {
        png: "image/png",
        jpg: "image/jpeg",
        webp: "image/webp"
    }, Zh = class j_ {
        constructor(e){
            this._renderer = e;
        }
        _normalizeOptions(e, t = {}) {
            return e instanceof Jt || e instanceof Ie ? {
                target: e,
                ...t
            } : {
                ...t,
                ...e
            };
        }
        async image(e) {
            const t = new Image;
            return t.src = await this.base64(e), t;
        }
        async base64(e) {
            e = this._normalizeOptions(e, j_.defaultImageOptions);
            const { format: t, quality: n } = e, s = this.canvas(e);
            if (s.toBlob !== void 0) return new Promise((r, a)=>{
                s.toBlob((o)=>{
                    if (!o) {
                        a(new Error("ICanvas.toBlob failed!"));
                        return;
                    }
                    const l = new FileReader;
                    l.onload = ()=>r(l.result), l.onerror = a, l.readAsDataURL(o);
                }, Nl[t], n);
            });
            if (s.toDataURL !== void 0) return s.toDataURL(Nl[t], n);
            if (s.convertToBlob !== void 0) {
                const r = await s.convertToBlob({
                    type: Nl[t],
                    quality: n
                });
                return new Promise((a, o)=>{
                    const l = new FileReader;
                    l.onload = ()=>a(l.result), l.onerror = o, l.readAsDataURL(r);
                });
            }
            throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");
        }
        canvas(e) {
            e = this._normalizeOptions(e);
            const t = e.target, n = this._renderer;
            if (t instanceof Ie) return n.texture.generateCanvas(t);
            const s = n.textureGenerator.generateTexture(e), r = n.texture.generateCanvas(s);
            return s.destroy(!0), r;
        }
        pixels(e) {
            e = this._normalizeOptions(e);
            const t = e.target, n = this._renderer, s = t instanceof Ie ? t : n.textureGenerator.generateTexture(e), r = n.texture.getPixels(s);
            return t instanceof Jt && s.destroy(!0), r;
        }
        texture(e) {
            return e = this._normalizeOptions(e), e.target instanceof Ie ? e.target : this._renderer.textureGenerator.generateTexture(e);
        }
        download(e) {
            e = this._normalizeOptions(e);
            const t = this.canvas(e), n = document.createElement("a");
            n.download = e.filename ?? "image.png", n.href = t.toDataURL("image/png"), document.body.appendChild(n), n.click(), document.body.removeChild(n);
        }
        log(e) {
            const t = e.width ?? 200;
            e = this._normalizeOptions(e);
            const n = this.canvas(e), s = n.toDataURL();
            console.log(`[Pixi Texture] ${n.width}px ${n.height}px`);
            const r = [
                "font-size: 1px;",
                `padding: ${t}px 300px;`,
                `background: url(${s}) no-repeat;`,
                "background-size: contain;"
            ].join(" ");
            console.log("%c ", r);
        }
        destroy() {
            this._renderer = null;
        }
    };
    Zh.extension = {
        type: [
            J.WebGLSystem,
            J.WebGPUSystem
        ],
        name: "extract"
    };
    Zh.defaultImageOptions = {
        format: "png",
        quality: 1
    };
    let q1 = Zh;
    class Jh extends Ie {
        static create(e) {
            return new Jh({
                source: new kt(e)
            });
        }
        resize(e, t, n) {
            return this.source.resize(e, t, n), this;
        }
    }
    const $1 = new mt, K1 = new sn, Z1 = [
        0,
        0,
        0,
        0
    ];
    class q_ {
        constructor(e){
            this._renderer = e;
        }
        generateTexture(e) {
            e instanceof Jt && (e = {
                target: e,
                frame: void 0,
                textureSourceOptions: {},
                resolution: void 0
            });
            const t = e.resolution || this._renderer.resolution, n = e.antialias || this._renderer.view.antialias, s = e.target;
            let r = e.clearColor;
            r ? r = Array.isArray(r) && r.length === 4 ? r : Et.shared.setValue(r).toArray() : r = Z1;
            const a = e.frame?.copyTo($1) || Ph(s, K1).rectangle;
            a.width = Math.max(a.width, 1 / t) | 0, a.height = Math.max(a.height, 1 / t) | 0;
            const o = Jh.create({
                ...e.textureSourceOptions,
                width: a.width,
                height: a.height,
                resolution: t,
                antialias: n
            }), l = Ne.shared.translate(-a.x, -a.y);
            return this._renderer.render({
                container: s,
                transform: l,
                target: o,
                clearColor: r
            }), o.source.updateMipmaps(), o;
        }
        destroy() {
            this._renderer = null;
        }
    }
    q_.extension = {
        type: [
            J.WebGLSystem,
            J.WebGPUSystem
        ],
        name: "textureGenerator"
    };
    J1 = function(i, e, t) {
        const n = (i >> 24 & 255) / 255;
        e[t++] = (i & 255) / 255 * n, e[t++] = (i >> 8 & 255) / 255 * n, e[t++] = (i >> 16 & 255) / 255 * n, e[t++] = n;
    };
    class $_ {
        constructor(e){
            this._stackIndex = 0, this._globalUniformDataStack = [], this._uniformsPool = [], this._activeUniforms = [], this._bindGroupPool = [], this._activeBindGroups = [], this._renderer = e;
        }
        reset() {
            this._stackIndex = 0;
            for(let e = 0; e < this._activeUniforms.length; e++)this._uniformsPool.push(this._activeUniforms[e]);
            for(let e = 0; e < this._activeBindGroups.length; e++)this._bindGroupPool.push(this._activeBindGroups[e]);
            this._activeUniforms.length = 0, this._activeBindGroups.length = 0;
        }
        start(e) {
            this.reset(), this.push(e);
        }
        bind({ size: e, projectionMatrix: t, worldTransformMatrix: n, worldColor: s, offset: r }) {
            const a = this._renderer.renderTarget.renderTarget, o = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {
                worldTransformMatrix: new Ne,
                worldColor: 4294967295,
                offset: new Ot
            }, l = {
                projectionMatrix: t || this._renderer.renderTarget.projectionMatrix,
                resolution: e || a.size,
                worldTransformMatrix: n || o.worldTransformMatrix,
                worldColor: s || o.worldColor,
                offset: r || o.offset,
                bindGroup: null
            }, h = this._uniformsPool.pop() || this._createUniforms();
            this._activeUniforms.push(h);
            const d = h.uniforms;
            d.uProjectionMatrix = l.projectionMatrix, d.uResolution = l.resolution, d.uWorldTransformMatrix.copyFrom(l.worldTransformMatrix), d.uWorldTransformMatrix.tx -= l.offset.x, d.uWorldTransformMatrix.ty -= l.offset.y, J1(l.worldColor, d.uWorldColorAlpha, 0), h.update();
            let c;
            this._renderer.renderPipes.uniformBatch ? c = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(h, !1) : (c = this._bindGroupPool.pop() || new Br, this._activeBindGroups.push(c), c.setResource(h, 0)), l.bindGroup = c, this._currentGlobalUniformData = l;
        }
        push(e) {
            this.bind(e), this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;
        }
        pop() {
            this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1], this._renderer.type === ns.WEBGL && this._currentGlobalUniformData.bindGroup.resources[0].update();
        }
        get bindGroup() {
            return this._currentGlobalUniformData.bindGroup;
        }
        get globalUniformData() {
            return this._currentGlobalUniformData;
        }
        get uniformGroup() {
            return this._currentGlobalUniformData.bindGroup.resources[0];
        }
        _createUniforms() {
            return new rs({
                uProjectionMatrix: {
                    value: new Ne,
                    type: "mat3x3<f32>"
                },
                uWorldTransformMatrix: {
                    value: new Ne,
                    type: "mat3x3<f32>"
                },
                uWorldColorAlpha: {
                    value: new Float32Array(4),
                    type: "vec4<f32>"
                },
                uResolution: {
                    value: [
                        0,
                        0
                    ],
                    type: "vec2<f32>"
                }
            }, {
                isStatic: !0
            });
        }
        destroy() {
            this._renderer = null;
        }
    }
    $_.extension = {
        type: [
            J.WebGLSystem,
            J.WebGPUSystem,
            J.CanvasSystem
        ],
        name: "globalUniforms"
    };
    let Q1 = 1;
    class K_ {
        constructor(){
            this._tasks = [], this._offset = 0;
        }
        init() {
            Ps.system.add(this._update, this);
        }
        repeat(e, t, n = !0) {
            const s = Q1++;
            let r = 0;
            return n && (this._offset += 1e3, r = this._offset), this._tasks.push({
                func: e,
                duration: t,
                start: performance.now(),
                offset: r,
                last: performance.now(),
                repeat: !0,
                id: s
            }), s;
        }
        cancel(e) {
            for(let t = 0; t < this._tasks.length; t++)if (this._tasks[t].id === e) {
                this._tasks.splice(t, 1);
                return;
            }
        }
        _update() {
            const e = performance.now();
            for(let t = 0; t < this._tasks.length; t++){
                const n = this._tasks[t];
                if (e - n.offset - n.last >= n.duration) {
                    const s = e - n.start;
                    n.func(s), n.last = e;
                }
            }
        }
        destroy() {
            Ps.system.remove(this._update, this), this._tasks.length = 0;
        }
    }
    K_.extension = {
        type: [
            J.WebGLSystem,
            J.WebGPUSystem,
            J.CanvasSystem
        ],
        name: "scheduler",
        priority: 0
    };
    let Yf = !1;
    function eR(i) {
        if (!Yf) {
            if (_t.get().getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
                const e = [
                    `%c  %c  %c  %c  %c PixiJS %c v${zc} (${i}) http://www.pixijs.com/

`,
                    "background: #E72264; padding:5px 0;",
                    "background: #6CA2EA; padding:5px 0;",
                    "background: #B5D33D; padding:5px 0;",
                    "background: #FED23F; padding:5px 0;",
                    "color: #FFFFFF; background: #E72264; padding:5px 0;",
                    "color: #E72264; background: #FFFFFF; padding:5px 0;"
                ];
                globalThis.console.log(...e);
            } else globalThis.console && globalThis.console.log(`PixiJS ${zc} - ${i} - http://www.pixijs.com/`);
            Yf = !0;
        }
    }
    class Qh {
        constructor(e){
            this._renderer = e;
        }
        init(e) {
            if (e.hello) {
                let t = this._renderer.name;
                this._renderer.type === ns.WEBGL && (t += ` ${this._renderer.context.webGLVersion}`), eR(t);
            }
        }
    }
    Qh.extension = {
        type: [
            J.WebGLSystem,
            J.WebGPUSystem,
            J.CanvasSystem
        ],
        name: "hello",
        priority: -2
    };
    Qh.defaultOptions = {
        hello: !1
    };
    function tR(i) {
        let e = !1;
        for(const n in i)if (i[n] == null) {
            e = !0;
            break;
        }
        if (!e) return i;
        const t = Object.create(null);
        for(const n in i){
            const s = i[n];
            s && (t[n] = s);
        }
        return t;
    }
    function nR(i) {
        let e = 0;
        for(let t = 0; t < i.length; t++)i[t] == null ? e++ : i[t - e] = i[t];
        return i.length -= e, i;
    }
    let iR = 0;
    const eu = class Z_ {
        constructor(e){
            this._managedRenderables = [], this._managedHashes = [], this._managedArrays = [], this._renderer = e;
        }
        init(e) {
            e = {
                ...Z_.defaultOptions,
                ...e
            }, this.maxUnusedTime = e.renderableGCMaxUnusedTime, this._frequency = e.renderableGCFrequency, this.enabled = e.renderableGCActive;
        }
        get enabled() {
            return !!this._handler;
        }
        set enabled(e) {
            this.enabled !== e && (e ? (this._handler = this._renderer.scheduler.repeat(()=>this.run(), this._frequency, !1), this._hashHandler = this._renderer.scheduler.repeat(()=>{
                for (const t of this._managedHashes)t.context[t.hash] = tR(t.context[t.hash]);
            }, this._frequency), this._arrayHandler = this._renderer.scheduler.repeat(()=>{
                for (const t of this._managedArrays)nR(t.context[t.hash]);
            }, this._frequency)) : (this._renderer.scheduler.cancel(this._handler), this._renderer.scheduler.cancel(this._hashHandler), this._renderer.scheduler.cancel(this._arrayHandler)));
        }
        addManagedHash(e, t) {
            this._managedHashes.push({
                context: e,
                hash: t
            });
        }
        addManagedArray(e, t) {
            this._managedArrays.push({
                context: e,
                hash: t
            });
        }
        prerender({ container: e }) {
            this._now = performance.now(), e.renderGroup.gcTick = iR++, this._updateInstructionGCTick(e.renderGroup, e.renderGroup.gcTick);
        }
        addRenderable(e) {
            this.enabled && (e._lastUsed === -1 && (this._managedRenderables.push(e), e.once("destroyed", this._removeRenderable, this)), e._lastUsed = this._now);
        }
        run() {
            const e = this._now, t = this._managedRenderables, n = this._renderer.renderPipes;
            let s = 0;
            for(let r = 0; r < t.length; r++){
                const a = t[r];
                if (a === null) {
                    s++;
                    continue;
                }
                const o = a.renderGroup ?? a.parentRenderGroup, l = o?.instructionSet?.gcTick ?? -1;
                if ((o?.gcTick ?? 0) === l && (a._lastUsed = e), e - a._lastUsed > this.maxUnusedTime) {
                    if (!a.destroyed) {
                        const h = n;
                        o && (o.structureDidChange = !0), h[a.renderPipeId].destroyRenderable(a);
                    }
                    a._lastUsed = -1, s++, a.off("destroyed", this._removeRenderable, this);
                } else t[r - s] = a;
            }
            t.length -= s;
        }
        destroy() {
            this.enabled = !1, this._renderer = null, this._managedRenderables.length = 0, this._managedHashes.length = 0, this._managedArrays.length = 0;
        }
        _removeRenderable(e) {
            const t = this._managedRenderables.indexOf(e);
            t >= 0 && (e.off("destroyed", this._removeRenderable, this), this._managedRenderables[t] = null);
        }
        _updateInstructionGCTick(e, t) {
            e.instructionSet.gcTick = t;
            for (const n of e.renderGroupChildren)this._updateInstructionGCTick(n, t);
        }
    };
    eu.extension = {
        type: [
            J.WebGLSystem,
            J.WebGPUSystem
        ],
        name: "renderableGC",
        priority: 0
    };
    eu.defaultOptions = {
        renderableGCActive: !0,
        renderableGCMaxUnusedTime: 6e4,
        renderableGCFrequency: 3e4
    };
    let sR = eu;
    const tu = class J_ {
        constructor(e){
            this._renderer = e, this.count = 0, this.checkCount = 0;
        }
        init(e) {
            e = {
                ...J_.defaultOptions,
                ...e
            }, this.checkCountMax = e.textureGCCheckCountMax, this.maxIdle = e.textureGCAMaxIdle ?? e.textureGCMaxIdle, this.active = e.textureGCActive;
        }
        postrender() {
            this._renderer.renderingToScreen && (this.count++, this.active && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())));
        }
        run() {
            const e = this._renderer.texture.managedTextures;
            for(let t = 0; t < e.length; t++){
                const n = e[t];
                n.autoGarbageCollect && n.resource && n._touched > -1 && this.count - n._touched > this.maxIdle && (n._touched = -1, n.unload());
            }
        }
        destroy() {
            this._renderer = null;
        }
    };
    tu.extension = {
        type: [
            J.WebGLSystem,
            J.WebGPUSystem
        ],
        name: "textureGC"
    };
    tu.defaultOptions = {
        textureGCActive: !0,
        textureGCAMaxIdle: null,
        textureGCMaxIdle: 60 * 60,
        textureGCCheckCountMax: 600
    };
    let rR = tu;
    const nu = class Q_ {
        get autoDensity() {
            return this.texture.source.autoDensity;
        }
        set autoDensity(e) {
            this.texture.source.autoDensity = e;
        }
        get resolution() {
            return this.texture.source._resolution;
        }
        set resolution(e) {
            this.texture.source.resize(this.texture.source.width, this.texture.source.height, e);
        }
        init(e) {
            e = {
                ...Q_.defaultOptions,
                ...e
            }, e.view && (et(dt, "ViewSystem.view has been renamed to ViewSystem.canvas"), e.canvas = e.view), this.screen = new mt(0, 0, e.width, e.height), this.canvas = e.canvas || _t.get().createCanvas(), this.antialias = !!e.antialias, this.texture = M_(this.canvas, e), this.renderTarget = new Jc({
                colorTextures: [
                    this.texture
                ],
                depth: !!e.depth,
                isRoot: !0
            }), this.texture.source.transparent = e.backgroundAlpha < 1, this.resolution = e.resolution;
        }
        resize(e, t, n) {
            this.texture.source.resize(e, t, n), this.screen.width = this.texture.frame.width, this.screen.height = this.texture.frame.height;
        }
        destroy(e = !1) {
            (typeof e == "boolean" ? e : !!e?.removeView) && this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);
        }
    };
    nu.extension = {
        type: [
            J.WebGLSystem,
            J.WebGPUSystem,
            J.CanvasSystem
        ],
        name: "view",
        priority: 0
    };
    nu.defaultOptions = {
        width: 800,
        height: 600,
        autoDensity: !1,
        antialias: !1
    };
    let aR = nu;
    const oR = [
        j1,
        $_,
        Qh,
        aR,
        V_,
        rR,
        q_,
        q1,
        wm,
        sR,
        K_
    ], lR = [
        Y_,
        l_,
        W_,
        G_,
        h_,
        d_,
        u_,
        O_
    ], cR = [
        ...oR,
        T_,
        e1,
        qw,
        f_,
        U_,
        w_,
        __,
        D_,
        I_,
        v_,
        P1,
        y_,
        x_
    ], hR = [
        ...lR
    ], uR = [
        a_,
        N_,
        F_
    ], eg = [], tg = [], ng = [];
    At.handleByNamedList(J.WebGLSystem, eg);
    At.handleByNamedList(J.WebGLPipes, tg);
    At.handleByNamedList(J.WebGLPipesAdaptor, ng);
    At.add(...cR, ...hR, ...uR);
    class dR extends JM {
        constructor(){
            const e = {
                name: "webgl",
                type: ns.WEBGL,
                systems: eg,
                renderPipes: tg,
                renderPipeAdaptors: ng
            };
            super(e);
        }
    }
    At.add(wT, RT);
    function jf(i, e) {
        if (e === jg) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), i;
        if (e === Mc || e === dp) {
            let t = i.getIndex();
            if (t === null) {
                const a = [], o = i.getAttribute("position");
                if (o !== void 0) {
                    for(let l = 0; l < o.count; l++)a.push(l);
                    i.setIndex(a), t = i.getIndex();
                } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), i;
            }
            const n = t.count - 2, s = [];
            if (e === Mc) for(let a = 1; a <= n; a++)s.push(t.getX(0)), s.push(t.getX(a)), s.push(t.getX(a + 1));
            else for(let a = 0; a < n; a++)a % 2 === 0 ? (s.push(t.getX(a)), s.push(t.getX(a + 1)), s.push(t.getX(a + 2))) : (s.push(t.getX(a + 2)), s.push(t.getX(a + 1)), s.push(t.getX(a)));
            s.length / 3 !== n && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
            const r = i.clone();
            return r.setIndex(s), r.clearGroups(), r;
        } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), i;
    }
    class fR extends er {
        constructor(e){
            super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {
                return new xR(t);
            }), this.register(function(t) {
                return new vR(t);
            }), this.register(function(t) {
                return new RR(t);
            }), this.register(function(t) {
                return new CR(t);
            }), this.register(function(t) {
                return new PR(t);
            }), this.register(function(t) {
                return new bR(t);
            }), this.register(function(t) {
                return new SR(t);
            }), this.register(function(t) {
                return new TR(t);
            }), this.register(function(t) {
                return new MR(t);
            }), this.register(function(t) {
                return new gR(t);
            }), this.register(function(t) {
                return new AR(t);
            }), this.register(function(t) {
                return new yR(t);
            }), this.register(function(t) {
                return new wR(t);
            }), this.register(function(t) {
                return new ER(t);
            }), this.register(function(t) {
                return new mR(t);
            }), this.register(function(t) {
                return new IR(t);
            }), this.register(function(t) {
                return new DR(t);
            });
        }
        load(e, t, n, s) {
            const r = this;
            let a;
            if (this.resourcePath !== "") a = this.resourcePath;
            else if (this.path !== "") {
                const h = Ir.extractUrlBase(e);
                a = Ir.resolveURL(h, this.path);
            } else a = Ir.extractUrlBase(e);
            this.manager.itemStart(e);
            const o = function(h) {
                s ? s(h) : console.error(h), r.manager.itemError(e), r.manager.itemEnd(e);
            }, l = new Dp(this.manager);
            l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function(h) {
                try {
                    r.parse(h, a, function(d) {
                        t(d), r.manager.itemEnd(e);
                    }, o);
                } catch (d) {
                    o(d);
                }
            }, n, o);
        }
        setDRACOLoader(e) {
            return this.dracoLoader = e, this;
        }
        setKTX2Loader(e) {
            return this.ktx2Loader = e, this;
        }
        setMeshoptDecoder(e) {
            return this.meshoptDecoder = e, this;
        }
        register(e) {
            return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
        }
        unregister(e) {
            return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
        }
        parse(e, t, n, s) {
            let r;
            const a = {}, o = {}, l = new TextDecoder;
            if (typeof e == "string") r = JSON.parse(e);
            else if (e instanceof ArrayBuffer) if (l.decode(new Uint8Array(e, 0, 4)) === ig) {
                try {
                    a[je.KHR_BINARY_GLTF] = new LR(e);
                } catch (c) {
                    s && s(c);
                    return;
                }
                r = JSON.parse(a[je.KHR_BINARY_GLTF].content);
            } else r = JSON.parse(l.decode(e));
            else r = e;
            if (r.asset === void 0 || r.asset.version[0] < 2) {
                s && s(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
                return;
            }
            const h = new YR(r, {
                path: t || this.resourcePath || "",
                crossOrigin: this.crossOrigin,
                requestHeader: this.requestHeader,
                manager: this.manager,
                ktx2Loader: this.ktx2Loader,
                meshoptDecoder: this.meshoptDecoder
            });
            h.fileLoader.setRequestHeader(this.requestHeader);
            for(let d = 0; d < this.pluginCallbacks.length; d++){
                const c = this.pluginCallbacks[d](h);
                c.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), o[c.name] = c, a[c.name] = !0;
            }
            if (r.extensionsUsed) for(let d = 0; d < r.extensionsUsed.length; ++d){
                const c = r.extensionsUsed[d], u = r.extensionsRequired || [];
                switch(c){
                    case je.KHR_MATERIALS_UNLIT:
                        a[c] = new _R;
                        break;
                    case je.KHR_DRACO_MESH_COMPRESSION:
                        a[c] = new BR(r, this.dracoLoader);
                        break;
                    case je.KHR_TEXTURE_TRANSFORM:
                        a[c] = new UR;
                        break;
                    case je.KHR_MESH_QUANTIZATION:
                        a[c] = new FR;
                        break;
                    default:
                        u.indexOf(c) >= 0 && o[c] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + c + '".');
                }
            }
            h.setExtensions(a), h.setPlugins(o), h.parse(n, s);
        }
        parseAsync(e, t) {
            const n = this;
            return new Promise(function(s, r) {
                n.parse(e, t, s, r);
            });
        }
    }
    function pR() {
        let i = {};
        return {
            get: function(e) {
                return i[e];
            },
            add: function(e, t) {
                i[e] = t;
            },
            remove: function(e) {
                delete i[e];
            },
            removeAll: function() {
                i = {};
            }
        };
    }
    const je = {
        KHR_BINARY_GLTF: "KHR_binary_glTF",
        KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
        KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
        KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
        KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
        KHR_MATERIALS_IOR: "KHR_materials_ior",
        KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
        KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
        KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
        KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
        KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
        KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
        KHR_MATERIALS_VOLUME: "KHR_materials_volume",
        KHR_TEXTURE_BASISU: "KHR_texture_basisu",
        KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
        KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
        KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
        EXT_MATERIALS_BUMP: "EXT_materials_bump",
        EXT_TEXTURE_WEBP: "EXT_texture_webp",
        EXT_TEXTURE_AVIF: "EXT_texture_avif",
        EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
        EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
    };
    class mR {
        constructor(e){
            this.parser = e, this.name = je.KHR_LIGHTS_PUNCTUAL, this.cache = {
                refs: {},
                uses: {}
            };
        }
        _markDefs() {
            const e = this.parser, t = this.parser.json.nodes || [];
            for(let n = 0, s = t.length; n < s; n++){
                const r = t[n];
                r.extensions && r.extensions[this.name] && r.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, r.extensions[this.name].light);
            }
        }
        _loadLight(e) {
            const t = this.parser, n = "light:" + e;
            let s = t.cache.get(n);
            if (s) return s;
            const r = t.json, l = ((r.extensions && r.extensions[this.name] || {}).lights || [])[e];
            let h;
            const d = new Oe(16777215);
            l.color !== void 0 && d.setRGB(l.color[0], l.color[1], l.color[2], Zt);
            const c = l.range !== void 0 ? l.range : 0;
            switch(l.type){
                case "directional":
                    h = new bh(d), h.target.position.set(0, 0, -1), h.add(h.target);
                    break;
                case "point":
                    h = new T0(d), h.distance = c;
                    break;
                case "spot":
                    h = new b0(d), h.distance = c, l.spot = l.spot || {}, l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0, l.spot.outerConeAngle = l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4, h.angle = l.spot.outerConeAngle, h.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle, h.target.position.set(0, 0, -1), h.add(h.target);
                    break;
                default:
                    throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type);
            }
            return h.position.set(0, 0, 0), ti(h, l), l.intensity !== void 0 && (h.intensity = l.intensity), h.name = t.createUniqueName(l.name || "light_" + e), s = Promise.resolve(h), t.cache.add(n, s), s;
        }
        getDependency(e, t) {
            if (e === "light") return this._loadLight(t);
        }
        createNodeAttachment(e) {
            const t = this, n = this.parser, r = n.json.nodes[e], o = (r.extensions && r.extensions[this.name] || {}).light;
            return o === void 0 ? null : this._loadLight(o).then(function(l) {
                return n._getNodeRef(t.cache, o, l);
            });
        }
    }
    class _R {
        constructor(){
            this.name = je.KHR_MATERIALS_UNLIT;
        }
        getMaterialType() {
            return qi;
        }
        extendParams(e, t, n) {
            const s = [];
            e.color = new Oe(1, 1, 1), e.opacity = 1;
            const r = t.pbrMetallicRoughness;
            if (r) {
                if (Array.isArray(r.baseColorFactor)) {
                    const a = r.baseColorFactor;
                    e.color.setRGB(a[0], a[1], a[2], Zt), e.opacity = a[3];
                }
                r.baseColorTexture !== void 0 && s.push(n.assignTexture(e, "map", r.baseColorTexture, Ft));
            }
            return Promise.all(s);
        }
    }
    class gR {
        constructor(e){
            this.parser = e, this.name = je.KHR_MATERIALS_EMISSIVE_STRENGTH;
        }
        extendMaterialParams(e, t) {
            const s = this.parser.json.materials[e];
            if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
            const r = s.extensions[this.name].emissiveStrength;
            return r !== void 0 && (t.emissiveIntensity = r), Promise.resolve();
        }
    }
    class xR {
        constructor(e){
            this.parser = e, this.name = je.KHR_MATERIALS_CLEARCOAT;
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : Xn;
        }
        extendMaterialParams(e, t) {
            const n = this.parser, s = n.json.materials[e];
            if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
            const r = [], a = s.extensions[this.name];
            if (a.clearcoatFactor !== void 0 && (t.clearcoat = a.clearcoatFactor), a.clearcoatTexture !== void 0 && r.push(n.assignTexture(t, "clearcoatMap", a.clearcoatTexture)), a.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = a.clearcoatRoughnessFactor), a.clearcoatRoughnessTexture !== void 0 && r.push(n.assignTexture(t, "clearcoatRoughnessMap", a.clearcoatRoughnessTexture)), a.clearcoatNormalTexture !== void 0 && (r.push(n.assignTexture(t, "clearcoatNormalMap", a.clearcoatNormalTexture)), a.clearcoatNormalTexture.scale !== void 0)) {
                const o = a.clearcoatNormalTexture.scale;
                t.clearcoatNormalScale = new Ze(o, o);
            }
            return Promise.all(r);
        }
    }
    class vR {
        constructor(e){
            this.parser = e, this.name = je.KHR_MATERIALS_DISPERSION;
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : Xn;
        }
        extendMaterialParams(e, t) {
            const s = this.parser.json.materials[e];
            if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
            const r = s.extensions[this.name];
            return t.dispersion = r.dispersion !== void 0 ? r.dispersion : 0, Promise.resolve();
        }
    }
    class yR {
        constructor(e){
            this.parser = e, this.name = je.KHR_MATERIALS_IRIDESCENCE;
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : Xn;
        }
        extendMaterialParams(e, t) {
            const n = this.parser, s = n.json.materials[e];
            if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
            const r = [], a = s.extensions[this.name];
            return a.iridescenceFactor !== void 0 && (t.iridescence = a.iridescenceFactor), a.iridescenceTexture !== void 0 && r.push(n.assignTexture(t, "iridescenceMap", a.iridescenceTexture)), a.iridescenceIor !== void 0 && (t.iridescenceIOR = a.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [
                100,
                400
            ]), a.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = a.iridescenceThicknessMinimum), a.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = a.iridescenceThicknessMaximum), a.iridescenceThicknessTexture !== void 0 && r.push(n.assignTexture(t, "iridescenceThicknessMap", a.iridescenceThicknessTexture)), Promise.all(r);
        }
    }
    class bR {
        constructor(e){
            this.parser = e, this.name = je.KHR_MATERIALS_SHEEN;
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : Xn;
        }
        extendMaterialParams(e, t) {
            const n = this.parser, s = n.json.materials[e];
            if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
            const r = [];
            t.sheenColor = new Oe(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
            const a = s.extensions[this.name];
            if (a.sheenColorFactor !== void 0) {
                const o = a.sheenColorFactor;
                t.sheenColor.setRGB(o[0], o[1], o[2], Zt);
            }
            return a.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = a.sheenRoughnessFactor), a.sheenColorTexture !== void 0 && r.push(n.assignTexture(t, "sheenColorMap", a.sheenColorTexture, Ft)), a.sheenRoughnessTexture !== void 0 && r.push(n.assignTexture(t, "sheenRoughnessMap", a.sheenRoughnessTexture)), Promise.all(r);
        }
    }
    class SR {
        constructor(e){
            this.parser = e, this.name = je.KHR_MATERIALS_TRANSMISSION;
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : Xn;
        }
        extendMaterialParams(e, t) {
            const n = this.parser, s = n.json.materials[e];
            if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
            const r = [], a = s.extensions[this.name];
            return a.transmissionFactor !== void 0 && (t.transmission = a.transmissionFactor), a.transmissionTexture !== void 0 && r.push(n.assignTexture(t, "transmissionMap", a.transmissionTexture)), Promise.all(r);
        }
    }
    class TR {
        constructor(e){
            this.parser = e, this.name = je.KHR_MATERIALS_VOLUME;
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : Xn;
        }
        extendMaterialParams(e, t) {
            const n = this.parser, s = n.json.materials[e];
            if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
            const r = [], a = s.extensions[this.name];
            t.thickness = a.thicknessFactor !== void 0 ? a.thicknessFactor : 0, a.thicknessTexture !== void 0 && r.push(n.assignTexture(t, "thicknessMap", a.thicknessTexture)), t.attenuationDistance = a.attenuationDistance || 1 / 0;
            const o = a.attenuationColor || [
                1,
                1,
                1
            ];
            return t.attenuationColor = new Oe().setRGB(o[0], o[1], o[2], Zt), Promise.all(r);
        }
    }
    class MR {
        constructor(e){
            this.parser = e, this.name = je.KHR_MATERIALS_IOR;
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : Xn;
        }
        extendMaterialParams(e, t) {
            const s = this.parser.json.materials[e];
            if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
            const r = s.extensions[this.name];
            return t.ior = r.ior !== void 0 ? r.ior : 1.5, Promise.resolve();
        }
    }
    class AR {
        constructor(e){
            this.parser = e, this.name = je.KHR_MATERIALS_SPECULAR;
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : Xn;
        }
        extendMaterialParams(e, t) {
            const n = this.parser, s = n.json.materials[e];
            if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
            const r = [], a = s.extensions[this.name];
            t.specularIntensity = a.specularFactor !== void 0 ? a.specularFactor : 1, a.specularTexture !== void 0 && r.push(n.assignTexture(t, "specularIntensityMap", a.specularTexture));
            const o = a.specularColorFactor || [
                1,
                1,
                1
            ];
            return t.specularColor = new Oe().setRGB(o[0], o[1], o[2], Zt), a.specularColorTexture !== void 0 && r.push(n.assignTexture(t, "specularColorMap", a.specularColorTexture, Ft)), Promise.all(r);
        }
    }
    class ER {
        constructor(e){
            this.parser = e, this.name = je.EXT_MATERIALS_BUMP;
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : Xn;
        }
        extendMaterialParams(e, t) {
            const n = this.parser, s = n.json.materials[e];
            if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
            const r = [], a = s.extensions[this.name];
            return t.bumpScale = a.bumpFactor !== void 0 ? a.bumpFactor : 1, a.bumpTexture !== void 0 && r.push(n.assignTexture(t, "bumpMap", a.bumpTexture)), Promise.all(r);
        }
    }
    class wR {
        constructor(e){
            this.parser = e, this.name = je.KHR_MATERIALS_ANISOTROPY;
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : Xn;
        }
        extendMaterialParams(e, t) {
            const n = this.parser, s = n.json.materials[e];
            if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
            const r = [], a = s.extensions[this.name];
            return a.anisotropyStrength !== void 0 && (t.anisotropy = a.anisotropyStrength), a.anisotropyRotation !== void 0 && (t.anisotropyRotation = a.anisotropyRotation), a.anisotropyTexture !== void 0 && r.push(n.assignTexture(t, "anisotropyMap", a.anisotropyTexture)), Promise.all(r);
        }
    }
    class RR {
        constructor(e){
            this.parser = e, this.name = je.KHR_TEXTURE_BASISU;
        }
        loadTexture(e) {
            const t = this.parser, n = t.json, s = n.textures[e];
            if (!s.extensions || !s.extensions[this.name]) return null;
            const r = s.extensions[this.name], a = t.options.ktx2Loader;
            if (!a) {
                if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                return null;
            }
            return t.loadTextureImage(e, r.source, a);
        }
    }
    class CR {
        constructor(e){
            this.parser = e, this.name = je.EXT_TEXTURE_WEBP, this.isSupported = null;
        }
        loadTexture(e) {
            const t = this.name, n = this.parser, s = n.json, r = s.textures[e];
            if (!r.extensions || !r.extensions[t]) return null;
            const a = r.extensions[t], o = s.images[a.source];
            let l = n.textureLoader;
            if (o.uri) {
                const h = n.options.manager.getHandler(o.uri);
                h !== null && (l = h);
            }
            return this.detectSupport().then(function(h) {
                if (h) return n.loadTextureImage(e, a.source, l);
                if (s.extensionsRequired && s.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                return n.loadTexture(e);
            });
        }
        detectSupport() {
            return this.isSupported || (this.isSupported = new Promise(function(e) {
                const t = new Image;
                t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
                    e(t.height === 1);
                };
            })), this.isSupported;
        }
    }
    class PR {
        constructor(e){
            this.parser = e, this.name = je.EXT_TEXTURE_AVIF, this.isSupported = null;
        }
        loadTexture(e) {
            const t = this.name, n = this.parser, s = n.json, r = s.textures[e];
            if (!r.extensions || !r.extensions[t]) return null;
            const a = r.extensions[t], o = s.images[a.source];
            let l = n.textureLoader;
            if (o.uri) {
                const h = n.options.manager.getHandler(o.uri);
                h !== null && (l = h);
            }
            return this.detectSupport().then(function(h) {
                if (h) return n.loadTextureImage(e, a.source, l);
                if (s.extensionsRequired && s.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
                return n.loadTexture(e);
            });
        }
        detectSupport() {
            return this.isSupported || (this.isSupported = new Promise(function(e) {
                const t = new Image;
                t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function() {
                    e(t.height === 1);
                };
            })), this.isSupported;
        }
    }
    class IR {
        constructor(e){
            this.name = je.EXT_MESHOPT_COMPRESSION, this.parser = e;
        }
        loadBufferView(e) {
            const t = this.parser.json, n = t.bufferViews[e];
            if (n.extensions && n.extensions[this.name]) {
                const s = n.extensions[this.name], r = this.parser.getDependency("buffer", s.buffer), a = this.parser.options.meshoptDecoder;
                if (!a || !a.supported) {
                    if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                    return null;
                }
                return r.then(function(o) {
                    const l = s.byteOffset || 0, h = s.byteLength || 0, d = s.count, c = s.byteStride, u = new Uint8Array(o, l, h);
                    return a.decodeGltfBufferAsync ? a.decodeGltfBufferAsync(d, c, u, s.mode, s.filter).then(function(f) {
                        return f.buffer;
                    }) : a.ready.then(function() {
                        const f = new ArrayBuffer(d * c);
                        return a.decodeGltfBuffer(new Uint8Array(f), d, c, u, s.mode, s.filter), f;
                    });
                });
            } else return null;
        }
    }
    class DR {
        constructor(e){
            this.name = je.EXT_MESH_GPU_INSTANCING, this.parser = e;
        }
        createNodeMesh(e) {
            const t = this.parser.json, n = t.nodes[e];
            if (!n.extensions || !n.extensions[this.name] || n.mesh === void 0) return null;
            const s = t.meshes[n.mesh];
            for (const h of s.primitives)if (h.mode !== pn.TRIANGLES && h.mode !== pn.TRIANGLE_STRIP && h.mode !== pn.TRIANGLE_FAN && h.mode !== void 0) return null;
            const a = n.extensions[this.name].attributes, o = [], l = {};
            for(const h in a)o.push(this.parser.getDependency("accessor", a[h]).then((d)=>(l[h] = d, l[h])));
            return o.length < 1 ? null : (o.push(this.parser.createNodeMesh(e)), Promise.all(o).then((h)=>{
                const d = h.pop(), c = d.isGroup ? d.children : [
                    d
                ], u = h[0].count, f = [];
                for (const _ of c){
                    const g = new He, m = new k, p = new Dn, x = new k(1, 1, 1), v = new t0(_.geometry, _.material, u);
                    for(let y = 0; y < u; y++)l.TRANSLATION && m.fromBufferAttribute(l.TRANSLATION, y), l.ROTATION && p.fromBufferAttribute(l.ROTATION, y), l.SCALE && x.fromBufferAttribute(l.SCALE, y), v.setMatrixAt(y, g.compose(m, p, x));
                    for(const y in l)if (y === "_COLOR_0") {
                        const P = l[y];
                        v.instanceColor = new Ec(P.array, P.itemSize, P.normalized);
                    } else y !== "TRANSLATION" && y !== "ROTATION" && y !== "SCALE" && _.geometry.setAttribute(y, l[y]);
                    yt.prototype.copy.call(v, _), this.parser.assignFinalMaterial(v), f.push(v);
                }
                return d.isGroup ? (d.clear(), d.add(...f), d) : f[0];
            }));
        }
    }
    const ig = "glTF", br = 12, qf = {
        JSON: 1313821514,
        BIN: 5130562
    };
    class LR {
        constructor(e){
            this.name = je.KHR_BINARY_GLTF, this.content = null, this.body = null;
            const t = new DataView(e, 0, br), n = new TextDecoder;
            if (this.header = {
                magic: n.decode(new Uint8Array(e.slice(0, 4))),
                version: t.getUint32(4, !0),
                length: t.getUint32(8, !0)
            }, this.header.magic !== ig) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
            if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
            const s = this.header.length - br, r = new DataView(e, br);
            let a = 0;
            for(; a < s;){
                const o = r.getUint32(a, !0);
                a += 4;
                const l = r.getUint32(a, !0);
                if (a += 4, l === qf.JSON) {
                    const h = new Uint8Array(e, br + a, o);
                    this.content = n.decode(h);
                } else if (l === qf.BIN) {
                    const h = br + a;
                    this.body = e.slice(h, h + o);
                }
                a += o;
            }
            if (this.content === null) throw new Error("THREE.GLTFLoader: JSON content not found.");
        }
    }
    class BR {
        constructor(e, t){
            if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
            this.name = je.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload();
        }
        decodePrimitive(e, t) {
            const n = this.json, s = this.dracoLoader, r = e.extensions[this.name].bufferView, a = e.extensions[this.name].attributes, o = {}, l = {}, h = {};
            for(const d in a){
                const c = nh[d] || d.toLowerCase();
                o[c] = a[d];
            }
            for(const d in e.attributes){
                const c = nh[d] || d.toLowerCase();
                if (a[d] !== void 0) {
                    const u = n.accessors[e.attributes[d]], f = Fs[u.componentType];
                    h[c] = f.name, l[c] = u.normalized === !0;
                }
            }
            return t.getDependency("bufferView", r).then(function(d) {
                return new Promise(function(c, u) {
                    s.decodeDracoFile(d, function(f) {
                        for(const _ in f.attributes){
                            const g = f.attributes[_], m = l[_];
                            m !== void 0 && (g.normalized = m);
                        }
                        c(f);
                    }, o, h, Zt, u);
                });
            });
        }
    }
    class UR {
        constructor(){
            this.name = je.KHR_TEXTURE_TRANSFORM;
        }
        extendTexture(e, t) {
            return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.texCoord !== void 0 && (e.channel = t.texCoord), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e;
        }
    }
    class FR {
        constructor(){
            this.name = je.KHR_MESH_QUANTIZATION;
        }
    }
    class sg extends qr {
        constructor(e, t, n, s){
            super(e, t, n, s);
        }
        copySampleValue_(e) {
            const t = this.resultBuffer, n = this.sampleValues, s = this.valueSize, r = e * s * 3 + s;
            for(let a = 0; a !== s; a++)t[a] = n[r + a];
            return t;
        }
        interpolate_(e, t, n, s) {
            const r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = o * 2, h = o * 3, d = s - t, c = (n - t) / d, u = c * c, f = u * c, _ = e * h, g = _ - h, m = -2 * f + 3 * u, p = f - u, x = 1 - m, v = p - u + c;
            for(let y = 0; y !== o; y++){
                const P = a[g + y + o], w = a[g + y + l] * d, R = a[_ + y + o], B = a[_ + y] * d;
                r[y] = x * P + v * w + m * R + p * B;
            }
            return r;
        }
    }
    const NR = new Dn;
    class OR extends sg {
        interpolate_(e, t, n, s) {
            const r = super.interpolate_(e, t, n, s);
            return NR.fromArray(r).normalize().toArray(r), r;
        }
    }
    const pn = {
        POINTS: 0,
        LINES: 1,
        LINE_LOOP: 2,
        LINE_STRIP: 3,
        TRIANGLES: 4,
        TRIANGLE_STRIP: 5,
        TRIANGLE_FAN: 6
    }, Fs = {
        5120: Int8Array,
        5121: Uint8Array,
        5122: Int16Array,
        5123: Uint16Array,
        5125: Uint32Array,
        5126: Float32Array
    }, $f = {
        9728: $t,
        9729: cn,
        9984: tp,
        9985: Oa,
        9986: Tr,
        9987: ni
    }, Kf = {
        33071: yi,
        33648: Ja,
        10497: Gs
    }, Ol = {
        SCALAR: 1,
        VEC2: 2,
        VEC3: 3,
        VEC4: 4,
        MAT2: 4,
        MAT3: 9,
        MAT4: 16
    }, nh = {
        POSITION: "position",
        NORMAL: "normal",
        TANGENT: "tangent",
        TEXCOORD_0: "uv",
        TEXCOORD_1: "uv1",
        TEXCOORD_2: "uv2",
        TEXCOORD_3: "uv3",
        COLOR_0: "color",
        WEIGHTS_0: "skinWeight",
        JOINTS_0: "skinIndex"
    }, gi = {
        scale: "scale",
        translation: "position",
        rotation: "quaternion",
        weights: "morphTargetInfluences"
    }, kR = {
        CUBICSPLINE: void 0,
        LINEAR: Vr,
        STEP: zr
    }, kl = {
        OPAQUE: "OPAQUE",
        MASK: "MASK",
        BLEND: "BLEND"
    };
    function GR(i) {
        return i.DefaultMaterial === void 0 && (i.DefaultMaterial = new Vs({
            color: 16777215,
            emissive: 0,
            metalness: 1,
            roughness: 1,
            transparent: !1,
            depthTest: !0,
            side: ci
        })), i.DefaultMaterial;
    }
    function ki(i, e, t) {
        for(const n in t.extensions)i[n] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[n] = t.extensions[n]);
    }
    function ti(i, e) {
        e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(i.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras));
    }
    function HR(i, e, t) {
        let n = !1, s = !1, r = !1;
        for(let h = 0, d = e.length; h < d; h++){
            const c = e[h];
            if (c.POSITION !== void 0 && (n = !0), c.NORMAL !== void 0 && (s = !0), c.COLOR_0 !== void 0 && (r = !0), n && s && r) break;
        }
        if (!n && !s && !r) return Promise.resolve(i);
        const a = [], o = [], l = [];
        for(let h = 0, d = e.length; h < d; h++){
            const c = e[h];
            if (n) {
                const u = c.POSITION !== void 0 ? t.getDependency("accessor", c.POSITION) : i.attributes.position;
                a.push(u);
            }
            if (s) {
                const u = c.NORMAL !== void 0 ? t.getDependency("accessor", c.NORMAL) : i.attributes.normal;
                o.push(u);
            }
            if (r) {
                const u = c.COLOR_0 !== void 0 ? t.getDependency("accessor", c.COLOR_0) : i.attributes.color;
                l.push(u);
            }
        }
        return Promise.all([
            Promise.all(a),
            Promise.all(o),
            Promise.all(l)
        ]).then(function(h) {
            const d = h[0], c = h[1], u = h[2];
            return n && (i.morphAttributes.position = d), s && (i.morphAttributes.normal = c), r && (i.morphAttributes.color = u), i.morphTargetsRelative = !0, i;
        });
    }
    function zR(i, e) {
        if (i.updateMorphTargets(), e.weights !== void 0) for(let t = 0, n = e.weights.length; t < n; t++)i.morphTargetInfluences[t] = e.weights[t];
        if (e.extras && Array.isArray(e.extras.targetNames)) {
            const t = e.extras.targetNames;
            if (i.morphTargetInfluences.length === t.length) {
                i.morphTargetDictionary = {};
                for(let n = 0, s = t.length; n < s; n++)i.morphTargetDictionary[t[n]] = n;
            } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
        }
    }
    function VR(i) {
        let e;
        const t = i.extensions && i.extensions[je.KHR_DRACO_MESH_COMPRESSION];
        if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + Gl(t.attributes) : e = i.indices + ":" + Gl(i.attributes) + ":" + i.mode, i.targets !== void 0) for(let n = 0, s = i.targets.length; n < s; n++)e += ":" + Gl(i.targets[n]);
        return e;
    }
    function Gl(i) {
        let e = "";
        const t = Object.keys(i).sort();
        for(let n = 0, s = t.length; n < s; n++)e += t[n] + ":" + i[t[n]] + ";";
        return e;
    }
    function ih(i) {
        switch(i){
            case Int8Array:
                return 1 / 127;
            case Uint8Array:
                return 1 / 255;
            case Int16Array:
                return 1 / 32767;
            case Uint16Array:
                return 1 / 65535;
            default:
                throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
        }
    }
    function WR(i) {
        return i.search(/\.jpe?g($|\?)/i) > 0 || i.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : i.search(/\.webp($|\?)/i) > 0 || i.search(/^data\:image\/webp/) === 0 ? "image/webp" : i.search(/\.ktx2($|\?)/i) > 0 || i.search(/^data\:image\/ktx2/) === 0 ? "image/ktx2" : "image/png";
    }
    const XR = new He;
    class YR {
        constructor(e = {}, t = {}){
            this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new pR, this.associations = new Map, this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = {
                refs: {},
                uses: {}
            }, this.cameraCache = {
                refs: {},
                uses: {}
            }, this.lightCache = {
                refs: {},
                uses: {}
            }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
            let n = !1, s = -1, r = !1, a = -1;
            if (typeof navigator < "u") {
                const o = navigator.userAgent;
                n = /^((?!chrome|android).)*safari/i.test(o) === !0;
                const l = o.match(/Version\/(\d+)/);
                s = n && l ? parseInt(l[1], 10) : -1, r = o.indexOf("Firefox") > -1, a = r ? o.match(/Firefox\/([0-9]+)\./)[1] : -1;
            }
            typeof createImageBitmap > "u" || n && s < 17 || r && a < 98 ? this.textureLoader = new Lp(this.options.manager) : this.textureLoader = new A0(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new Dp(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0);
        }
        setExtensions(e) {
            this.extensions = e;
        }
        setPlugins(e) {
            this.plugins = e;
        }
        parse(e, t) {
            const n = this, s = this.json, r = this.extensions;
            this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(a) {
                return a._markDefs && a._markDefs();
            }), Promise.all(this._invokeAll(function(a) {
                return a.beforeRoot && a.beforeRoot();
            })).then(function() {
                return Promise.all([
                    n.getDependencies("scene"),
                    n.getDependencies("animation"),
                    n.getDependencies("camera")
                ]);
            }).then(function(a) {
                const o = {
                    scene: a[0][s.scene || 0],
                    scenes: a[0],
                    animations: a[1],
                    cameras: a[2],
                    asset: s.asset,
                    parser: n,
                    userData: {}
                };
                return ki(r, o, s), ti(o, s), Promise.all(n._invokeAll(function(l) {
                    return l.afterRoot && l.afterRoot(o);
                })).then(function() {
                    for (const l of o.scenes)l.updateMatrixWorld();
                    e(o);
                });
            }).catch(t);
        }
        _markDefs() {
            const e = this.json.nodes || [], t = this.json.skins || [], n = this.json.meshes || [];
            for(let s = 0, r = t.length; s < r; s++){
                const a = t[s].joints;
                for(let o = 0, l = a.length; o < l; o++)e[a[o]].isBone = !0;
            }
            for(let s = 0, r = e.length; s < r; s++){
                const a = e[s];
                a.mesh !== void 0 && (this._addNodeRef(this.meshCache, a.mesh), a.skin !== void 0 && (n[a.mesh].isSkinnedMesh = !0)), a.camera !== void 0 && this._addNodeRef(this.cameraCache, a.camera);
            }
        }
        _addNodeRef(e, t) {
            t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
        }
        _getNodeRef(e, t, n) {
            if (e.refs[t] <= 1) return n;
            const s = n.clone(), r = (a, o)=>{
                const l = this.associations.get(a);
                l != null && this.associations.set(o, l);
                for (const [h, d] of a.children.entries())r(d, o.children[h]);
            };
            return r(n, s), s.name += "_instance_" + e.uses[t]++, s;
        }
        _invokeOne(e) {
            const t = Object.values(this.plugins);
            t.push(this);
            for(let n = 0; n < t.length; n++){
                const s = e(t[n]);
                if (s) return s;
            }
            return null;
        }
        _invokeAll(e) {
            const t = Object.values(this.plugins);
            t.unshift(this);
            const n = [];
            for(let s = 0; s < t.length; s++){
                const r = e(t[s]);
                r && n.push(r);
            }
            return n;
        }
        getDependency(e, t) {
            const n = e + ":" + t;
            let s = this.cache.get(n);
            if (!s) {
                switch(e){
                    case "scene":
                        s = this.loadScene(t);
                        break;
                    case "node":
                        s = this._invokeOne(function(r) {
                            return r.loadNode && r.loadNode(t);
                        });
                        break;
                    case "mesh":
                        s = this._invokeOne(function(r) {
                            return r.loadMesh && r.loadMesh(t);
                        });
                        break;
                    case "accessor":
                        s = this.loadAccessor(t);
                        break;
                    case "bufferView":
                        s = this._invokeOne(function(r) {
                            return r.loadBufferView && r.loadBufferView(t);
                        });
                        break;
                    case "buffer":
                        s = this.loadBuffer(t);
                        break;
                    case "material":
                        s = this._invokeOne(function(r) {
                            return r.loadMaterial && r.loadMaterial(t);
                        });
                        break;
                    case "texture":
                        s = this._invokeOne(function(r) {
                            return r.loadTexture && r.loadTexture(t);
                        });
                        break;
                    case "skin":
                        s = this.loadSkin(t);
                        break;
                    case "animation":
                        s = this._invokeOne(function(r) {
                            return r.loadAnimation && r.loadAnimation(t);
                        });
                        break;
                    case "camera":
                        s = this.loadCamera(t);
                        break;
                    default:
                        if (s = this._invokeOne(function(r) {
                            return r != this && r.getDependency && r.getDependency(e, t);
                        }), !s) throw new Error("Unknown type: " + e);
                        break;
                }
                this.cache.add(n, s);
            }
            return s;
        }
        getDependencies(e) {
            let t = this.cache.get(e);
            if (!t) {
                const n = this, s = this.json[e + (e === "mesh" ? "es" : "s")] || [];
                t = Promise.all(s.map(function(r, a) {
                    return n.getDependency(e, a);
                })), this.cache.add(e, t);
            }
            return t;
        }
        loadBuffer(e) {
            const t = this.json.buffers[e], n = this.fileLoader;
            if (t.type && t.type !== "arraybuffer") throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
            if (t.uri === void 0 && e === 0) return Promise.resolve(this.extensions[je.KHR_BINARY_GLTF].body);
            const s = this.options;
            return new Promise(function(r, a) {
                n.load(Ir.resolveURL(t.uri, s.path), r, void 0, function() {
                    a(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
                });
            });
        }
        loadBufferView(e) {
            const t = this.json.bufferViews[e];
            return this.getDependency("buffer", t.buffer).then(function(n) {
                const s = t.byteLength || 0, r = t.byteOffset || 0;
                return n.slice(r, r + s);
            });
        }
        loadAccessor(e) {
            const t = this, n = this.json, s = this.json.accessors[e];
            if (s.bufferView === void 0 && s.sparse === void 0) {
                const a = Ol[s.type], o = Fs[s.componentType], l = s.normalized === !0, h = new o(s.count * a);
                return Promise.resolve(new Kt(h, a, l));
            }
            const r = [];
            return s.bufferView !== void 0 ? r.push(this.getDependency("bufferView", s.bufferView)) : r.push(null), s.sparse !== void 0 && (r.push(this.getDependency("bufferView", s.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", s.sparse.values.bufferView))), Promise.all(r).then(function(a) {
                const o = a[0], l = Ol[s.type], h = Fs[s.componentType], d = h.BYTES_PER_ELEMENT, c = d * l, u = s.byteOffset || 0, f = s.bufferView !== void 0 ? n.bufferViews[s.bufferView].byteStride : void 0, _ = s.normalized === !0;
                let g, m;
                if (f && f !== c) {
                    const p = Math.floor(u / f), x = "InterleavedBuffer:" + s.bufferView + ":" + s.componentType + ":" + p + ":" + s.count;
                    let v = t.cache.get(x);
                    v || (g = new h(o, p * f, s.count * f / d), v = new Kx(g, f / d), t.cache.add(x, v)), m = new mh(v, l, u % f / d, _);
                } else o === null ? g = new h(s.count * l) : g = new h(o, u, s.count * l), m = new Kt(g, l, _);
                if (s.sparse !== void 0) {
                    const p = Ol.SCALAR, x = Fs[s.sparse.indices.componentType], v = s.sparse.indices.byteOffset || 0, y = s.sparse.values.byteOffset || 0, P = new x(a[1], v, s.sparse.count * p), w = new h(a[2], y, s.sparse.count * l);
                    o !== null && (m = new Kt(m.array.slice(), m.itemSize, m.normalized)), m.normalized = !1;
                    for(let R = 0, B = P.length; R < B; R++){
                        const T = P[R];
                        if (m.setX(T, w[R * l]), l >= 2 && m.setY(T, w[R * l + 1]), l >= 3 && m.setZ(T, w[R * l + 2]), l >= 4 && m.setW(T, w[R * l + 3]), l >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
                    }
                    m.normalized = _;
                }
                return m;
            });
        }
        loadTexture(e) {
            const t = this.json, n = this.options, r = t.textures[e].source, a = t.images[r];
            let o = this.textureLoader;
            if (a.uri) {
                const l = n.manager.getHandler(a.uri);
                l !== null && (o = l);
            }
            return this.loadTextureImage(e, r, o);
        }
        loadTextureImage(e, t, n) {
            const s = this, r = this.json, a = r.textures[e], o = r.images[t], l = (o.uri || o.bufferView) + ":" + a.sampler;
            if (this.textureCache[l]) return this.textureCache[l];
            const h = this.loadImageSource(t, n).then(function(d) {
                d.flipY = !1, d.name = a.name || o.name || "", d.name === "" && typeof o.uri == "string" && o.uri.startsWith("data:image/") === !1 && (d.name = o.uri);
                const u = (r.samplers || {})[a.sampler] || {};
                return d.magFilter = $f[u.magFilter] || cn, d.minFilter = $f[u.minFilter] || ni, d.wrapS = Kf[u.wrapS] || Gs, d.wrapT = Kf[u.wrapT] || Gs, d.generateMipmaps = !d.isCompressedTexture && d.minFilter !== $t && d.minFilter !== cn, s.associations.set(d, {
                    textures: e
                }), d;
            }).catch(function() {
                return null;
            });
            return this.textureCache[l] = h, h;
        }
        loadImageSource(e, t) {
            const n = this, s = this.json, r = this.options;
            if (this.sourceCache[e] !== void 0) return this.sourceCache[e].then((c)=>c.clone());
            const a = s.images[e], o = self.URL || self.webkitURL;
            let l = a.uri || "", h = !1;
            if (a.bufferView !== void 0) l = n.getDependency("bufferView", a.bufferView).then(function(c) {
                h = !0;
                const u = new Blob([
                    c
                ], {
                    type: a.mimeType
                });
                return l = o.createObjectURL(u), l;
            });
            else if (a.uri === void 0) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
            const d = Promise.resolve(l).then(function(c) {
                return new Promise(function(u, f) {
                    let _ = u;
                    t.isImageBitmapLoader === !0 && (_ = function(g) {
                        const m = new nn(g);
                        m.needsUpdate = !0, u(m);
                    }), t.load(Ir.resolveURL(c, r.path), _, void 0, f);
                });
            }).then(function(c) {
                return h === !0 && o.revokeObjectURL(l), ti(c, a), c.userData.mimeType = a.mimeType || WR(a.uri), c;
            }).catch(function(c) {
                throw console.error("THREE.GLTFLoader: Couldn't load texture", l), c;
            });
            return this.sourceCache[e] = d, d;
        }
        assignTexture(e, t, n, s) {
            const r = this;
            return this.getDependency("texture", n.index).then(function(a) {
                if (!a) return null;
                if (n.texCoord !== void 0 && n.texCoord > 0 && (a = a.clone(), a.channel = n.texCoord), r.extensions[je.KHR_TEXTURE_TRANSFORM]) {
                    const o = n.extensions !== void 0 ? n.extensions[je.KHR_TEXTURE_TRANSFORM] : void 0;
                    if (o) {
                        const l = r.associations.get(a);
                        a = r.extensions[je.KHR_TEXTURE_TRANSFORM].extendTexture(a, o), r.associations.set(a, l);
                    }
                }
                return s !== void 0 && (a.colorSpace = s), e[t] = a, a;
            });
        }
        assignFinalMaterial(e) {
            const t = e.geometry;
            let n = e.material;
            const s = t.attributes.tangent === void 0, r = t.attributes.color !== void 0, a = t.attributes.normal === void 0;
            if (e.isPoints) {
                const o = "PointsMaterial:" + n.uuid;
                let l = this.cache.get(o);
                l || (l = new wp, Gn.prototype.copy.call(l, n), l.color.copy(n.color), l.map = n.map, l.sizeAttenuation = !1, this.cache.add(o, l)), n = l;
            } else if (e.isLine) {
                const o = "LineBasicMaterial:" + n.uuid;
                let l = this.cache.get(o);
                l || (l = new Ep, Gn.prototype.copy.call(l, n), l.color.copy(n.color), l.map = n.map, this.cache.add(o, l)), n = l;
            }
            if (s || r || a) {
                let o = "ClonedMaterial:" + n.uuid + ":";
                s && (o += "derivative-tangents:"), r && (o += "vertex-colors:"), a && (o += "flat-shading:");
                let l = this.cache.get(o);
                l || (l = n.clone(), r && (l.vertexColors = !0), a && (l.flatShading = !0), s && (l.normalScale && (l.normalScale.y *= -1), l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)), this.cache.add(o, l), this.associations.set(l, this.associations.get(n))), n = l;
            }
            e.material = n;
        }
        getMaterialType() {
            return Vs;
        }
        loadMaterial(e) {
            const t = this, n = this.json, s = this.extensions, r = n.materials[e];
            let a;
            const o = {}, l = r.extensions || {}, h = [];
            if (l[je.KHR_MATERIALS_UNLIT]) {
                const c = s[je.KHR_MATERIALS_UNLIT];
                a = c.getMaterialType(), h.push(c.extendParams(o, r, t));
            } else {
                const c = r.pbrMetallicRoughness || {};
                if (o.color = new Oe(1, 1, 1), o.opacity = 1, Array.isArray(c.baseColorFactor)) {
                    const u = c.baseColorFactor;
                    o.color.setRGB(u[0], u[1], u[2], Zt), o.opacity = u[3];
                }
                c.baseColorTexture !== void 0 && h.push(t.assignTexture(o, "map", c.baseColorTexture, Ft)), o.metalness = c.metallicFactor !== void 0 ? c.metallicFactor : 1, o.roughness = c.roughnessFactor !== void 0 ? c.roughnessFactor : 1, c.metallicRoughnessTexture !== void 0 && (h.push(t.assignTexture(o, "metalnessMap", c.metallicRoughnessTexture)), h.push(t.assignTexture(o, "roughnessMap", c.metallicRoughnessTexture))), a = this._invokeOne(function(u) {
                    return u.getMaterialType && u.getMaterialType(e);
                }), h.push(Promise.all(this._invokeAll(function(u) {
                    return u.extendMaterialParams && u.extendMaterialParams(e, o);
                })));
            }
            r.doubleSided === !0 && (o.side = gn);
            const d = r.alphaMode || kl.OPAQUE;
            if (d === kl.BLEND ? (o.transparent = !0, o.depthWrite = !1) : (o.transparent = !1, d === kl.MASK && (o.alphaTest = r.alphaCutoff !== void 0 ? r.alphaCutoff : .5)), r.normalTexture !== void 0 && a !== qi && (h.push(t.assignTexture(o, "normalMap", r.normalTexture)), o.normalScale = new Ze(1, 1), r.normalTexture.scale !== void 0)) {
                const c = r.normalTexture.scale;
                o.normalScale.set(c, c);
            }
            if (r.occlusionTexture !== void 0 && a !== qi && (h.push(t.assignTexture(o, "aoMap", r.occlusionTexture)), r.occlusionTexture.strength !== void 0 && (o.aoMapIntensity = r.occlusionTexture.strength)), r.emissiveFactor !== void 0 && a !== qi) {
                const c = r.emissiveFactor;
                o.emissive = new Oe().setRGB(c[0], c[1], c[2], Zt);
            }
            return r.emissiveTexture !== void 0 && a !== qi && h.push(t.assignTexture(o, "emissiveMap", r.emissiveTexture, Ft)), Promise.all(h).then(function() {
                const c = new a(o);
                return r.name && (c.name = r.name), ti(c, r), t.associations.set(c, {
                    materials: e
                }), r.extensions && ki(s, c, r), c;
            });
        }
        createUniqueName(e) {
            const t = lt.sanitizeNodeName(e || "");
            return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t);
        }
        loadGeometries(e) {
            const t = this, n = this.extensions, s = this.primitiveCache;
            function r(o) {
                return n[je.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(o, t).then(function(l) {
                    return Zf(l, o, t);
                });
            }
            const a = [];
            for(let o = 0, l = e.length; o < l; o++){
                const h = e[o], d = VR(h), c = s[d];
                if (c) a.push(c.promise);
                else {
                    let u;
                    h.extensions && h.extensions[je.KHR_DRACO_MESH_COMPRESSION] ? u = r(h) : u = Zf(new Wn, h, t), s[d] = {
                        primitive: h,
                        promise: u
                    }, a.push(u);
                }
            }
            return Promise.all(a);
        }
        loadMesh(e) {
            const t = this, n = this.json, s = this.extensions, r = n.meshes[e], a = r.primitives, o = [];
            for(let l = 0, h = a.length; l < h; l++){
                const d = a[l].material === void 0 ? GR(this.cache) : this.getDependency("material", a[l].material);
                o.push(d);
            }
            return o.push(t.loadGeometries(a)), Promise.all(o).then(function(l) {
                const h = l.slice(0, l.length - 1), d = l[l.length - 1], c = [];
                for(let f = 0, _ = d.length; f < _; f++){
                    const g = d[f], m = a[f];
                    let p;
                    const x = h[f];
                    if (m.mode === pn.TRIANGLES || m.mode === pn.TRIANGLE_STRIP || m.mode === pn.TRIANGLE_FAN || m.mode === void 0) p = r.isSkinnedMesh === !0 ? new Jx(g, x) : new Nt(g, x), p.isSkinnedMesh === !0 && p.normalizeSkinWeights(), m.mode === pn.TRIANGLE_STRIP ? p.geometry = jf(p.geometry, dp) : m.mode === pn.TRIANGLE_FAN && (p.geometry = jf(p.geometry, Mc));
                    else if (m.mode === pn.LINES) p = new s0(g, x);
                    else if (m.mode === pn.LINE_STRIP) p = new xh(g, x);
                    else if (m.mode === pn.LINE_LOOP) p = new r0(g, x);
                    else if (m.mode === pn.POINTS) p = new a0(g, x);
                    else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + m.mode);
                    Object.keys(p.geometry.morphAttributes).length > 0 && zR(p, r), p.name = t.createUniqueName(r.name || "mesh_" + e), ti(p, r), m.extensions && ki(s, p, m), t.assignFinalMaterial(p), c.push(p);
                }
                for(let f = 0, _ = c.length; f < _; f++)t.associations.set(c[f], {
                    meshes: e,
                    primitives: f
                });
                if (c.length === 1) return r.extensions && ki(s, c[0], r), c[0];
                const u = new $i;
                r.extensions && ki(s, u, r), t.associations.set(u, {
                    meshes: e
                });
                for(let f = 0, _ = c.length; f < _; f++)u.add(c[f]);
                return u;
            });
        }
        loadCamera(e) {
            let t;
            const n = this.json.cameras[e], s = n[n.type];
            if (!s) {
                console.warn("THREE.GLTFLoader: Missing camera parameters.");
                return;
            }
            return n.type === "perspective" ? t = new jt(yx.radToDeg(s.yfov), s.aspectRatio || 1, s.znear || 1, s.zfar || 2e6) : n.type === "orthographic" && (t = new yh(-s.xmag, s.xmag, s.ymag, -s.ymag, s.znear, s.zfar)), n.name && (t.name = this.createUniqueName(n.name)), ti(t, n), Promise.resolve(t);
        }
        loadSkin(e) {
            const t = this.json.skins[e], n = [];
            for(let s = 0, r = t.joints.length; s < r; s++)n.push(this._loadNodeShallow(t.joints[s]));
            return t.inverseBindMatrices !== void 0 ? n.push(this.getDependency("accessor", t.inverseBindMatrices)) : n.push(null), Promise.all(n).then(function(s) {
                const r = s.pop(), a = s, o = [], l = [];
                for(let h = 0, d = a.length; h < d; h++){
                    const c = a[h];
                    if (c) {
                        o.push(c);
                        const u = new He;
                        r !== null && u.fromArray(r.array, h * 16), l.push(u);
                    } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[h]);
                }
                return new _h(o, l);
            });
        }
        loadAnimation(e) {
            const t = this.json, n = this, s = t.animations[e], r = s.name ? s.name : "animation_" + e, a = [], o = [], l = [], h = [], d = [];
            for(let c = 0, u = s.channels.length; c < u; c++){
                const f = s.channels[c], _ = s.samplers[f.sampler], g = f.target, m = g.node, p = s.parameters !== void 0 ? s.parameters[_.input] : _.input, x = s.parameters !== void 0 ? s.parameters[_.output] : _.output;
                g.node !== void 0 && (a.push(this.getDependency("node", m)), o.push(this.getDependency("accessor", p)), l.push(this.getDependency("accessor", x)), h.push(_), d.push(g));
            }
            return Promise.all([
                Promise.all(a),
                Promise.all(o),
                Promise.all(l),
                Promise.all(h),
                Promise.all(d)
            ]).then(function(c) {
                const u = c[0], f = c[1], _ = c[2], g = c[3], m = c[4], p = [];
                for(let x = 0, v = u.length; x < v; x++){
                    const y = u[x], P = f[x], w = _[x], R = g[x], B = m[x];
                    if (y === void 0) continue;
                    y.updateMatrix && y.updateMatrix();
                    const T = n._createAnimationTracks(y, P, w, R, B);
                    if (T) for(let S = 0; S < T.length; S++)p.push(T[S]);
                }
                return new Rc(r, void 0, p);
            });
        }
        createNodeMesh(e) {
            const t = this.json, n = this, s = t.nodes[e];
            return s.mesh === void 0 ? null : n.getDependency("mesh", s.mesh).then(function(r) {
                const a = n._getNodeRef(n.meshCache, s.mesh, r);
                return s.weights !== void 0 && a.traverse(function(o) {
                    if (o.isMesh) for(let l = 0, h = s.weights.length; l < h; l++)o.morphTargetInfluences[l] = s.weights[l];
                }), a;
            });
        }
        loadNode(e) {
            const t = this.json, n = this, s = t.nodes[e], r = n._loadNodeShallow(e), a = [], o = s.children || [];
            for(let h = 0, d = o.length; h < d; h++)a.push(n.getDependency("node", o[h]));
            const l = s.skin === void 0 ? Promise.resolve(null) : n.getDependency("skin", s.skin);
            return Promise.all([
                r,
                Promise.all(a),
                l
            ]).then(function(h) {
                const d = h[0], c = h[1], u = h[2];
                u !== null && d.traverse(function(f) {
                    f.isSkinnedMesh && f.bind(u, XR);
                });
                for(let f = 0, _ = c.length; f < _; f++)d.add(c[f]);
                return d;
            });
        }
        _loadNodeShallow(e) {
            const t = this.json, n = this.extensions, s = this;
            if (this.nodeCache[e] !== void 0) return this.nodeCache[e];
            const r = t.nodes[e], a = r.name ? s.createUniqueName(r.name) : "", o = [], l = s._invokeOne(function(h) {
                return h.createNodeMesh && h.createNodeMesh(e);
            });
            return l && o.push(l), r.camera !== void 0 && o.push(s.getDependency("camera", r.camera).then(function(h) {
                return s._getNodeRef(s.cameraCache, r.camera, h);
            })), s._invokeAll(function(h) {
                return h.createNodeAttachment && h.createNodeAttachment(e);
            }).forEach(function(h) {
                o.push(h);
            }), this.nodeCache[e] = Promise.all(o).then(function(h) {
                let d;
                if (r.isBone === !0 ? d = new Mp : h.length > 1 ? d = new $i : h.length === 1 ? d = h[0] : d = new yt, d !== h[0]) for(let c = 0, u = h.length; c < u; c++)d.add(h[c]);
                if (r.name && (d.userData.name = r.name, d.name = a), ti(d, r), r.extensions && ki(n, d, r), r.matrix !== void 0) {
                    const c = new He;
                    c.fromArray(r.matrix), d.applyMatrix4(c);
                } else r.translation !== void 0 && d.position.fromArray(r.translation), r.rotation !== void 0 && d.quaternion.fromArray(r.rotation), r.scale !== void 0 && d.scale.fromArray(r.scale);
                return s.associations.has(d) || s.associations.set(d, {}), s.associations.get(d).nodes = e, d;
            }), this.nodeCache[e];
        }
        loadScene(e) {
            const t = this.extensions, n = this.json.scenes[e], s = this, r = new $i;
            n.name && (r.name = s.createUniqueName(n.name)), ti(r, n), n.extensions && ki(t, r, n);
            const a = n.nodes || [], o = [];
            for(let l = 0, h = a.length; l < h; l++)o.push(s.getDependency("node", a[l]));
            return Promise.all(o).then(function(l) {
                for(let d = 0, c = l.length; d < c; d++)r.add(l[d]);
                const h = (d)=>{
                    const c = new Map;
                    for (const [u, f] of s.associations)(u instanceof Gn || u instanceof nn) && c.set(u, f);
                    return d.traverse((u)=>{
                        const f = s.associations.get(u);
                        f != null && c.set(u, f);
                    }), c;
                };
                return s.associations = h(r), r;
            });
        }
        _createAnimationTracks(e, t, n, s, r) {
            const a = [], o = e.name ? e.name : e.uuid, l = [];
            gi[r.path] === gi.weights ? e.traverse(function(u) {
                u.morphTargetInfluences && l.push(u.name ? u.name : u.uuid);
            }) : l.push(o);
            let h;
            switch(gi[r.path]){
                case gi.weights:
                    h = Ws;
                    break;
                case gi.rotation:
                    h = Xs;
                    break;
                case gi.translation:
                case gi.scale:
                    h = Ys;
                    break;
                default:
                    switch(n.itemSize){
                        case 1:
                            h = Ws;
                            break;
                        case 2:
                        case 3:
                        default:
                            h = Ys;
                            break;
                    }
                    break;
            }
            const d = s.interpolation !== void 0 ? kR[s.interpolation] : Vr, c = this._getArrayFromAccessor(n);
            for(let u = 0, f = l.length; u < f; u++){
                const _ = new h(l[u] + "." + gi[r.path], t.array, c, d);
                s.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(_), a.push(_);
            }
            return a;
        }
        _getArrayFromAccessor(e) {
            let t = e.array;
            if (e.normalized) {
                const n = ih(t.constructor), s = new Float32Array(t.length);
                for(let r = 0, a = t.length; r < a; r++)s[r] = t[r] * n;
                t = s;
            }
            return t;
        }
        _createCubicSplineTrackInterpolant(e) {
            e.createInterpolant = function(n) {
                const s = this instanceof Xs ? OR : sg;
                return new s(this.times, this.values, this.getValueSize() / 3, n);
            }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0;
        }
    }
    function jR(i, e, t) {
        const n = e.attributes, s = new Ln;
        if (n.POSITION !== void 0) {
            const o = t.json.accessors[n.POSITION], l = o.min, h = o.max;
            if (l !== void 0 && h !== void 0) {
                if (s.set(new k(l[0], l[1], l[2]), new k(h[0], h[1], h[2])), o.normalized) {
                    const d = ih(Fs[o.componentType]);
                    s.min.multiplyScalar(d), s.max.multiplyScalar(d);
                }
            } else {
                console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                return;
            }
        } else return;
        const r = e.targets;
        if (r !== void 0) {
            const o = new k, l = new k;
            for(let h = 0, d = r.length; h < d; h++){
                const c = r[h];
                if (c.POSITION !== void 0) {
                    const u = t.json.accessors[c.POSITION], f = u.min, _ = u.max;
                    if (f !== void 0 && _ !== void 0) {
                        if (l.setX(Math.max(Math.abs(f[0]), Math.abs(_[0]))), l.setY(Math.max(Math.abs(f[1]), Math.abs(_[1]))), l.setZ(Math.max(Math.abs(f[2]), Math.abs(_[2]))), u.normalized) {
                            const g = ih(Fs[u.componentType]);
                            l.multiplyScalar(g);
                        }
                        o.max(l);
                    } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                }
            }
            s.expandByVector(o);
        }
        i.boundingBox = s;
        const a = new Vn;
        s.getCenter(a.center), a.radius = s.min.distanceTo(s.max) / 2, i.boundingSphere = a;
    }
    function Zf(i, e, t) {
        const n = e.attributes, s = [];
        function r(a, o) {
            return t.getDependency("accessor", a).then(function(l) {
                i.setAttribute(o, l);
            });
        }
        for(const a in n){
            const o = nh[a] || a.toLowerCase();
            o in i.attributes || s.push(r(n[a], o));
        }
        if (e.indices !== void 0 && !i.index) {
            const a = t.getDependency("accessor", e.indices).then(function(o) {
                i.setIndex(o);
            });
            s.push(a);
        }
        return Ke.workingColorSpace !== Zt && "COLOR_0" in n && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Ke.workingColorSpace}" not supported.`), ti(i, e), jR(i, e, t), Promise.all(s).then(function() {
            return e.targets !== void 0 ? HR(i, e.targets, t) : i;
        });
    }
    class zn {
        static _instance = new zn;
        static get instance() {
            return this._instance;
        }
        constructor(){}
        _models = new Map;
        _textures2D = new Map;
        _textures3D = new Map;
        _sounds = new Map;
        getModel(e) {
            const t = this._models.get(e);
            if (!t) throw new Error(`Model ${e} not found`);
            return t;
        }
        getTexture2D(e) {
            const t = this._textures2D.get(e);
            if (!t) throw new Error(`Texture ${e} not found`);
            return t;
        }
        getTexture3D(e) {
            const t = this._textures3D.get(e);
            if (!t) throw new Error(`Texture ${e} not found`);
            return t;
        }
        getSound(e) {
            const t = this._sounds.get(e);
            if (!t) throw new Error(`Sound ${e} not found`);
            return t;
        }
        async loadAsync() {
            await this.loadModels(), await this.loadTextures2D(), await this.loadTextures3D(), this.loadSounds();
        }
        async loadModels() {
            const e = await new fR().loadAsync("assets/models/cibus_ninja.glb");
            this._models.set("ninja", e);
        }
        async loadTextures2D() {
            const e = async (t, n)=>{
                const s = await Rr.load(t);
                this._textures2D.set(n, s);
            };
            await e("assets/textures/mute.png", "mute"), await e("assets/textures/unmute.png", "unmute");
        }
        async loadTextures3D() {
            const e = new Lp, t = async (n, s)=>{
                const r = await e.loadAsync(n);
                this._textures3D.set(s, r);
            };
            await t("assets/textures/ninja.png", "ninja"), await t("assets/textures/sand.jpg", "ground"), await t("assets/textures/brick.png", "wall");
        }
        loadSounds() {
            this._sounds.set("background", new Ed.Howl({
                src: "assets/audio/background.wav",
                loop: !0,
                volume: .25
            })), this._sounds.set("click", new Ed.Howl({
                src: "assets/audio/click.wav",
                volume: .9
            }));
        }
    }
    class qe {
        static _instance = new qe;
        _width;
        _height;
        _aspectRatio;
        _threeRenderer;
        _pixiRenderer;
        _camera3D;
        static get instance() {
            return this._instance;
        }
        get width() {
            return this._width;
        }
        get height() {
            return this._height;
        }
        get aspectRatio() {
            return this._aspectRatio;
        }
        get camera3D() {
            return this._camera3D;
        }
        get threeRenderer() {
            return this._threeRenderer;
        }
        get pixiRenderer() {
            return this._pixiRenderer;
        }
        constructor(){
            const e = document.getElementById("main");
            if (!e) throw new Error("Canvas element not found");
            this._width = window.innerWidth, this._height = window.innerHeight, this._aspectRatio = 1, this._threeRenderer = new TT({
                canvas: e,
                antialias: !0,
                stencil: !0
            }), this._pixiRenderer = new dR, this._camera3D = new jt(60, this._width / this._height, .1, 1e3);
        }
        async init() {
            this._threeRenderer.setSize(this._width, this._height), this._threeRenderer.setClearColor(14540253, 1), this._threeRenderer.shadowMap.enabled = !0, await this._pixiRenderer.init({
                canvas: this._threeRenderer.domElement,
                context: this._threeRenderer.getContext(),
                width: this._width,
                height: this._height,
                clearBeforeRender: !1
            });
        }
        render(e) {
            this._threeRenderer.resetState(), this._threeRenderer.render(e.scene3D, this._camera3D), this._pixiRenderer.resetState(), this._pixiRenderer.render(e.container2D);
        }
        resize(e, t) {
            e / t >= this._aspectRatio ? (e = t * this._aspectRatio, t = t) : (e = e, t = e / this._aspectRatio), this._width = e, this._height = t, this._threeRenderer.setSize(this._width, this._height), this._pixiRenderer.resize(this._width, this._height), this._camera3D.aspect = this._width / this._height, this._camera3D.updateProjectionMatrix();
        }
    }
    class rg {
        _model;
        _animationMixer;
        _collider;
        _velocity = {
            x: 0,
            y: 0
        };
        _speed = 2;
        constructor(){
            this._model = zn.instance.getModel("ninja");
            const e = zn.instance.getTexture3D("ninja");
            this._model.scene.traverse((t)=>{
                t instanceof Nt && (t.material.map = e, t.material.side = gn, t.castShadow = !0);
            }), this._animationMixer = new G0(this._model.scene), this._collider = new Ln;
        }
        get model() {
            return this._model;
        }
        get collider() {
            return this._collider;
        }
        get animationMixer() {
            return this._animationMixer;
        }
        get velocity() {
            return this._velocity;
        }
        setAnimation(e) {
            e >= 0 && e < this._model.animations.length && (this._animationMixer.stopAllAction(), this._animationMixer.clipAction(this._model.animations[e]).play().setLoop(up, 1 / 0), this._collider.setFromObject(this._model.scene));
        }
        moveLeft() {
            this._velocity.x = -this._speed, this._model.scene.rotation.y = Math.PI * 1.5;
        }
        moveRight() {
            this._velocity.x = this._speed, this._model.scene.rotation.y = Math.PI * .5;
        }
        moveUp() {
            this._velocity.y = this._speed, this._model.scene.rotation.y = Math.PI;
        }
        moveDown() {
            this._velocity.y = -this._speed, this._model.scene.rotation.y = 0;
        }
        stopMovement() {
            this._velocity.x = 0, this._velocity.y = 0, this._model.scene.rotation.y = 0;
        }
        checkCollisions(e) {
            const t = this._model.scene.position.z;
            this._model.scene.position.z = 0, this._collider.setFromObject(this._model.scene), this._collider.expandByScalar(this._collider.getSize(new k).length() * .05);
            let n = !1;
            for (let s of e)if (new Ln().setFromObject(s).intersectsBox(this._collider)) {
                n = !0;
                break;
            }
            return this._model.scene.position.z = t, n;
        }
        update(e) {
            (this._velocity.x != 0 || this._velocity.y != 0) && (this._model.scene.position.x += this._velocity.x * e, this._model.scene.position.y += this._velocity.y * e, qe.instance.camera3D.position.x = this._model.scene.position.x, qe.instance.camera3D.position.y = this._model.scene.position.y);
        }
    }
    class li {
        static _instance = new li;
        static get instance() {
            return this._instance;
        }
        constructor(){}
        static _muted = !0;
        static isMuted() {
            return this._muted;
        }
        static toggleMute() {
            this._muted = !this._muted;
        }
        static play(e) {
            const t = zn.instance.getSound(e);
            t.mute(this._muted), t.playing() || t.play();
        }
    }
    class qR {
        _muteButton;
        constructor(e){
            this._muteButton = e;
        }
        execute() {
            this._muteButton.texture = zn.instance.getTexture2D(li.isMuted() ? "unmute" : "mute"), li.toggleMute(), li.play("background");
        }
    }
    class ag {
        _scene3D = new $x;
        _container2D = new Jt;
        _volumeButton = new Jt;
        _toggleSoundCommand = null;
        get scene3D() {
            return this._scene3D;
        }
        get container2D() {
            return this._container2D;
        }
        constructor(){}
        placeVolumeButton() {
            const e = new es(zn.instance.getTexture2D(li.isMuted() ? "mute" : "unmute"));
            e.tint = 14540253, e.interactive = !0, e.eventMode = "static", this._toggleSoundCommand = new qR(e), e.on("pointerdown", ()=>{
                li.play("click"), this._toggleSoundCommand?.execute();
            }), this._volumeButton.addChild(e), this._container2D.addChild(this._volumeButton);
        }
        load() {}
        unload() {
            this.scene3D.clear(), this.container2D.removeChildren();
        }
        onKeyPressed(e) {
            e.key.toLowerCase() === "m" && this._toggleSoundCommand?.execute();
        }
        onKeyReleased(e) {}
        update(e) {}
        resize(e, t) {
            this._volumeButton.scale.x = qe.instance.aspectRatio, this._volumeButton.scale.y = qe.instance.aspectRatio, this._volumeButton.position.set(0, 0);
        }
    }
    class mn {
        static _instance = new mn;
        _scenes = new Map;
        _currentScene = null;
        constructor(){}
        static get instance() {
            return this._instance;
        }
        addScene(e, t) {
            this._scenes.set(e, t);
        }
        getScene(e) {
            return this._scenes.get(e);
        }
        switchToScene(e) {
            const t = this._scenes.get(e);
            if (!t) throw new Error(`Scene ${e} not found`);
            this._currentScene && this._currentScene.unload(), this._currentScene = t, t.load();
        }
        get currentScene() {
            if (!this._currentScene) throw new Error("No current scene set");
            return this._currentScene;
        }
    }
    class $R {
        _player;
        _actionText;
        _animationIndex;
        constructor(e, t, n){
            this._player = e, this._actionText = t, this._animationIndex = n;
        }
        execute() {
            this._player.setAnimation(this._animationIndex), this._actionText.text = this._player.model.animations[this._animationIndex].name;
        }
    }
    class KR extends ag {
        _player;
        _animationButtonsContainer = new Jt;
        _playButtonContainer = new Jt;
        _currentActionText = new xi({
            style: {
                fontFamily: "Arial",
                fill: "LightGray",
                align: "center"
            }
        });
        _playAnimationCommands = [];
        constructor(){
            super(), this._player = new rg;
            for(let e = 0; e < this._player.model.animations.length; e++)this._playAnimationCommands.push(new $R(this._player, this._currentActionText, e));
        }
        get player() {
            return this._player;
        }
        async load() {
            super.load(), this.resize(qe.instance.width, qe.instance.height), this.load3D(), this.loadGUI(), this.placeVolumeButton();
        }
        unload() {
            this._animationButtonsContainer.removeChildren(), this._playButtonContainer.removeChildren(), super.unload(), this._player.animationMixer.stopAllAction();
        }
        load3D() {
            this.addPlayer(), this.addFloor(), this.addLight();
        }
        addPlayer() {
            const e = this._player.model.scene;
            this.scene3D.add(e), e.position.set(0, 0, 0), e.scale.set(1, 1, 1), this._player.setAnimation(this._player.model.animations.length - 1), qe.instance.camera3D.position.set(e.position.x, e.position.y + 1.5, 6);
        }
        addFloor() {
            const e = new Zs(4, 4), t = new Vs({
                color: 5795445,
                side: gn,
                emissive: 5795445
            }), n = new Nt(e, t);
            n.rotation.x = Math.PI * .5, n.position.y = this._player.model.scene.position.y, n.receiveShadow = !0, this.scene3D.add(n);
        }
        addLight() {
            const e = new bh(16777215, 1);
            e.position.set(1, 3, 1), e.castShadow = !0, this.scene3D.add(e, new Bp);
        }
        fillAnimationButtonsContainer() {
            const e = qe.instance.width, t = qe.instance.height;
            this._animationButtonsContainer.addChild(new oi().roundRect(0, 0, e * .5, t * .1, 10).fill("DarkOrange")), this._animationButtonsContainer.x = (e - this._animationButtonsContainer.width) * .5, this._animationButtonsContainer.y = 10;
            const n = new xi({
                text: "Animations",
                style: {
                    fontSize: this._animationButtonsContainer.height * .25,
                    fill: "MediumBlue"
                }
            });
            n.anchor.set(.5, .5), n.x = this._animationButtonsContainer.x, n.y = this._animationButtonsContainer.height * .25, this._animationButtonsContainer.addChild(n);
            const s = 15657173, r = 11897088, a = this._player.model.animations.length, o = this._animationButtonsContainer.width / a;
            for(let l = 0, h = o * .5; l < a; l++, h += o){
                const d = new oi().circle(h, this._animationButtonsContainer.height * .75, this._animationButtonsContainer.height * .2).fill("Gold");
                d.interactive = !0, d.eventMode = "static", d.on("pointerdown", ()=>{
                    li.play("click"), d.tint = r, this._playAnimationCommands[l].execute();
                }), d.on("pointerup", ()=>{
                    d.tint = s;
                }), d.on("pointerover", ()=>{
                    d.tint = s;
                }), d.on("pointerout", ()=>{
                    d.tint = 16777215;
                }), this._animationButtonsContainer.addChild(d);
                const c = new xi({
                    text: `${l + 1}`,
                    style: {
                        fontSize: d.height * .5,
                        fill: "MediumBlue"
                    }
                });
                c.anchor.set(.5, .5), c.x = h, c.y = this._animationButtonsContainer.height * .75, this._animationButtonsContainer.addChild(c), this._animationButtonsContainer.width = e * .5, this._animationButtonsContainer.height = t * .1;
            }
        }
        fillPlayButtonContainer() {
            const e = qe.instance.width, t = new oi().ellipse(0, 0, this._animationButtonsContainer.width * .25, this._animationButtonsContainer.height * .5).fill("DarkOrange");
            t.alpha = .5, this._playButtonContainer.addChild(t), this._playButtonContainer.x = e * .5, this._playButtonContainer.y = 10 + this._animationButtonsContainer.height + this._playButtonContainer.height;
            const n = new xi({
                text: "Play Maze",
                style: {
                    fontSize: Math.min(this._playButtonContainer.width, this._playButtonContainer.height) * .25,
                    fill: "MediumBlue"
                }
            });
            n.anchor.set(.5, .5), this._playButtonContainer.addChild(n), t.interactive = !0, t.eventMode = "static";
            const s = 15657173, r = 11897088;
            t.on("pointerdown", ()=>{
                t.tint = r, li.play("click"), mn.instance.switchToScene("maze");
            }), t.on("pointerup", ()=>{
                t.tint = s;
            }), t.on("pointerover", ()=>{
                t.tint = s;
            }), t.on("pointerout", ()=>{
                t.tint = 16777215;
            });
        }
        setCurrentActionText() {
            this._currentActionText.text = this._player.model.animations[this._player.model.animations.length - 1].name, this._currentActionText.anchor.set(.5, .5), this._currentActionText.x = qe.instance.width * .5, this._currentActionText.y = qe.instance.height * .75;
        }
        loadGUI() {
            this.container2D.addChild(this._animationButtonsContainer), this.container2D.addChild(this._playButtonContainer), this.container2D.addChild(this._currentActionText), this.fillAnimationButtonsContainer(), this.fillPlayButtonContainer(), this.setCurrentActionText();
        }
        positionGUI() {
            const e = qe.instance.width * .5 / this._animationButtonsContainer.width;
            this._animationButtonsContainer.width = qe.instance.width * .5, this._animationButtonsContainer.height *= e, this._animationButtonsContainer.x = (qe.instance.width - this._animationButtonsContainer.width) * .5, this._animationButtonsContainer.children.forEach((t)=>{
                t instanceof xi && (t.style.fontSize = this._animationButtonsContainer.height * .2);
            }), this._playButtonContainer.width = this._animationButtonsContainer.width * .5, this._playButtonContainer.height = this._animationButtonsContainer.height, this._playButtonContainer.x = qe.instance.width * .5, this._playButtonContainer.y = 10 + this._animationButtonsContainer.height + this._playButtonContainer.height, this._playButtonContainer.children.forEach((t)=>{
                t instanceof xi && (t.style.fontSize = Math.min(this._playButtonContainer.width, this._playButtonContainer.height) * .25);
            }), this._currentActionText.x = qe.instance.width * .5, this._currentActionText.y = qe.instance.height * .75;
        }
        onKeyPressed(e) {
            super.onKeyPressed(e);
            const t = this._player.model.animations.length.toString();
            e.key >= "1" && e.key <= t && this._playAnimationCommands[+e.key - 1].execute();
        }
        update(e) {
            super.update(e), this._player.model.scene.rotation.y += e * .5, this._player.animationMixer.update(e), this._player.update(e);
        }
        resize(e, t) {
            super.resize(e, t), this.positionGUI();
        }
    }
    class Za {
        _levelScheme = [];
        _start = {
            x: 0,
            y: 0
        };
        _exit = {
            x: 0,
            y: 0
        };
        constructor(e){
            this._levelScheme = e;
        }
        get start() {
            return this._start;
        }
        get exit() {
            return this._exit;
        }
        get levelScheme() {
            return this._levelScheme;
        }
        setScheme(e) {
            this._levelScheme = e;
        }
        setStart(e, t) {
            this.start.x = e, this.start.y = t;
        }
        setExit(e, t) {
            this.exit.x = e, this.exit.y = t;
        }
    }
    class Sr {
        static _levelIndex = 0;
        static _levels = [
            this.level1(),
            this.level2(),
            this.level3()
        ];
        constructor(){}
        static levelIndex() {
            return this._levelIndex;
        }
        static reset() {
            this._levelIndex = 0;
        }
        static nextLevel() {
            if (this._levels.length === 0) return this.level1();
            const e = this._levels[this._levelIndex++];
            return this._levelIndex >= this._levels.length && (this._levelIndex = 0), e;
        }
        static level1() {
            const e = new Za([
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    1,
                    0,
                    1,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    1,
                    0,
                    1,
                    1,
                    0,
                    1,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    0,
                    1,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    0
                ],
                [
                    1,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    0,
                    1,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    0
                ],
                [
                    1,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    1,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    1,
                    0,
                    0,
                    0,
                    1,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ]
            ]);
            return e.setStart(1, 1), e.setExit(16, 5), e;
        }
        static level2() {
            const e = new Za([
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    1,
                    1
                ],
                [
                    1,
                    0,
                    1,
                    1,
                    0,
                    0,
                    0,
                    0,
                    1,
                    1,
                    1,
                    1,
                    0,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    1,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    1,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    1,
                    0,
                    1,
                    1,
                    1,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    0,
                    0,
                    1,
                    1,
                    1,
                    0,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    1,
                    1,
                    0,
                    1,
                    0,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    0,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ]
            ]);
            return e.setStart(2, 6), e.setExit(4, -2), e;
        }
        static level3() {
            const e = new Za([
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    0,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    1,
                    0,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    1,
                    1,
                    0,
                    1,
                    0,
                    1,
                    1,
                    1,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    1,
                    1,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    1,
                    1,
                    1,
                    1,
                    0,
                    1,
                    0,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    1,
                    1,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    1,
                    1,
                    0,
                    1,
                    1,
                    1,
                    0,
                    0,
                    0,
                    1,
                    1,
                    1,
                    0,
                    0,
                    0,
                    0,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    1,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    1,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    1,
                    1,
                    1,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    0,
                    0,
                    1,
                    1,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    1,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    1,
                    0,
                    1,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    1,
                    1,
                    1,
                    1,
                    0,
                    0,
                    1,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    1,
                    0,
                    1,
                    1,
                    1,
                    1,
                    1,
                    0,
                    1,
                    1,
                    1,
                    0,
                    1,
                    1,
                    0,
                    0,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    1,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    0,
                    1,
                    1,
                    0,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    0,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ]
            ]);
            return e.setStart(9, 4), e.setExit(8, 17), e;
        }
    }
    class On extends ag {
        _player;
        _mapTiles = [];
        _walls = [];
        _level = new Za([]);
        _levelCompleted = !1;
        _levelText = new xi({
            style: {
                fill: "MediumBlue"
            }
        });
        _nextButton = new Jt;
        _nextButtonText = new xi({
            text: "Next Level",
            style: {
                fill: "MediumBlue"
            }
        });
        static _moveKeys = new Map([
            [
                "left",
                "a"
            ],
            [
                "right",
                "d"
            ],
            [
                "up",
                "w"
            ],
            [
                "down",
                "s"
            ]
        ]);
        constructor(){
            super(), this._player = new rg;
        }
        async load() {
            Sr.reset(), this.resize(qe.instance.width, qe.instance.height), this.loadGUI(), this.load3D(), this.placeVolumeButton();
        }
        unload() {
            this._nextButton.removeChildren(), super.unload();
        }
        load3D() {
            const e = this._player.model.scene;
            e.scale.set(.45, .45, .45);
            const t = new bh(16777215, 1);
            t.position.set(1, 3, 1), this.scene3D.add(e, new Bp, t), this.loadLevel();
        }
        loadLevel() {
            this._levelCompleted = !1, this._nextButton.visible = !1, this._walls.forEach((t)=>{
                this.scene3D.remove(t);
            }), this._mapTiles.forEach((t)=>{
                this.scene3D.remove(t);
            }), this._levelText.text = `Level ${Sr.levelIndex() + 1}`, this._level = Sr.nextLevel();
            const e = this._player.model.scene;
            e.position.set(this._level.start.x, this._level.start.y, .7), e.rotation.y = 0, this._player.setAnimation(this._player.model.animations.length - 1), qe.instance.camera3D.position.set(e.position.x, e.position.y, 10), this.fillMap();
        }
        fillMap() {
            const e = new Nt(new Zs(1, 1), new Vs({
                map: zn.instance.getTexture3D("ground")
            })), t = new Nt(new Ks(1, 1, 1), new Vs({
                map: zn.instance.getTexture3D("wall")
            }));
            this._walls = [], this._mapTiles = [];
            const n = this._level.levelScheme;
            for(let s = 0; s < n.length; s++)for(let r = 0; r < n[s].length; r++){
                const a = r, o = n.length - 1 - s;
                if (n[s][r] == 1) {
                    const l = t.clone();
                    l.position.set(a, o, 0), this._walls.push(l), this.scene3D.add(l);
                } else {
                    const l = e.clone();
                    l.position.set(a, o, 0), this._mapTiles.push(l), this.scene3D.add(l);
                }
            }
        }
        addInteractiveFrame() {
            const e = new oi().rect(0, 0, qe.instance.width, qe.instance.height).fill("0xFFFFFF00");
            e.interactive = !0, e.eventMode = "static", this.container2D.addChild(e), e.on("pointerdown", (t)=>{
                const n = t.global.x - qe.instance.width * .5, s = t.global.y - qe.instance.height * .5;
                Math.abs(n) >= Math.abs(s) ? n > 0 ? this._player.moveRight() : this._player.moveLeft() : s > 0 ? this._player.moveDown() : this._player.moveUp();
            }), e.on("pointerup", ()=>{
                this._player.stopMovement();
            });
        }
        fillTitleBar() {
            const e = qe.instance.width, t = qe.instance.height, n = new oi().rect(e * .125, 0, e * .75, Math.min(30, t * .1)).fill("DarkOrange");
            this.container2D.addChild(n), this._levelText.style.fontSize = n.height * .5, this._levelText.anchor.set(.5, .5), this._levelText.x = e * .5, this._levelText.y = n.y + n.height * .5, this.container2D.addChild(this._levelText);
        }
        fillNextButton() {
            const e = qe.instance.width, t = qe.instance.height, n = e * .25, s = t * .1, r = (e - n) * .5, a = (t * .25 - s) * .5, o = new oi().roundRect(r, a, n, s, 10).fill("DarkOrange");
            o.alpha = .5;
            const l = 15657173, h = 11897088;
            o.interactive = !0, o.eventMode = "static", o.on("pointerdown", ()=>{
                o.tint = h, Sr.levelIndex() > 0 ? this.loadLevel() : mn.instance.switchToScene("intro");
            }), o.on("pointerup", ()=>{
                o.tint = l;
            }), o.on("pointerover", ()=>{
                o.tint = l;
            }), o.on("pointerout", ()=>{
                o.tint = 16777215;
            }), this._nextButton.addChild(o), this._nextButtonText.anchor.set(.5, .5), this._nextButtonText.x = e * .5, this._nextButtonText.y = a + o.height * .5, this._nextButton.addChild(this._nextButtonText), this.container2D.addChild(this._nextButton);
        }
        async loadGUI() {
            this.addInteractiveFrame(), this.fillTitleBar(), this.fillNextButton();
        }
        onKeyPressed(e) {
            super.onKeyPressed(e), e.key.toLowerCase() === On._moveKeys.get("left") && this._player.moveLeft(), e.key.toLowerCase() === On._moveKeys.get("right") && this._player.moveRight(), e.key.toLowerCase() === On._moveKeys.get("up") && this._player.moveUp(), e.key.toLowerCase() === On._moveKeys.get("down") && this._player.moveDown();
        }
        onKeyReleased(e) {
            switch(super.onKeyReleased(e), e.key.toLowerCase()){
                case On._moveKeys.get("left"):
                case On._moveKeys.get("right"):
                case On._moveKeys.get("up"):
                case On._moveKeys.get("down"):
                    this._player.stopMovement();
            }
        }
        update(e) {
            if (super.update(e), this._player.animationMixer.update(e), this._levelCompleted) return;
            const t = this._player.model.scene, n = t.position.clone();
            if (this._player.update(e), this._player.checkCollisions(this._walls)) {
                this._player.model.scene.position.copy(n);
                return;
            }
            Math.abs(t.position.x - this._level.exit.x) < .5 && Math.abs(t.position.y - this._level.exit.y) < .5 && (Sr.levelIndex() === 0 && (this._nextButtonText.text = "To Main"), this._levelCompleted = !0, this._nextButton.visible = !0, this._player.setAnimation(1));
        }
        resize(e, t) {
            super.resize(e, t), this.container2D.width = qe.instance.width, this.container2D.height = qe.instance.height;
        }
    }
    (async ()=>{
        await zn.instance.loadAsync(), await qe.instance.init(), mn.instance.addScene("intro", new KR), mn.instance.addScene("maze", new On), mn.instance.switchToScene("intro");
        const i = new w0;
        function e() {
            mn.instance.currentScene.update(i.getDelta()), qe.instance.render(mn.instance.currentScene), requestAnimationFrame(e);
        }
        e();
        function t(n, s) {
            qe.instance.resize(n, s), mn.instance.currentScene.resize(n, s);
        }
        window.addEventListener("keydown", (n)=>{
            mn.instance.currentScene.onKeyPressed(n);
        }), window.addEventListener("keyup", (n)=>{
            mn.instance.currentScene.onKeyReleased(n);
        }), window.addEventListener("resize", ()=>{
            t(window.innerWidth, window.innerHeight);
        });
    })();
})();
export { _t as $, HA as A, Br as B, Jt as C, Oh as D, J as E, c_ as F, Lm as G, kh as H, go as I, FA as J, kA as K, Fm as L, Ne as M, Nm as N, Om as O, Ot as P, Pf as Q, ns as R, Kr as S, Ps as T, Uc as U, Qd as V, VE as W, oi as X, Mt as Y, GT as Z, k_ as _, yn as a, Ef as a0, mt as a1, $c as a2, so as a3, qc as a4, Rf as a5, Xm as a6, rs as b, Ls as c, Ie as d, At as e, sn as f, et as g, is as h, wt as i, Et as j, $s as k, NE as l, J1 as m, Vt as n, zm as o, tf as p, Xr as q, QT as r, as as s, $r as t, ir as u, dt as v, tt as w, kT as x, UA as y, Bl as z, __tla };
